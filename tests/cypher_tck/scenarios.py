from graphistry.compute import e_forward, e_undirected, n

from tests.cypher_tck.models import Expected, GraphFixture, Scenario
from tests.cypher_tck.parse_cypher import graph_fixture_from_create


MATCH5_GRAPH = graph_fixture_from_create(
    """
    CREATE (n0:A {name: 'n0'}),
           (n00:B {name: 'n00'}),
           (n01:B {name: 'n01'}),
           (n000:C {name: 'n000'}),
           (n001:C {name: 'n001'}),
           (n010:C {name: 'n010'}),
           (n011:C {name: 'n011'}),
           (n0000:D {name: 'n0000'}),
           (n0001:D {name: 'n0001'}),
           (n0010:D {name: 'n0010'}),
           (n0011:D {name: 'n0011'}),
           (n0100:D {name: 'n0100'}),
           (n0101:D {name: 'n0101'}),
           (n0110:D {name: 'n0110'}),
           (n0111:D {name: 'n0111'})
    CREATE (n0)-[:LIKES]->(n00),
           (n0)-[:LIKES]->(n01),
           (n00)-[:LIKES]->(n000),
           (n00)-[:LIKES]->(n001),
           (n01)-[:LIKES]->(n010),
           (n01)-[:LIKES]->(n011),
           (n000)-[:LIKES]->(n0000),
           (n000)-[:LIKES]->(n0001),
           (n001)-[:LIKES]->(n0010),
           (n001)-[:LIKES]->(n0011),
           (n010)-[:LIKES]->(n0100),
           (n010)-[:LIKES]->(n0101),
           (n011)-[:LIKES]->(n0110),
           (n011)-[:LIKES]->(n0111)
    """
)

MATCH7_GRAPH_SINGLE = graph_fixture_from_create(
    """
    CREATE (s:Single), (a:A {num: 42}),
           (b:B {num: 46}), (c:C)
    CREATE (s)-[:REL]->(a),
           (s)-[:REL]->(b),
           (a)-[:REL]->(c),
           (b)-[:LOOP]->(b)
    """
)

MATCH7_GRAPH_AB = graph_fixture_from_create(
    """
    CREATE (:A)-[:T]->(:B)
    """
)

MATCH7_GRAPH_ABC = graph_fixture_from_create(
    """
    CREATE (a {name: 'A'}), (b {name: 'B'}), (c {name: 'C'})
    CREATE (a)-[:KNOWS]->(b),
           (b)-[:KNOWS]->(c)
    """
)

MATCH7_GRAPH_REL = graph_fixture_from_create(
    """
    CREATE (a:A {num: 1})-[:REL {name: 'r1'}]->(b:B {num: 2})-[:REL {name: 'r2'}]->(c:C {num: 3})
    """
)

MATCH7_GRAPH_X = graph_fixture_from_create(
    """
    CREATE (a {name: 'A'}), (b {name: 'B'}), (c {name: 'C'})
    CREATE (a)-[:X]->(b)
    """
)

MATCH7_GRAPH_AB_X = graph_fixture_from_create(
    """
    CREATE (a {name: 'A'}), (b {name: 'B'})
    CREATE (a)-[:X]->(b)
    """
)

MATCH7_GRAPH_LABELS = graph_fixture_from_create(
    """
    CREATE (:X), (x:X), (y1:Y), (y2:Y:Z)
    CREATE (x)-[:REL]->(y1),
           (x)-[:REL]->(y2)
    """
)

MATCH7_GRAPH_PLAYER_TEAM_BOTH = graph_fixture_from_create(
    """
    CREATE (a:Player), (b:Team)
    CREATE (a)-[:PLAYS_FOR]->(b),
           (a)-[:SUPPORTS]->(b)
    """
)

MATCH7_GRAPH_PLAYER_TEAM_SINGLE = graph_fixture_from_create(
    """
    CREATE (a:Player), (b:Team)
    CREATE (a)-[:PLAYS_FOR]->(b)
    """
)

MATCH7_GRAPH_PLAYER_TEAM_DIFF = graph_fixture_from_create(
    """
    CREATE (a:Player), (b:Team), (c:Team)
    CREATE (a)-[:PLAYS_FOR]->(b),
           (a)-[:SUPPORTS]->(c)
    """
)

WITH_ORDERBY4_GRAPH = graph_fixture_from_create(
    """
    CREATE (:A {num: 1, num2: 4}),
           (:A {num: 5, num2: 2}),
           (:A {num: 9, num2: 0}),
           (:A {num: 3, num2: 3}),
           (:A {num: 7, num2: 1})
    """
)


BINARY_TREE_1_GRAPH = graph_fixture_from_create(
    """
    CREATE (a:A {name: 'a'}),
           (b1:X {name: 'b1'}),
           (b2:X {name: 'b2'}),
           (b3:X {name: 'b3'}),
           (b4:X {name: 'b4'}),
           (c11:X {name: 'c11'}),
           (c12:X {name: 'c12'}),
           (c21:X {name: 'c21'}),
           (c22:X {name: 'c22'}),
           (c31:X {name: 'c31'}),
           (c32:X {name: 'c32'}),
           (c41:X {name: 'c41'}),
           (c42:X {name: 'c42'})
    CREATE (a)-[:KNOWS]->(b1),
           (a)-[:KNOWS]->(b2),
           (a)-[:FOLLOWS]->(b3),
           (a)-[:FOLLOWS]->(b4)
    CREATE (b1)-[:FRIEND]->(c11),
           (b1)-[:FRIEND]->(c12),
           (b2)-[:FRIEND]->(c21),
           (b2)-[:FRIEND]->(c22),
           (b3)-[:FRIEND]->(c31),
           (b3)-[:FRIEND]->(c32),
           (b4)-[:FRIEND]->(c41),
           (b4)-[:FRIEND]->(c42)
    CREATE (b1)-[:FRIEND]->(b2),
           (b2)-[:FRIEND]->(b3),
           (b3)-[:FRIEND]->(b4),
           (b4)-[:FRIEND]->(b1);
    """
)

BINARY_TREE_2_GRAPH = graph_fixture_from_create(
    """
    CREATE (a:A {name: 'a'}),
           (b1:X {name: 'b1'}),
           (b2:X {name: 'b2'}),
           (b3:X {name: 'b3'}),
           (b4:X {name: 'b4'}),
           (c11:X {name: 'c11'}),
           (c12:Y {name: 'c12'}),
           (c21:X {name: 'c21'}),
           (c22:Y {name: 'c22'}),
           (c31:X {name: 'c31'}),
           (c32:Y {name: 'c32'}),
           (c41:X {name: 'c41'}),
           (c42:Y {name: 'c42'})
    CREATE (a)-[:KNOWS]->(b1),
           (a)-[:KNOWS]->(b2),
           (a)-[:FOLLOWS]->(b3),
           (a)-[:FOLLOWS]->(b4)
    CREATE (b1)-[:FRIEND]->(c11),
           (b1)-[:FRIEND]->(c12),
           (b2)-[:FRIEND]->(c21),
           (b2)-[:FRIEND]->(c22),
           (b3)-[:FRIEND]->(c31),
           (b3)-[:FRIEND]->(c32),
           (b4)-[:FRIEND]->(c41),
           (b4)-[:FRIEND]->(c42)
    CREATE (b1)-[:FRIEND]->(b2),
           (b2)-[:FRIEND]->(b3),
           (b3)-[:FRIEND]->(b4),
           (b4)-[:FRIEND]->(b1);
    """
)


SCENARIOS = [
    Scenario(
        key="match1-1",
        feature_path="tck/features/clauses/match/Match1.feature",
        scenario="[1] Match non-existent nodes returns empty",
        cypher="MATCH (n)\nRETURN n",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(node_ids=[]),
        gfql=[n()],
        tags=("match", "return", "empty-graph"),
    ),
    Scenario(
        key="match1-2",
        feature_path="tck/features/clauses/match/Match1.feature",
        scenario="[2] Matching all nodes",
        cypher="MATCH (n)\nRETURN n",
        graph=graph_fixture_from_create(
            """
            CREATE (:A), (:B {name: 'b'}), ({name: 'c'})
            """
        ),
        expected=Expected(
            node_ids=["anon_1", "anon_2", "anon_3"],
            rows=[
                {"n": "(:A)"},
                {"n": "(:B {name: 'b'})"},
                {"n": "({name: 'c'})"},
            ],
        ),
        gfql=[n()],
        tags=("match", "return", "parser-graph"),
    ),
    Scenario(
        key="match1-3",
        feature_path="tck/features/clauses/match/Match1.feature",
        scenario="[3] Matching nodes using multiple labels",
        cypher="MATCH (a:A:B)\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:A:B:C), (:A:B), (:A:C), (:B:C),
                   (:A), (:B), (:C),
                   ({name: ':A:B:C'}), ({abc: 'abc'}), ()
            """
        ),
        expected=Expected(node_ids=["anon_1", "anon_2"]),
        gfql=[n({"label__A": True, "label__B": True})],
        tags=("match", "labels", "parser-graph"),
    ),
    Scenario(
        key="match1-4",
        feature_path="tck/features/clauses/match/Match1.feature",
        scenario="[4] Simple node inline property predicate",
        cypher="MATCH (n {name: 'bar'})\nRETURN n",
        graph=GraphFixture(
            nodes=[
                {"id": "n1", "name": "bar"},
                {"id": "n2", "name": "monkey"},
                {"id": "n3", "firstname": "bar"},
            ],
            edges=[],
        ),
        expected=Expected(
            node_ids=["n1"],
            rows=[{"n": "({name: 'bar'})"}],
        ),
        gfql=[n({"name": "bar"})],
        tags=("match", "property", "inline-predicate"),
    ),
    Scenario(
        key="match1-5",
        feature_path="tck/features/clauses/match/Match1.feature",
        scenario="[5] Use multiple MATCH clauses to do a Cartesian product",
        cypher="MATCH (n), (m)\nRETURN n.num AS n, m.num AS m",
        graph=graph_fixture_from_create(
            """
            CREATE ({num: 1}), ({num: 2}), ({num: 3})
            """
        ),
        expected=Expected(
            rows=[
                {"n": 1, "m": 1},
                {"n": 1, "m": 2},
                {"n": 1, "m": 3},
                {"n": 2, "m": 1},
                {"n": 2, "m": 2},
                {"n": 2, "m": 3},
                {"n": 3, "m": 3},
                {"n": 3, "m": 1},
                {"n": 3, "m": 2},
            ]
        ),
        gfql=None,
        status="xfail",
        reason="Cartesian product + projection results not supported in current GFQL harness",
        tags=("match", "cartesian", "return", "xfail"),
    ),
    Scenario(
        key="match-where1-3",
        feature_path="tck/features/clauses/match-where/MatchWhere1.feature",
        scenario="[3] Filter node with property predicate on a single variable with multiple bindings",
        cypher="MATCH (n)\nWHERE n.name = 'Bar'\nRETURN n",
        graph=graph_fixture_from_create(
            """
            CREATE (), ({name: 'Bar'}), (:Bar)
            """
        ),
        expected=Expected(node_ids=["anon_2"]),
        gfql=[n({"name": "Bar"})],
        tags=("match-where", "property"),
    ),
    Scenario(
        key="match-where1-4",
        feature_path="tck/features/clauses/match-where/MatchWhere1.feature",
        scenario="[4] Filter start node of relationship with property predicate on multi variables with multiple bindings",
        cypher="MATCH (n:Person)-->()\nWHERE n.name = 'Bob'\nRETURN n",
        graph=graph_fixture_from_create(
            """
            CREATE (a:Person {name: 'Alice'}), (b:Person {name: 'Bob'}),
                   (c), (d)
            CREATE (a)-[:T]->(c),
                   (b)-[:T]->(d)
            """
        ),
        expected=Expected(node_ids=["b"]),
        gfql=[n({"label__Person": True, "name": "Bob"}, name="n"), e_forward(), n()],
        return_alias="n",
        tags=("match-where", "relationship", "alias"),
    ),
    Scenario(
        key="match-where1-5",
        feature_path="tck/features/clauses/match-where/MatchWhere1.feature",
        scenario="[5] Filter end node of relationship with property predicate on multi variables with multiple bindings",
        cypher="MATCH ()-[rel:X]-(a)\nWHERE a.name = 'Andres'\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE ({name: 'Someone'})<-[:X]-()-[:X]->({name: 'Andres'})
            """
        ),
        expected=Expected(node_ids=["anon_3"]),
        gfql=[n(), e_undirected({"type": "X"}), n({"name": "Andres"}, name="a")],
        return_alias="a",
        tags=("match-where", "relationship", "type"),
    ),
    Scenario(
        key="match-where1-6",
        feature_path="tck/features/clauses/match-where/MatchWhere1.feature",
        scenario="[6] Filter node with a parameter in a property predicate on multi variables with one binding",
        cypher="MATCH (a)-[r]->(b)\nWHERE b.name = $param\nRETURN r",
        graph=graph_fixture_from_create(
            """
            CREATE (:A)-[:T {name: 'bar'}]->(:B {name: 'me'})
            """
        ),
        expected=Expected(
            rows=[{"r": "[:T {name: 'bar'}]"}],
        ),
        gfql=None,
        status="xfail",
        reason="Parameter binding and edge-return validation not supported in harness",
        tags=("match-where", "params", "edge-return", "xfail"),
    ),
    Scenario(
        key="match-where1-7",
        feature_path="tck/features/clauses/match-where/MatchWhere1.feature",
        scenario="[7] Filter relationship with relationship type predicate on multi variables with multiple bindings",
        cypher="MATCH (n {name: 'A'})-[r]->(x)\nWHERE type(r) = 'KNOWS'\nRETURN x",
        graph=graph_fixture_from_create(
            """
            CREATE (a:A {name: 'A'}),
              (b:B {name: 'B'}),
              (c:C {name: 'C'}),
              (a)-[:KNOWS]->(b),
              (a)-[:HATES]->(c)
            """
        ),
        expected=Expected(node_ids=["b"]),
        gfql=[n({"name": "A"}, name="n"), e_forward({"type": "KNOWS"}), n(name="x")],
        return_alias="x",
        tags=("match-where", "relationship", "type"),
    ),
    Scenario(
        key="match-where1-8",
        feature_path="tck/features/clauses/match-where/MatchWhere1.feature",
        scenario="[8] Filter relationship with property predicate on multi variables with multiple bindings",
        cypher="MATCH (node)-[r:KNOWS]->(a)\nWHERE r.name = 'monkey'\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:A)<-[:KNOWS {name: 'monkey'}]-()-[:KNOWS {name: 'woot'}]->(:B)
            """
        ),
        expected=Expected(node_ids=["anon_1"]),
        gfql=[n(), e_forward({"type": "KNOWS", "name": "monkey"}, name="r"), n(name="a")],
        return_alias="a",
        tags=("match-where", "relationship", "property"),
    ),
    Scenario(
        key="match-where1-9",
        feature_path="tck/features/clauses/match-where/MatchWhere1.feature",
        scenario="[9] Filter relationship with a parameter in a property predicate on multi variables with one binding",
        cypher="MATCH (a)-[r]->(b)\nWHERE r.name = $param\nRETURN b",
        graph=graph_fixture_from_create(
            """
            CREATE (:A)-[:T {name: 'bar'}]->(:B {name: 'me'})
            """
        ),
        expected=Expected(
            node_ids=["anon_2"],
            rows=[{"b": "(:B {name: 'me'})"}],
        ),
        gfql=None,
        status="xfail",
        reason="Parameter binding and edge-return validation not supported in harness",
        tags=("match-where", "params", "edge-return", "xfail"),
    ),
    Scenario(
        key="match-where1-10",
        feature_path="tck/features/clauses/match-where/MatchWhere1.feature",
        scenario="[10] Filter node with disjunctive property predicate on single variables with multiple bindings",
        cypher="MATCH (n)\nWHERE n.p1 = 12 OR n.p2 = 13\nRETURN n",
        graph=graph_fixture_from_create(
            """
            CREATE (a:A {p1: 12}),
              (b:B {p2: 13}),
              (c:C)
            """
        ),
        expected=Expected(node_ids=["a", "b"]),
        gfql=None,
        status="xfail",
        reason="Disjunctive WHERE predicates are not supported in harness",
        tags=("match-where", "or", "xfail"),
    ),
    Scenario(
        key="match-where1-11",
        feature_path="tck/features/clauses/match-where/MatchWhere1.feature",
        scenario="[11] Filter relationship with disjunctive relationship type predicate on multi variables with multiple bindings",
        cypher="MATCH (n)-[r]->(x)\nWHERE type(r) = 'KNOWS' OR type(r) = 'HATES'\nRETURN r",
        graph=graph_fixture_from_create(
            """
            CREATE (a {name: 'A'}),
              (b {name: 'B'}),
              (c {name: 'C'}),
              (a)-[:KNOWS]->(b),
              (a)-[:HATES]->(c),
              (a)-[:WONDERS]->(c)
            """
        ),
        expected=Expected(
            rows=[
                {"r": "[:KNOWS]"},
                {"r": "[:HATES]"},
            ]
        ),
        gfql=None,
        status="xfail",
        reason="Disjunctive WHERE predicates and edge-return validation are not supported",
        tags=("match-where", "or", "edge-return", "xfail"),
    ),
    Scenario(
        key="match-where1-12",
        feature_path="tck/features/clauses/match-where/MatchWhere1.feature",
        scenario="[12] Filter path with path length predicate on multi variables with one binding",
        cypher="MATCH p = (n)-->(x)\nWHERE length(p) = 1\nRETURN x",
        graph=graph_fixture_from_create(
            """
            CREATE (a:A {name: 'A'})-[:KNOWS]->(b:B {name: 'B'})
            """
        ),
        expected=Expected(node_ids=["b"]),
        gfql=None,
        status="xfail",
        reason="Path variables and length() predicates are not supported in harness",
        tags=("match-where", "path-length", "xfail"),
    ),
    Scenario(
        key="match-where1-13",
        feature_path="tck/features/clauses/match-where/MatchWhere1.feature",
        scenario="[13] Filter path with false path length predicate on multi variables with one binding",
        cypher="MATCH p = (n)-->(x)\nWHERE length(p) = 10\nRETURN x",
        graph=graph_fixture_from_create(
            """
            CREATE (a:A {name: 'A'})-[:KNOWS]->(b:B {name: 'B'})
            """
        ),
        expected=Expected(node_ids=[]),
        gfql=None,
        status="xfail",
        reason="Path variables and length() predicates are not supported in harness",
        tags=("match-where", "path-length", "xfail"),
    ),
    Scenario(
        key="match-where1-14",
        feature_path="tck/features/clauses/match-where/MatchWhere1.feature",
        scenario="[14] Fail when filtering path with property predicate",
        cypher="MATCH (n)\nMATCH r = (n)-[*]->()\nWHERE r.name = 'apa'\nRETURN r",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Syntax error validation for invalid path property predicates not enforced",
        tags=("match-where", "syntax-error", "xfail"),
    ),
    Scenario(
        key="match-where1-15",
        feature_path="tck/features/clauses/match-where/MatchWhere1.feature",
        scenario="[15] Fail on aggregation in WHERE",
        cypher="MATCH (a)\nWHERE count(a) > 10\nRETURN a",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Syntax error validation for aggregations in WHERE not enforced",
        tags=("match-where", "syntax-error", "xfail"),
    ),
    Scenario(
        key="match-where2-1",
        feature_path="tck/features/clauses/match-where/MatchWhere2.feature",
        scenario="[1] Filter nodes with conjunctive two-part property predicate on multi variables with multiple bindings",
        cypher="MATCH (a)--(b)--(c)--(d)--(a), (b)--(d)\nWHERE a.id = 1\n  AND c.id = 2\nRETURN d",
        graph=graph_fixture_from_create(
            """
            CREATE (a:A), (b:B {id: 1}), (c:C {id: 2}), (d:D)
            CREATE (a)-[:T]->(b),
                   (a)-[:T]->(c),
                   (a)-[:T]->(d),
                   (b)-[:T]->(c),
                   (b)-[:T]->(d),
                   (c)-[:T]->(d)
            """
        ),
        expected=Expected(
            node_ids=["a", "d"],
            rows=[
                {"d": "(:A)"},
                {"d": "(:D)"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Multi-variable WHERE predicates and complex pattern matching not supported",
        return_alias="d",
        tags=("match-where", "and", "multi-var", "xfail"),
    ),
    Scenario(
        key="match-where2-2",
        feature_path="tck/features/clauses/match-where/MatchWhere2.feature",
        scenario="[2] Filter node with conjunctive multi-part property predicates on multi variables with multiple bindings",
        cypher="MATCH (advertiser)-[:ADV_HAS_PRODUCT]->(out)-[:AP_HAS_VALUE]->(red)<-[:AA_HAS_VALUE]-(a)\nWHERE advertiser.id = $1\n  AND a.id = $2\n  AND red.name = 'red'\n  AND out.name = 'product1'\nRETURN out.name",
        graph=graph_fixture_from_create(
            """
            CREATE (advertiser {name: 'advertiser1', id: 0}),
                   (thing {name: 'Color', id: 1}),
                   (red {name: 'red'}),
                   (p1 {name: 'product1'}),
                   (p2 {name: 'product4'})
            CREATE (advertiser)-[:ADV_HAS_PRODUCT]->(p1),
                   (advertiser)-[:ADV_HAS_PRODUCT]->(p2),
                   (thing)-[:AA_HAS_VALUE]->(red),
                   (p1)-[:AP_HAS_VALUE]->(red),
                   (p2)-[:AP_HAS_VALUE]->(red)
            """
        ),
        expected=Expected(
            rows=[{"out.name": "'product1'"}],
        ),
        gfql=None,
        status="xfail",
        reason="Parameter binding, multi-variable WHERE, and projection validation not supported",
        tags=("match-where", "params", "and", "multi-var", "xfail"),
    ),
    Scenario(
        key="match-where3-1",
        feature_path="tck/features/clauses/match-where/MatchWhere3.feature",
        scenario="[1] Join between node identities",
        cypher="MATCH (a), (b)\nWHERE a = b\nRETURN a, b",
        graph=graph_fixture_from_create(
            """
            CREATE (:A), (:B)
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:A)", "b": "(:A)"},
                {"a": "(:B)", "b": "(:B)"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Cartesian products, variable equality joins, and row projections are not supported",
        tags=("match-where", "join", "identity", "xfail"),
    ),
    Scenario(
        key="match-where3-2",
        feature_path="tck/features/clauses/match-where/MatchWhere3.feature",
        scenario="[2] Join between node properties of disconnected nodes",
        cypher="MATCH (a:A), (b:B)\nWHERE a.id = b.id\nRETURN a, b",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {id: 1}),
                   (:A {id: 2}),
                   (:B {id: 2}),
                   (:B {id: 3})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:A {id: 2})", "b": "(:B {id: 2})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Cartesian products, cross-variable equality predicates, and row projections are not supported",
        tags=("match-where", "join", "property", "xfail"),
    ),
    Scenario(
        key="match-where3-3",
        feature_path="tck/features/clauses/match-where/MatchWhere3.feature",
        scenario="[3] Join between node properties of adjacent nodes",
        cypher="MATCH (n)-[rel]->(x)\nWHERE n.animal = x.animal\nRETURN n, x",
        graph=graph_fixture_from_create(
            """
            CREATE (a:A {animal: 'monkey'}),
              (b:B {animal: 'cow'}),
              (c:C {animal: 'monkey'}),
              (d:D {animal: 'cow'}),
              (a)-[:KNOWS]->(b),
              (a)-[:KNOWS]->(c),
              (d)-[:KNOWS]->(b),
              (d)-[:KNOWS]->(c)
            """
        ),
        expected=Expected(
            rows=[
                {"n": "(:A {animal: 'monkey'})", "x": "(:C {animal: 'monkey'})"},
                {"n": "(:D {animal: 'cow'})", "x": "(:B {animal: 'cow'})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Cross-variable equality predicates and row projections are not supported",
        tags=("match-where", "join", "property", "xfail"),
    ),
    Scenario(
        key="match-where4-1",
        feature_path="tck/features/clauses/match-where/MatchWhere4.feature",
        scenario="[1] Join nodes on inequality",
        cypher="MATCH (a), (b)\nWHERE a <> b\nRETURN a, b",
        graph=graph_fixture_from_create(
            """
            CREATE (:A), (:B)
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:A)", "b": "(:B)"},
                {"a": "(:B)", "b": "(:A)"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Cartesian products, variable inequality joins, and row projections are not supported",
        tags=("match-where", "join", "inequality", "xfail"),
    ),
    Scenario(
        key="match-where4-2",
        feature_path="tck/features/clauses/match-where/MatchWhere4.feature",
        scenario="[2] Join with disjunctive multi-part predicates including patterns",
        cypher="MATCH (a), (b)\nWHERE a.id = 0\n  AND (a)-[:T]->(b:TheLabel)\n  OR (a)-[:T*]->(b:MissingLabel)\nRETURN DISTINCT b",
        graph=graph_fixture_from_create(
            """
            CREATE (a:TheLabel {id: 0}), (b:TheLabel {id: 1}), (c:TheLabel {id: 2})
            CREATE (a)-[:T]->(b),
                   (b)-[:T]->(c)
            """
        ),
        expected=Expected(
            node_ids=["b"],
            rows=[
                {"b": "(:TheLabel {id: 1})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Pattern predicates, variable-length relationships, OR, DISTINCT, and row projections not supported",
        tags=("match-where", "or", "pattern-predicate", "variable-length", "distinct", "xfail"),
    ),
    Scenario(
        key="match-where5-1",
        feature_path="tck/features/clauses/match-where/MatchWhere5.feature",
        scenario="[1] Filter out on null",
        cypher="MATCH (:Root {name: 'x'})-->(i:TextNode)\nWHERE i.var > 'te'\nRETURN i",
        graph=graph_fixture_from_create(
            """
            CREATE (root:Root {name: 'x'}),
                   (child1:TextNode {var: 'text'}),
                   (child2:IntNode {var: 0})
            CREATE (root)-[:T]->(child1),
                   (root)-[:T]->(child2)
            """
        ),
        expected=Expected(
            node_ids=["child1"],
            rows=[
                {"i": "(:TextNode {var: 'text'})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Comparison predicates and null semantics are not supported in the harness",
        tags=("match-where", "null", "comparison", "xfail"),
    ),
    Scenario(
        key="match-where5-2",
        feature_path="tck/features/clauses/match-where/MatchWhere5.feature",
        scenario="[2] Filter out on null if the AND'd predicate evaluates to false",
        cypher="MATCH (:Root {name: 'x'})-->(i:TextNode)\nWHERE i.var > 'te' AND i:TextNode\nRETURN i",
        graph=graph_fixture_from_create(
            """
            CREATE (root:Root {name: 'x'}),
                   (child1:TextNode {var: 'text'}),
                   (child2:IntNode {var: 0})
            CREATE (root)-[:T]->(child1),
                   (root)-[:T]->(child2)
            """
        ),
        expected=Expected(
            node_ids=["child1"],
            rows=[
                {"i": "(:TextNode {var: 'text'})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Comparison predicates, label predicates in WHERE, and null semantics are not supported",
        tags=("match-where", "null", "comparison", "label-predicate", "xfail"),
    ),
    Scenario(
        key="match-where5-3",
        feature_path="tck/features/clauses/match-where/MatchWhere5.feature",
        scenario="[3] Filter out on null if the AND'd predicate evaluates to true",
        cypher="MATCH (:Root {name: 'x'})-->(i:TextNode)\nWHERE i.var > 'te' AND i.var IS NOT NULL\nRETURN i",
        graph=graph_fixture_from_create(
            """
            CREATE (root:Root {name: 'x'}),
                   (child1:TextNode {var: 'text'}),
                   (child2:IntNode {var: 0})
            CREATE (root)-[:T]->(child1),
                   (root)-[:T]->(child2)
            """
        ),
        expected=Expected(
            node_ids=["child1"],
            rows=[
                {"i": "(:TextNode {var: 'text'})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Comparison predicates, IS NOT NULL, and null semantics are not supported",
        tags=("match-where", "null", "comparison", "is-not-null", "xfail"),
    ),
    Scenario(
        key="match-where5-4",
        feature_path="tck/features/clauses/match-where/MatchWhere5.feature",
        scenario="[4] Do not filter out on null if the OR'd predicate evaluates to true",
        cypher="MATCH (:Root {name: 'x'})-->(i)\nWHERE i.var > 'te' OR i.var IS NOT NULL\nRETURN i",
        graph=graph_fixture_from_create(
            """
            CREATE (root:Root {name: 'x'}),
                   (child1:TextNode {var: 'text'}),
                   (child2:IntNode {var: 0})
            CREATE (root)-[:T]->(child1),
                   (root)-[:T]->(child2)
            """
        ),
        expected=Expected(
            node_ids=["child1", "child2"],
            rows=[
                {"i": "(:TextNode {var: 'text'})"},
                {"i": "(:IntNode {var: 0})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="OR predicates, comparison predicates, IS NOT NULL, and null semantics are not supported",
        tags=("match-where", "null", "or", "comparison", "is-not-null", "xfail"),
    ),
    Scenario(
        key="match-where6-1",
        feature_path="tck/features/clauses/match-where/MatchWhere6.feature",
        scenario="[1] Filter node with node label predicate on multi variables with multiple bindings after MATCH and OPTIONAL MATCH",
        cypher="MATCH (a)-->(b)\nWHERE b:B\nOPTIONAL MATCH (a)-->(c)\nWHERE c:C\nRETURN a.name",
        graph=graph_fixture_from_create(
            """
            CREATE (a {name: 'A'}), (b:B {name: 'B'}), (c:C {name: 'C'}), (d:D {name: 'C'})
            CREATE (a)-[:T]->(b),
                   (a)-[:T]->(c),
                   (a)-[:T]->(d)
            """
        ),
        expected=Expected(
            rows=[
                {"a.name": "'A'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="OPTIONAL MATCH semantics, label predicates in WHERE, and projection comparisons are not supported",
        tags=("match-where", "optional-match", "label-predicate", "xfail"),
    ),
    Scenario(
        key="match-where6-2",
        feature_path="tck/features/clauses/match-where/MatchWhere6.feature",
        scenario="[2] Filter node with false node label predicate after OPTIONAL MATCH",
        cypher="MATCH (n:Single)\nOPTIONAL MATCH (n)-[r]-(m)\nWHERE m:NonExistent\nRETURN r",
        graph=graph_fixture_from_create(
            """
            CREATE (s:Single), (a:A {num: 42}),
                   (b:B {num: 46}), (c:C)
            CREATE (s)-[:REL]->(a),
                   (s)-[:REL]->(b),
                   (a)-[:REL]->(c),
                   (b)-[:LOOP]->(b)
            """
        ),
        expected=Expected(
            rows=[
                {"r": "null"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="OPTIONAL MATCH semantics, label predicates in WHERE, and null row comparisons are not supported",
        tags=("match-where", "optional-match", "label-predicate", "null", "xfail"),
    ),
    Scenario(
        key="match-where6-3",
        feature_path="tck/features/clauses/match-where/MatchWhere6.feature",
        scenario="[3] Filter node with property predicate on multi variables with multiple bindings after OPTIONAL MATCH",
        cypher="MATCH (n:Single)\nOPTIONAL MATCH (n)-[r]-(m)\nWHERE m.num = 42\nRETURN m",
        graph=graph_fixture_from_create(
            """
            CREATE (s:Single), (a:A {num: 42}),
                   (b:B {num: 46}), (c:C)
            CREATE (s)-[:REL]->(a),
                   (s)-[:REL]->(b),
                   (a)-[:REL]->(c),
                   (b)-[:LOOP]->(b)
            """
        ),
        expected=Expected(
            rows=[
                {"m": "(:A {num: 42})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="OPTIONAL MATCH semantics and row projections are not supported",
        tags=("match-where", "optional-match", "property", "xfail"),
    ),
    Scenario(
        key="match-where6-4",
        feature_path="tck/features/clauses/match-where/MatchWhere6.feature",
        scenario="[4] Do not fail when predicates on optionally matched and missed nodes are invalid",
        cypher="MATCH (n)-->(x0)\nOPTIONAL MATCH (x0)-->(x1)\nWHERE x1.name = 'bar'\nRETURN x0.name",
        graph=graph_fixture_from_create(
            """
            CREATE (a), (b {name: 'Mark'})
            CREATE (a)-[:T]->(b)
            """
        ),
        expected=Expected(
            rows=[
                {"x0.name": "'Mark'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="OPTIONAL MATCH semantics and null predicate handling are not supported",
        tags=("match-where", "optional-match", "null", "xfail"),
    ),
    Scenario(
        key="match-where6-5",
        feature_path="tck/features/clauses/match-where/MatchWhere6.feature",
        scenario="[5] Matching and optionally matching with unbound nodes and equality predicate in reverse direction",
        cypher="MATCH (a1)-[r]->()\nWITH r, a1\n  LIMIT 1\nOPTIONAL MATCH (a2)<-[r]-(b2)\nWHERE a1 = a2\nRETURN a1, r, b2, a2",
        graph=graph_fixture_from_create(
            """
            CREATE (:A)-[:T]->(:B)
            """
        ),
        expected=Expected(
            rows=[
                {"a1": "(:A)", "r": "[:T]", "b2": "null", "a2": "null"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH/LIMIT scoping, OPTIONAL MATCH semantics, and variable equality joins are not supported",
        tags=("match-where", "optional-match", "with", "limit", "join", "xfail"),
    ),
    Scenario(
        key="match-where6-6",
        feature_path="tck/features/clauses/match-where/MatchWhere6.feature",
        scenario="[6] Join nodes on non-equality of properties – OPTIONAL MATCH and WHERE",
        cypher="MATCH (x:X)\nOPTIONAL MATCH (x)-[:E1]->(y:Y)\nWHERE x.val < y.val\nRETURN x, y",
        graph=graph_fixture_from_create(
            """
            CREATE
              (:X {val: 1})-[:E1]->(:Y {val: 2})-[:E2]->(:Z {val: 3}),
              (:X {val: 4})-[:E1]->(:Y {val: 5}),
              (:X {val: 6})
            """
        ),
        expected=Expected(
            rows=[
                {"x": "(:X {val: 1})", "y": "(:Y {val: 2})"},
                {"x": "(:X {val: 4})", "y": "(:Y {val: 5})"},
                {"x": "(:X {val: 6})", "y": "null"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="OPTIONAL MATCH semantics, variable comparisons, and row projections are not supported",
        tags=("match-where", "optional-match", "comparison", "join", "xfail"),
    ),
    Scenario(
        key="match-where6-7",
        feature_path="tck/features/clauses/match-where/MatchWhere6.feature",
        scenario="[7] Join nodes on non-equality of properties – OPTIONAL MATCH on two relationships and WHERE",
        cypher="MATCH (x:X)\nOPTIONAL MATCH (x)-[:E1]->(y:Y)-[:E2]->(z:Z)\nWHERE x.val < z.val\nRETURN x, y, z",
        graph=graph_fixture_from_create(
            """
            CREATE
              (:X {val: 1})-[:E1]->(:Y {val: 2})-[:E2]->(:Z {val: 3}),
              (:X {val: 4})-[:E1]->(:Y {val: 5}),
              (:X {val: 6})
            """
        ),
        expected=Expected(
            rows=[
                {"x": "(:X {val: 1})", "y": "(:Y {val: 2})", "z": "(:Z {val: 3})"},
                {"x": "(:X {val: 4})", "y": "null", "z": "null"},
                {"x": "(:X {val: 6})", "y": "null", "z": "null"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="OPTIONAL MATCH semantics, variable comparisons, and row projections are not supported",
        tags=("match-where", "optional-match", "comparison", "join", "xfail"),
    ),
    Scenario(
        key="match-where6-8",
        feature_path="tck/features/clauses/match-where/MatchWhere6.feature",
        scenario="[8] Join nodes on non-equality of properties – Two OPTIONAL MATCH clauses and WHERE",
        cypher="MATCH (x:X)\nOPTIONAL MATCH (x)-[:E1]->(y:Y)\nOPTIONAL MATCH (y)-[:E2]->(z:Z)\nWHERE x.val < z.val\nRETURN x, y, z",
        graph=graph_fixture_from_create(
            """
            CREATE
              (:X {val: 1})-[:E1]->(:Y {val: 2})-[:E2]->(:Z {val: 3}),
              (:X {val: 4})-[:E1]->(:Y {val: 5}),
              (:X {val: 6})
            """
        ),
        expected=Expected(
            rows=[
                {"x": "(:X {val: 1})", "y": "(:Y {val: 2})", "z": "(:Z {val: 3})"},
                {"x": "(:X {val: 4})", "y": "(:Y {val: 5})", "z": "null"},
                {"x": "(:X {val: 6})", "y": "null", "z": "null"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="OPTIONAL MATCH semantics, variable comparisons, and row projections are not supported",
        tags=("match-where", "optional-match", "comparison", "join", "xfail"),
    ),
    Scenario(
        key="match2-1",
        feature_path="tck/features/clauses/match/Match2.feature",
        scenario="[1] Match non-existent relationships returns empty",
        cypher="MATCH ()-[r]->()\nRETURN r",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(edge_ids=[]),
        gfql=[n(), e_forward(), n()],
        tags=("match", "relationship", "empty-graph"),
    ),
    Scenario(
        key="match2-2",
        feature_path="tck/features/clauses/match/Match2.feature",
        scenario="[2] Matching a relationship pattern using a label predicate on both sides",
        cypher="MATCH (:A)-[r]->(:B)\nRETURN r",
        graph=graph_fixture_from_create(
            """
            CREATE (:A)-[:T1]->(:B),
                   (:B)-[:T2]->(:A),
                   (:B)-[:T3]->(:B),
                   (:A)-[:T4]->(:A)
            """
        ),
        expected=Expected(
            edge_ids=["rel_1"],
            rows=[
                {"r": "[:T1]"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Label predicates on both sides of relationship matches are not supported in the harness",
        tags=("match", "relationship", "label", "xfail"),
    ),
    Scenario(
        key="match2-3",
        feature_path="tck/features/clauses/match/Match2.feature",
        scenario="[3] Matching a self-loop with an undirected relationship pattern",
        cypher="MATCH ()-[r]-()\nRETURN type(r) AS r",
        graph=graph_fixture_from_create(
            """
            CREATE (a)
            CREATE (a)-[:T]->(a)
            """
        ),
        expected=Expected(
            rows=[
                {"r": "'T'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="type(r) projection and row comparisons are not supported",
        tags=("match", "relationship", "type-projection", "xfail"),
    ),
    Scenario(
        key="match2-4",
        feature_path="tck/features/clauses/match/Match2.feature",
        scenario="[4] Matching a self-loop with a directed relationship pattern",
        cypher="MATCH ()-[r]->()\nRETURN type(r) AS r",
        graph=graph_fixture_from_create(
            """
            CREATE (a)
            CREATE (a)-[:T]->(a)
            """
        ),
        expected=Expected(
            rows=[
                {"r": "'T'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="type(r) projection and row comparisons are not supported",
        tags=("match", "relationship", "type-projection", "xfail"),
    ),
    Scenario(
        key="match2-5",
        feature_path="tck/features/clauses/match/Match2.feature",
        scenario="[5] Match relationship with inline property value",
        cypher="MATCH (node)-[r:KNOWS {name: 'monkey'}]->(a)\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:A)<-[:KNOWS {name: 'monkey'}]-()-[:KNOWS {name: 'woot'}]->(:B)
            """
        ),
        expected=Expected(
            node_ids=["anon_1"],
            rows=[
                {"a": "(:A)"},
            ],
        ),
        gfql=[n(), e_forward({"type": "KNOWS", "name": "monkey"}), n(name="a")],
        return_alias="a",
        tags=("match", "relationship", "property"),
    ),
    Scenario(
        key="match2-6",
        feature_path="tck/features/clauses/match/Match2.feature",
        scenario="[6] Match relationships with multiple types",
        cypher="MATCH (n)-[r:KNOWS|HATES]->(x)\nRETURN r",
        graph=graph_fixture_from_create(
            """
            CREATE (a {name: 'A'}),
              (b {name: 'B'}),
              (c {name: 'C'}),
              (a)-[:KNOWS]->(b),
              (a)-[:HATES]->(c),
              (a)-[:WONDERS]->(c)
            """
        ),
        expected=Expected(
            rows=[
                {"r": "[:KNOWS]"},
                {"r": "[:HATES]"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Multiple relationship types and row projections are not supported",
        tags=("match", "relationship", "multi-type", "xfail"),
    ),
    Scenario(
        key="match3-1",
        feature_path="tck/features/clauses/match/Match3.feature",
        scenario="[1] Get neighbours",
        cypher="MATCH (n1)-[rel:KNOWS]->(n2)\nRETURN n1, n2",
        graph=graph_fixture_from_create(
            """
            CREATE (a:A {num: 1})-[:KNOWS]->(b:B {num: 2})
            """
        ),
        expected=Expected(
            rows=[
                {"n1": "(:A {num: 1})", "n2": "(:B {num: 2})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Row projections with multiple return columns are not supported",
        tags=("match", "relationship", "return", "xfail"),
    ),
    Scenario(
        key="match3-2",
        feature_path="tck/features/clauses/match/Match3.feature",
        scenario="[2] Directed match of a simple relationship",
        cypher="MATCH (a)-[r]->(b)\nRETURN a, r, b",
        graph=graph_fixture_from_create(
            """
            CREATE (:A)-[:LOOP]->(:B)
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:A)", "r": "[:LOOP]", "b": "(:B)"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Row projections with relationships are not supported",
        tags=("match", "relationship", "return", "xfail"),
    ),
    Scenario(
        key="match3-3",
        feature_path="tck/features/clauses/match/Match3.feature",
        scenario="[3] Undirected match on simple relationship graph",
        cypher="MATCH (a)-[r]-(b)\nRETURN a, r, b",
        graph=graph_fixture_from_create(
            """
            CREATE (:A)-[:LOOP]->(:B)
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:A)", "r": "[:LOOP]", "b": "(:B)"},
                {"a": "(:B)", "r": "[:LOOP]", "b": "(:A)"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Row projections with undirected relationship matches are not supported",
        tags=("match", "relationship", "undirected", "xfail"),
    ),
    Scenario(
        key="match3-5",
        feature_path="tck/features/clauses/match/Match3.feature",
        scenario="[5] Return two subgraphs with bound undirected relationship",
        cypher="MATCH (a)-[r {name: 'r'}]-(b)\nRETURN a, b",
        graph=graph_fixture_from_create(
            """
            CREATE (a:A {num: 1})-[:REL {name: 'r'}]->(b:B {num: 2})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:B {num: 2})", "b": "(:A {num: 1})"},
                {"a": "(:A {num: 1})", "b": "(:B {num: 2})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Row projections with undirected relationship matches are not supported",
        tags=("match", "relationship", "undirected", "xfail"),
    ),
    Scenario(
        key="match3-7",
        feature_path="tck/features/clauses/match/Match3.feature",
        scenario="[7] Matching nodes with many labels",
        cypher="MATCH (n:A:B:C:D:E:F:G:H:I:J:K:L:M)-[:T]->(m:Z:Y:X:W:V:U)\nRETURN n, m",
        graph=graph_fixture_from_create(
            """
            CREATE (a:A:B:C:D:E:F:G:H:I:J:K:L:M),
                   (b:U:V:W:X:Y:Z)
            CREATE (a)-[:T]->(b)
            """
        ),
        expected=Expected(
            rows=[
                {"n": "(:A:B:C:D:E:F:G:H:I:J:K:L:M)", "m": "(:Z:Y:X:W:V:U)"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Label predicates on relationship endpoints and row projections are not supported",
        tags=("match", "relationship", "label", "xfail"),
    ),
    Scenario(
        key="match3-4",
        feature_path="tck/features/clauses/match/Match3.feature",
        scenario="[4] Get two related nodes",
        cypher="MATCH ()-[rel:KNOWS]->(x)\nRETURN x",
        graph=graph_fixture_from_create(
            """
            CREATE (a:A {num: 1}),
              (a)-[:KNOWS]->(b:B {num: 2}),
              (a)-[:KNOWS]->(c:C {num: 3})
            """
        ),
        expected=Expected(
            node_ids=["b", "c"],
            rows=[
                {"x": "(:B {num: 2})"},
                {"x": "(:C {num: 3})"},
            ],
        ),
        gfql=[n(), e_forward({"type": "KNOWS"}), n(name="x")],
        return_alias="x",
        tags=("match", "relationship", "return"),
    ),
    Scenario(
        key="match3-6",
        feature_path="tck/features/clauses/match/Match3.feature",
        scenario="[6] Matching a relationship pattern using a label predicate",
        cypher="MATCH (a)-->(b:Foo)\nRETURN b",
        graph=graph_fixture_from_create(
            """
            CREATE (a), (b1:Foo), (b2)
            CREATE (a)-[:T]->(b1),
                   (a)-[:T]->(b2)
            """
        ),
        expected=Expected(
            node_ids=["b1"],
            rows=[
                {"b": "(:Foo)"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Label predicates on relationship endpoints are not supported in the harness",
        tags=("match", "relationship", "label", "xfail"),
    ),
    Scenario(
        key="match3-8",
        feature_path="tck/features/clauses/match/Match3.feature",
        scenario="[8] Matching using relationship predicate with multiples of the same type",
        cypher="MATCH (a)-[:T|:T]->(b)\nRETURN b",
        graph=graph_fixture_from_create(
            """
            CREATE (a:A), (b:B)
            CREATE (a)-[:T]->(b)
            """
        ),
        expected=Expected(
            node_ids=["b"],
            rows=[
                {"b": "(:B)"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Multiple relationship types are not supported",
        tags=("match", "relationship", "multi-type", "xfail"),
    ),
    Scenario(
        key="match3-9",
        feature_path="tck/features/clauses/match/Match3.feature",
        scenario="[9] Get related to related to",
        cypher="MATCH (n)-->(a)-->(b)\nRETURN b",
        graph=graph_fixture_from_create(
            """
            CREATE (a:A {num: 1})-[:KNOWS]->(b:B {num: 2})-[:FRIEND]->(c:C {num: 3})
            """
        ),
        expected=Expected(
            node_ids=["c"],
            rows=[
                {"b": "(:C {num: 3})"},
            ],
        ),
        gfql=[n(), e_forward(), n(), e_forward(), n(name="b")],
        return_alias="b",
        tags=("match", "relationship", "multi-hop", "return"),
    ),
    Scenario(
        key="match3-10",
        feature_path="tck/features/clauses/match/Match3.feature",
        scenario="[10] Matching using self-referencing pattern returns no result",
        cypher="MATCH (a)-->(b), (b)-->(b)\nRETURN b",
        graph=graph_fixture_from_create(
            """
            CREATE (a), (b), (c)
            CREATE (a)-[:T]->(b),
                   (b)-[:T]->(c)
            """
        ),
        expected=Expected(
            node_ids=[],
            rows=[],
        ),
        gfql=None,
        status="xfail",
        reason="Pattern-level variable reuse and row projections are not supported",
        tags=("match", "pattern-join", "self-reference", "xfail"),
    ),
    Scenario(
        key="match3-11",
        feature_path="tck/features/clauses/match/Match3.feature",
        scenario="[11] Undirected match in self-relationship graph",
        cypher="MATCH (a)-[r]-(b)\nRETURN a, r, b",
        graph=graph_fixture_from_create(
            """
            CREATE (a:A)-[:LOOP]->(a)
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:A)", "r": "[:LOOP]", "b": "(:A)"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Row projections with undirected relationship matches are not supported",
        tags=("match", "relationship", "undirected", "xfail"),
    ),
    Scenario(
        key="match3-12",
        feature_path="tck/features/clauses/match/Match3.feature",
        scenario="[12] Undirected match of self-relationship in self-relationship graph",
        cypher="MATCH (n)-[r]-(n)\nRETURN n, r",
        graph=graph_fixture_from_create(
            """
            CREATE (a:A)-[:LOOP]->(a)
            """
        ),
        expected=Expected(
            rows=[
                {"n": "(:A)", "r": "[:LOOP]"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Repeated node variables in patterns and row projections are not supported",
        tags=("match", "relationship", "undirected", "self-reference", "xfail"),
    ),
    Scenario(
        key="match3-13",
        feature_path="tck/features/clauses/match/Match3.feature",
        scenario="[13] Directed match on self-relationship graph",
        cypher="MATCH (a)-[r]->(b)\nRETURN a, r, b",
        graph=graph_fixture_from_create(
            """
            CREATE (a:A)-[:LOOP]->(a)
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:A)", "r": "[:LOOP]", "b": "(:A)"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Row projections with relationship matches are not supported",
        tags=("match", "relationship", "return", "xfail"),
    ),
    Scenario(
        key="match3-14",
        feature_path="tck/features/clauses/match/Match3.feature",
        scenario="[14] Directed match of self-relationship on self-relationship graph",
        cypher="MATCH (n)-[r]->(n)\nRETURN n, r",
        graph=graph_fixture_from_create(
            """
            CREATE (a:A)-[:LOOP]->(a)
            """
        ),
        expected=Expected(
            rows=[
                {"n": "(:A)", "r": "[:LOOP]"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Repeated node variables in patterns and row projections are not supported",
        tags=("match", "relationship", "self-reference", "xfail"),
    ),
    Scenario(
        key="match3-15",
        feature_path="tck/features/clauses/match/Match3.feature",
        scenario="[15] Mixing directed and undirected pattern parts with self-relationship, simple",
        cypher="MATCH (x:A)-[r1]->(y)-[r2]-(z)\nRETURN x, r1, y, r2, z",
        graph=graph_fixture_from_create(
            """
            CREATE (:A)-[:T1]->(l:Looper),
                   (l)-[:LOOP]->(l),
                   (l)-[:T2]->(:B)
            """
        ),
        expected=Expected(
            rows=[
                {"x": "(:A)", "r1": "[:T1]", "y": "(:Looper)", "r2": "[:LOOP]", "z": "(:Looper)"},
                {"x": "(:A)", "r1": "[:T1]", "y": "(:Looper)", "r2": "[:T2]", "z": "(:B)"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Mixed directed/undirected patterns and row projections are not supported",
        tags=("match", "relationship", "mixed-direction", "xfail"),
    ),
    Scenario(
        key="match3-16",
        feature_path="tck/features/clauses/match/Match3.feature",
        scenario="[16] Mixing directed and undirected pattern parts with self-relationship, undirected",
        cypher="MATCH (x)-[r1]-(y)-[r2]-(z)\nRETURN x, r1, y, r2, z",
        graph=graph_fixture_from_create(
            """
            CREATE (:A)-[:T1]->(l:Looper),
                   (l)-[:LOOP]->(l),
                   (l)-[:T2]->(:B)
            """
        ),
        expected=Expected(
            rows=[
                {"x": "(:A)", "r1": "[:T1]", "y": "(:Looper)", "r2": "[:LOOP]", "z": "(:Looper)"},
                {"x": "(:A)", "r1": "[:T1]", "y": "(:Looper)", "r2": "[:T2]", "z": "(:B)"},
                {"x": "(:Looper)", "r1": "[:LOOP]", "y": "(:Looper)", "r2": "[:T1]", "z": "(:A)"},
                {"x": "(:Looper)", "r1": "[:LOOP]", "y": "(:Looper)", "r2": "[:T2]", "z": "(:B)"},
                {"x": "(:B)", "r1": "[:T2]", "y": "(:Looper)", "r2": "[:LOOP]", "z": "(:Looper)"},
                {"x": "(:B)", "r1": "[:T2]", "y": "(:Looper)", "r2": "[:T1]", "z": "(:A)"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Undirected multi-hop patterns and row projections are not supported",
        tags=("match", "relationship", "undirected", "xfail"),
    ),
    Scenario(
        key="match3-17",
        feature_path="tck/features/clauses/match/Match3.feature",
        scenario="[17] Handling cyclic patterns",
        cypher="MATCH (a)-[:A]->()-[:B]->(a)\nRETURN a.name",
        graph=graph_fixture_from_create(
            """
            CREATE (a {name: 'a'}), (b {name: 'b'}), (c {name: 'c'})
            CREATE (a)-[:A]->(b),
                   (b)-[:B]->(a),
                   (b)-[:B]->(c)
            """
        ),
        expected=Expected(
            rows=[
                {"a.name": "'a'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Pattern-level variable reuse and property projections are not supported",
        tags=("match", "pattern-join", "cycle", "xfail"),
    ),
    Scenario(
        key="match3-18",
        feature_path="tck/features/clauses/match/Match3.feature",
        scenario="[18] Handling cyclic patterns when separated into two parts",
        cypher="MATCH (a)-[:A]->(b), (b)-[:B]->(a)\nRETURN a.name",
        graph=graph_fixture_from_create(
            """
            CREATE (a {name: 'a'}), (b {name: 'b'}), (c {name: 'c'})
            CREATE (a)-[:A]->(b),
                   (b)-[:B]->(a),
                   (b)-[:B]->(c)
            """
        ),
        expected=Expected(
            rows=[
                {"a.name": "'a'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Pattern-level variable reuse across comma-separated patterns is not supported",
        tags=("match", "pattern-join", "cycle", "xfail"),
    ),
    Scenario(
        key="match3-19",
        feature_path="tck/features/clauses/match/Match3.feature",
        scenario="[19] Two bound nodes pointing to the same node",
        cypher="MATCH (a {name: 'A'}), (b {name: 'B'})\nMATCH (a)-->(x)<-->(b)\nRETURN x",
        graph=graph_fixture_from_create(
            """
            CREATE (a {name: 'A'}), (b {name: 'B'}),
                   (x1 {name: 'x1'}), (x2 {name: 'x2'})
            CREATE (a)-[:KNOWS]->(x1),
                   (a)-[:KNOWS]->(x2),
                   (b)-[:KNOWS]->(x1),
                   (b)-[:KNOWS]->(x2)
            """
        ),
        expected=Expected(
            rows=[
                {"x": "({name: 'x1'})"},
                {"x": "({name: 'x2'})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Pattern-level variable binding across multiple MATCH clauses is not supported",
        tags=("match", "pattern-join", "multi-match", "xfail"),
    ),
    Scenario(
        key="match3-20",
        feature_path="tck/features/clauses/match/Match3.feature",
        scenario="[20] Three bound nodes pointing to the same node",
        cypher="MATCH (a {name: 'A'}), (b {name: 'B'}), (c {name: 'C'})\nMATCH (a)-->(x), (b)-->(x), (c)-->(x)\nRETURN x",
        graph=graph_fixture_from_create(
            """
            CREATE (a {name: 'A'}), (b {name: 'B'}), (c {name: 'C'}),
                   (x1 {name: 'x1'}), (x2 {name: 'x2'})
            CREATE (a)-[:KNOWS]->(x1),
                   (a)-[:KNOWS]->(x2),
                   (b)-[:KNOWS]->(x1),
                   (b)-[:KNOWS]->(x2),
                   (c)-[:KNOWS]->(x1),
                   (c)-[:KNOWS]->(x2)
            """
        ),
        expected=Expected(
            rows=[
                {"x": "({name: 'x1'})"},
                {"x": "({name: 'x2'})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Pattern-level variable binding across multiple MATCH clauses is not supported",
        tags=("match", "pattern-join", "multi-match", "xfail"),
    ),
    Scenario(
        key="match3-21",
        feature_path="tck/features/clauses/match/Match3.feature",
        scenario="[21] Three bound nodes pointing to the same node with extra connections",
        cypher="MATCH (a {name: 'a'}), (b {name: 'b'}), (c {name: 'c'})\nMATCH (a)-->(x), (b)-->(x), (c)-->(x)\nRETURN x",
        graph=graph_fixture_from_create(
            """
            CREATE (a {name: 'a'}), (b {name: 'b'}), (c {name: 'c'}),
                   (d {name: 'd'}), (e {name: 'e'}), (f {name: 'f'}),
                   (g {name: 'g'}), (h {name: 'h'}), (i {name: 'i'}),
                   (j {name: 'j'}), (k {name: 'k'})
            CREATE (a)-[:KNOWS]->(d),
                   (a)-[:KNOWS]->(e),
                   (a)-[:KNOWS]->(f),
                   (a)-[:KNOWS]->(g),
                   (a)-[:KNOWS]->(i),
                   (b)-[:KNOWS]->(d),
                   (b)-[:KNOWS]->(e),
                   (b)-[:KNOWS]->(f),
                   (b)-[:KNOWS]->(h),
                   (b)-[:KNOWS]->(k),
                   (c)-[:KNOWS]->(d),
                   (c)-[:KNOWS]->(e),
                   (c)-[:KNOWS]->(h),
                   (c)-[:KNOWS]->(g),
                   (c)-[:KNOWS]->(j)
            """
        ),
        expected=Expected(
            rows=[
                {"x": "({name: 'd'})"},
                {"x": "({name: 'e'})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Pattern-level variable binding across multiple MATCH clauses is not supported",
        tags=("match", "pattern-join", "multi-match", "xfail"),
    ),
    Scenario(
        key="match3-22",
        feature_path="tck/features/clauses/match/Match3.feature",
        scenario="[22] Returning bound nodes that are not part of the pattern",
        cypher="MATCH (a {name: 'A'}), (c {name: 'C'})\nMATCH (a)-->(b)\nRETURN a, b, c",
        graph=graph_fixture_from_create(
            """
            CREATE (a {name: 'A'}), (b {name: 'B'}),
                   (c {name: 'C'})
            CREATE (a)-[:KNOWS]->(b)
            """
        ),
        expected=Expected(
            rows=[
                {"a": "({name: 'A'})", "b": "({name: 'B'})", "c": "({name: 'C'})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Multiple MATCH clause bindings and row projections are not supported",
        tags=("match", "multi-match", "return", "xfail"),
    ),
    Scenario(
        key="match3-23",
        feature_path="tck/features/clauses/match/Match3.feature",
        scenario="[23] Matching disconnected patterns",
        cypher="MATCH (a)-->(b)\nMATCH (c)-->(d)\nRETURN a, b, c, d",
        graph=graph_fixture_from_create(
            """
            CREATE (a:A), (b:B), (c:C)
            CREATE (a)-[:T]->(b),
                   (a)-[:T]->(c)
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:A)", "b": "(:B)", "c": "(:A)", "d": "(:B)"},
                {"a": "(:A)", "b": "(:B)", "c": "(:A)", "d": "(:C)"},
                {"a": "(:A)", "b": "(:C)", "c": "(:A)", "d": "(:B)"},
                {"a": "(:A)", "b": "(:C)", "c": "(:A)", "d": "(:C)"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Cartesian products across multiple MATCH clauses and row projections are not supported",
        tags=("match", "cartesian", "return", "xfail"),
    ),
    Scenario(
        key="match3-24",
        feature_path="tck/features/clauses/match/Match3.feature",
        scenario="[24] Matching twice with duplicate relationship types on same relationship",
        cypher="MATCH (a1)-[r:T]->()\nWITH r, a1\nMATCH (a1)-[r:T]->(b2)\nRETURN a1, r, b2",
        graph=graph_fixture_from_create(
            """
            CREATE (:A)-[:T]->(:B)
            """
        ),
        expected=Expected(
            rows=[
                {"a1": "(:A)", "r": "[:T]", "b2": "(:B)"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH/LIMIT scoping and row projections are not supported",
        tags=("match", "with", "pipeline", "xfail"),
    ),
    Scenario(
        key="match3-25",
        feature_path="tck/features/clauses/match/Match3.feature",
        scenario="[25] Matching twice with an additional node label",
        cypher="MATCH (a1)-[r]->()\nWITH r, a1\nMATCH (a1:X)-[r]->(b2)\nRETURN a1, r, b2",
        graph=graph_fixture_from_create(
            """
            CREATE ()-[:T]->()
            """
        ),
        expected=Expected(
            rows=[],
        ),
        gfql=None,
        status="xfail",
        reason="WITH/LIMIT scoping, label predicates, and row projections are not supported",
        tags=("match", "with", "label", "xfail"),
    ),
    Scenario(
        key="match3-26",
        feature_path="tck/features/clauses/match/Match3.feature",
        scenario="[26] Matching twice with a duplicate predicate",
        cypher="MATCH (a1:X:Y)-[r]->()\nWITH r, a1\nMATCH (a1:Y)-[r]->(b2)\nRETURN a1, r, b2",
        graph=graph_fixture_from_create(
            """
            CREATE (:X:Y)-[:T]->()
            """
        ),
        expected=Expected(
            rows=[
                {"a1": "(:X:Y)", "r": "[:T]", "b2": "()"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH/LIMIT scoping, label predicates, and row projections are not supported",
        tags=("match", "with", "label", "xfail"),
    ),
    Scenario(
        key="match3-27",
        feature_path="tck/features/clauses/match/Match3.feature",
        scenario="[27] Matching from null nodes should return no results owing to finding no matches",
        cypher="OPTIONAL MATCH (a)\nWITH a\nMATCH (a)-->(b)\nRETURN b",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[],
        ),
        gfql=None,
        status="xfail",
        reason="OPTIONAL MATCH semantics, WITH pipelines, and null handling are not supported",
        tags=("match", "optional-match", "with", "null", "xfail"),
    ),
    Scenario(
        key="match3-28",
        feature_path="tck/features/clauses/match/Match3.feature",
        scenario="[28] Matching from null nodes should return no results owing to matches being filtered out",
        cypher="OPTIONAL MATCH (a:TheLabel)\nWITH a\nMATCH (a)-->(b)\nRETURN b",
        graph=graph_fixture_from_create(
            """
            CREATE ()-[:T]->()
            """
        ),
        expected=Expected(
            rows=[],
        ),
        gfql=None,
        status="xfail",
        reason="OPTIONAL MATCH semantics, WITH pipelines, and null handling are not supported",
        tags=("match", "optional-match", "with", "null", "xfail"),
    ),
    Scenario(
        key="match3-29",
        feature_path="tck/features/clauses/match/Match3.feature",
        scenario="[29] Fail when re-using a relationship in the same pattern",
        cypher="MATCH (a)-[r]->()-[r]->(a)\nRETURN r",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Compile-time validation for relationship uniqueness is not enforced",
        tags=("match", "syntax-error", "xfail"),
    ),
    Scenario(
        key="match3-30",
        feature_path="tck/features/clauses/match/Match3.feature",
        scenario="[30] Fail when using a list or nodes as a node",
        cypher="MATCH (n)\nWITH [n] AS users\nMATCH (users)-->(messages)\nRETURN messages",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Compile-time validation for variable type conflicts is not enforced",
        tags=("match", "syntax-error", "xfail"),
    ),
    Scenario(
        key="match4-1",
        feature_path="tck/features/clauses/match/Match4.feature",
        scenario="[1] Handling fixed-length variable length pattern",
        cypher="MATCH (a)-[r*1..1]->(b)\nRETURN r",
        graph=graph_fixture_from_create(
            """
            CREATE ()-[:T]->()
            """
        ),
        expected=Expected(
            rows=[
                {"r": "[[:T]]"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Variable-length relationship matching and row projections are not supported",
        tags=("match", "variable-length", "xfail"),
    ),
    Scenario(
        key="match4-2",
        feature_path="tck/features/clauses/match/Match4.feature",
        scenario="[2] Simple variable length pattern",
        cypher="MATCH (a {name: 'A'})-[*]->(x)\nRETURN x",
        graph=graph_fixture_from_create(
            """
            CREATE (a {name: 'A'}), (b {name: 'B'}),
                   (c {name: 'C'}), (d {name: 'D'})
            CREATE (a)-[:CONTAINS]->(b),
                   (b)-[:CONTAINS]->(c),
                   (c)-[:CONTAINS]->(d)
            """
        ),
        expected=Expected(
            rows=[
                {"x": "({name: 'B'})"},
                {"x": "({name: 'C'})"},
                {"x": "({name: 'D'})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Variable-length relationship matching is not supported",
        tags=("match", "variable-length", "xfail"),
    ),
    Scenario(
        key="match4-3",
        feature_path="tck/features/clauses/match/Match4.feature",
        scenario="[3] Zero-length variable length pattern in the middle of the pattern",
        cypher="MATCH (a {name: 'A'})-[:CONTAINS*0..1]->(b)-[:FRIEND*0..1]->(c)\nRETURN a, b, c",
        graph=graph_fixture_from_create(
            """
            CREATE (a {name: 'A'}), (b {name: 'B'}),
                   (c {name: 'C'}), ({name: 'D'}),
                   ({name: 'E'})
            CREATE (a)-[:CONTAINS]->(b),
                   (b)-[:FRIEND]->(c)
            """
        ),
        expected=Expected(
            rows=[
                {"a": "({name: 'A'})", "b": "({name: 'A'})", "c": "({name: 'A'})"},
                {"a": "({name: 'A'})", "b": "({name: 'B'})", "c": "({name: 'B'})"},
                {"a": "({name: 'A'})", "b": "({name: 'B'})", "c": "({name: 'C'})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Variable-length relationship matching and row projections are not supported",
        tags=("match", "variable-length", "xfail"),
    ),
    Scenario(
        key="match4-4",
        feature_path="tck/features/clauses/match/Match4.feature",
        scenario="[4] Matching longer variable length paths",
        cypher="MATCH (n {var: 'start'})-[:T*]->(m {var: 'end'})\nRETURN m",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"m": "({var: 'end'})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Variable-length relationship matching and UNWIND-based setup are not supported in the harness",
        tags=("match", "variable-length", "xfail"),
    ),
    Scenario(
        key="match4-5",
        feature_path="tck/features/clauses/match/Match4.feature",
        scenario="[5] Matching variable length pattern with property predicate",
        cypher="MATCH (a:Artist)-[:WORKED_WITH* {year: 1988}]->(b:Artist)\nRETURN *",
        graph=graph_fixture_from_create(
            """
            CREATE (a:Artist:A), (b:Artist:B), (c:Artist:C)
            CREATE (a)-[:WORKED_WITH {year: 1987}]->(b),
                   (b)-[:WORKED_WITH {year: 1988}]->(c)
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:Artist:B)", "b": "(:Artist:C)"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Variable-length relationship matching and row projections are not supported",
        tags=("match", "variable-length", "xfail"),
    ),
    Scenario(
        key="match4-6",
        feature_path="tck/features/clauses/match/Match4.feature",
        scenario="[6] Matching variable length patterns from a bound node",
        cypher="MATCH (a:A)\nMATCH (a)-[r*2]->()\nRETURN r",
        graph=graph_fixture_from_create(
            """
            CREATE (a:A), (b), (c)
            CREATE (a)-[:X]->(b),
                   (b)-[:Y]->(c)
            """
        ),
        expected=Expected(
            rows=[
                {"r": "[[:X], [:Y]]"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Variable-length relationship matching and list projections are not supported",
        tags=("match", "variable-length", "xfail"),
    ),
    Scenario(
        key="match4-7",
        feature_path="tck/features/clauses/match/Match4.feature",
        scenario="[7] Matching variable length patterns including a bound relationship",
        cypher="MATCH ()-[r:EDGE]-()\nMATCH p = (n)-[*0..1]-()-[r]-()-[*0..1]-(m)\nRETURN count(p) AS c",
        graph=graph_fixture_from_create(
            """
            CREATE (n0:Node),
                   (n1:Node),
                   (n2:Node),
                   (n3:Node),
                   (n0)-[:EDGE]->(n1),
                   (n1)-[:EDGE]->(n2),
                   (n2)-[:EDGE]->(n3)
            """
        ),
        expected=Expected(
            rows=[
                {"c": 32},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Variable-length relationship matching and aggregations are not supported",
        tags=("match", "variable-length", "aggregation", "xfail"),
    ),
    Scenario(
        key="match4-8",
        feature_path="tck/features/clauses/match/Match4.feature",
        scenario="[8] Matching relationships into a list and matching variable length using the list",
        cypher="MATCH ()-[r1]->()-[r2]->()\nWITH [r1, r2] AS rs\n  LIMIT 1\nMATCH (first)-[rs*]->(second)\nRETURN first, second",
        graph=graph_fixture_from_create(
            """
            CREATE (a:A), (b:B), (c:C)
            CREATE (a)-[:Y]->(b),
                   (b)-[:Y]->(c)
            """
        ),
        expected=Expected(
            rows=[
                {"first": "(:A)", "second": "(:C)"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, list relationship variables, and variable-length matching are not supported",
        tags=("match", "variable-length", "with", "xfail"),
    ),
    Scenario(
        key="match4-9",
        feature_path="tck/features/clauses/match/Match4.feature",
        scenario="[9] Fail when asterisk operator is missing",
        cypher="MATCH (a:A)\nMATCH (a)-[:LIKES..]->(c)\nRETURN c.name",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Compile-time validation for invalid relationship patterns is not enforced",
        tags=("match", "syntax-error", "xfail"),
    ),
    Scenario(
        key="match4-10",
        feature_path="tck/features/clauses/match/Match4.feature",
        scenario="[10] Fail on negative bound",
        cypher="MATCH (a:A)\nMATCH (a)-[:LIKES*-2]->(c)\nRETURN c.name",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Compile-time validation for invalid relationship patterns is not enforced",
        tags=("match", "syntax-error", "xfail"),
    ),
    Scenario(
        key="match5-1",
        feature_path="tck/features/clauses/match/Match5.feature",
        scenario="[1] Handling unbounded variable length match",
        cypher="MATCH (a:A)\nMATCH (a)-[:LIKES*]->(c)\nRETURN c.name",
        graph=MATCH5_GRAPH,
        expected=Expected(
            rows=[
                {"c.name": "'n00'"},
                {"c.name": "'n01'"},
                {"c.name": "'n000'"},
                {"c.name": "'n001'"},
                {"c.name": "'n010'"},
                {"c.name": "'n011'"},
                {"c.name": "'n0000'"},
                {"c.name": "'n0001'"},
                {"c.name": "'n0010'"},
                {"c.name": "'n0011'"},
                {"c.name": "'n0100'"},
                {"c.name": "'n0101'"},
                {"c.name": "'n0110'"},
                {"c.name": "'n0111'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Variable-length relationship matching and row projections are not supported",
        tags=("match", "variable-length", "xfail"),
    ),
    Scenario(
        key="match5-2",
        feature_path="tck/features/clauses/match/Match5.feature",
        scenario="[2] Handling explicitly unbounded variable length match",
        cypher="MATCH (a:A)\nMATCH (a)-[:LIKES*..]->(c)\nRETURN c.name",
        graph=MATCH5_GRAPH,
        expected=Expected(
            rows=[
                {"c.name": "'n00'"},
                {"c.name": "'n01'"},
                {"c.name": "'n000'"},
                {"c.name": "'n001'"},
                {"c.name": "'n010'"},
                {"c.name": "'n011'"},
                {"c.name": "'n0000'"},
                {"c.name": "'n0001'"},
                {"c.name": "'n0010'"},
                {"c.name": "'n0011'"},
                {"c.name": "'n0100'"},
                {"c.name": "'n0101'"},
                {"c.name": "'n0110'"},
                {"c.name": "'n0111'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Variable-length relationship matching and row projections are not supported",
        tags=("match", "variable-length", "xfail"),
    ),
    Scenario(
        key="match5-3",
        feature_path="tck/features/clauses/match/Match5.feature",
        scenario="[3] Handling single bounded variable length match 1",
        cypher="MATCH (a:A)\nMATCH (a)-[:LIKES*0]->(c)\nRETURN c.name",
        graph=MATCH5_GRAPH,
        expected=Expected(
            rows=[
                {"c.name": "'n0'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Variable-length relationship matching and row projections are not supported",
        tags=("match", "variable-length", "xfail"),
    ),
    Scenario(
        key="match5-4",
        feature_path="tck/features/clauses/match/Match5.feature",
        scenario="[4] Handling single bounded variable length match 2",
        cypher="MATCH (a:A)\nMATCH (a)-[:LIKES*1]->(c)\nRETURN c.name",
        graph=MATCH5_GRAPH,
        expected=Expected(
            rows=[
                {"c.name": "'n00'"},
                {"c.name": "'n01'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Variable-length relationship matching and row projections are not supported",
        tags=("match", "variable-length", "xfail"),
    ),
    Scenario(
        key="match5-5",
        feature_path="tck/features/clauses/match/Match5.feature",
        scenario="[5] Handling single bounded variable length match 3",
        cypher="MATCH (a:A)\nMATCH (a)-[:LIKES*2]->(c)\nRETURN c.name",
        graph=MATCH5_GRAPH,
        expected=Expected(
            rows=[
                {"c.name": "'n000'"},
                {"c.name": "'n001'"},
                {"c.name": "'n010'"},
                {"c.name": "'n011'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Variable-length relationship matching and row projections are not supported",
        tags=("match", "variable-length", "xfail"),
    ),
    Scenario(
        key="match5-6",
        feature_path="tck/features/clauses/match/Match5.feature",
        scenario="[6] Handling upper and lower bounded variable length match 1",
        cypher="MATCH (a:A)\nMATCH (a)-[:LIKES*0..2]->(c)\nRETURN c.name",
        graph=MATCH5_GRAPH,
        expected=Expected(
            rows=[
                {"c.name": "'n0'"},
                {"c.name": "'n00'"},
                {"c.name": "'n01'"},
                {"c.name": "'n000'"},
                {"c.name": "'n001'"},
                {"c.name": "'n010'"},
                {"c.name": "'n011'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Variable-length relationship matching and row projections are not supported",
        tags=("match", "variable-length", "xfail"),
    ),
    Scenario(
        key="match5-7",
        feature_path="tck/features/clauses/match/Match5.feature",
        scenario="[7] Handling upper and lower bounded variable length match 2",
        cypher="MATCH (a:A)\nMATCH (a)-[:LIKES*1..2]->(c)\nRETURN c.name",
        graph=MATCH5_GRAPH,
        expected=Expected(
            rows=[
                {"c.name": "'n00'"},
                {"c.name": "'n01'"},
                {"c.name": "'n000'"},
                {"c.name": "'n001'"},
                {"c.name": "'n010'"},
                {"c.name": "'n011'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Variable-length relationship matching and row projections are not supported",
        tags=("match", "variable-length", "xfail"),
    ),
    Scenario(
        key="match5-8",
        feature_path="tck/features/clauses/match/Match5.feature",
        scenario="[8] Handling symmetrically bounded variable length match, bounds are zero",
        cypher="MATCH (a:A)\nMATCH (a)-[:LIKES*0..0]->(c)\nRETURN c.name",
        graph=MATCH5_GRAPH,
        expected=Expected(
            rows=[
                {"c.name": "'n0'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Variable-length relationship matching and row projections are not supported",
        tags=("match", "variable-length", "xfail"),
    ),
    Scenario(
        key="match5-9",
        feature_path="tck/features/clauses/match/Match5.feature",
        scenario="[9] Handling symmetrically bounded variable length match, bounds are one",
        cypher="MATCH (a:A)\nMATCH (a)-[:LIKES*1..1]->(c)\nRETURN c.name",
        graph=MATCH5_GRAPH,
        expected=Expected(
            rows=[
                {"c.name": "'n00'"},
                {"c.name": "'n01'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Variable-length relationship matching and row projections are not supported",
        tags=("match", "variable-length", "xfail"),
    ),
    Scenario(
        key="match5-10",
        feature_path="tck/features/clauses/match/Match5.feature",
        scenario="[10] Handling symmetrically bounded variable length match, bounds are two",
        cypher="MATCH (a:A)\nMATCH (a)-[:LIKES*2..2]->(c)\nRETURN c.name",
        graph=MATCH5_GRAPH,
        expected=Expected(
            rows=[
                {"c.name": "'n000'"},
                {"c.name": "'n001'"},
                {"c.name": "'n010'"},
                {"c.name": "'n011'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Variable-length relationship matching and row projections are not supported",
        tags=("match", "variable-length", "xfail"),
    ),
    Scenario(
        key="match5-11",
        feature_path="tck/features/clauses/match/Match5.feature",
        scenario="[11] Handling upper and lower bounded variable length match, empty interval 1",
        cypher="MATCH (a:A)\nMATCH (a)-[:LIKES*2..1]->(c)\nRETURN c.name",
        graph=MATCH5_GRAPH,
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason="Variable-length relationship matching and row projections are not supported",
        tags=("match", "variable-length", "xfail"),
    ),
    Scenario(
        key="match5-12",
        feature_path="tck/features/clauses/match/Match5.feature",
        scenario="[12] Handling upper and lower bounded variable length match, empty interval 2",
        cypher="MATCH (a:A)\nMATCH (a)-[:LIKES*1..0]->(c)\nRETURN c.name",
        graph=MATCH5_GRAPH,
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason="Variable-length relationship matching and row projections are not supported",
        tags=("match", "variable-length", "xfail"),
    ),
    Scenario(
        key="match5-13",
        feature_path="tck/features/clauses/match/Match5.feature",
        scenario="[13] Handling upper bounded variable length match, empty interval",
        cypher="MATCH (a:A)\nMATCH (a)-[:LIKES*..0]->(c)\nRETURN c.name",
        graph=MATCH5_GRAPH,
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason="Variable-length relationship matching and row projections are not supported",
        tags=("match", "variable-length", "xfail"),
    ),
    Scenario(
        key="match5-14",
        feature_path="tck/features/clauses/match/Match5.feature",
        scenario="[14] Handling upper bounded variable length match 1",
        cypher="MATCH (a:A)\nMATCH (a)-[:LIKES*..1]->(c)\nRETURN c.name",
        graph=MATCH5_GRAPH,
        expected=Expected(
            rows=[
                {"c.name": "'n00'"},
                {"c.name": "'n01'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Variable-length relationship matching and row projections are not supported",
        tags=("match", "variable-length", "xfail"),
    ),
    Scenario(
        key="match5-15",
        feature_path="tck/features/clauses/match/Match5.feature",
        scenario="[15] Handling upper bounded variable length match 2",
        cypher="MATCH (a:A)\nMATCH (a)-[:LIKES*..2]->(c)\nRETURN c.name",
        graph=MATCH5_GRAPH,
        expected=Expected(
            rows=[
                {"c.name": "'n00'"},
                {"c.name": "'n01'"},
                {"c.name": "'n000'"},
                {"c.name": "'n001'"},
                {"c.name": "'n010'"},
                {"c.name": "'n011'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Variable-length relationship matching and row projections are not supported",
        tags=("match", "variable-length", "xfail"),
    ),
    Scenario(
        key="match5-16",
        feature_path="tck/features/clauses/match/Match5.feature",
        scenario="[16] Handling lower bounded variable length match 1",
        cypher="MATCH (a:A)\nMATCH (a)-[:LIKES*0..]->(c)\nRETURN c.name",
        graph=MATCH5_GRAPH,
        expected=Expected(
            rows=[
                {"c.name": "'n0'"},
                {"c.name": "'n00'"},
                {"c.name": "'n01'"},
                {"c.name": "'n000'"},
                {"c.name": "'n001'"},
                {"c.name": "'n010'"},
                {"c.name": "'n011'"},
                {"c.name": "'n0000'"},
                {"c.name": "'n0001'"},
                {"c.name": "'n0010'"},
                {"c.name": "'n0011'"},
                {"c.name": "'n0100'"},
                {"c.name": "'n0101'"},
                {"c.name": "'n0110'"},
                {"c.name": "'n0111'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Variable-length relationship matching and row projections are not supported",
        tags=("match", "variable-length", "xfail"),
    ),
    Scenario(
        key="match5-17",
        feature_path="tck/features/clauses/match/Match5.feature",
        scenario="[17] Handling lower bounded variable length match 2",
        cypher="MATCH (a:A)\nMATCH (a)-[:LIKES*1..]->(c)\nRETURN c.name",
        graph=MATCH5_GRAPH,
        expected=Expected(
            rows=[
                {"c.name": "'n00'"},
                {"c.name": "'n01'"},
                {"c.name": "'n000'"},
                {"c.name": "'n001'"},
                {"c.name": "'n010'"},
                {"c.name": "'n011'"},
                {"c.name": "'n0000'"},
                {"c.name": "'n0001'"},
                {"c.name": "'n0010'"},
                {"c.name": "'n0011'"},
                {"c.name": "'n0100'"},
                {"c.name": "'n0101'"},
                {"c.name": "'n0110'"},
                {"c.name": "'n0111'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Variable-length relationship matching and row projections are not supported",
        tags=("match", "variable-length", "xfail"),
    ),
    Scenario(
        key="match5-18",
        feature_path="tck/features/clauses/match/Match5.feature",
        scenario="[18] Handling lower bounded variable length match 3",
        cypher="MATCH (a:A)\nMATCH (a)-[:LIKES*2..]->(c)\nRETURN c.name",
        graph=MATCH5_GRAPH,
        expected=Expected(
            rows=[
                {"c.name": "'n000'"},
                {"c.name": "'n001'"},
                {"c.name": "'n010'"},
                {"c.name": "'n011'"},
                {"c.name": "'n0000'"},
                {"c.name": "'n0001'"},
                {"c.name": "'n0010'"},
                {"c.name": "'n0011'"},
                {"c.name": "'n0100'"},
                {"c.name": "'n0101'"},
                {"c.name": "'n0110'"},
                {"c.name": "'n0111'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Variable-length relationship matching and row projections are not supported",
        tags=("match", "variable-length", "xfail"),
    ),
    Scenario(
        key="match5-19",
        feature_path="tck/features/clauses/match/Match5.feature",
        scenario="[19] Handling a variable length relationship and a standard relationship in chain, zero length 1",
        cypher="MATCH (a:A)\nMATCH (a)-[:LIKES*0]->()-[:LIKES]->(c)\nRETURN c.name",
        graph=MATCH5_GRAPH,
        expected=Expected(
            rows=[
                {"c.name": "'n00'"},
                {"c.name": "'n01'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Variable-length relationship matching and row projections are not supported",
        tags=("match", "variable-length", "xfail"),
    ),
    Scenario(
        key="match5-20",
        feature_path="tck/features/clauses/match/Match5.feature",
        scenario="[20] Handling a variable length relationship and a standard relationship in chain, zero length 2",
        cypher="MATCH (a:A)\nMATCH (a)-[:LIKES]->()-[:LIKES*0]->(c)\nRETURN c.name",
        graph=MATCH5_GRAPH,
        expected=Expected(
            rows=[
                {"c.name": "'n00'"},
                {"c.name": "'n01'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Variable-length relationship matching and row projections are not supported",
        tags=("match", "variable-length", "xfail"),
    ),
    Scenario(
        key="match5-21",
        feature_path="tck/features/clauses/match/Match5.feature",
        scenario="[21] Handling a variable length relationship and a standard relationship in chain, single length 1",
        cypher="MATCH (a:A)\nMATCH (a)-[:LIKES*1]->()-[:LIKES]->(c)\nRETURN c.name",
        graph=MATCH5_GRAPH,
        expected=Expected(
            rows=[
                {"c.name": "'n000'"},
                {"c.name": "'n001'"},
                {"c.name": "'n010'"},
                {"c.name": "'n011'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Variable-length relationship matching and row projections are not supported",
        tags=("match", "variable-length", "xfail"),
    ),
    Scenario(
        key="match5-22",
        feature_path="tck/features/clauses/match/Match5.feature",
        scenario="[22] Handling a variable length relationship and a standard relationship in chain, single length 2",
        cypher="MATCH (a:A)\nMATCH (a)-[:LIKES]->()-[:LIKES*1]->(c)\nRETURN c.name",
        graph=MATCH5_GRAPH,
        expected=Expected(
            rows=[
                {"c.name": "'n000'"},
                {"c.name": "'n001'"},
                {"c.name": "'n010'"},
                {"c.name": "'n011'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Variable-length relationship matching and row projections are not supported",
        tags=("match", "variable-length", "xfail"),
    ),
    Scenario(
        key="match5-23",
        feature_path="tck/features/clauses/match/Match5.feature",
        scenario="[23] Handling a variable length relationship and a standard relationship in chain, longer 1",
        cypher="MATCH (a:A)\nMATCH (a)-[:LIKES*2]->()-[:LIKES]->(c)\nRETURN c.name",
        graph=MATCH5_GRAPH,
        expected=Expected(
            rows=[
                {"c.name": "'n0000'"},
                {"c.name": "'n0001'"},
                {"c.name": "'n0010'"},
                {"c.name": "'n0011'"},
                {"c.name": "'n0100'"},
                {"c.name": "'n0101'"},
                {"c.name": "'n0110'"},
                {"c.name": "'n0111'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Variable-length relationship matching and row projections are not supported",
        tags=("match", "variable-length", "xfail"),
    ),
    Scenario(
        key="match5-24",
        feature_path="tck/features/clauses/match/Match5.feature",
        scenario="[24] Handling a variable length relationship and a standard relationship in chain, longer 2",
        cypher="MATCH (a:A)\nMATCH (a)-[:LIKES]->()-[:LIKES*2]->(c)\nRETURN c.name",
        graph=MATCH5_GRAPH,
        expected=Expected(
            rows=[
                {"c.name": "'n0000'"},
                {"c.name": "'n0001'"},
                {"c.name": "'n0010'"},
                {"c.name": "'n0011'"},
                {"c.name": "'n0100'"},
                {"c.name": "'n0101'"},
                {"c.name": "'n0110'"},
                {"c.name": "'n0111'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Variable-length relationship matching and row projections are not supported",
        tags=("match", "variable-length", "xfail"),
    ),
    Scenario(
        key="match5-25",
        feature_path="tck/features/clauses/match/Match5.feature",
        scenario="[25] Handling a variable length relationship and a standard relationship in chain, longer 3",
        cypher="MATCH (a:A)\nMATCH (a)-[:LIKES]->()-[:LIKES*3]->(c)\nRETURN c.name",
        graph=MATCH5_GRAPH,
        expected=Expected(
            rows=[
                {"c.name": "'n00000'"},
                {"c.name": "'n00001'"},
                {"c.name": "'n00010'"},
                {"c.name": "'n00011'"},
                {"c.name": "'n00100'"},
                {"c.name": "'n00101'"},
                {"c.name": "'n00110'"},
                {"c.name": "'n00111'"},
                {"c.name": "'n01000'"},
                {"c.name": "'n01001'"},
                {"c.name": "'n01010'"},
                {"c.name": "'n01011'"},
                {"c.name": "'n01100'"},
                {"c.name": "'n01101'"},
                {"c.name": "'n01110'"},
                {"c.name": "'n01111'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Variable-length relationship matching and MATCH/CREATE setup expressions are not supported",
        tags=("match", "variable-length", "xfail"),
    ),
    Scenario(
        key="match5-26",
        feature_path="tck/features/clauses/match/Match5.feature",
        scenario="[26] Handling mixed relationship patterns and directions 1",
        cypher="MATCH (a:A)\nMATCH (a)<-[:LIKES]-()-[:LIKES*3]->(c)\nRETURN c.name",
        graph=MATCH5_GRAPH,
        expected=Expected(
            rows=[
                {"c.name": "'n00000'"},
                {"c.name": "'n00001'"},
                {"c.name": "'n00010'"},
                {"c.name": "'n00011'"},
                {"c.name": "'n00100'"},
                {"c.name": "'n00101'"},
                {"c.name": "'n00110'"},
                {"c.name": "'n00111'"},
                {"c.name": "'n01000'"},
                {"c.name": "'n01001'"},
                {"c.name": "'n01010'"},
                {"c.name": "'n01011'"},
                {"c.name": "'n01100'"},
                {"c.name": "'n01101'"},
                {"c.name": "'n01110'"},
                {"c.name": "'n01111'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Variable-length relationship matching, direction mixing, and MATCH/DELETE/CREATE setup are not supported",
        tags=("match", "variable-length", "direction", "xfail"),
    ),
    Scenario(
        key="match5-27",
        feature_path="tck/features/clauses/match/Match5.feature",
        scenario="[27] Handling mixed relationship patterns and directions 2",
        cypher="MATCH (a:A)\nMATCH (a)-[:LIKES]->()<-[:LIKES*3]->(c)\nRETURN c.name",
        graph=MATCH5_GRAPH,
        expected=Expected(
            rows=[
                {"c.name": "'n00000'"},
                {"c.name": "'n00001'"},
                {"c.name": "'n00010'"},
                {"c.name": "'n00011'"},
                {"c.name": "'n00100'"},
                {"c.name": "'n00101'"},
                {"c.name": "'n00110'"},
                {"c.name": "'n00111'"},
                {"c.name": "'n01000'"},
                {"c.name": "'n01001'"},
                {"c.name": "'n01010'"},
                {"c.name": "'n01011'"},
                {"c.name": "'n01100'"},
                {"c.name": "'n01101'"},
                {"c.name": "'n01110'"},
                {"c.name": "'n01111'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Variable-length relationship matching, direction mixing, and MATCH/DELETE/CREATE setup are not supported",
        tags=("match", "variable-length", "direction", "xfail"),
    ),
    Scenario(
        key="match5-28",
        feature_path="tck/features/clauses/match/Match5.feature",
        scenario="[28] Handling mixed relationship patterns 1",
        cypher="MATCH (a:A)\nMATCH (p)-[:LIKES*1]->()-[:LIKES]->()-[r:LIKES*2]->(c)\nRETURN c.name",
        graph=MATCH5_GRAPH,
        expected=Expected(
            rows=[
                {"c.name": "'n00000'"},
                {"c.name": "'n00001'"},
                {"c.name": "'n00010'"},
                {"c.name": "'n00011'"},
                {"c.name": "'n00100'"},
                {"c.name": "'n00101'"},
                {"c.name": "'n00110'"},
                {"c.name": "'n00111'"},
                {"c.name": "'n01000'"},
                {"c.name": "'n01001'"},
                {"c.name": "'n01010'"},
                {"c.name": "'n01011'"},
                {"c.name": "'n01100'"},
                {"c.name": "'n01101'"},
                {"c.name": "'n01110'"},
                {"c.name": "'n01111'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Variable-length relationship matching and MATCH/CREATE setup expressions are not supported",
        tags=("match", "variable-length", "xfail"),
    ),
    Scenario(
        key="match5-29",
        feature_path="tck/features/clauses/match/Match5.feature",
        scenario="[29] Handling mixed relationship patterns 2",
        cypher="MATCH (a:A)\nMATCH (p)-[:LIKES]->()-[:LIKES*2]->()-[r:LIKES]->(c)\nRETURN c.name",
        graph=MATCH5_GRAPH,
        expected=Expected(
            rows=[
                {"c.name": "'n00000'"},
                {"c.name": "'n00001'"},
                {"c.name": "'n00010'"},
                {"c.name": "'n00011'"},
                {"c.name": "'n00100'"},
                {"c.name": "'n00101'"},
                {"c.name": "'n00110'"},
                {"c.name": "'n00111'"},
                {"c.name": "'n01000'"},
                {"c.name": "'n01001'"},
                {"c.name": "'n01010'"},
                {"c.name": "'n01011'"},
                {"c.name": "'n01100'"},
                {"c.name": "'n01101'"},
                {"c.name": "'n01110'"},
                {"c.name": "'n01111'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Variable-length relationship matching and MATCH/CREATE setup expressions are not supported",
        tags=("match", "variable-length", "xfail"),
    ),
    Scenario(
        key="match6-1",
        feature_path="tck/features/clauses/match/Match6.feature",
        scenario="[1] Zero-length named path",
        cypher="MATCH p = (a)\nRETURN p",
        graph=graph_fixture_from_create(
            """
            CREATE ()
            """
        ),
        expected=Expected(
            rows=[
                {"p": "<()>"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Named path returns are not supported in the harness",
        tags=("match", "path", "xfail"),
    ),
    Scenario(
        key="match6-2",
        feature_path="tck/features/clauses/match/Match6.feature",
        scenario="[2] Return a simple path",
        cypher="MATCH p = (a {name: 'A'})-->(b)\nRETURN p",
        graph=graph_fixture_from_create(
            """
            CREATE (a:A {name: 'A'})-[:KNOWS]->(b:B {name: 'B'})
            """
        ),
        expected=Expected(
            rows=[
                {"p": "<(:A {name: 'A'})-[:KNOWS]->(:B {name: 'B'})>"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Named path returns are not supported in the harness",
        tags=("match", "path", "xfail"),
    ),
    Scenario(
        key="match6-3",
        feature_path="tck/features/clauses/match/Match6.feature",
        scenario="[3] Return a three node path",
        cypher="MATCH p = (a {name: 'A'})-[rel1]->(b)-[rel2]->(c)\nRETURN p",
        graph=graph_fixture_from_create(
            """
            CREATE (a:A {name: 'A'})-[:KNOWS]->(b:B {name: 'B'})-[:KNOWS]->(c:C {name: 'C'})
            """
        ),
        expected=Expected(
            rows=[
                {"p": "<(:A {name: 'A'})-[:KNOWS]->(:B {name: 'B'})-[:KNOWS]->(:C {name: 'C'})>"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Named path returns are not supported in the harness",
        tags=("match", "path", "xfail"),
    ),
    Scenario(
        key="match6-4",
        feature_path="tck/features/clauses/match/Match6.feature",
        scenario="[4] Respecting direction when matching non-existent path",
        cypher="MATCH p = ({name: 'a'})<--({name: 'b'})\nRETURN p",
        graph=graph_fixture_from_create(
            """
            CREATE (a {name: 'a'}), (b {name: 'b'})
            CREATE (a)-[:T]->(b)
            """
        ),
        expected=Expected(
            rows=[],
        ),
        gfql=None,
        status="xfail",
        reason="Named path returns are not supported in the harness",
        tags=("match", "path", "direction", "xfail"),
    ),
    Scenario(
        key="match6-5",
        feature_path="tck/features/clauses/match/Match6.feature",
        scenario="[5] Path query should return results in written order",
        cypher="MATCH p = (a:Label1)<--(:Label2)\nRETURN p",
        graph=graph_fixture_from_create(
            """
            CREATE (:Label1)<-[:TYPE]-(:Label2)
            """
        ),
        expected=Expected(
            rows=[
                {"p": "<(:Label1)<-[:TYPE]-(:Label2)>"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Named path returns are not supported in the harness",
        tags=("match", "path", "direction", "xfail"),
    ),
    Scenario(
        key="match6-6",
        feature_path="tck/features/clauses/match/Match6.feature",
        scenario="[6] Handling direction of named paths",
        cypher="MATCH p = (b)<--(a)\nRETURN p",
        graph=graph_fixture_from_create(
            """
            CREATE (a:A)-[:T]->(b:B)
            """
        ),
        expected=Expected(
            rows=[
                {"p": "<(:B)<-[:T]-(:A)>"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Named path returns are not supported in the harness",
        tags=("match", "path", "direction", "xfail"),
    ),
    Scenario(
        key="match6-7",
        feature_path="tck/features/clauses/match/Match6.feature",
        scenario="[7] Respecting direction when matching existing path",
        cypher="MATCH p = ({name: 'a'})-->({name: 'b'})\nRETURN p",
        graph=graph_fixture_from_create(
            """
            CREATE (a {name: 'a'}), (b {name: 'b'})
            CREATE (a)-[:T]->(b)
            """
        ),
        expected=Expected(
            rows=[
                {"p": "<({name: 'a'})-[:T]->({name: 'b'})>"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Named path returns are not supported in the harness",
        tags=("match", "path", "direction", "xfail"),
    ),
    Scenario(
        key="match6-8",
        feature_path="tck/features/clauses/match/Match6.feature",
        scenario="[8] Respecting direction when matching non-existent path with multiple directions",
        cypher="MATCH p = (n)-->(k)<--(n)\nRETURN p",
        graph=graph_fixture_from_create(
            """
            CREATE (a), (b)
            CREATE (a)-[:T]->(b),
                   (b)-[:T]->(a)
            """
        ),
        expected=Expected(
            rows=[],
        ),
        gfql=None,
        status="xfail",
        reason="Named path returns are not supported in the harness",
        tags=("match", "path", "direction", "xfail"),
    ),
    Scenario(
        key="match6-9",
        feature_path="tck/features/clauses/match/Match6.feature",
        scenario="[9] Longer path query should return results in written order",
        cypher="MATCH p = (a:Label1)<--(:Label2)--()\nRETURN p",
        graph=graph_fixture_from_create(
            """
            CREATE (:Label1)<-[:T1]-(:Label2)-[:T2]->(:Label3)
            """
        ),
        expected=Expected(
            rows=[
                {"p": "<(:Label1)<-[:T1]-(:Label2)-[:T2]->(:Label3)>"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Named path returns are not supported in the harness",
        tags=("match", "path", "xfail"),
    ),
    Scenario(
        key="match6-10",
        feature_path="tck/features/clauses/match/Match6.feature",
        scenario="[10] Named path with alternating directed/undirected relationships",
        cypher="MATCH p = (n)-->(m)--(o)\nRETURN p",
        graph=graph_fixture_from_create(
            """
            CREATE (a:A), (b:B), (c:C)
            CREATE (b)-[:T]->(a),
                   (c)-[:T]->(b)
            """
        ),
        expected=Expected(
            rows=[
                {"p": "<(:C)-[:T]->(:B)-[:T]->(:A)>"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Named path returns are not supported in the harness",
        tags=("match", "path", "undirected", "xfail"),
    ),
    Scenario(
        key="match6-11",
        feature_path="tck/features/clauses/match/Match6.feature",
        scenario="[11] Named path with multiple alternating directed/undirected relationships",
        cypher="MATCH path = (n)-->(m)--(o)--(p)\nRETURN path",
        graph=graph_fixture_from_create(
            """
            CREATE (a:A), (b:B), (c:C), (d:D)
            CREATE (b)-[:T]->(a),
                   (c)-[:T]->(b),
                   (d)-[:T]->(c)
            """
        ),
        expected=Expected(
            rows=[
                {"path": "<(:D)-[:T]->(:C)-[:T]->(:B)-[:T]->(:A)>"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Named path returns are not supported in the harness",
        tags=("match", "path", "undirected", "xfail"),
    ),
    Scenario(
        key="match6-12",
        feature_path="tck/features/clauses/match/Match6.feature",
        scenario="[12] Matching path with multiple bidirectional relationships",
        cypher="MATCH p=(n)<-->(k)<-->(n)\nRETURN p",
        graph=graph_fixture_from_create(
            """
            CREATE (a:A), (b:B)
            CREATE (a)-[:T1]->(b),
                   (b)-[:T2]->(a)
            """
        ),
        expected=Expected(
            rows=[
                {"p": "<(:A)<-[:T2]-(:B)<-[:T1]-(:A)>"},
                {"p": "<(:A)-[:T1]->(:B)-[:T2]->(:A)>"},
                {"p": "<(:B)<-[:T1]-(:A)<-[:T2]-(:B)>"},
                {"p": "<(:B)-[:T2]->(:A)-[:T1]->(:B)>"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Named path returns are not supported in the harness",
        tags=("match", "path", "undirected", "xfail"),
    ),
    Scenario(
        key="match6-13",
        feature_path="tck/features/clauses/match/Match6.feature",
        scenario="[13] Matching path with both directions should respect other directions",
        cypher="MATCH p = (n)<-->(k)<--(n)\nRETURN p",
        graph=graph_fixture_from_create(
            """
            CREATE (a:A), (b:B)
            CREATE (a)-[:T1]->(b),
                   (b)-[:T2]->(a)
            """
        ),
        expected=Expected(
            rows=[
                {"p": "<(:A)<-[:T2]-(:B)<-[:T1]-(:A)>"},
                {"p": "<(:B)<-[:T1]-(:A)<-[:T2]-(:B)>"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Named path returns are not supported in the harness",
        tags=("match", "path", "undirected", "xfail"),
    ),
    Scenario(
        key="match6-14",
        feature_path="tck/features/clauses/match/Match6.feature",
        scenario="[14] Named path with undirected fixed variable length pattern",
        cypher="MATCH topRoute = (:Start)<-[:CONNECTED_TO]-()-[:CONNECTED_TO*3..3]-(:End)\nRETURN topRoute",
        graph=graph_fixture_from_create(
            """
            CREATE (db1:Start), (db2:End), (mid), (other)
            CREATE (mid)-[:CONNECTED_TO]->(db1),
                   (mid)-[:CONNECTED_TO]->(db2),
                   (mid)-[:CONNECTED_TO]->(db2),
                   (mid)-[:CONNECTED_TO]->(other),
                   (mid)-[:CONNECTED_TO]->(other)
            """
        ),
        expected=Expected(
            rows=[
                {"topRoute": "<(:Start)<-[:CONNECTED_TO]-()-[:CONNECTED_TO]->()<-[:CONNECTED_TO]-()-[:CONNECTED_TO]->(:End)>"},
                {"topRoute": "<(:Start)<-[:CONNECTED_TO]-()-[:CONNECTED_TO]->()<-[:CONNECTED_TO]-()-[:CONNECTED_TO]->(:End)>"},
                {"topRoute": "<(:Start)<-[:CONNECTED_TO]-()-[:CONNECTED_TO]->()<-[:CONNECTED_TO]-()-[:CONNECTED_TO]->(:End)>"},
                {"topRoute": "<(:Start)<-[:CONNECTED_TO]-()-[:CONNECTED_TO]->()<-[:CONNECTED_TO]-()-[:CONNECTED_TO]->(:End)>"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Variable-length relationship matching and named path returns are not supported",
        tags=("match", "path", "variable-length", "xfail"),
    ),
    Scenario(
        key="match6-15",
        feature_path="tck/features/clauses/match/Match6.feature",
        scenario="[15] Variable-length named path",
        cypher="MATCH p = ()-[*0..]->()\nRETURN p",
        graph=graph_fixture_from_create(
            """
            CREATE ()
            """
        ),
        expected=Expected(
            rows=[
                {"p": "<()>"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Variable-length relationship matching and named path returns are not supported",
        tags=("match", "path", "variable-length", "xfail"),
    ),
    Scenario(
        key="match6-16",
        feature_path="tck/features/clauses/match/Match6.feature",
        scenario="[16] Return a var length path",
        cypher="MATCH p = (n {name: 'A'})-[:KNOWS*1..2]->(x)\nRETURN p",
        graph=graph_fixture_from_create(
            """
            CREATE (a:A {name: 'A'})-[:KNOWS {num: 1}]->(b:B {name: 'B'})-[:KNOWS {num: 2}]->(c:C {name: 'C'})
            """
        ),
        expected=Expected(
            rows=[
                {"p": "<(:A {name: 'A'})-[:KNOWS {num: 1}]->(:B {name: 'B'})>"},
                {"p": "<(:A {name: 'A'})-[:KNOWS {num: 1}]->(:B {name: 'B'})-[:KNOWS {num: 2}]->(:C {name: 'C'})>"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Variable-length relationship matching and named path returns are not supported",
        tags=("match", "path", "variable-length", "xfail"),
    ),
    Scenario(
        key="match6-17",
        feature_path="tck/features/clauses/match/Match6.feature",
        scenario="[17] Return a named var length path of length zero",
        cypher="MATCH p = (a {name: 'A'})-[:KNOWS*0..1]->(b)-[:FRIEND*0..1]->(c)\nRETURN p",
        graph=graph_fixture_from_create(
            """
            CREATE (a:A {name: 'A'})-[:KNOWS]->(b:B {name: 'B'})-[:FRIEND]->(c:C {name: 'C'})
            """
        ),
        expected=Expected(
            rows=[
                {"p": "<(:A {name: 'A'})>"},
                {"p": "<(:A {name: 'A'})-[:KNOWS]->(:B {name: 'B'})>"},
                {"p": "<(:A {name: 'A'})-[:KNOWS]->(:B {name: 'B'})-[:FRIEND]->(:C {name: 'C'})>"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Variable-length relationship matching and named path returns are not supported",
        tags=("match", "path", "variable-length", "xfail"),
    ),
    Scenario(
        key="match6-18",
        feature_path="tck/features/clauses/match/Match6.feature",
        scenario="[18] Undirected named path",
        cypher="MATCH p = (n:Movie)--(m)\nRETURN p\n  LIMIT 1",
        graph=graph_fixture_from_create(
            """
            CREATE (a:Movie), (b)
            CREATE (b)-[:T]->(a)
            """
        ),
        expected=Expected(
            rows=[
                {"p": "<(:Movie)<-[:T]-()>"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Named path returns and LIMIT handling are not supported",
        tags=("match", "path", "limit", "xfail"),
    ),
    Scenario(
        key="match6-19",
        feature_path="tck/features/clauses/match/Match6.feature",
        scenario="[19] Variable length relationship without lower bound",
        cypher="MATCH p = ({name: 'A'})-[:KNOWS*..2]->()\nRETURN p",
        graph=graph_fixture_from_create(
            """
            CREATE (a {name: 'A'}), (b {name: 'B'}),
                   (c {name: 'C'})
            CREATE (a)-[:KNOWS]->(b),
                   (b)-[:KNOWS]->(c)
            """
        ),
        expected=Expected(
            rows=[
                {"p": "<({name: 'A'})-[:KNOWS]->({name: 'B'})>"},
                {"p": "<({name: 'A'})-[:KNOWS]->({name: 'B'})-[:KNOWS]->({name: 'C'})>"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Variable-length relationship matching and named path returns are not supported",
        tags=("match", "path", "variable-length", "xfail"),
    ),
    Scenario(
        key="match6-20",
        feature_path="tck/features/clauses/match/Match6.feature",
        scenario="[20] Variable length relationship without bounds",
        cypher="MATCH p = ({name: 'A'})-[:KNOWS*..]->()\nRETURN p",
        graph=graph_fixture_from_create(
            """
            CREATE (a {name: 'A'}), (b {name: 'B'}),
                   (c {name: 'C'})
            CREATE (a)-[:KNOWS]->(b),
                   (b)-[:KNOWS]->(c)
            """
        ),
        expected=Expected(
            rows=[
                {"p": "<({name: 'A'})-[:KNOWS]->({name: 'B'})>"},
                {"p": "<({name: 'A'})-[:KNOWS]->({name: 'B'})-[:KNOWS]->({name: 'C'})>"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Variable-length relationship matching and named path returns are not supported",
        tags=("match", "path", "variable-length", "xfail"),
    ),
    Scenario(
        key="match6-21",
        feature_path="tck/features/clauses/match/Match6.feature",
        scenario="[21] Fail when a node has the same variable in a preceding MATCH",
        cypher="MATCH <pattern>\nMATCH p = ()-[]-()\nRETURN p",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Compile-time validation for variable reuse in MATCH is not enforced",
        tags=("match", "syntax-error", "xfail"),
    ),
    Scenario(
        key="match6-22",
        feature_path="tck/features/clauses/match/Match6.feature",
        scenario="[22] Fail when a relationship has the same variable in a preceding MATCH",
        cypher="MATCH <pattern>\nMATCH p = ()-[]-()\nRETURN p",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Compile-time validation for variable reuse in MATCH is not enforced",
        tags=("match", "syntax-error", "xfail"),
    ),
    Scenario(
        key="match7-1",
        feature_path="tck/features/clauses/match/Match7.feature",
        scenario="[1] Simple OPTIONAL MATCH on empty graph",
        cypher="OPTIONAL MATCH (n)\nRETURN n",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"n": "null"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="OPTIONAL MATCH semantics and null row preservation are not supported",
        tags=("match", "optional-match", "null", "xfail"),
    ),
    Scenario(
        key="match7-2",
        feature_path="tck/features/clauses/match/Match7.feature",
        scenario="[2] OPTIONAL MATCH with previously bound nodes",
        cypher="MATCH (n)\nOPTIONAL MATCH (n)-[:NOT_EXIST]->(x)\nRETURN n, x",
        graph=graph_fixture_from_create(
            """
            CREATE ()
            """
        ),
        expected=Expected(
            rows=[
                {"n": "()", "x": "null"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="OPTIONAL MATCH semantics and row projections are not supported",
        tags=("match", "optional-match", "null", "xfail"),
    ),
    Scenario(
        key="match7-3",
        feature_path="tck/features/clauses/match/Match7.feature",
        scenario="[3] OPTIONAL MATCH and bound nodes",
        cypher="MATCH (a:A), (b:C)\nOPTIONAL MATCH (x)-->(b)\nRETURN x",
        graph=MATCH7_GRAPH_SINGLE,
        expected=Expected(
            rows=[
                {"x": "(:A {num: 42})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="OPTIONAL MATCH semantics and row projections are not supported",
        tags=("match", "optional-match", "xfail"),
    ),
    Scenario(
        key="match7-4",
        feature_path="tck/features/clauses/match/Match7.feature",
        scenario="[4] Optionally matching relationship with bound nodes in reverse direction",
        cypher="MATCH (a1)-[r]->()\nWITH r, a1\n  LIMIT 1\nOPTIONAL MATCH (a1)<-[r]-(b2)\nRETURN a1, r, b2",
        graph=MATCH7_GRAPH_AB,
        expected=Expected(
            rows=[
                {"a1": "(:A)", "r": "[:T]", "b2": "null"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH/LIMIT scoping and OPTIONAL MATCH semantics are not supported",
        tags=("match", "optional-match", "with", "limit", "xfail"),
    ),
    Scenario(
        key="match7-5",
        feature_path="tck/features/clauses/match/Match7.feature",
        scenario="[5] Optionally matching relationship with a relationship that is already bound",
        cypher="MATCH ()-[r]->()\nWITH r\n  LIMIT 1\nOPTIONAL MATCH (a2)-[r]->(b2)\nRETURN a2, r, b2",
        graph=MATCH7_GRAPH_AB,
        expected=Expected(
            rows=[
                {"a2": "(:A)", "r": "[:T]", "b2": "(:B)"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH/LIMIT scoping and OPTIONAL MATCH semantics are not supported",
        tags=("match", "optional-match", "with", "limit", "xfail"),
    ),
    Scenario(
        key="match7-6",
        feature_path="tck/features/clauses/match/Match7.feature",
        scenario="[6] Optionally matching relationship with a relationship and node that are both already bound",
        cypher="MATCH (a1)-[r]->()\nWITH r, a1\n  LIMIT 1\nOPTIONAL MATCH (a1)-[r]->(b2)\nRETURN a1, r, b2",
        graph=MATCH7_GRAPH_AB,
        expected=Expected(
            rows=[
                {"a1": "(:A)", "r": "[:T]", "b2": "(:B)"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH/LIMIT scoping and OPTIONAL MATCH semantics are not supported",
        tags=("match", "optional-match", "with", "limit", "xfail"),
    ),
    Scenario(
        key="match7-7",
        feature_path="tck/features/clauses/match/Match7.feature",
        scenario="[7] MATCH with OPTIONAL MATCH in longer pattern",
        cypher="MATCH (a {name: 'A'})\nOPTIONAL MATCH (a)-[:KNOWS]->()-[:KNOWS]->(foo)\nRETURN foo",
        graph=MATCH7_GRAPH_ABC,
        expected=Expected(
            rows=[
                {"foo": "({name: 'C'})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="OPTIONAL MATCH semantics and row projections are not supported",
        tags=("match", "optional-match", "xfail"),
    ),
    Scenario(
        key="match7-8",
        feature_path="tck/features/clauses/match/Match7.feature",
        scenario="[8] Longer pattern with bound nodes without matches",
        cypher="MATCH (a:A), (c:C)\nOPTIONAL MATCH (a)-->(b)-->(c)\nRETURN b",
        graph=MATCH7_GRAPH_SINGLE,
        expected=Expected(
            rows=[
                {"b": "null"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="OPTIONAL MATCH semantics and null propagation are not supported",
        tags=("match", "optional-match", "null", "xfail"),
    ),
    Scenario(
        key="match7-9",
        feature_path="tck/features/clauses/match/Match7.feature",
        scenario="[9] Longer pattern with bound nodes",
        cypher="MATCH (a:Single), (c:C)\nOPTIONAL MATCH (a)-->(b)-->(c)\nRETURN b",
        graph=MATCH7_GRAPH_SINGLE,
        expected=Expected(
            rows=[
                {"b": "(:A {num: 42})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="OPTIONAL MATCH semantics and row projections are not supported",
        tags=("match", "optional-match", "xfail"),
    ),
    Scenario(
        key="match7-10",
        feature_path="tck/features/clauses/match/Match7.feature",
        scenario="[10] Optionally matching from null nodes should return null",
        cypher="OPTIONAL MATCH (a)\nWITH a\nOPTIONAL MATCH (a)-->(b)\nRETURN b",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"b": "null"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, OPTIONAL MATCH semantics, and null handling are not supported",
        tags=("match", "optional-match", "with", "null", "xfail"),
    ),
    Scenario(
        key="match7-11",
        feature_path="tck/features/clauses/match/Match7.feature",
        scenario="[11] Return two subgraphs with bound undirected relationship and optional relationship",
        cypher="MATCH (a)-[r {name: 'r1'}]-(b)\nOPTIONAL MATCH (b)-[r2]-(c)\nWHERE r <> r2\nRETURN a, b, c",
        graph=MATCH7_GRAPH_REL,
        expected=Expected(
            rows=[
                {"a": "(:A {num: 1})", "b": "(:B {num: 2})", "c": "(:C {num: 3})"},
                {"a": "(:B {num: 2})", "b": "(:A {num: 1})", "c": "null"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="OPTIONAL MATCH semantics, variable comparison joins, and row projections are not supported",
        tags=("match", "optional-match", "join", "xfail"),
    ),
    Scenario(
        key="match7-12",
        feature_path="tck/features/clauses/match/Match7.feature",
        scenario="[12] Variable length optional relationships",
        cypher="MATCH (a:Single)\nOPTIONAL MATCH (a)-[*]->(b)\nRETURN b",
        graph=MATCH7_GRAPH_SINGLE,
        expected=Expected(
            rows=[
                {"b": "(:A {num: 42})"},
                {"b": "(:B {num: 46})"},
                {"b": "(:B {num: 46})"},
                {"b": "(:C)"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="OPTIONAL MATCH semantics, variable-length relationships, and row projections are not supported",
        tags=("match", "optional-match", "variable-length", "xfail"),
    ),
    Scenario(
        key="match7-13",
        feature_path="tck/features/clauses/match/Match7.feature",
        scenario="[13] Variable length optional relationships with bound nodes",
        cypher="MATCH (a:Single), (x:C)\nOPTIONAL MATCH (a)-[*]->(x)\nRETURN x",
        graph=MATCH7_GRAPH_SINGLE,
        expected=Expected(
            rows=[
                {"x": "(:C)"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="OPTIONAL MATCH semantics and variable-length relationships are not supported",
        tags=("match", "optional-match", "variable-length", "xfail"),
    ),
    Scenario(
        key="match7-14",
        feature_path="tck/features/clauses/match/Match7.feature",
        scenario="[14] Variable length optional relationships with length predicates",
        cypher="MATCH (a:Single)\nOPTIONAL MATCH (a)-[*3..]-(b)\nRETURN b",
        graph=MATCH7_GRAPH_SINGLE,
        expected=Expected(
            rows=[
                {"b": "null"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="OPTIONAL MATCH semantics and variable-length relationships are not supported",
        tags=("match", "optional-match", "variable-length", "null", "xfail"),
    ),
    Scenario(
        key="match7-15",
        feature_path="tck/features/clauses/match/Match7.feature",
        scenario="[15] Variable length patterns and nulls",
        cypher="MATCH (a:A)\nOPTIONAL MATCH (a)-[:FOO]->(b:B)\nOPTIONAL MATCH (b)<-[:BAR*]-(c:B)\nRETURN a, b, c",
        graph=graph_fixture_from_create(
            """
            CREATE (a:A), (b:B)
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:A)", "b": "null", "c": "null"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="OPTIONAL MATCH semantics and variable-length relationships are not supported",
        tags=("match", "optional-match", "variable-length", "null", "xfail"),
    ),
    Scenario(
        key="match7-16",
        feature_path="tck/features/clauses/match/Match7.feature",
        scenario="[16] Optionally matching named paths - null result",
        cypher="MATCH (a:A)\nOPTIONAL MATCH p = (a)-[:X]->(b)\nRETURN p",
        graph=MATCH7_GRAPH_SINGLE,
        expected=Expected(
            rows=[
                {"p": "null"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="OPTIONAL MATCH semantics and named path returns are not supported",
        tags=("match", "optional-match", "path", "null", "xfail"),
    ),
    Scenario(
        key="match7-17",
        feature_path="tck/features/clauses/match/Match7.feature",
        scenario="[17] Optionally matching named paths - existing result",
        cypher="MATCH (a {name: 'A'}), (x)\nWHERE x.name IN ['B', 'C']\nOPTIONAL MATCH p = (a)-->(x)\nRETURN x, p",
        graph=MATCH7_GRAPH_X,
        expected=Expected(
            rows=[
                {"x": "({name: 'B'})", "p": "<({name: 'A'})-[:X]->({name: 'B'})>"},
                {"x": "({name: 'C'})", "p": "null"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="OPTIONAL MATCH semantics, IN predicates, and named path returns are not supported",
        tags=("match", "optional-match", "path", "in-predicate", "xfail"),
    ),
    Scenario(
        key="match7-18",
        feature_path="tck/features/clauses/match/Match7.feature",
        scenario="[18] Named paths inside optional matches with node predicates",
        cypher="MATCH (a:A), (b:B)\nOPTIONAL MATCH p = (a)-[:X]->(b)\nRETURN p",
        graph=MATCH7_GRAPH_SINGLE,
        expected=Expected(
            rows=[
                {"p": "null"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="OPTIONAL MATCH semantics and named path returns are not supported",
        tags=("match", "optional-match", "path", "xfail"),
    ),
    Scenario(
        key="match7-19",
        feature_path="tck/features/clauses/match/Match7.feature",
        scenario="[19] Optionally matching named paths with single and variable length patterns",
        cypher="MATCH (a {name: 'A'})\nOPTIONAL MATCH p = (a)-->(b)-[*]->(c)\nRETURN p",
        graph=MATCH7_GRAPH_AB_X,
        expected=Expected(
            rows=[
                {"p": "null"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="OPTIONAL MATCH semantics, variable-length relationships, and named path returns are not supported",
        tags=("match", "optional-match", "path", "variable-length", "xfail"),
    ),
    Scenario(
        key="match7-20",
        feature_path="tck/features/clauses/match/Match7.feature",
        scenario="[20] Variable length optional relationships with bound nodes, no matches",
        cypher="MATCH (a:A), (b:B)\nOPTIONAL MATCH p = (a)-[*]->(b)\nRETURN p",
        graph=MATCH7_GRAPH_SINGLE,
        expected=Expected(
            rows=[
                {"p": "null"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="OPTIONAL MATCH semantics, variable-length relationships, and named path returns are not supported",
        tags=("match", "optional-match", "path", "variable-length", "null", "xfail"),
    ),
    Scenario(
        key="match7-21",
        feature_path="tck/features/clauses/match/Match7.feature",
        scenario="[21] Handling optional matches between nulls",
        cypher="OPTIONAL MATCH (a:NotThere)\nOPTIONAL MATCH (b:NotThere)\nWITH a, b\nOPTIONAL MATCH (b)-[r:NOR_THIS]->(a)\nRETURN a, b, r",
        graph=MATCH7_GRAPH_SINGLE,
        expected=Expected(
            rows=[
                {"a": "null", "b": "null", "r": "null"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, OPTIONAL MATCH semantics, and null handling are not supported",
        tags=("match", "optional-match", "with", "null", "xfail"),
    ),
    Scenario(
        key="match7-22",
        feature_path="tck/features/clauses/match/Match7.feature",
        scenario="[22] MATCH after OPTIONAL MATCH",
        cypher="MATCH (a:Single)\nOPTIONAL MATCH (a)-->(b:NonExistent)\nOPTIONAL MATCH (a)-->(c:NonExistent)\nWITH coalesce(b, c) AS x\nMATCH (x)-->(d)\nRETURN d",
        graph=MATCH7_GRAPH_SINGLE,
        expected=Expected(
            rows=[],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, OPTIONAL MATCH semantics, and row projections are not supported",
        tags=("match", "optional-match", "with", "xfail"),
    ),
    Scenario(
        key="match7-23",
        feature_path="tck/features/clauses/match/Match7.feature",
        scenario="[23] OPTIONAL MATCH with labels on the optional end node",
        cypher="MATCH (a:X)\nOPTIONAL MATCH (a)-->(b:Y)\nRETURN b",
        graph=MATCH7_GRAPH_LABELS,
        expected=Expected(
            rows=[
                {"b": "null"},
                {"b": "(:Y)"},
                {"b": "(:Y:Z)"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="OPTIONAL MATCH semantics and label predicates on relationship endpoints are not supported",
        tags=("match", "optional-match", "label", "xfail"),
    ),
    Scenario(
        key="match7-24",
        feature_path="tck/features/clauses/match/Match7.feature",
        scenario="[24] Optionally matching self-loops",
        cypher="MATCH (a:B)\nOPTIONAL MATCH (a)-[r]-(a)\nRETURN r",
        graph=MATCH7_GRAPH_SINGLE,
        expected=Expected(
            rows=[
                {"r": "[:LOOP]"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="OPTIONAL MATCH semantics and row projections are not supported",
        tags=("match", "optional-match", "relationship", "xfail"),
    ),
    Scenario(
        key="match7-25",
        feature_path="tck/features/clauses/match/Match7.feature",
        scenario="[25] Optionally matching self-loops without matches",
        cypher="MATCH (a)\nWHERE NOT (a:B)\nOPTIONAL MATCH (a)-[r]->(a)\nRETURN r",
        graph=MATCH7_GRAPH_SINGLE,
        expected=Expected(
            rows=[
                {"r": "null"},
                {"r": "null"},
                {"r": "null"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="OPTIONAL MATCH semantics, label predicates in WHERE, and null handling are not supported",
        tags=("match", "optional-match", "label-predicate", "null", "xfail"),
    ),
    Scenario(
        key="match7-26",
        feature_path="tck/features/clauses/match/Match7.feature",
        scenario="[26] Handling correlated optional matches; first does not match implies second does not match",
        cypher="MATCH (a:A), (b:B)\nOPTIONAL MATCH (a)-->(x)\nOPTIONAL MATCH (x)-[r]->(b)\nRETURN x, r",
        graph=MATCH7_GRAPH_SINGLE,
        expected=Expected(
            rows=[
                {"x": "(:C)", "r": "null"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="OPTIONAL MATCH semantics and row projections are not supported",
        tags=("match", "optional-match", "xfail"),
    ),
    Scenario(
        key="match7-27",
        feature_path="tck/features/clauses/match/Match7.feature",
        scenario="[27] Handling optional matches between optionally matched entities",
        cypher="OPTIONAL MATCH (a:NotThere)\nWITH a\nMATCH (b:B)\nWITH a, b\nOPTIONAL MATCH (b)-[r:NOR_THIS]->(a)\nRETURN a, b, r",
        graph=MATCH7_GRAPH_SINGLE,
        expected=Expected(
            rows=[
                {"a": "null", "b": "(:B {num: 46})", "r": "null"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, OPTIONAL MATCH semantics, and row projections are not supported",
        tags=("match", "optional-match", "with", "null", "xfail"),
    ),
    Scenario(
        key="match7-28",
        feature_path="tck/features/clauses/match/Match7.feature",
        scenario="[28] Handling optional matches with inline label predicate",
        cypher="MATCH (n:Single)\nOPTIONAL MATCH (n)-[r]-(m:NonExistent)\nRETURN r",
        graph=MATCH7_GRAPH_SINGLE,
        expected=Expected(
            rows=[
                {"r": "null"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="OPTIONAL MATCH semantics and label predicates on relationship endpoints are not supported",
        tags=("match", "optional-match", "label", "xfail"),
    ),
    Scenario(
        key="match7-29",
        feature_path="tck/features/clauses/match/Match7.feature",
        scenario="[29] Satisfies the open world assumption, relationships between same nodes",
        cypher="MATCH (p:Player)-[:PLAYS_FOR]->(team:Team)\nOPTIONAL MATCH (p)-[s:SUPPORTS]->(team)\nRETURN count(*) AS matches, s IS NULL AS optMatch",
        graph=MATCH7_GRAPH_PLAYER_TEAM_BOTH,
        expected=Expected(
            rows=[
                {"matches": 1, "optMatch": "false"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="OPTIONAL MATCH semantics, aggregations, and IS NULL projections are not supported",
        tags=("match", "optional-match", "aggregation", "is-null", "xfail"),
    ),
    Scenario(
        key="match7-30",
        feature_path="tck/features/clauses/match/Match7.feature",
        scenario="[30] Satisfies the open world assumption, single relationship",
        cypher="MATCH (p:Player)-[:PLAYS_FOR]->(team:Team)\nOPTIONAL MATCH (p)-[s:SUPPORTS]->(team)\nRETURN count(*) AS matches, s IS NULL AS optMatch",
        graph=MATCH7_GRAPH_PLAYER_TEAM_SINGLE,
        expected=Expected(
            rows=[
                {"matches": 1, "optMatch": "true"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="OPTIONAL MATCH semantics, aggregations, and IS NULL projections are not supported",
        tags=("match", "optional-match", "aggregation", "is-null", "xfail"),
    ),
    Scenario(
        key="match7-31",
        feature_path="tck/features/clauses/match/Match7.feature",
        scenario="[31] Satisfies the open world assumption, relationships between different nodes",
        cypher="MATCH (p:Player)-[:PLAYS_FOR]->(team:Team)\nOPTIONAL MATCH (p)-[s:SUPPORTS]->(team)\nRETURN count(*) AS matches, s IS NULL AS optMatch",
        graph=MATCH7_GRAPH_PLAYER_TEAM_DIFF,
        expected=Expected(
            rows=[
                {"matches": 1, "optMatch": "true"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="OPTIONAL MATCH semantics, aggregations, and IS NULL projections are not supported",
        tags=("match", "optional-match", "aggregation", "is-null", "xfail"),
    ),
    Scenario(
        key="match8-1",
        feature_path="tck/features/clauses/match/Match8.feature",
        scenario="[1] Pattern independent of bound variables results in cross product",
        cypher="MATCH (a)\nWITH a\nMATCH (b)\nRETURN a, b",
        graph=graph_fixture_from_create(
            """
            CREATE (:A), (:B)
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:A)", "b": "(:A)"},
                {"a": "(:A)", "b": "(:B)"},
                {"a": "(:B)", "b": "(:A)"},
                {"a": "(:B)", "b": "(:B)"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, cartesian products, and row projections are not supported",
        tags=("match", "with", "cartesian", "xfail"),
    ),
    Scenario(
        key="match8-2",
        feature_path="tck/features/clauses/match/Match8.feature",
        scenario="[2] Counting rows after MATCH, MERGE, OPTIONAL MATCH",
        cypher="MATCH (a)\nMERGE (b)\nWITH *\nOPTIONAL MATCH (a)--(b)\nRETURN count(*)",
        graph=graph_fixture_from_create(
            """
            CREATE (a:A), (b:B)
            CREATE (a)-[:T1]->(b),
                   (b)-[:T2]->(a)
            """
        ),
        expected=Expected(
            rows=[
                {"count(*)": 6},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="MERGE, OPTIONAL MATCH semantics, aggregations, and row projections are not supported",
        tags=("match", "merge", "optional-match", "aggregation", "xfail"),
    ),
    Scenario(
        key="match8-3",
        feature_path="tck/features/clauses/match/Match8.feature",
        scenario="[3] Matching and disregarding output, then matching again",
        cypher="MATCH ()-->()\nWITH 1 AS x\nMATCH ()-[r1]->()<--()\nRETURN sum(r1.times)",
        graph=graph_fixture_from_create(
            """
            CREATE (andres {name: 'Andres'}),
                   (michael {name: 'Michael'}),
                   (peter {name: 'Peter'}),
                   (bread {type: 'Bread'}),
                   (veggies {type: 'Veggies'}),
                   (meat {type: 'Meat'})
            CREATE (andres)-[:ATE {times: 10}]->(bread),
                   (andres)-[:ATE {times: 8}]->(veggies),
                   (michael)-[:ATE {times: 4}]->(veggies),
                   (michael)-[:ATE {times: 6}]->(bread),
                   (michael)-[:ATE {times: 9}]->(meat),
                   (peter)-[:ATE {times: 7}]->(veggies),
                   (peter)-[:ATE {times: 7}]->(bread),
                   (peter)-[:ATE {times: 4}]->(meat)
            """
        ),
        expected=Expected(
            rows=[
                {"sum(r1.times)": 776},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, aggregations, and row projections are not supported",
        tags=("match", "with", "aggregation", "xfail"),
    ),
    Scenario(
        key="match9-1",
        feature_path="tck/features/clauses/match/Match9.feature",
        scenario="[1] Variable length relationship variables are lists of relationships",
        cypher="MATCH ()-[r*0..1]-()\nRETURN last(r) AS l",
        graph=graph_fixture_from_create(
            """
            CREATE (a), (b), (c)
            CREATE (a)-[:T]->(b)
            """
        ),
        expected=Expected(
            rows=[
                {"l": "[:T]"},
                {"l": "[:T]"},
                {"l": "null"},
                {"l": "null"},
                {"l": "null"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Variable-length relationship lists, list functions, and row projections are not supported",
        tags=("match", "variable-length", "list", "xfail"),
    ),
    Scenario(
        key="match9-2",
        feature_path="tck/features/clauses/match/Match9.feature",
        scenario="[2] Return relationships by collecting them as a list - directed, one way",
        cypher="MATCH (a)-[r:REL*2..2]->(b:End)\nRETURN r",
        graph=graph_fixture_from_create(
            """
            CREATE (a:A)-[:REL {num: 1}]->(b:B)-[:REL {num: 2}]->(e:End)
            """
        ),
        expected=Expected(
            rows=[
                {"r": "[[:REL {num: 1}], [:REL {num: 2}]]"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Variable-length relationship lists and list projections are not supported",
        tags=("match", "variable-length", "list", "xfail"),
    ),
    Scenario(
        key="match9-3",
        feature_path="tck/features/clauses/match/Match9.feature",
        scenario="[3] Return relationships by collecting them as a list - undirected, starting from two extremes",
        cypher="MATCH (a)-[r:REL*2..2]-(b:End)\nRETURN r",
        graph=graph_fixture_from_create(
            """
            CREATE (a:End)-[:REL {num: 1}]->(b:B)-[:REL {num: 2}]->(c:End)
            """
        ),
        expected=Expected(
            rows=[
                {"r": "[[:REL {num:1}], [:REL {num:2}]]"},
                {"r": "[[:REL {num:2}], [:REL {num:1}]]"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Variable-length relationship lists and list projections are not supported",
        tags=("match", "variable-length", "list", "xfail"),
    ),
    Scenario(
        key="match9-4",
        feature_path="tck/features/clauses/match/Match9.feature",
        scenario="[4] Return relationships by collecting them as a list - undirected, starting from one extreme",
        cypher="MATCH (a:Start)-[r:REL*2..2]-(b)\nRETURN r",
        graph=graph_fixture_from_create(
            """
            CREATE (s:Start)-[:REL {num: 1}]->(b:B)-[:REL {num: 2}]->(c:C)
            """
        ),
        expected=Expected(
            rows=[
                {"r": "[[:REL {num: 1}], [:REL {num: 2}]]"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Variable-length relationship lists and list projections are not supported",
        tags=("match", "variable-length", "list", "xfail"),
    ),
    Scenario(
        key="match9-5",
        feature_path="tck/features/clauses/match/Match9.feature",
        scenario="[5] Variable length pattern with label predicate on both sides",
        cypher="MATCH (a:Blue)-[r*]->(b:Green)\nRETURN count(r)",
        graph=graph_fixture_from_create(
            """
            CREATE (a:Blue), (b:Red), (c:Green), (d:Yellow)
            CREATE (a)-[:T]->(b),
                   (b)-[:T]->(c),
                   (b)-[:T]->(d)
            """
        ),
        expected=Expected(
            rows=[
                {"count(r)": 1},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Variable-length patterns, label predicates, and aggregations are not supported",
        tags=("match", "variable-length", "label", "aggregation", "xfail"),
    ),
    Scenario(
        key="match9-6",
        feature_path="tck/features/clauses/match/Match9.feature",
        scenario="[6] Matching relationships into a list and matching variable length using the list, with bound nodes",
        cypher="MATCH (a)-[r1]->()-[r2]->(b)\nWITH [r1, r2] AS rs, a AS first, b AS second\n  LIMIT 1\nMATCH (first)-[rs*]->(second)\nRETURN first, second",
        graph=graph_fixture_from_create(
            """
            CREATE (a:A), (b:B), (c:C)
            CREATE (a)-[:Y]->(b),
                   (b)-[:Y]->(c)
            """
        ),
        expected=Expected(
            rows=[
                {"first": "(:A)", "second": "(:C)"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH/LIMIT pipelines, variable-length patterns, and relationship list matching are not supported",
        tags=("match", "with", "limit", "variable-length", "list", "xfail"),
    ),
    Scenario(
        key="match9-7",
        feature_path="tck/features/clauses/match/Match9.feature",
        scenario="[7] Matching relationships into a list and matching variable length using the list, with bound nodes, wrong direction",
        cypher="MATCH (a)-[r1]->()-[r2]->(b)\nWITH [r1, r2] AS rs, a AS second, b AS first\n  LIMIT 1\nMATCH (first)-[rs*]->(second)\nRETURN first, second",
        graph=graph_fixture_from_create(
            """
            CREATE (a:A), (b:B), (c:C)
            CREATE (a)-[:Y]->(b),
                   (b)-[:Y]->(c)
            """
        ),
        expected=Expected(
            rows=[],
        ),
        gfql=None,
        status="xfail",
        reason="WITH/LIMIT pipelines, variable-length patterns, and relationship list matching are not supported",
        tags=("match", "with", "limit", "variable-length", "list", "xfail"),
    ),
    Scenario(
        key="match9-8",
        feature_path="tck/features/clauses/match/Match9.feature",
        scenario="[8] Variable length relationship in OPTIONAL MATCH",
        cypher="MATCH (a:A), (b:B)\nOPTIONAL MATCH (a)-[r*]-(b)\nWHERE r IS NULL\n  AND a <> b\nRETURN b",
        graph=graph_fixture_from_create(
            """
            CREATE (:A), (:B)
            """
        ),
        expected=Expected(
            rows=[
                {"b": "(:B)"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="OPTIONAL MATCH semantics, variable-length patterns, null predicates, and variable comparisons are not supported",
        tags=("match", "optional-match", "variable-length", "null", "comparison", "xfail"),
    ),
    Scenario(
        key="match9-9",
        feature_path="tck/features/clauses/match/Match9.feature",
        scenario="[9] Optionally matching named paths with variable length patterns",
        cypher="MATCH (a {name: 'A'}), (x)\nWHERE x.name IN ['B', 'C']\nOPTIONAL MATCH p = (a)-[r*]->(x)\nRETURN r, x, p",
        graph=graph_fixture_from_create(
            """
            CREATE (a {name: 'A'}), (b {name: 'B'}), (c {name: 'C'})
            CREATE (a)-[:X]->(b)
            """
        ),
        expected=Expected(
            rows=[
                {"r": "[[:X]]", "x": "({name: 'B'})", "p": "<({name: 'A'})-[:X]->({name: 'B'})>"},
                {"r": "null", "x": "({name: 'C'})", "p": "null"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="OPTIONAL MATCH semantics, variable-length relationship lists, IN predicates, and named path returns are not supported",
        tags=("match", "optional-match", "variable-length", "list", "path", "in-predicate", "xfail"),
    ),
    Scenario(
        key="return1-1",
        feature_path="tck/features/clauses/return/Return1.feature",
        scenario="[1] Returning a list property",
        cypher="MATCH (n)\nRETURN n",
        graph=GraphFixture(
            nodes=[
                {"id": "n1", "labels": [], "numbers": [1, 2, 3]},
            ],
            edges=[],
        ),
        expected=Expected(
            node_ids=["n1"],
            rows=[
                {"n": "({numbers: [1, 2, 3]})"},
            ],
        ),
        gfql=[n()],
        tags=("return", "list-property"),
    ),
    Scenario(
        key="return1-2",
        feature_path="tck/features/clauses/return/Return1.feature",
        scenario="[2] Fail when returning an undefined variable",
        cypher="MATCH ()\nRETURN foo",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Compile-time validation for undefined variables is not enforced",
        tags=("return", "syntax-error", "xfail"),
    ),
    Scenario(
        key="return2-1",
        feature_path="tck/features/clauses/return/Return2.feature",
        scenario="[1] Arithmetic expressions should propagate null values",
        cypher="RETURN 1 + (2 - (3 * (4 / (5 ^ (6 % null))))) AS a",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"a": "null"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="RETURN expression evaluation and null arithmetic semantics are not supported",
        tags=("return", "expression", "null", "xfail"),
    ),
    Scenario(
        key="return2-2",
        feature_path="tck/features/clauses/return/Return2.feature",
        scenario="[2] Returning a node property value",
        cypher="MATCH (a)\nRETURN a.num",
        graph=graph_fixture_from_create(
            """
            CREATE ({num: 1})
            """
        ),
        expected=Expected(
            rows=[
                {"a.num": 1},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="RETURN property projections are not supported",
        tags=("return", "property", "xfail"),
    ),
    Scenario(
        key="return2-3",
        feature_path="tck/features/clauses/return/Return2.feature",
        scenario="[3] Missing node property should become null",
        cypher="MATCH (a)\nRETURN a.name",
        graph=graph_fixture_from_create(
            """
            CREATE ({num: 1})
            """
        ),
        expected=Expected(
            rows=[
                {"a.name": "null"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="RETURN property projections and null semantics are not supported",
        tags=("return", "property", "null", "xfail"),
    ),
    Scenario(
        key="return2-4",
        feature_path="tck/features/clauses/return/Return2.feature",
        scenario="[4] Returning a relationship property value",
        cypher="MATCH ()-[r]->()\nRETURN r.num",
        graph=graph_fixture_from_create(
            """
            CREATE ()-[:T {num: 1}]->()
            """
        ),
        expected=Expected(
            rows=[
                {"r.num": 1},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="RETURN relationship property projections are not supported",
        tags=("return", "relationship", "property", "xfail"),
    ),
    Scenario(
        key="return2-5",
        feature_path="tck/features/clauses/return/Return2.feature",
        scenario="[5] Missing relationship property should become null",
        cypher="MATCH ()-[r]->()\nRETURN r.name2",
        graph=graph_fixture_from_create(
            """
            CREATE ()-[:T {name: 1}]->()
            """
        ),
        expected=Expected(
            rows=[
                {"r.name2": "null"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="RETURN relationship property projections and null semantics are not supported",
        tags=("return", "relationship", "property", "null", "xfail"),
    ),
    Scenario(
        key="return2-6",
        feature_path="tck/features/clauses/return/Return2.feature",
        scenario="[6] Adding a property and a literal in projection",
        cypher="MATCH (a)\nRETURN a.num + 1 AS foo",
        graph=graph_fixture_from_create(
            """
            CREATE ({num: 1})
            """
        ),
        expected=Expected(
            rows=[
                {"foo": 2},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="RETURN arithmetic expression evaluation is not supported",
        tags=("return", "expression", "arithmetic", "xfail"),
    ),
    Scenario(
        key="return2-7",
        feature_path="tck/features/clauses/return/Return2.feature",
        scenario="[7] Adding list properties in projection",
        cypher="MATCH (a)\nRETURN a.list2 + a.list1 AS foo",
        graph=GraphFixture(
            nodes=[
                {"id": "n1", "labels": [], "list1": [1, 2, 3], "list2": [4, 5]},
            ],
            edges=[],
        ),
        expected=Expected(
            rows=[
                {"foo": "[4, 5, 1, 2, 3]"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="RETURN list expressions and list property projections are not supported",
        tags=("return", "list", "expression", "xfail"),
    ),
    Scenario(
        key="return2-8",
        feature_path="tck/features/clauses/return/Return2.feature",
        scenario="[8] Returning label predicate expression",
        cypher="MATCH (n)\nRETURN (n:Foo)",
        graph=graph_fixture_from_create(
            """
            CREATE (), (:Foo)
            """
        ),
        expected=Expected(
            rows=[
                {"(n:Foo)": "true"},
                {"(n:Foo)": "false"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="RETURN label predicate expressions are not supported",
        tags=("return", "label-predicate", "xfail"),
    ),
    Scenario(
        key="return2-9",
        feature_path="tck/features/clauses/return/Return2.feature",
        scenario="[9] Returning a projected map",
        cypher="RETURN {a: 1, b: 'foo'}",
        graph=GraphFixture(
            nodes=[
                {"id": "n1", "labels": [], "numbers": [1, 2, 3]},
            ],
            edges=[],
        ),
        expected=Expected(
            rows=[
                {"{a: 1, b: 'foo'}": "{a: 1, b: 'foo'}"},
                {"{a: 1, b: 'foo'}": "{a: 1, b: 'foo'}"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="RETURN map projections are not supported",
        tags=("return", "map", "xfail"),
    ),
    Scenario(
        key="return2-10",
        feature_path="tck/features/clauses/return/Return2.feature",
        scenario="[10] Return count aggregation over an empty graph",
        cypher="MATCH (a)\nRETURN count(a) > 0",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"count(a) > 0": "false"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Aggregations and boolean projections are not supported",
        tags=("return", "aggregation", "xfail"),
    ),
    Scenario(
        key="return2-11",
        feature_path="tck/features/clauses/return/Return2.feature",
        scenario="[11] RETURN does not lose precision on large integers",
        cypher="MATCH (p:TheLabel)\nRETURN p.id",
        graph=graph_fixture_from_create(
            """
            CREATE (:TheLabel {id: 4611686018427387905})
            """
        ),
        expected=Expected(
            rows=[
                {"p.id": 4611686018427387905},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="RETURN property projections are not supported",
        tags=("return", "property", "big-int", "xfail"),
    ),
    Scenario(
        key="return2-12",
        feature_path="tck/features/clauses/return/Return2.feature",
        scenario="[12] Projecting a list of nodes and relationships",
        cypher="MATCH (n)-[r]->(m)\nRETURN [n, r, m] AS r",
        graph=graph_fixture_from_create(
            """
            CREATE (a:A), (b:B)
            CREATE (a)-[:T]->(b)
            """
        ),
        expected=Expected(
            rows=[
                {"r": "[(:A), [:T], (:B)]"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="RETURN list projections of nodes and relationships are not supported",
        tags=("return", "list", "projection", "xfail"),
    ),
    Scenario(
        key="return2-13",
        feature_path="tck/features/clauses/return/Return2.feature",
        scenario="[13] Projecting a map of nodes and relationships",
        cypher="MATCH (n)-[r]->(m)\nRETURN {node1: n, rel: r, node2: m} AS m",
        graph=graph_fixture_from_create(
            """
            CREATE (a:A), (b:B)
            CREATE (a)-[:T]->(b)
            """
        ),
        expected=Expected(
            rows=[
                {"m": "{node1: (:A), rel: [:T], node2: (:B)}"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="RETURN map projections of nodes and relationships are not supported",
        tags=("return", "map", "projection", "xfail"),
    ),
    Scenario(
        key="return2-14",
        feature_path="tck/features/clauses/return/Return2.feature",
        scenario="[14] Do not fail when returning type of deleted relationships",
        cypher="MATCH ()-[r]->()\nDELETE r\nRETURN type(r)",
        graph=graph_fixture_from_create(
            """
            CREATE ()-[:T]->()
            """
        ),
        expected=Expected(
            rows=[
                {"type(r)": "'T'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="DELETE semantics and return expressions on deleted relationships are not supported",
        tags=("return", "delete", "type", "xfail"),
    ),
    Scenario(
        key="return2-15",
        feature_path="tck/features/clauses/return/Return2.feature",
        scenario="[15] Fail when returning properties of deleted nodes",
        cypher="MATCH (n)\nDELETE n\nRETURN n.num",
        graph=graph_fixture_from_create(
            """
            CREATE ({num: 0})
            """
        ),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="DELETE semantics and deleted-entity runtime errors are not supported",
        tags=("return", "delete", "runtime-error", "xfail"),
    ),
    Scenario(
        key="return2-16",
        feature_path="tck/features/clauses/return/Return2.feature",
        scenario="[16] Fail when returning labels of deleted nodes",
        cypher="MATCH (n)\nDELETE n\nRETURN labels(n)",
        graph=graph_fixture_from_create(
            """
            CREATE (:A)
            """
        ),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="DELETE semantics and deleted-entity runtime errors are not supported",
        tags=("return", "delete", "runtime-error", "xfail"),
    ),
    Scenario(
        key="return2-17",
        feature_path="tck/features/clauses/return/Return2.feature",
        scenario="[17] Fail when returning properties of deleted relationships",
        cypher="MATCH ()-[r]->()\nDELETE r\nRETURN r.num",
        graph=graph_fixture_from_create(
            """
            CREATE ()-[:T {num: 0}]->()
            """
        ),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="DELETE semantics and deleted-entity runtime errors are not supported",
        tags=("return", "delete", "runtime-error", "xfail"),
    ),
    Scenario(
        key="return2-18",
        feature_path="tck/features/clauses/return/Return2.feature",
        scenario="[18] Fail on projecting a non-existent function",
        cypher="MATCH (a)\nRETURN foo(a)",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Compile-time validation for unknown functions is not enforced",
        tags=("return", "syntax-error", "function", "xfail"),
    ),
    Scenario(
        key="return3-1",
        feature_path="tck/features/clauses/return/Return3.feature",
        scenario="[1] Returning multiple expressions",
        cypher="MATCH (a)\nRETURN a.id IS NOT NULL AS a, a IS NOT NULL AS b",
        graph=GraphFixture(
            nodes=[
                {"node_id": "n1", "labels": []},
            ],
            edges=[],
            node_id="node_id",
            node_columns=("node_id", "labels"),
        ),
        expected=Expected(
            rows=[
                {"a": "false", "b": "true"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="RETURN expression projections and null predicates are not supported",
        tags=("return", "expression", "null", "xfail"),
    ),
    Scenario(
        key="return3-2",
        feature_path="tck/features/clauses/return/Return3.feature",
        scenario="[2] Returning multiple node property values",
        cypher="MATCH (a)\nRETURN a.name, a.age, a.seasons",
        graph=GraphFixture(
            nodes=[
                {
                    "id": "n1",
                    "labels": [],
                    "name": "Philip J. Fry",
                    "age": 2046,
                    "seasons": [1, 2, 3, 4, 5, 6, 7],
                }
            ],
            edges=[],
        ),
        expected=Expected(
            rows=[
                {
                    "a.name": "'Philip J. Fry'",
                    "a.age": 2046,
                    "a.seasons": "[1, 2, 3, 4, 5, 6, 7]",
                },
            ],
        ),
        gfql=None,
        status="xfail",
        reason="RETURN property projections are not supported",
        tags=("return", "property", "xfail"),
    ),
    Scenario(
        key="return3-3",
        feature_path="tck/features/clauses/return/Return3.feature",
        scenario="[3] Projecting nodes and relationships",
        cypher="MATCH (a)-[r]->()\nRETURN a AS foo, r AS bar",
        graph=graph_fixture_from_create(
            """
            CREATE (a:A), (b:B)
            CREATE (a)-[:T]->(b)
            """
        ),
        expected=Expected(
            rows=[
                {"foo": "(:A)", "bar": "[:T]"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="RETURN projections of nodes and relationships are not supported",
        tags=("return", "projection", "xfail"),
    ),
    Scenario(
        key="return4-1",
        feature_path="tck/features/clauses/return/Return4.feature",
        scenario="[1] Honour the column name for RETURN items",
        cypher="MATCH (a)\nWITH a.name AS a\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE ({name: 'Someone'})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "'Someone'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines and RETURN property projections are not supported",
        tags=("return", "with", "projection", "xfail"),
    ),
    Scenario(
        key="return4-2",
        feature_path="tck/features/clauses/return/Return4.feature",
        scenario="[2] Support column renaming",
        cypher="MATCH (a)\nRETURN a AS ColumnName",
        graph=graph_fixture_from_create(
            """
            CREATE (:Singleton)
            """
        ),
        expected=Expected(
            rows=[
                {"ColumnName": "(:Singleton)"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="RETURN column renaming and projections are not supported",
        tags=("return", "alias", "projection", "xfail"),
    ),
    Scenario(
        key="return4-3",
        feature_path="tck/features/clauses/return/Return4.feature",
        scenario="[3] Aliasing expressions",
        cypher="MATCH (a)\nRETURN a.id AS a, a.id",
        graph=graph_fixture_from_create(
            """
            CREATE ({id: 42})
            """
        ),
        expected=Expected(
            rows=[
                {"a": 42, "a.id": 42},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="RETURN expression projections are not supported",
        tags=("return", "expression", "projection", "xfail"),
    ),
    Scenario(
        key="return4-4",
        feature_path="tck/features/clauses/return/Return4.feature",
        scenario="[4] Keeping used expression 1",
        cypher="MATCH (n)\nRETURN cOuNt( * )",
        graph=graph_fixture_from_create(
            """
            CREATE ()
            """
        ),
        expected=Expected(
            rows=[
                {"cOuNt( * )": 1},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Aggregations and RETURN projections are not supported",
        tags=("return", "aggregation", "xfail"),
    ),
    Scenario(
        key="return4-5",
        feature_path="tck/features/clauses/return/Return4.feature",
        scenario="[5] Keeping used expression 2",
        cypher="MATCH p = (n)-->(b)\nRETURN nOdEs( p )",
        graph=graph_fixture_from_create(
            """
            CREATE ()
            """
        ),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason="Path expressions and RETURN projections are not supported",
        tags=("return", "path", "projection", "xfail"),
    ),
    Scenario(
        key="return4-6",
        feature_path="tck/features/clauses/return/Return4.feature",
        scenario="[6] Keeping used expression 3",
        cypher="MATCH p = (n)-->(b)\nRETURN coUnt( dIstInct p )",
        graph=graph_fixture_from_create(
            """
            CREATE ()
            """
        ),
        expected=Expected(
            rows=[
                {"coUnt( dIstInct p )": 0},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Aggregations, DISTINCT, and path expressions are not supported",
        tags=("return", "aggregation", "distinct", "path", "xfail"),
    ),
    Scenario(
        key="return4-7",
        feature_path="tck/features/clauses/return/Return4.feature",
        scenario="[7] Keeping used expression 4",
        cypher="MATCH p = (n)-->(b)\nRETURN aVg(    n.aGe     )",
        graph=graph_fixture_from_create(
            """
            CREATE ()
            """
        ),
        expected=Expected(
            rows=[
                {"aVg(    n.aGe     )": "null"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Aggregations and RETURN projections are not supported",
        tags=("return", "aggregation", "projection", "xfail"),
    ),
    Scenario(
        key="return4-8",
        feature_path="tck/features/clauses/return/Return4.feature",
        scenario="[8] Support column renaming for aggregations",
        cypher="MATCH ()\nRETURN count(*) AS columnName",
        graph=GraphFixture(
            nodes=[{"id": f"n{i}", "labels": []} for i in range(11)],
            edges=[],
        ),
        expected=Expected(
            rows=[
                {"columnName": 11},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Aggregations and RETURN projections are not supported",
        tags=("return", "aggregation", "alias", "xfail"),
    ),
    Scenario(
        key="return4-9",
        feature_path="tck/features/clauses/return/Return4.feature",
        scenario="[9] Handle subexpression in aggregation also occurring as standalone expression with nested aggregation in a literal map",
        cypher="MATCH (a:A), (b:B)\nRETURN coalesce(a.num, b.num) AS foo,\n  b.num AS bar,\n  {name: count(b)} AS baz",
        graph=graph_fixture_from_create(
            """
            CREATE (:A), (:B {num: 42})
            """
        ),
        expected=Expected(
            rows=[
                {"foo": 42, "bar": 42, "baz": "{name: 1}"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="RETURN expressions, aggregations, and map projections are not supported",
        tags=("return", "aggregation", "expression", "map", "xfail"),
    ),
    Scenario(
        key="return4-10",
        feature_path="tck/features/clauses/return/Return4.feature",
        scenario="[10] Fail when returning multiple columns with same name",
        cypher="RETURN 1 AS a, 2 AS a",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Compile-time validation for duplicate column names is not enforced",
        tags=("return", "syntax-error", "xfail"),
    ),
    Scenario(
        key="return4-11",
        feature_path="tck/features/clauses/return/Return4.feature",
        scenario="[11] Reusing variable names in RETURN",
        cypher="MATCH (person:Person)<--(message)<-[like]-(:Person)\nWITH like.creationDate AS likeTime, person AS person\n  ORDER BY likeTime, message.id\nWITH head(collect({likeTime: likeTime})) AS latestLike, person AS person\nRETURN latestLike.likeTime AS likeTime\n  ORDER BY likeTime",
        graph=graph_fixture_from_create(
            """
            CREATE (a:Person), (b:Person), (m:Message {id: 10})
            CREATE (a)-[:LIKE {creationDate: 20160614}]->(m)-[:POSTED_BY]->(b)
            """
        ),
        expected=Expected(
            rows=[
                {"likeTime": 20160614},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, aggregations, and list/map expressions are not supported",
        tags=("return", "with", "orderby", "aggregation", "xfail"),
    ),
    Scenario(
        key="return5-1",
        feature_path="tck/features/clauses/return/Return5.feature",
        scenario="[1] DISTINCT inside aggregation should work with lists in maps",
        cypher="MATCH (n)\nRETURN count(DISTINCT {name: n.list}) AS count",
        graph=GraphFixture(
            nodes=[
                {"id": "n1", "labels": [], "list": ["A", "B"]},
                {"id": "n2", "labels": [], "list": ["A", "B"]},
            ],
            edges=[],
        ),
        expected=Expected(
            rows=[
                {"count": 1},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="DISTINCT aggregation and map/list projections are not supported",
        tags=("return", "distinct", "aggregation", "xfail"),
    ),
    Scenario(
        key="return5-2",
        feature_path="tck/features/clauses/return/Return5.feature",
        scenario="[2] DISTINCT on nullable values",
        cypher="MATCH (n)\nRETURN DISTINCT n.name",
        graph=GraphFixture(
            nodes=[
                {"id": "n1", "labels": [], "name": "Florescu"},
                {"id": "n2", "labels": []},
                {"id": "n3", "labels": []},
            ],
            edges=[],
        ),
        expected=Expected(
            rows=[
                {"n.name": "'Florescu'"},
                {"n.name": "null"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="DISTINCT projections and null semantics are not supported",
        tags=("return", "distinct", "null", "xfail"),
    ),
    Scenario(
        key="return5-3",
        feature_path="tck/features/clauses/return/Return5.feature",
        scenario="[3] DISTINCT inside aggregation should work with nested lists in maps",
        cypher="MATCH (n)\nRETURN count(DISTINCT {name: [[n.list, n.list], [n.list, n.list]]}) AS count",
        graph=GraphFixture(
            nodes=[
                {"id": "n1", "labels": [], "list": ["A", "B"]},
                {"id": "n2", "labels": [], "list": ["A", "B"]},
            ],
            edges=[],
        ),
        expected=Expected(
            rows=[
                {"count": 1},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="DISTINCT aggregation and nested list projections are not supported",
        tags=("return", "distinct", "aggregation", "list", "xfail"),
    ),
    Scenario(
        key="return5-4",
        feature_path="tck/features/clauses/return/Return5.feature",
        scenario="[4] DISTINCT inside aggregation should work with nested lists of maps in maps",
        cypher="MATCH (n)\nRETURN count(DISTINCT {name: [{name2: n.list}, {baz: {apa: n.list}}]}) AS count",
        graph=GraphFixture(
            nodes=[
                {"id": "n1", "labels": [], "list": ["A", "B"]},
                {"id": "n2", "labels": [], "list": ["A", "B"]},
            ],
            edges=[],
        ),
        expected=Expected(
            rows=[
                {"count": 1},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="DISTINCT aggregation and nested map/list projections are not supported",
        tags=("return", "distinct", "aggregation", "map", "xfail"),
    ),
    Scenario(
        key="return5-5",
        feature_path="tck/features/clauses/return/Return5.feature",
        scenario="[5] Aggregate on list values",
        cypher="MATCH (a)\nRETURN DISTINCT a.color, count(*)",
        graph=GraphFixture(
            nodes=[
                {"id": "n1", "labels": [], "color": ["red"]},
                {"id": "n2", "labels": [], "color": ["blue"]},
                {"id": "n3", "labels": [], "color": ["red"]},
            ],
            edges=[],
        ),
        expected=Expected(
            rows=[
                {"a.color": "['red']", "count(*)": 2},
                {"a.color": "['blue']", "count(*)": 1},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="DISTINCT projections, aggregations, and list values are not supported",
        tags=("return", "distinct", "aggregation", "list", "xfail"),
    ),
    Scenario(
        key="return6-1",
        feature_path="tck/features/clauses/return/Return6.feature",
        scenario="[1] Return count aggregation over nodes",
        cypher="MATCH (n)\nRETURN n.num AS n, count(n) AS count",
        graph=graph_fixture_from_create(
            """
            CREATE ({num: 42})
            """
        ),
        expected=Expected(
            rows=[
                {"n": 42, "count": 1},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Aggregations and RETURN projections are not supported",
        tags=("return", "aggregation", "xfail"),
    ),
    Scenario(
        key="return6-2",
        feature_path="tck/features/clauses/return/Return6.feature",
        scenario="[2] Projecting an arithmetic expression with aggregation",
        cypher="MATCH (a)\nRETURN a, count(a) + 3",
        graph=graph_fixture_from_create(
            """
            CREATE ({id: 42})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "({id: 42})", "count(a) + 3": 4},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Aggregations, arithmetic expressions, and RETURN projections are not supported",
        tags=("return", "aggregation", "expression", "xfail"),
    ),
    Scenario(
        key="return6-3",
        feature_path="tck/features/clauses/return/Return6.feature",
        scenario="[3] Aggregating by a list property has a correct definition of equality",
        cypher="MATCH (a)\nWITH a.num AS a, count(*) AS count\nRETURN count",
        graph=GraphFixture(
            nodes=[
                {"id": "n1", "labels": [], "a": [1, 2, 3]},
                {"id": "n2", "labels": [], "a": [1, 2, 3]},
            ],
            edges=[],
        ),
        expected=Expected(
            rows=[
                {"count": 2},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, aggregations, and list property projections are not supported",
        tags=("return", "with", "aggregation", "list", "xfail"),
    ),
    Scenario(
        key="return6-4",
        feature_path="tck/features/clauses/return/Return6.feature",
        scenario="[4] Support multiple divisions in aggregate function",
        cypher="MATCH (n)\nRETURN count(n) / 60 / 60 AS count",
        graph=GraphFixture(
            nodes=[{"id": f"n{i}", "labels": []} for i in range(7251)],
            edges=[],
        ),
        expected=Expected(
            rows=[
                {"count": 2},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Aggregations and arithmetic expressions are not supported",
        tags=("return", "aggregation", "expression", "xfail"),
    ),
    Scenario(
        key="return6-5",
        feature_path="tck/features/clauses/return/Return6.feature",
        scenario="[5] Aggregates inside normal functions",
        cypher="MATCH (a)\nRETURN size(collect(a))",
        graph=GraphFixture(
            nodes=[{"id": f"n{i}", "labels": []} for i in range(11)],
            edges=[],
        ),
        expected=Expected(
            rows=[
                {"size(collect(a))": 11},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Aggregations, list functions, and RETURN projections are not supported",
        tags=("return", "aggregation", "list", "xfail"),
    ),
    Scenario(
        key="return6-6",
        feature_path="tck/features/clauses/return/Return6.feature",
        scenario="[6] Handle aggregates inside non-aggregate expressions",
        cypher="MATCH (a {name: 'Andres'})<-[:FATHER]-(child)\nRETURN a.name, {foo: a.name='Andres', kids: collect(child.name)}",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason="Aggregations inside map projections are not supported",
        tags=("return", "aggregation", "map", "xfail"),
    ),
    Scenario(
        key="return6-7",
        feature_path="tck/features/clauses/return/Return6.feature",
        scenario="[7] Aggregate on property",
        cypher="MATCH (n)\nRETURN n.num, count(*)",
        graph=graph_fixture_from_create(
            """
            CREATE ({num: 33})
            CREATE ({num: 33})
            CREATE ({num: 42})
            """
        ),
        expected=Expected(
            rows=[
                {"n.num": 42, "count(*)": 1},
                {"n.num": 33, "count(*)": 2},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Aggregations and RETURN projections are not supported",
        tags=("return", "aggregation", "xfail"),
    ),
    Scenario(
        key="return6-8",
        feature_path="tck/features/clauses/return/Return6.feature",
        scenario="[8] Handle aggregation on functions",
        cypher="MATCH p=(a:L)-[*]->(b)\nRETURN b, avg(length(p))",
        graph=graph_fixture_from_create(
            """
            CREATE (a:L), (b1), (b2)
            CREATE (a)-[:A]->(b1), (a)-[:A]->(b2)
            """
        ),
        expected=Expected(
            rows=[
                {"b": "()", "avg(length(p))": 1.0},
                {"b": "()", "avg(length(p))": 1.0},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Variable-length patterns, path length functions, and aggregations are not supported",
        tags=("return", "variable-length", "path", "aggregation", "xfail"),
    ),
    Scenario(
        key="return6-9",
        feature_path="tck/features/clauses/return/Return6.feature",
        scenario="[9] Aggregates with arithmetics",
        cypher="MATCH ()\nRETURN count(*) * 10 AS c",
        graph=graph_fixture_from_create(
            """
            CREATE ()
            """
        ),
        expected=Expected(
            rows=[
                {"c": 10},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Aggregations and arithmetic expressions are not supported",
        tags=("return", "aggregation", "expression", "xfail"),
    ),
    Scenario(
        key="return6-10",
        feature_path="tck/features/clauses/return/Return6.feature",
        scenario="[10] Multiple aggregates on same variable",
        cypher="MATCH (n)\nRETURN count(n), collect(n)",
        graph=graph_fixture_from_create(
            """
            CREATE ()
            """
        ),
        expected=Expected(
            rows=[
                {"count(n)": 1, "collect(n)": "[()]"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Aggregations and list projections are not supported",
        tags=("return", "aggregation", "list", "xfail"),
    ),
    Scenario(
        key="return6-11",
        feature_path="tck/features/clauses/return/Return6.feature",
        scenario="[11] Counting matches",
        cypher="MATCH ()\nRETURN count(*)",
        graph=GraphFixture(
            nodes=[{"id": f"n{i}", "labels": []} for i in range(100)],
            edges=[],
        ),
        expected=Expected(
            rows=[
                {"count(*)": 100},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Aggregations are not supported",
        tags=("return", "aggregation", "xfail"),
    ),
    Scenario(
        key="return6-12",
        feature_path="tck/features/clauses/return/Return6.feature",
        scenario="[12] Counting matches per group",
        cypher="MATCH (a:L)-[rel]->(b)\nRETURN a, count(*)",
        graph=graph_fixture_from_create(
            """
            CREATE (a:L), (b1), (b2)
            CREATE (a)-[:A]->(b1), (a)-[:A]->(b2)
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:L)", "count(*)": 2},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Aggregations and RETURN projections are not supported",
        tags=("return", "aggregation", "xfail"),
    ),
    Scenario(
        key="return6-13",
        feature_path="tck/features/clauses/return/Return6.feature",
        scenario="[13] Returning the minimum length of paths",
        cypher="MATCH p = (a:T {name: 'a'})-[:R*]->(other:T)\nWHERE other <> a\nWITH a, other, min(length(p)) AS len\nRETURN a.name AS name, collect(other.name) AS others, len",
        graph=graph_fixture_from_create(
            """
            CREATE (a:T {name: 'a'}), (b:T {name: 'b'}), (c:T {name: 'c'})
            CREATE (a)-[:R]->(b)
            CREATE (a)-[:R]->(c)
            CREATE (c)-[:R]->(b)
            """
        ),
        expected=Expected(
            rows=[
                {"name": "'a'", "others": "['c', 'b']", "len": 1},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Variable-length patterns, path length functions, WITH pipelines, and aggregations are not supported",
        tags=("return", "variable-length", "path", "with", "aggregation", "xfail"),
    ),
    Scenario(
        key="return6-14",
        feature_path="tck/features/clauses/return/Return6.feature",
        scenario="[14] Aggregates in aggregates",
        cypher="RETURN count(count(*))",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Compile-time validation for nested aggregations is not enforced",
        tags=("return", "syntax-error", "aggregation", "xfail"),
    ),
    Scenario(
        key="return6-15",
        feature_path="tck/features/clauses/return/Return6.feature",
        scenario="[15] Using `rand()` in aggregations",
        cypher="RETURN count(rand())",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Compile-time validation for non-constant aggregation expressions is not enforced",
        tags=("return", "syntax-error", "aggregation", "xfail"),
    ),
    Scenario(
        key="return6-16",
        feature_path="tck/features/clauses/return/Return6.feature",
        scenario="[16] Aggregation on complex expressions",
        cypher="MATCH (me)-[r1:ATE]->()<-[r2:ATE]-(you)\nWHERE me.name = 'Michael'\nWITH me, count(DISTINCT r1) AS H1, count(DISTINCT r2) AS H2, you\nMATCH (me)-[r1:ATE]->()<-[r2:ATE]-(you)\nRETURN me, you, sum((1 - abs(r1.times / H1 - r2.times / H2)) * (r1.times + r2.times) / (H1 + H2)) AS sum",
        graph=graph_fixture_from_create(
            """
            CREATE (andres {name: 'Andres'}),
                   (michael {name: 'Michael'}),
                   (peter {name: 'Peter'}),
                   (bread {type: 'Bread'}),
                   (veggies {type: 'Veggies'}),
                   (meat {type: 'Meat'})
            CREATE (andres)-[:ATE {times: 10}]->(bread),
                   (andres)-[:ATE {times: 8}]->(veggies),
                   (michael)-[:ATE {times: 4}]->(veggies),
                   (michael)-[:ATE {times: 6}]->(bread),
                   (michael)-[:ATE {times: 9}]->(meat),
                   (peter)-[:ATE {times: 7}]->(veggies),
                   (peter)-[:ATE {times: 7}]->(bread),
                   (peter)-[:ATE {times: 4}]->(meat)
            """
        ),
        expected=Expected(
            rows=[
                {"me": "({name: 'Michael'})", "you": "({name: 'Andres'})", "sum": -7},
                {"me": "({name: 'Michael'})", "you": "({name: 'Peter'})", "sum": 0},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, DISTINCT aggregations, and complex expressions are not supported",
        tags=("return", "with", "distinct", "aggregation", "xfail"),
    ),
    Scenario(
        key="return6-17",
        feature_path="tck/features/clauses/return/Return6.feature",
        scenario="[17] Handle constants and parameters inside an expression which contains an aggregation expression",
        cypher="MATCH (person)\nRETURN $age + avg(person.age) - 1000",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"$age + avg(person.age) - 1000": "null"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Parameters, aggregations, and RETURN expressions are not supported",
        tags=("return", "params", "aggregation", "xfail"),
    ),
    Scenario(
        key="return6-18",
        feature_path="tck/features/clauses/return/Return6.feature",
        scenario="[18] Handle returned variables inside an expression which contains an aggregation expression",
        cypher="MATCH (me: Person)--(you: Person)\nWITH me.age AS age, you\nRETURN age, age + count(you.age)",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, aggregations, and RETURN expressions are not supported",
        tags=("return", "with", "aggregation", "xfail"),
    ),
    Scenario(
        key="return6-19",
        feature_path="tck/features/clauses/return/Return6.feature",
        scenario="[19] Handle returned property accesses inside an expression which contains an aggregation expression",
        cypher="MATCH (me: Person)--(you: Person)\nRETURN me.age, me.age + count(you.age)",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason="Aggregations and RETURN expressions are not supported",
        tags=("return", "aggregation", "xfail"),
    ),
    Scenario(
        key="return6-20",
        feature_path="tck/features/clauses/return/Return6.feature",
        scenario="[20] Fail if not returned variables are used inside an expression which contains an aggregation expression",
        cypher="MATCH (me: Person)--(you: Person)\nRETURN me.age + count(you.age)",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Compile-time validation for ambiguous aggregation expressions is not enforced",
        tags=("return", "syntax-error", "aggregation", "xfail"),
    ),
    Scenario(
        key="return6-21",
        feature_path="tck/features/clauses/return/Return6.feature",
        scenario="[21] Fail if more complex expressions, even if returned, are used inside expression which contains an aggregation expression",
        cypher="MATCH (me: Person)--(you: Person)\nRETURN me.age + you.age, me.age + you.age + count(*)",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Compile-time validation for ambiguous aggregation expressions is not enforced",
        tags=("return", "syntax-error", "aggregation", "xfail"),
    ),
    Scenario(
        key="return7-1",
        feature_path="tck/features/clauses/return/Return7.feature",
        scenario="[1] Return all variables",
        cypher="MATCH p = (a:Start)-->(b)\nRETURN *",
        graph=graph_fixture_from_create(
            """
            CREATE (:Start)-[:T]->()
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:Start)", "b": "()", "p": "<(:Start)-[:T]->()>"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="RETURN * projections and named path returns are not supported",
        tags=("return", "projection", "path", "xfail"),
    ),
    Scenario(
        key="return7-2",
        feature_path="tck/features/clauses/return/Return7.feature",
        scenario="[2] Fail when using RETURN * without variables in scope",
        cypher="MATCH ()\nRETURN *",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Compile-time validation for RETURN * without scoped variables is not enforced",
        tags=("return", "syntax-error", "xfail"),
    ),
    Scenario(
        key="return8-1",
        feature_path="tck/features/clauses/return/Return8.feature",
        scenario="[1] Return aggregation after With filtering",
        cypher="MATCH (n)\nWITH n\nWHERE n.num = 42\nRETURN count(*)",
        graph=graph_fixture_from_create(
            """
            CREATE ({num: 43}), ({num: 42})
            """
        ),
        expected=Expected(
            rows=[
                {"count(*)": 1},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, WHERE filtering, and aggregations are not supported",
        tags=("return", "with", "aggregation", "xfail"),
    ),
    Scenario(
        key="return-orderby1-1",
        feature_path="tck/features/clauses/return-orderby/ReturnOrderBy1.feature",
        scenario="[1] ORDER BY should order booleans in the expected order",
        cypher="UNWIND [true, false] AS bools\nRETURN bools\nORDER BY bools",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"bools": "false"},
                {"bools": "true"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="UNWIND and ORDER BY are not supported",
        tags=("return", "orderby", "unwind", "xfail"),
    ),
    Scenario(
        key="return-orderby1-2",
        feature_path="tck/features/clauses/return-orderby/ReturnOrderBy1.feature",
        scenario="[2] ORDER BY DESC should order booleans in the expected order",
        cypher="UNWIND [true, false] AS bools\nRETURN bools\nORDER BY bools DESC",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"bools": "true"},
                {"bools": "false"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="UNWIND and ORDER BY are not supported",
        tags=("return", "orderby", "unwind", "xfail"),
    ),
    Scenario(
        key="return-orderby1-3",
        feature_path="tck/features/clauses/return-orderby/ReturnOrderBy1.feature",
        scenario="[3] ORDER BY should order strings in the expected order",
        cypher="UNWIND ['.*', '', ' ', 'one'] AS strings\nRETURN strings\nORDER BY strings",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"strings": "''"},
                {"strings": "' '"},
                {"strings": "'.*'"},
                {"strings": "'one'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="UNWIND and ORDER BY are not supported",
        tags=("return", "orderby", "unwind", "xfail"),
    ),
    Scenario(
        key="return-orderby1-4",
        feature_path="tck/features/clauses/return-orderby/ReturnOrderBy1.feature",
        scenario="[4] ORDER BY DESC should order strings in the expected order",
        cypher="UNWIND ['.*', '', ' ', 'one'] AS strings\nRETURN strings\nORDER BY strings DESC",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"strings": "'one'"},
                {"strings": "'.*'"},
                {"strings": "' '"},
                {"strings": "''"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="UNWIND and ORDER BY are not supported",
        tags=("return", "orderby", "unwind", "xfail"),
    ),
    Scenario(
        key="return-orderby1-5",
        feature_path="tck/features/clauses/return-orderby/ReturnOrderBy1.feature",
        scenario="[5] ORDER BY should order ints in the expected order",
        cypher="UNWIND [1, 3, 2] AS ints\nRETURN ints\nORDER BY ints",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"ints": 1},
                {"ints": 2},
                {"ints": 3},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="UNWIND and ORDER BY are not supported",
        tags=("return", "orderby", "unwind", "xfail"),
    ),
    Scenario(
        key="return-orderby1-6",
        feature_path="tck/features/clauses/return-orderby/ReturnOrderBy1.feature",
        scenario="[6] ORDER BY DESC should order ints in the expected order",
        cypher="UNWIND [1, 3, 2] AS ints\nRETURN ints\nORDER BY ints DESC",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"ints": 3},
                {"ints": 2},
                {"ints": 1},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="UNWIND and ORDER BY are not supported",
        tags=("return", "orderby", "unwind", "xfail"),
    ),
    Scenario(
        key="return-orderby1-7",
        feature_path="tck/features/clauses/return-orderby/ReturnOrderBy1.feature",
        scenario="[7] ORDER BY should order floats in the expected order",
        cypher="UNWIND [1.5, 1.3, 999.99] AS floats\nRETURN floats\nORDER BY floats",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"floats": 1.3},
                {"floats": 1.5},
                {"floats": 999.99},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="UNWIND and ORDER BY are not supported",
        tags=("return", "orderby", "unwind", "xfail"),
    ),
    Scenario(
        key="return-orderby1-8",
        feature_path="tck/features/clauses/return-orderby/ReturnOrderBy1.feature",
        scenario="[8] ORDER BY DESC should order floats in the expected order",
        cypher="UNWIND [1.5, 1.3, 999.99] AS floats\nRETURN floats\nORDER BY floats DESC",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"floats": 999.99},
                {"floats": 1.5},
                {"floats": 1.3},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="UNWIND and ORDER BY are not supported",
        tags=("return", "orderby", "unwind", "xfail"),
    ),
    Scenario(
        key="return-orderby1-9",
        feature_path="tck/features/clauses/return-orderby/ReturnOrderBy1.feature",
        scenario="[9] ORDER BY should order lists in the expected order",
        cypher="UNWIND [[], ['a'], ['a', 1], [1], [1, 'a'], [1, null], [null, 1], [null, 2]] AS lists\nRETURN lists\nORDER BY lists",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"lists": "[]"},
                {"lists": "['a']"},
                {"lists": "['a', 1]"},
                {"lists": "[1]"},
                {"lists": "[1, 'a']"},
                {"lists": "[1, null]"},
                {"lists": "[null, 1]"},
                {"lists": "[null, 2]"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="UNWIND and ORDER BY are not supported",
        tags=("return", "orderby", "unwind", "xfail"),
    ),
    Scenario(
        key="return-orderby1-10",
        feature_path="tck/features/clauses/return-orderby/ReturnOrderBy1.feature",
        scenario="[10] ORDER BY DESC should order lists in the expected order",
        cypher="UNWIND [[], ['a'], ['a', 1], [1], [1, 'a'], [1, null], [null, 1], [null, 2]] AS lists\nRETURN lists\nORDER BY lists DESC",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"lists": "[null, 2]"},
                {"lists": "[null, 1]"},
                {"lists": "[1, null]"},
                {"lists": "[1, 'a']"},
                {"lists": "[1]"},
                {"lists": "['a', 1]"},
                {"lists": "['a']"},
                {"lists": "[]"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="UNWIND and ORDER BY are not supported",
        tags=("return", "orderby", "unwind", "xfail"),
    ),
    Scenario(
        key="return-orderby1-11",
        feature_path="tck/features/clauses/return-orderby/ReturnOrderBy1.feature",
        scenario="[11] ORDER BY should order distinct types in the expected order",
        cypher="MATCH p = (n:N)-[r:REL]->()\nUNWIND [n, r, p, 1.5, ['list'], 'text', null, false, 0.0 / 0.0, {a: 'map'}] AS types\nRETURN types\nORDER BY types",
        graph=graph_fixture_from_create(
            """
            CREATE (:N)-[:REL]->()
            """
        ),
        expected=Expected(
            rows=[
                {"types": "{a: 'map'}"},
                {"types": "(:N)"},
                {"types": "[:REL]"},
                {"types": "['list']"},
                {"types": "<(:N)-[:REL]->()>"},
                {"types": "'text'"},
                {"types": "false"},
                {"types": 1.5},
                {"types": "NaN"},
                {"types": "null"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="UNWIND, ORDER BY, and heterogeneous type ordering are not supported",
        tags=("return", "orderby", "unwind", "xfail"),
    ),
    Scenario(
        key="return-orderby1-12",
        feature_path="tck/features/clauses/return-orderby/ReturnOrderBy1.feature",
        scenario="[12] ORDER BY DESC should order distinct types in the expected order",
        cypher="MATCH p = (n:N)-[r:REL]->()\nUNWIND [n, r, p, 1.5, ['list'], 'text', null, false, 0.0 / 0.0, {a: 'map'}] AS types\nRETURN types\nORDER BY types DESC",
        graph=graph_fixture_from_create(
            """
            CREATE (:N)-[:REL]->()
            """
        ),
        expected=Expected(
            rows=[
                {"types": "null"},
                {"types": "NaN"},
                {"types": 1.5},
                {"types": "false"},
                {"types": "'text'"},
                {"types": "<(:N)-[:REL]->()>"},
                {"types": "['list']"},
                {"types": "[:REL]"},
                {"types": "(:N)"},
                {"types": "{a: 'map'}"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="UNWIND, ORDER BY, and heterogeneous type ordering are not supported",
        tags=("return", "orderby", "unwind", "xfail"),
    ),
    Scenario(
        key="return-orderby2-1",
        feature_path="tck/features/clauses/return-orderby/ReturnOrderBy2.feature",
        scenario="[1] ORDER BY should return results in ascending order",
        cypher="MATCH (n)\nRETURN n.num AS prop\nORDER BY n.num",
        graph=graph_fixture_from_create(
            """
            CREATE (n1 {num: 1}),
              (n2 {num: 3}),
              (n3 {num: -5})
            """
        ),
        expected=Expected(
            rows=[
                {"prop": -5},
                {"prop": 1},
                {"prop": 3},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="ORDER BY and RETURN projections are not supported",
        tags=("return", "orderby", "projection", "xfail"),
    ),
    Scenario(
        key="return-orderby2-2",
        feature_path="tck/features/clauses/return-orderby/ReturnOrderBy2.feature",
        scenario="[2] ORDER BY DESC should return results in descending order",
        cypher="MATCH (n)\nRETURN n.num AS prop\nORDER BY n.num DESC",
        graph=graph_fixture_from_create(
            """
            CREATE (n1 {num: 1}),
              (n2 {num: 3}),
              (n3 {num: -5})
            """
        ),
        expected=Expected(
            rows=[
                {"prop": 3},
                {"prop": 1},
                {"prop": -5},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="ORDER BY and RETURN projections are not supported",
        tags=("return", "orderby", "projection", "xfail"),
    ),
    Scenario(
        key="return-orderby2-3",
        feature_path="tck/features/clauses/return-orderby/ReturnOrderBy2.feature",
        scenario="[3] Sort on aggregated function",
        cypher="MATCH (n)\nRETURN n.division, max(n.age)\nORDER BY max(n.age)",
        graph=graph_fixture_from_create(
            """
            CREATE ({division: 'A', age: 22}),
              ({division: 'B', age: 33}),
              ({division: 'B', age: 44}),
              ({division: 'C', age: 55})
            """
        ),
        expected=Expected(
            rows=[
                {"n.division": "'A'", "max(n.age)": 22},
                {"n.division": "'B'", "max(n.age)": 44},
                {"n.division": "'C'", "max(n.age)": 55},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="ORDER BY and aggregations are not supported",
        tags=("return", "orderby", "aggregation", "xfail"),
    ),
    Scenario(
        key="return-orderby2-4",
        feature_path="tck/features/clauses/return-orderby/ReturnOrderBy2.feature",
        scenario="[4] Support sort and distinct",
        cypher="MATCH (a)\nRETURN DISTINCT a\nORDER BY a.name",
        graph=graph_fixture_from_create(
            """
            CREATE ({name: 'A'}),
              ({name: 'B'}),
              ({name: 'C'})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "({name: 'A'})"},
                {"a": "({name: 'B'})"},
                {"a": "({name: 'C'})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="ORDER BY and DISTINCT projections are not supported",
        tags=("return", "orderby", "distinct", "xfail"),
    ),
    Scenario(
        key="return-orderby2-5",
        feature_path="tck/features/clauses/return-orderby/ReturnOrderBy2.feature",
        scenario="[5] Support ordering by a property after being distinct-ified",
        cypher="MATCH (a)-->(b)\nRETURN DISTINCT b\nORDER BY b.name",
        graph=graph_fixture_from_create(
            """
            CREATE (:A)-[:T]->(:B)
            """
        ),
        expected=Expected(
            rows=[
                {"b": "(:B)"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="ORDER BY and DISTINCT projections are not supported",
        tags=("return", "orderby", "distinct", "xfail"),
    ),
    Scenario(
        key="return-orderby2-6",
        feature_path="tck/features/clauses/return-orderby/ReturnOrderBy2.feature",
        scenario="[6] Count star should count everything in scope",
        cypher="MATCH (a)\nRETURN a, count(*)\nORDER BY count(*)",
        graph=graph_fixture_from_create(
            """
            CREATE (:L1), (:L2), (:L3)
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:L1)", "count(*)": 1},
                {"a": "(:L2)", "count(*)": 1},
                {"a": "(:L3)", "count(*)": 1},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="ORDER BY and aggregations are not supported",
        tags=("return", "orderby", "aggregation", "xfail"),
    ),
    Scenario(
        key="return-orderby2-7",
        feature_path="tck/features/clauses/return-orderby/ReturnOrderBy2.feature",
        scenario="[7] Ordering with aggregation",
        cypher="MATCH (n)\nRETURN n.name, count(*) AS foo\nORDER BY n.name",
        graph=graph_fixture_from_create(
            """
            CREATE ({name: 'nisse'})
            """
        ),
        expected=Expected(
            rows=[
                {"n.name": "'nisse'", "foo": 1},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="ORDER BY and aggregations are not supported",
        tags=("return", "orderby", "aggregation", "xfail"),
    ),
    Scenario(
        key="return-orderby2-8",
        feature_path="tck/features/clauses/return-orderby/ReturnOrderBy2.feature",
        scenario="[8] Returning all variables with ordering",
        cypher="MATCH (n)\nRETURN *\nORDER BY n.id",
        graph=graph_fixture_from_create(
            """
            CREATE ({id: 1}), ({id: 10})
            """
        ),
        expected=Expected(
            rows=[
                {"n": "({id: 1})"},
                {"n": "({id: 10})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="RETURN * projections and ORDER BY are not supported",
        tags=("return", "orderby", "return-star", "xfail"),
    ),
    Scenario(
        key="return-orderby2-9",
        feature_path="tck/features/clauses/return-orderby/ReturnOrderBy2.feature",
        scenario="[9] Using aliased DISTINCT expression in ORDER BY",
        cypher="MATCH (n)\nRETURN DISTINCT n.id AS id\nORDER BY id DESC",
        graph=graph_fixture_from_create(
            """
            CREATE ({id: 1}), ({id: 10})
            """
        ),
        expected=Expected(
            rows=[
                {"id": 10},
                {"id": 1},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="ORDER BY and DISTINCT projections are not supported",
        tags=("return", "orderby", "distinct", "xfail"),
    ),
    Scenario(
        key="return-orderby2-10",
        feature_path="tck/features/clauses/return-orderby/ReturnOrderBy2.feature",
        scenario="[10] Returned columns do not change from using ORDER BY",
        cypher="MATCH (n)\nRETURN DISTINCT n\nORDER BY n.id",
        graph=graph_fixture_from_create(
            """
            CREATE ({id: 1}), ({id: 10})
            """
        ),
        expected=Expected(
            rows=[
                {"n": "({id: 1})"},
                {"n": "({id: 10})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="ORDER BY and DISTINCT projections are not supported",
        tags=("return", "orderby", "distinct", "xfail"),
    ),
    Scenario(
        key="return-orderby2-11",
        feature_path="tck/features/clauses/return-orderby/ReturnOrderBy2.feature",
        scenario="[11] Aggregates ordered by arithmetics",
        cypher="MATCH (a:A), (b:X)\nRETURN count(a) * 10 + count(b) * 5 AS x\nORDER BY x",
        graph=graph_fixture_from_create(
            """
            CREATE (:A), (:X), (:X)
            """
        ),
        expected=Expected(
            rows=[
                {"x": 30},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="ORDER BY and aggregation expressions are not supported",
        tags=("return", "orderby", "aggregation", "xfail"),
    ),
    Scenario(
        key="return-orderby2-12",
        feature_path="tck/features/clauses/return-orderby/ReturnOrderBy2.feature",
        scenario="[12] Aggregation of named paths",
        cypher="MATCH p = (a)-[*]->(b)\nRETURN collect(nodes(p)) AS paths, length(p) AS l\nORDER BY l",
        graph=graph_fixture_from_create(
            """
            CREATE (a:A), (b:B), (c:C), (d:D), (e:E), (f:F)
            CREATE (a)-[:R]->(b)
            CREATE (c)-[:R]->(d)
            CREATE (d)-[:R]->(e)
            CREATE (e)-[:R]->(f)
            """
        ),
        expected=Expected(
            rows=[
                {"paths": "[[(:A), (:B)], [(:C), (:D)], [(:D), (:E)], [(:E), (:F)]]", "l": 1},
                {"paths": "[[(:C), (:D), (:E)], [(:D), (:E), (:F)]]", "l": 2},
                {"paths": "[[(:C), (:D), (:E), (:F)]]", "l": 3},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Variable-length patterns, path functions, aggregations, and ORDER BY are not supported",
        tags=("return", "orderby", "path", "aggregation", "xfail"),
    ),
    Scenario(
        key="return-orderby2-13",
        feature_path="tck/features/clauses/return-orderby/ReturnOrderBy2.feature",
        scenario="[13] Fail when sorting on variable removed by DISTINCT",
        cypher="MATCH (a)\nRETURN DISTINCT a.name\nORDER BY a.age",
        graph=graph_fixture_from_create(
            """
            CREATE ({name: 'A', age: 13}), ({name: 'B', age: 12}), ({name: 'C', age: 11})
            """
        ),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Compile-time validation for ORDER BY variable scoping is not enforced",
        tags=("return", "orderby", "syntax-error", "xfail"),
    ),
    Scenario(
        key="return-orderby2-14",
        feature_path="tck/features/clauses/return-orderby/ReturnOrderBy2.feature",
        scenario="[14] Fail on aggregation in ORDER BY after RETURN",
        cypher="MATCH (n)\nRETURN n.num1\nORDER BY max(n.num2)",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Compile-time validation for ORDER BY aggregation expressions is not enforced",
        tags=("return", "orderby", "syntax-error", "xfail"),
    ),
    Scenario(
        key="return-orderby3-1",
        feature_path="tck/features/clauses/return-orderby/ReturnOrderBy3.feature",
        scenario="[1] Sort on aggregate function and normal property",
        cypher="MATCH (n)\nRETURN n.division, count(*)\nORDER BY count(*) DESC, n.division ASC",
        graph=graph_fixture_from_create(
            """
            CREATE ({division: 'Sweden'})
            CREATE ({division: 'Germany'})
            CREATE ({division: 'England'})
            CREATE ({division: 'Sweden'})
            """
        ),
        expected=Expected(
            rows=[
                {"n.division": "'Sweden'", "count(*)": 2},
                {"n.division": "'England'", "count(*)": 1},
                {"n.division": "'Germany'", "count(*)": 1},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="ORDER BY and aggregations are not supported",
        tags=("return", "orderby", "aggregation", "xfail"),
    ),
    Scenario(
        key="return-orderby4-1",
        feature_path="tck/features/clauses/return-orderby/ReturnOrderBy4.feature",
        scenario="[1] ORDER BY of a column introduced in RETURN should return salient results in ascending order",
        cypher="WITH [0, 1] AS prows, [[2], [3, 4]] AS qrows\nUNWIND prows AS p\nUNWIND qrows[p] AS q\nWITH p, count(q) AS rng\nRETURN p\nORDER BY rng",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"p": 0},
                {"p": 1},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, UNWIND, and ORDER BY are not supported",
        tags=("return", "orderby", "with", "unwind", "xfail"),
    ),
    Scenario(
        key="return-orderby4-2",
        feature_path="tck/features/clauses/return-orderby/ReturnOrderBy4.feature",
        scenario="[2] Handle projections with ORDER BY",
        cypher="MATCH (c:Crew {name: 'Neo'})\nWITH c, 0 AS relevance\nRETURN c.rank AS rank\nORDER BY relevance, c.rank",
        graph=graph_fixture_from_create(
            """
            CREATE (c1:Crew {name: 'Neo', rank: 1}),
              (c2:Crew {name: 'Neo', rank: 2}),
              (c3:Crew {name: 'Neo', rank: 3}),
              (c4:Crew {name: 'Neo', rank: 4}),
              (c5:Crew {name: 'Neo', rank: 5})
            """
        ),
        expected=Expected(
            rows=[
                {"rank": 1},
                {"rank": 2},
                {"rank": 3},
                {"rank": 4},
                {"rank": 5},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines and ORDER BY are not supported",
        tags=("return", "orderby", "with", "xfail"),
    ),
    Scenario(
        key="return-orderby5-1",
        feature_path="tck/features/clauses/return-orderby/ReturnOrderBy5.feature",
        scenario="[1] Renaming columns before ORDER BY should return results in ascending order",
        cypher="MATCH (n)\nRETURN n.num AS n\nORDER BY n + 2",
        graph=graph_fixture_from_create(
            """
            CREATE (n1 {num: 1}),
              (n2 {num: 3}),
              (n3 {num: -5})
            """
        ),
        expected=Expected(
            rows=[
                {"n": -5},
                {"n": 1},
                {"n": 3},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="ORDER BY expression evaluation is not supported",
        tags=("return", "orderby", "expression", "xfail"),
    ),
    Scenario(
        key="return-orderby6-1",
        feature_path="tck/features/clauses/return-orderby/ReturnOrderBy6.feature",
        scenario="[1] Handle constants and parameters inside an order by item which contains an aggregation expression",
        cypher="MATCH (person)\nRETURN avg(person.age) AS avgAge\nORDER BY $age + avg(person.age) - 1000",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"avgAge": "null"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Parameters, aggregations, and ORDER BY are not supported",
        tags=("return", "orderby", "aggregation", "params", "xfail"),
    ),
    Scenario(
        key="return-orderby6-2",
        feature_path="tck/features/clauses/return-orderby/ReturnOrderBy6.feature",
        scenario="[2] Handle returned aliases inside an order by item which contains an aggregation expression",
        cypher="MATCH (me: Person)--(you: Person)\nRETURN me.age AS age, count(you.age) AS cnt\nORDER BY age, age + count(you.age)",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason="Aggregations and ORDER BY are not supported",
        tags=("return", "orderby", "aggregation", "xfail"),
    ),
    Scenario(
        key="return-orderby6-3",
        feature_path="tck/features/clauses/return-orderby/ReturnOrderBy6.feature",
        scenario="[3] Handle returned property accesses inside an order by item which contains an aggregation expression",
        cypher="MATCH (me: Person)--(you: Person)\nRETURN me.age AS age, count(you.age) AS cnt\nORDER BY me.age + count(you.age)",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason="Aggregations and ORDER BY are not supported",
        tags=("return", "orderby", "aggregation", "xfail"),
    ),
    Scenario(
        key="return-orderby6-4",
        feature_path="tck/features/clauses/return-orderby/ReturnOrderBy6.feature",
        scenario="[4] Fail if not returned variables are used inside an order by item which contains an aggregation expression",
        cypher="MATCH (me: Person)--(you: Person)\nRETURN count(you.age) AS agg\nORDER BY me.age + count(you.age)",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Compile-time validation for ORDER BY aggregation expressions is not enforced",
        tags=("return", "orderby", "syntax-error", "xfail"),
    ),
    Scenario(
        key="return-orderby6-5",
        feature_path="tck/features/clauses/return-orderby/ReturnOrderBy6.feature",
        scenario="[5] Fail if more complex expressions, even if returned, are used inside an order by item which contains an aggregation expression",
        cypher="MATCH (me: Person)--(you: Person)\nRETURN me.age + you.age, count(*) AS cnt\nORDER BY me.age + you.age + count(*)",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Compile-time validation for ORDER BY aggregation expressions is not enforced",
        tags=("return", "orderby", "syntax-error", "xfail"),
    ),
    Scenario(
        key="return-skip-limit1-1",
        feature_path="tck/features/clauses/return-skip-limit/ReturnSkipLimit1.feature",
        scenario="[1] Start the result from the second row",
        cypher="MATCH (n)\nRETURN n\nORDER BY n.name ASC\nSKIP 2",
        graph=graph_fixture_from_create(
            """
            CREATE ({name: 'A'}),
              ({name: 'B'}),
              ({name: 'C'}),
              ({name: 'D'}),
              ({name: 'E'})
            """
        ),
        expected=Expected(
            rows=[
                {"n": "({name: 'C'})"},
                {"n": "({name: 'D'})"},
                {"n": "({name: 'E'})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="SKIP and ORDER BY are not supported",
        tags=("return", "skip", "orderby", "xfail"),
    ),
    Scenario(
        key="return-skip-limit1-2",
        feature_path="tck/features/clauses/return-skip-limit/ReturnSkipLimit1.feature",
        scenario="[2] Start the result from the second row by param",
        cypher="MATCH (n)\nRETURN n\nORDER BY n.name ASC\nSKIP $skipAmount",
        graph=graph_fixture_from_create(
            """
            CREATE ({name: 'A'}),
              ({name: 'B'}),
              ({name: 'C'}),
              ({name: 'D'}),
              ({name: 'E'})
            """
        ),
        expected=Expected(
            rows=[
                {"n": "({name: 'C'})"},
                {"n": "({name: 'D'})"},
                {"n": "({name: 'E'})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="SKIP, ORDER BY, and parameter binding are not supported",
        tags=("return", "skip", "orderby", "params", "xfail"),
    ),
    Scenario(
        key="return-skip-limit1-3",
        feature_path="tck/features/clauses/return-skip-limit/ReturnSkipLimit1.feature",
        scenario="[3] SKIP with an expression that does not depend on variables",
        cypher="MATCH (n)\nWITH n SKIP toInteger(rand()*9)\nWITH count(*) AS count\nRETURN count > 0 AS nonEmpty",
        graph=GraphFixture(
            nodes=[{"id": f"n{i}", "labels": [], "nr": i} for i in range(1, 11)],
            edges=[],
        ),
        expected=Expected(
            rows=[
                {"nonEmpty": "true"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, SKIP, and functions are not supported",
        tags=("return", "skip", "with", "function", "xfail"),
    ),
    Scenario(
        key="return-skip-limit1-4",
        feature_path="tck/features/clauses/return-skip-limit/ReturnSkipLimit1.feature",
        scenario="[4] Accept skip zero",
        cypher="MATCH (n)\nWHERE 1 = 0\nRETURN n\nSKIP 0",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason="SKIP is not supported",
        tags=("return", "skip", "xfail"),
    ),
    Scenario(
        key="return-skip-limit1-5",
        feature_path="tck/features/clauses/return-skip-limit/ReturnSkipLimit1.feature",
        scenario="[5] SKIP with an expression that depends on variables should fail",
        cypher="MATCH (n)\nRETURN n\nSKIP n.count",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Compile-time validation for SKIP expressions is not enforced",
        tags=("return", "skip", "syntax-error", "xfail"),
    ),
    Scenario(
        key="return-skip-limit1-6",
        feature_path="tck/features/clauses/return-skip-limit/ReturnSkipLimit1.feature",
        scenario="[6] Negative parameter for SKIP should fail",
        cypher="MATCH (p:Person)\nRETURN p.name AS name\nSKIP $_skip",
        graph=graph_fixture_from_create(
            """
            CREATE (s:Person {name: 'Steven'}),
                   (c:Person {name: 'Craig'})
            """
        ),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Parameter binding and runtime validation for SKIP are not supported",
        tags=("return", "skip", "params", "runtime-error", "xfail"),
    ),
    Scenario(
        key="return-skip-limit1-7",
        feature_path="tck/features/clauses/return-skip-limit/ReturnSkipLimit1.feature",
        scenario="[7] Negative SKIP should fail",
        cypher="MATCH (p:Person)\nRETURN p.name AS name\nSKIP -1",
        graph=graph_fixture_from_create(
            """
            CREATE (s:Person {name: 'Steven'}),
                   (c:Person {name: 'Craig'})
            """
        ),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Compile-time validation for SKIP arguments is not enforced",
        tags=("return", "skip", "syntax-error", "xfail"),
    ),
    Scenario(
        key="return-skip-limit1-8",
        feature_path="tck/features/clauses/return-skip-limit/ReturnSkipLimit1.feature",
        scenario="[8] Floating point parameter for SKIP should fail",
        cypher="MATCH (p:Person)\nRETURN p.name AS name\nSKIP $_limit",
        graph=graph_fixture_from_create(
            """
            CREATE (s:Person {name: 'Steven'}),
                   (c:Person {name: 'Craig'})
            """
        ),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Parameter binding and runtime validation for SKIP are not supported",
        tags=("return", "skip", "params", "runtime-error", "xfail"),
    ),
    Scenario(
        key="return-skip-limit1-9",
        feature_path="tck/features/clauses/return-skip-limit/ReturnSkipLimit1.feature",
        scenario="[9] Floating point SKIP should fail",
        cypher="MATCH (p:Person)\nRETURN p.name AS name\nSKIP 1.5",
        graph=graph_fixture_from_create(
            """
            CREATE (s:Person {name: 'Steven'}),
                   (c:Person {name: 'Craig'})
            """
        ),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Compile-time validation for SKIP arguments is not enforced",
        tags=("return", "skip", "syntax-error", "xfail"),
    ),
    Scenario(
        key="return-skip-limit1-10",
        feature_path="tck/features/clauses/return-skip-limit/ReturnSkipLimit1.feature",
        scenario="[10] Fail when using non-constants in SKIP",
        cypher="MATCH (n)\nRETURN n\nSKIP n.count",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Compile-time validation for SKIP expressions is not enforced",
        tags=("return", "skip", "syntax-error", "xfail"),
    ),
    Scenario(
        key="return-skip-limit1-11",
        feature_path="tck/features/clauses/return-skip-limit/ReturnSkipLimit1.feature",
        scenario="[11] Fail when using negative value in SKIP",
        cypher="MATCH (n)\nRETURN n\nSKIP -1",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Compile-time validation for SKIP arguments is not enforced",
        tags=("return", "skip", "syntax-error", "xfail"),
    ),
    Scenario(
        key="return-skip-limit2-1",
        feature_path="tck/features/clauses/return-skip-limit/ReturnSkipLimit2.feature",
        scenario="[1] Limit to two hits",
        cypher="UNWIND [1, 1, 1, 1, 1] AS i\nRETURN i\nLIMIT 2",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"i": 1},
                {"i": 1},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="UNWIND and LIMIT are not supported",
        tags=("return", "limit", "unwind", "xfail"),
    ),
    Scenario(
        key="return-skip-limit2-2",
        feature_path="tck/features/clauses/return-skip-limit/ReturnSkipLimit2.feature",
        scenario="[2] Limit to two hits with explicit order",
        cypher="MATCH (n)\nRETURN n\nORDER BY n.name ASC\nLIMIT 2",
        graph=graph_fixture_from_create(
            """
            CREATE ({name: 'A'}),
              ({name: 'B'}),
              ({name: 'C'}),
              ({name: 'D'}),
              ({name: 'E'})
            """
        ),
        expected=Expected(
            rows=[
                {"n": "({name: 'A'})"},
                {"n": "({name: 'B'})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="LIMIT and ORDER BY are not supported",
        tags=("return", "limit", "orderby", "xfail"),
    ),
    Scenario(
        key="return-skip-limit2-3",
        feature_path="tck/features/clauses/return-skip-limit/ReturnSkipLimit2.feature",
        scenario="[3] LIMIT 0 should return an empty result",
        cypher="MATCH (n)\nRETURN n\nLIMIT 0",
        graph=graph_fixture_from_create(
            """
            CREATE (), (), ()
            """
        ),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason="LIMIT is not supported",
        tags=("return", "limit", "xfail"),
    ),
    Scenario(
        key="return-skip-limit2-4",
        feature_path="tck/features/clauses/return-skip-limit/ReturnSkipLimit2.feature",
        scenario="[4] Handle ORDER BY with LIMIT 1",
        cypher="MATCH (p:Person)\nRETURN p.name AS name\nORDER BY p.name\nLIMIT 1",
        graph=graph_fixture_from_create(
            """
            CREATE (s:Person {name: 'Steven'}),
              (c:Person {name: 'Craig'})
            """
        ),
        expected=Expected(
            rows=[
                {"name": "'Craig'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="LIMIT and ORDER BY are not supported",
        tags=("return", "limit", "orderby", "xfail"),
    ),
    Scenario(
        key="return-skip-limit2-5",
        feature_path="tck/features/clauses/return-skip-limit/ReturnSkipLimit2.feature",
        scenario="[5] ORDER BY with LIMIT 0 should not generate errors",
        cypher="MATCH (p:Person)\nRETURN p.name AS name\nORDER BY p.name\nLIMIT 0",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason="LIMIT and ORDER BY are not supported",
        tags=("return", "limit", "orderby", "xfail"),
    ),
    Scenario(
        key="return-skip-limit2-6",
        feature_path="tck/features/clauses/return-skip-limit/ReturnSkipLimit2.feature",
        scenario="[6] LIMIT with an expression that does not depend on variables",
        cypher="MATCH (n)\nWITH n LIMIT toInteger(ceil(1.7))\nRETURN count(*) AS count",
        graph=GraphFixture(
            nodes=[{"id": f"n{i}", "labels": [], "nr": i} for i in range(1, 4)],
            edges=[],
        ),
        expected=Expected(
            rows=[
                {"count": 2},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, LIMIT, and functions are not supported",
        tags=("return", "limit", "with", "function", "xfail"),
    ),
    Scenario(
        key="return-skip-limit2-7",
        feature_path="tck/features/clauses/return-skip-limit/ReturnSkipLimit2.feature",
        scenario="[7] Limit to more rows than actual results 1",
        cypher="MATCH (foo)\nRETURN foo.num AS x\nORDER BY x DESC\nLIMIT 4",
        graph=graph_fixture_from_create(
            """
            CREATE ({num: 1}), ({num: 3}), ({num: 2})
            """
        ),
        expected=Expected(
            rows=[
                {"x": 3},
                {"x": 2},
                {"x": 1},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="LIMIT and ORDER BY are not supported",
        tags=("return", "limit", "orderby", "xfail"),
    ),
    Scenario(
        key="return-skip-limit2-8",
        feature_path="tck/features/clauses/return-skip-limit/ReturnSkipLimit2.feature",
        scenario="[8] Limit to more rows than actual results 2",
        cypher="MATCH (a:A)-->(n)-->(m)\nRETURN n.num, count(*)\nORDER BY n.num\nLIMIT 1000",
        graph=graph_fixture_from_create(
            """
            CREATE (a:A), (n1 {num: 1}), (n2 {num: 2}),
                   (m1), (m2)
            CREATE (a)-[:T]->(n1),
                   (n1)-[:T]->(m1),
                   (a)-[:T]->(n2),
                   (n2)-[:T]->(m2)
            """
        ),
        expected=Expected(
            rows=[
                {"n.num": 1, "count(*)": 1},
                {"n.num": 2, "count(*)": 1},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="LIMIT, ORDER BY, and aggregations are not supported",
        tags=("return", "limit", "orderby", "aggregation", "xfail"),
    ),
    Scenario(
        key="return-skip-limit2-9",
        feature_path="tck/features/clauses/return-skip-limit/ReturnSkipLimit2.feature",
        scenario="[9] Fail when using non-constants in LIMIT",
        cypher="MATCH (n)\nRETURN n\nLIMIT n.count",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Compile-time validation for LIMIT expressions is not enforced",
        tags=("return", "limit", "syntax-error", "xfail"),
    ),
    Scenario(
        key="return-skip-limit2-10",
        feature_path="tck/features/clauses/return-skip-limit/ReturnSkipLimit2.feature",
        scenario="[10] Negative parameter for LIMIT should fail",
        cypher="MATCH (p:Person)\nRETURN p.name AS name\nLIMIT $_limit",
        graph=graph_fixture_from_create(
            """
            CREATE (s:Person {name: 'Steven'}),
                   (c:Person {name: 'Craig'})
            """
        ),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Parameter binding and runtime validation for LIMIT are not supported",
        tags=("return", "limit", "params", "runtime-error", "xfail"),
    ),
    Scenario(
        key="return-skip-limit2-11",
        feature_path="tck/features/clauses/return-skip-limit/ReturnSkipLimit2.feature",
        scenario="[11] Negative parameter for LIMIT with ORDER BY should fail",
        cypher="MATCH (p:Person)\nRETURN p.name AS name\nORDER BY name\nLIMIT $_limit",
        graph=graph_fixture_from_create(
            """
            CREATE (s:Person {name: 'Steven'}),
                   (c:Person {name: 'Craig'})
            """
        ),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Parameter binding and runtime validation for LIMIT are not supported",
        tags=("return", "limit", "orderby", "params", "runtime-error", "xfail"),
    ),
    Scenario(
        key="return-skip-limit2-12",
        feature_path="tck/features/clauses/return-skip-limit/ReturnSkipLimit2.feature",
        scenario="[12] Fail when using negative value in LIMIT 1",
        cypher="MATCH (n)\nRETURN n\nLIMIT -1",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Compile-time validation for LIMIT arguments is not enforced",
        tags=("return", "limit", "syntax-error", "xfail"),
    ),
    Scenario(
        key="return-skip-limit2-13",
        feature_path="tck/features/clauses/return-skip-limit/ReturnSkipLimit2.feature",
        scenario="[13] Fail when using negative value in LIMIT 2",
        cypher="MATCH (p:Person)\nRETURN p.name AS name\nLIMIT -1",
        graph=graph_fixture_from_create(
            """
            CREATE (s:Person {name: 'Steven'}),
                   (c:Person {name: 'Craig'})
            """
        ),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Compile-time validation for LIMIT arguments is not enforced",
        tags=("return", "limit", "syntax-error", "xfail"),
    ),
    Scenario(
        key="return-skip-limit2-14",
        feature_path="tck/features/clauses/return-skip-limit/ReturnSkipLimit2.feature",
        scenario="[14] Floating point parameter for LIMIT should fail",
        cypher="MATCH (p:Person)\nRETURN p.name AS name\nLIMIT $_limit",
        graph=graph_fixture_from_create(
            """
            CREATE (s:Person {name: 'Steven'}),
                   (c:Person {name: 'Craig'})
            """
        ),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Parameter binding and runtime validation for LIMIT are not supported",
        tags=("return", "limit", "params", "runtime-error", "xfail"),
    ),
    Scenario(
        key="return-skip-limit2-15",
        feature_path="tck/features/clauses/return-skip-limit/ReturnSkipLimit2.feature",
        scenario="[15] Floating point parameter for LIMIT with ORDER BY should fail",
        cypher="MATCH (p:Person)\nRETURN p.name AS name\nORDER BY name\nLIMIT $_limit",
        graph=graph_fixture_from_create(
            """
            CREATE (s:Person {name: 'Steven'}),
                   (c:Person {name: 'Craig'})
            """
        ),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Parameter binding and runtime validation for LIMIT are not supported",
        tags=("return", "limit", "orderby", "params", "runtime-error", "xfail"),
    ),
    Scenario(
        key="return-skip-limit2-16",
        feature_path="tck/features/clauses/return-skip-limit/ReturnSkipLimit2.feature",
        scenario="[16] Fail when using floating point in LIMIT 1",
        cypher="MATCH (n)\nRETURN n\nLIMIT 1.7",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Compile-time validation for LIMIT arguments is not enforced",
        tags=("return", "limit", "syntax-error", "xfail"),
    ),
    Scenario(
        key="return-skip-limit2-17",
        feature_path="tck/features/clauses/return-skip-limit/ReturnSkipLimit2.feature",
        scenario="[17] Fail when using floating point in LIMIT 2",
        cypher="MATCH (p:Person)\nRETURN p.name AS name\nLIMIT 1.5",
        graph=graph_fixture_from_create(
            """
            CREATE (s:Person {name: 'Steven'}),
                   (c:Person {name: 'Craig'})
            """
        ),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Compile-time validation for LIMIT arguments is not enforced",
        tags=("return", "limit", "syntax-error", "xfail"),
    ),
    Scenario(
        key="return-skip-limit3-1",
        feature_path="tck/features/clauses/return-skip-limit/ReturnSkipLimit3.feature",
        scenario="[1] Get rows in the middle",
        cypher="MATCH (n)\nRETURN n\nORDER BY n.name ASC\nSKIP 2\nLIMIT 2",
        graph=graph_fixture_from_create(
            """
            CREATE ({name: 'A'}),
              ({name: 'B'}),
              ({name: 'C'}),
              ({name: 'D'}),
              ({name: 'E'})
            """
        ),
        expected=Expected(
            rows=[
                {"n": "({name: 'C'})"},
                {"n": "({name: 'D'})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="SKIP/LIMIT and ORDER BY are not supported",
        tags=("return", "skip", "limit", "orderby", "xfail"),
    ),
    Scenario(
        key="return-skip-limit3-2",
        feature_path="tck/features/clauses/return-skip-limit/ReturnSkipLimit3.feature",
        scenario="[2] Get rows in the middle by param",
        cypher="MATCH (n)\nRETURN n\nORDER BY n.name ASC\nSKIP $s\nLIMIT $l",
        graph=graph_fixture_from_create(
            """
            CREATE ({name: 'A'}),
              ({name: 'B'}),
              ({name: 'C'}),
              ({name: 'D'}),
              ({name: 'E'})
            """
        ),
        expected=Expected(
            rows=[
                {"n": "({name: 'C'})"},
                {"n": "({name: 'D'})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="SKIP/LIMIT, ORDER BY, and parameter binding are not supported",
        tags=("return", "skip", "limit", "orderby", "params", "xfail"),
    ),
    Scenario(
        key="return-skip-limit3-3",
        feature_path="tck/features/clauses/return-skip-limit/ReturnSkipLimit3.feature",
        scenario="[3] Limiting amount of rows when there are fewer left than the LIMIT argument",
        cypher="MATCH (a)\nRETURN a.count\nORDER BY a.count\nSKIP 10\nLIMIT 10",
        graph=GraphFixture(
            nodes=[{"id": f"n{i}", "labels": [], "count": i} for i in range(16)],
            edges=[],
        ),
        expected=Expected(
            rows=[
                {"a.count": 10},
                {"a.count": 11},
                {"a.count": 12},
                {"a.count": 13},
                {"a.count": 14},
                {"a.count": 15},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="UNWIND, SKIP/LIMIT, and ORDER BY are not supported",
        tags=("return", "skip", "limit", "orderby", "unwind", "xfail"),
    ),
    Scenario(
        key="with1-1",
        feature_path="tck/features/clauses/with/With1.feature",
        scenario="[1] Forwarind a node variable 1",
        cypher="MATCH (a:A)\nWITH a\nMATCH (a)-->(b)\nRETURN *",
        graph=graph_fixture_from_create(
            """
            CREATE (:A)-[:REL]->(:B)
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:A)", "b": "(:B)"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines and RETURN * projections are not supported",
        tags=("with", "pipeline", "return-star", "xfail"),
    ),
    Scenario(
        key="with1-2",
        feature_path="tck/features/clauses/with/With1.feature",
        scenario="[2] Forwarind a node variable 2",
        cypher="MATCH (a:A)\nWITH a\nMATCH (x:X), (a)-->(b)\nRETURN *",
        graph=graph_fixture_from_create(
            """
            CREATE (:A)-[:REL]->(:B)
            CREATE (:X)
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:A)", "b": "(:B)", "x": "(:X)"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, cartesian products, and RETURN * projections are not supported",
        tags=("with", "pipeline", "cartesian", "return-star", "xfail"),
    ),
    Scenario(
        key="with1-3",
        feature_path="tck/features/clauses/with/With1.feature",
        scenario="[3] Forwarding a relationship variable",
        cypher="MATCH ()-[r1]->(:X)\nWITH r1 AS r2\nMATCH ()-[r2]->()\nRETURN r2 AS rel",
        graph=graph_fixture_from_create(
            """
            CREATE ()-[:T1]->(:X),
                   ()-[:T2]->(:X),
                   ()-[:T3]->()
            """
        ),
        expected=Expected(
            rows=[
                {"rel": "[:T1]"},
                {"rel": "[:T2]"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines and relationship variable aliasing are not supported",
        tags=("with", "relationship", "alias", "xfail"),
    ),
    Scenario(
        key="with1-4",
        feature_path="tck/features/clauses/with/With1.feature",
        scenario="[4] Forwarding a path variable",
        cypher="MATCH p = (a)\nWITH p\nRETURN p",
        graph=graph_fixture_from_create(
            """
            CREATE ()
            """
        ),
        expected=Expected(
            rows=[
                {"p": "<()>"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines and path variables are not supported",
        tags=("with", "path", "xfail"),
    ),
    Scenario(
        key="with1-5",
        feature_path="tck/features/clauses/with/With1.feature",
        scenario="[5] Forwarding null",
        cypher="OPTIONAL MATCH (a:Start)\nWITH a\nMATCH (a)-->(b)\nRETURN *",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason="OPTIONAL MATCH semantics and WITH pipelines are not supported",
        tags=("with", "optional-match", "null", "xfail"),
    ),
    Scenario(
        key="with1-6",
        feature_path="tck/features/clauses/with/With1.feature",
        scenario="[6] Forwarding a node variable possibly null",
        cypher="OPTIONAL MATCH (a:A)\nWITH a AS a\nMATCH (b:B)\nRETURN a, b",
        graph=graph_fixture_from_create(
            """
            CREATE (s:Single), (a:A {num: 42}),
                   (b:B {num: 46}), (c:C)
            CREATE (s)-[:REL]->(a),
                   (s)-[:REL]->(b),
                   (a)-[:REL]->(c),
                   (b)-[:LOOP]->(b)
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:A {num: 42})", "b": "(:B {num: 46})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="OPTIONAL MATCH semantics and WITH pipelines are not supported",
        tags=("with", "optional-match", "xfail"),
    ),
    Scenario(
        key="with2-1",
        feature_path="tck/features/clauses/with/With2.feature",
        scenario="[1] Forwarding a property to express a join",
        cypher="MATCH (a:Begin)\nWITH a.num AS property\nMATCH (b)\nWHERE b.id = property\nRETURN b",
        graph=graph_fixture_from_create(
            """
            CREATE (a:End {num: 42, id: 0}),
                   (:End {num: 3}),
                   (:Begin {num: a.id})
            """
        ),
        expected=Expected(
            rows=[
                {"b": "(:End {num: 42, id: 0})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, joins, and row projections are not supported",
        tags=("with", "join", "xfail"),
    ),
    Scenario(
        key="with2-2",
        feature_path="tck/features/clauses/with/With2.feature",
        scenario="[2] Forwarding a nested map literal",
        cypher="WITH {name: {name2: 'baz'}} AS nestedMap\nRETURN nestedMap.name.name2",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"nestedMap.name.name2": "'baz'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines and map projections are not supported",
        tags=("with", "map", "projection", "xfail"),
    ),
    Scenario(
        key="with3-1",
        feature_path="tck/features/clauses/with/With3.feature",
        scenario="[1] Forwarding multiple node and relationship variables",
        cypher="MATCH (a)-[r]->(b:X)\nWITH a, r, b\nMATCH (a)-[r]->(b)\nRETURN r AS rel\n  ORDER BY rel.id",
        graph=graph_fixture_from_create(
            """
            CREATE ()-[:T1 {id: 0}]->(:X),
                   ()-[:T2 {id: 1}]->(:X),
                   ()-[:T2 {id: 2}]->()
            """
        ),
        expected=Expected(
            rows=[
                {"rel": "[:T1 {id: 0}]"},
                {"rel": "[:T2 {id: 1}]"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, and relationship projections are not supported",
        tags=("with", "orderby", "relationship", "xfail"),
    ),
    Scenario(
        key="with4-1",
        feature_path="tck/features/clauses/with/With4.feature",
        scenario="[1] Aliasing relationship variable",
        cypher="MATCH ()-[r1]->()\nWITH r1 AS r2\nRETURN r2 AS rel",
        graph=graph_fixture_from_create(
            """
            CREATE ()-[:T1]->(),
                   ()-[:T2]->()
            """
        ),
        expected=Expected(
            rows=[
                {"rel": "[:T1]"},
                {"rel": "[:T2]"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines and relationship aliasing are not supported",
        tags=("with", "alias", "relationship", "xfail"),
    ),
    Scenario(
        key="with4-2",
        feature_path="tck/features/clauses/with/With4.feature",
        scenario="[2] Aliasing expression to new variable name",
        cypher="MATCH (a:Begin)\nWITH a.num AS property\nMATCH (b:End)\nWHERE property = b.num\nRETURN b",
        graph=graph_fixture_from_create(
            """
            CREATE (:Begin {num: 42}),
                   (:End {num: 42}),
                   (:End {num: 3})
            """
        ),
        expected=Expected(
            rows=[
                {"b": "(:End {num: 42})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, expression aliasing, and row projections are not supported",
        tags=("with", "alias", "projection", "xfail"),
    ),
    Scenario(
        key="with4-3",
        feature_path="tck/features/clauses/with/With4.feature",
        scenario="[3] Aliasing expression to existing variable name",
        cypher="MATCH (n)\nWITH n.name AS n\nRETURN n",
        graph=graph_fixture_from_create(
            """
            CREATE ({num: 1, name: 'King Kong'}),
              ({num: 2, name: 'Ann Darrow'})
            """
        ),
        expected=Expected(
            rows=[
                {"n": "'Ann Darrow'"},
                {"n": "'King Kong'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines and expression projections are not supported",
        tags=("with", "alias", "projection", "xfail"),
    ),
    Scenario(
        key="with4-4",
        feature_path="tck/features/clauses/with/With4.feature",
        scenario="[4] Fail when forwarding multiple aliases with the same name",
        cypher="WITH 1 AS a, 2 AS a\nRETURN a",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Compile-time validation for duplicate WITH aliases is not enforced",
        tags=("with", "syntax-error", "xfail"),
    ),
    Scenario(
        key="with4-5",
        feature_path="tck/features/clauses/with/With4.feature",
        scenario="[5] Fail when not aliasing expressions in WITH",
        cypher="MATCH (a)\nWITH a, count(*)\nRETURN a",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Compile-time validation for WITH expression aliasing is not enforced",
        tags=("with", "syntax-error", "xfail"),
    ),
    Scenario(
        key="with4-6",
        feature_path="tck/features/clauses/with/With4.feature",
        scenario="[6] Reusing variable names in WITH",
        cypher="MATCH (person:Person)<--(message)<-[like]-(:Person)\nWITH like.creationDate AS likeTime, person AS person\n  ORDER BY likeTime, message.id\nWITH head(collect({likeTime: likeTime})) AS latestLike, person AS person\nWITH latestLike.likeTime AS likeTime\n  ORDER BY likeTime\nRETURN likeTime",
        graph=graph_fixture_from_create(
            """
            CREATE (a:Person), (b:Person), (m:Message {id: 10})
            CREATE (a)-[:LIKE {creationDate: 20160614}]->(m)-[:POSTED_BY]->(b)
            """
        ),
        expected=Expected(
            rows=[
                {"likeTime": 20160614},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, aggregations, and list/map expressions are not supported",
        tags=("with", "orderby", "aggregation", "xfail"),
    ),
    Scenario(
        key="with4-7",
        feature_path="tck/features/clauses/with/With4.feature",
        scenario="[7] Multiple aliasing and backreferencing",
        cypher="CREATE (m {id: 0})\nWITH {first: m.id} AS m\nWITH {second: m.first} AS m\nRETURN m.second",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"m.second": 0},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, map projections, and side effect validation are not supported",
        tags=("with", "map", "projection", "xfail"),
    ),
    Scenario(
        key="with5-1",
        feature_path="tck/features/clauses/with/With5.feature",
        scenario="[1] DISTINCT on an expression",
        cypher="MATCH (a)\nWITH DISTINCT a.name AS name\nRETURN name",
        graph=graph_fixture_from_create(
            """
            CREATE ({name: 'A'}),
                   ({name: 'A'}),
                   ({name: 'B'})
            """
        ),
        expected=Expected(
            rows=[
                {"name": "'A'"},
                {"name": "'B'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH DISTINCT projections are not supported",
        tags=("with", "distinct", "xfail"),
    ),
    Scenario(
        key="with5-2",
        feature_path="tck/features/clauses/with/With5.feature",
        scenario="[2] Handling DISTINCT with lists in maps",
        cypher="MATCH (n)\nWITH DISTINCT {name: n.list} AS map\nRETURN count(*)",
        graph=graph_fixture_from_create(
            """
            CREATE ({list: ['A', 'B']}), ({list: ['A', 'B']})
            """
        ),
        expected=Expected(
            rows=[
                {"count(*)": 1},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH DISTINCT projections and aggregations are not supported",
        tags=("with", "distinct", "aggregation", "xfail"),
    ),
    Scenario(
        key="with6-1",
        feature_path="tck/features/clauses/with/With6.feature",
        scenario="[1] Implicit grouping with single expression as grouping key and single aggregation",
        cypher="MATCH (a)\nWITH a.name AS name, count(*) AS relCount\nRETURN name, relCount",
        graph=graph_fixture_from_create(
            """
            CREATE ({name: 'A'}),
                   ({name: 'A'}),
                   ({name: 'B'})
            """
        ),
        expected=Expected(
            rows=[
                {"name": "'A'", "relCount": 2},
                {"name": "'B'", "relCount": 1},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH aggregations and row projections are not supported",
        tags=("with", "aggregation", "xfail"),
    ),
    Scenario(
        key="with6-2",
        feature_path="tck/features/clauses/with/With6.feature",
        scenario="[2] Implicit grouping with single relationship variable as grouping key and single aggregation",
        cypher="MATCH ()-[r1]->(:X)\nWITH r1 AS r2, count(*) AS c\nMATCH ()-[r2]->()\nRETURN r2 AS rel",
        graph=graph_fixture_from_create(
            """
            CREATE ()-[:T1]->(:X),
                   ()-[:T2]->(:X),
                   ()-[:T3]->()
            """
        ),
        expected=Expected(
            rows=[
                {"rel": "[:T1]"},
                {"rel": "[:T2]"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH aggregations and relationship projections are not supported",
        tags=("with", "aggregation", "relationship", "xfail"),
    ),
    Scenario(
        key="with6-3",
        feature_path="tck/features/clauses/with/With6.feature",
        scenario="[3] Implicit grouping with multiple node and relationship variables as grouping key and single aggregation",
        cypher="MATCH (a)-[r1]->(b:X)\nWITH a, r1 AS r2, b, count(*) AS c\nMATCH (a)-[r2]->(b)\nRETURN r2 AS rel",
        graph=graph_fixture_from_create(
            """
            CREATE ()-[:T1]->(:X),
                   ()-[:T2]->(:X),
                   ()-[:T3]->()
            """
        ),
        expected=Expected(
            rows=[
                {"rel": "[:T1]"},
                {"rel": "[:T2]"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH aggregations and relationship projections are not supported",
        tags=("with", "aggregation", "relationship", "xfail"),
    ),
    Scenario(
        key="with6-4",
        feature_path="tck/features/clauses/with/With6.feature",
        scenario="[4] Implicit grouping with single path variable as grouping key and single aggregation",
        cypher="MATCH p = ()-[*]->()\nWITH count(*) AS count, p AS p\nRETURN nodes(p) AS nodes",
        graph=graph_fixture_from_create(
            """
            CREATE (n1 {num: 1}), (n2 {num: 2}),
                   (n3 {num: 3}), (n4 {num: 4})
            CREATE (n1)-[:T]->(n2),
                   (n3)-[:T]->(n4)
            """
        ),
        expected=Expected(
            rows=[
                {"nodes": "[({num: 1}), ({num: 2})]"},
                {"nodes": "[({num: 3}), ({num: 4})]"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, variable-length patterns, path functions, and aggregations are not supported",
        tags=("with", "aggregation", "path", "variable-length", "xfail"),
    ),
    Scenario(
        key="with6-5",
        feature_path="tck/features/clauses/with/With6.feature",
        scenario="[5] Handle constants and parameters inside an expression which contains an aggregation expression",
        cypher="MATCH (person)\nWITH $age + avg(person.age) - 1000 AS agg\nRETURN *",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"agg": "null"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="Parameters, aggregations, and WITH pipelines are not supported",
        tags=("with", "aggregation", "params", "xfail"),
    ),
    Scenario(
        key="with6-6",
        feature_path="tck/features/clauses/with/With6.feature",
        scenario="[6] Handle projected variables inside an expression which contains an aggregation expression",
        cypher="MATCH (me: Person)--(you: Person)\nWITH me.age AS age, you\nWITH age, age + count(you.age) AS agg\nRETURN *",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason="WITH pipelines and aggregations are not supported",
        tags=("with", "aggregation", "xfail"),
    ),
    Scenario(
        key="with6-7",
        feature_path="tck/features/clauses/with/With6.feature",
        scenario="[7] Handle projected property accesses inside an expression which contains an aggregation expression",
        cypher="MATCH (me: Person)--(you: Person)\nWITH me.age AS age, me.age + count(you.age) AS agg\nRETURN *",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason="WITH pipelines and aggregations are not supported",
        tags=("with", "aggregation", "xfail"),
    ),
    Scenario(
        key="with6-8",
        feature_path="tck/features/clauses/with/With6.feature",
        scenario="[8] Fail if not projected variables are used inside an expression which contains an aggregation expression",
        cypher="MATCH (me: Person)--(you: Person)\nWITH me.age + count(you.age) AS agg\nRETURN *",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Compile-time validation for ambiguous aggregation expressions is not enforced",
        tags=("with", "syntax-error", "aggregation", "xfail"),
    ),
    Scenario(
        key="with6-9",
        feature_path="tck/features/clauses/with/With6.feature",
        scenario="[9] Fail if more complex expression, even if projected, are used inside expression which contains an aggregation expression",
        cypher="MATCH (me: Person)--(you: Person)\nWITH me.age + you.age AS grp, me.age + you.age + count(*) AS agg\nRETURN *",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Compile-time validation for ambiguous aggregation expressions is not enforced",
        tags=("with", "syntax-error", "aggregation", "xfail"),
    ),
    Scenario(
        key="with7-1",
        feature_path="tck/features/clauses/with/With7.feature",
        scenario="[1] A simple pattern with one bound endpoint",
        cypher="MATCH (a:A)-[r:REL]->(b:B)\nWITH a AS b, b AS tmp, r AS r\nWITH b AS a, r\nLIMIT 1\nMATCH (a)-[r]->(b)\nRETURN a, r, b",
        graph=graph_fixture_from_create(
            """
            CREATE (:A)-[:REL]->(:B)
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:A)", "r": "[:REL]", "b": "(:B)"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, LIMIT, and row projections are not supported",
        tags=("with", "limit", "xfail"),
    ),
    Scenario(
        key="with7-2",
        feature_path="tck/features/clauses/with/With7.feature",
        scenario="[2] Multiple WITHs using a predicate and aggregation",
        cypher="MATCH (david {name: 'David'})--(otherPerson)-->()\nWITH otherPerson, count(*) AS foaf\nWHERE foaf > 1\nWITH otherPerson\nWHERE otherPerson.name <> 'NotOther'\nRETURN count(*)",
        graph=graph_fixture_from_create(
            """
            CREATE (a {name: 'David'}),
                   (b {name: 'Other'}),
                   (c {name: 'NotOther'}),
                   (d {name: 'NotOther2'}),
                   (a)-[:REL]->(b),
                   (a)-[:REL]->(c),
                   (a)-[:REL]->(d),
                   (b)-[:REL]->(),
                   (b)-[:REL]->(),
                   (c)-[:REL]->(),
                   (c)-[:REL]->(),
                   (d)-[:REL]->()
            """
        ),
        expected=Expected(
            rows=[
                {"count(*)": 1},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, WHERE filtering, and aggregations are not supported",
        tags=("with", "where", "aggregation", "xfail"),
    ),
    Scenario(
        key="with-where1-1",
        feature_path="tck/features/clauses/with-where/WithWhere1.feature",
        scenario="[1] Filter node with property predicate on a single variable with multiple bindings",
        cypher="MATCH (a)\nWITH a\nWHERE a.name = 'B'\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE ({name: 'A'}),
                   ({name: 'B'}),
                   ({name: 'C'})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "({name: 'B'})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines and WHERE filtering are not supported",
        tags=("with", "where", "xfail"),
    ),
    Scenario(
        key="with-where1-2",
        feature_path="tck/features/clauses/with-where/WithWhere1.feature",
        scenario="[2] Filter node with property predicate on a single variable with multiple distinct bindings",
        cypher="MATCH (a)\nWITH DISTINCT a.name2 AS name\nWHERE a.name2 = 'B'\nRETURN *",
        graph=graph_fixture_from_create(
            """
            CREATE ({name2: 'A'}),
                   ({name2: 'A'}),
                   ({name2: 'B'})
            """
        ),
        expected=Expected(
            rows=[
                {"name": "'B'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH DISTINCT projections and WHERE filtering are not supported",
        tags=("with", "distinct", "where", "xfail"),
    ),
    Scenario(
        key="with-where1-3",
        feature_path="tck/features/clauses/with-where/WithWhere1.feature",
        scenario="[3] Filter for an unbound relationship variable",
        cypher="MATCH (a:A), (other:B)\nOPTIONAL MATCH (a)-[r]->(other)\nWITH other WHERE r IS NULL\nRETURN other",
        graph=graph_fixture_from_create(
            """
            CREATE (a:A), (b:B {id: 1}), (:B {id: 2})
            CREATE (a)-[:T]->(b)
            """
        ),
        expected=Expected(
            rows=[
                {"other": "(:B {id: 2})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, OPTIONAL MATCH semantics, and null handling are not supported",
        tags=("with", "optional-match", "null", "xfail"),
    ),
    Scenario(
        key="with-where1-4",
        feature_path="tck/features/clauses/with-where/WithWhere1.feature",
        scenario="[4] Filter for an unbound node variable",
        cypher="MATCH (other:B)\nOPTIONAL MATCH (a)-[r]->(other)\nWITH other WHERE a IS NULL\nRETURN other",
        graph=graph_fixture_from_create(
            """
            CREATE (a:A), (b:B {id: 1}), (:B {id: 2})
            CREATE (a)-[:T]->(b)
            """
        ),
        expected=Expected(
            rows=[
                {"other": "(:B {id: 2})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, OPTIONAL MATCH semantics, and null handling are not supported",
        tags=("with", "optional-match", "null", "xfail"),
    ),
    Scenario(
        key="with-where2-1",
        feature_path="tck/features/clauses/with-where/WithWhere2.feature",
        scenario="[1] Filter nodes with conjunctive two-part property predicate on multi variables with multiple bindings",
        cypher="MATCH (a)--(b)--(c)--(d)--(a), (b)--(d)\nWITH a, c, d\nWHERE a.id = 1\n  AND c.id = 2\nRETURN d",
        graph=graph_fixture_from_create(
            """
            CREATE (a:A), (b:B {id: 1}), (c:C {id: 2}), (d:D)
            CREATE (a)-[:T]->(b),
                   (a)-[:T]->(c),
                   (a)-[:T]->(d),
                   (b)-[:T]->(c),
                   (b)-[:T]->(d),
                   (c)-[:T]->(d)
            """
        ),
        expected=Expected(
            rows=[
                {"d": "(:A)"},
                {"d": "(:D)"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines and multi-variable WHERE predicates are not supported",
        tags=("with", "where", "multi-var", "xfail"),
    ),
    Scenario(
        key="with-where2-2",
        feature_path="tck/features/clauses/with-where/WithWhere2.feature",
        scenario="[2] Filter node with conjunctive multi-part property predicates on multi variables with multiple bindings",
        cypher="MATCH (advertiser)-[:ADV_HAS_PRODUCT]->(out)-[:AP_HAS_VALUE]->(red)<-[:AA_HAS_VALUE]-(a)\nWITH a, advertiser, red, out\nWHERE advertiser.id = $1\n  AND a.id = $2\n  AND red.name = 'red'\n  AND out.name = 'product1'\nRETURN out.name",
        graph=graph_fixture_from_create(
            """
            CREATE (advertiser {name: 'advertiser1', id: 0}),
                   (thing {name: 'Color', id: 1}),
                   (red {name: 'red'}),
                   (p1 {name: 'product1'}),
                   (p2 {name: 'product4'})
            CREATE (advertiser)-[:ADV_HAS_PRODUCT]->(p1),
                   (advertiser)-[:ADV_HAS_PRODUCT]->(p2),
                   (thing)-[:AA_HAS_VALUE]->(red),
                   (p1)-[:AP_HAS_VALUE]->(red),
                   (p2)-[:AP_HAS_VALUE]->(red)
            """
        ),
        expected=Expected(
            rows=[
                {"out.name": "'product1'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, parameter binding, and multi-variable WHERE predicates are not supported",
        tags=("with", "where", "params", "multi-var", "xfail"),
    ),
    Scenario(
        key="with-where3-1",
        feature_path="tck/features/clauses/with-where/WithWhere3.feature",
        scenario="[1] Join between node identities",
        cypher="MATCH (a), (b)\nWITH a, b\nWHERE a = b\nRETURN a, b",
        graph=graph_fixture_from_create(
            """
            CREATE (:A), (:B)
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:A)", "b": "(:A)"},
                {"a": "(:B)", "b": "(:B)"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, variable equality joins, and row projections are not supported",
        tags=("with", "join", "xfail"),
    ),
    Scenario(
        key="with-where3-2",
        feature_path="tck/features/clauses/with-where/WithWhere3.feature",
        scenario="[2] Join between node properties of disconnected nodes",
        cypher="MATCH (a:A), (b:B)\nWITH a, b\nWHERE a.id = b.id\nRETURN a, b",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {id: 1}),
                   (:A {id: 2}),
                   (:B {id: 2}),
                   (:B {id: 3})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:A {id: 2})", "b": "(:B {id: 2})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, variable comparison joins, and row projections are not supported",
        tags=("with", "join", "xfail"),
    ),
    Scenario(
        key="with-where3-3",
        feature_path="tck/features/clauses/with-where/WithWhere3.feature",
        scenario="[3] Join between node properties of adjacent nodes",
        cypher="MATCH (n)-[rel]->(x)\nWITH n, x\nWHERE n.animal = x.animal\nRETURN n, x",
        graph=graph_fixture_from_create(
            """
            CREATE (a:A {animal: 'monkey'}),
              (b:B {animal: 'cow'}),
              (c:C {animal: 'monkey'}),
              (d:D {animal: 'cow'}),
              (a)-[:KNOWS]->(b),
              (a)-[:KNOWS]->(c),
              (d)-[:KNOWS]->(b),
              (d)-[:KNOWS]->(c)
            """
        ),
        expected=Expected(
            rows=[
                {"n": "(:A {animal: 'monkey'})", "x": "(:C {animal: 'monkey'})"},
                {"n": "(:D {animal: 'cow'})", "x": "(:B {animal: 'cow'})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, variable comparison joins, and row projections are not supported",
        tags=("with", "join", "xfail"),
    ),
    Scenario(
        key="with-where4-1",
        feature_path="tck/features/clauses/with-where/WithWhere4.feature",
        scenario="[1] Join nodes on inequality",
        cypher="MATCH (a), (b)\nWITH a, b\nWHERE a <> b\nRETURN a, b",
        graph=graph_fixture_from_create(
            """
            CREATE (:A), (:B)
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:A)", "b": "(:B)"},
                {"a": "(:B)", "b": "(:A)"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, variable inequality joins, and row projections are not supported",
        tags=("with", "join", "inequality", "xfail"),
    ),
    Scenario(
        key="with-where4-2",
        feature_path="tck/features/clauses/with-where/WithWhere4.feature",
        scenario="[2] Join with disjunctive multi-part predicates including patterns",
        cypher="MATCH (a), (b)\nWITH a, b\nWHERE a.id = 0\n  AND (a)-[:T]->(b:TheLabel)\n  OR (a)-[:T*]->(b:MissingLabel)\nRETURN DISTINCT b",
        graph=graph_fixture_from_create(
            """
            CREATE (a:TheLabel {id: 0}), (b:TheLabel {id: 1}), (c:TheLabel {id: 2})
            CREATE (a)-[:T]->(b),
                   (b)-[:T]->(c)
            """
        ),
        expected=Expected(
            rows=[
                {"b": "(:TheLabel {id: 1})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, OR predicates, pattern predicates, variable-length patterns, and DISTINCT are not supported",
        tags=("with", "or", "pattern-predicate", "variable-length", "distinct", "xfail"),
    ),
    Scenario(
        key="with-where5-1",
        feature_path="tck/features/clauses/with-where/WithWhere5.feature",
        scenario="[1] Filter out on null",
        cypher="MATCH (:Root {name: 'x'})-->(i:TextNode)\nWITH i\nWHERE i.var > 'te'\nRETURN i",
        graph=graph_fixture_from_create(
            """
            CREATE (root:Root {name: 'x'}),
                   (child1:TextNode {var: 'text'}),
                   (child2:IntNode {var: 0})
            CREATE (root)-[:T]->(child1),
                   (root)-[:T]->(child2)
            """
        ),
        expected=Expected(
            rows=[
                {"i": "(:TextNode {var: 'text'})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, comparison predicates, and null semantics are not supported",
        tags=("with", "null", "comparison", "xfail"),
    ),
    Scenario(
        key="with-where5-2",
        feature_path="tck/features/clauses/with-where/WithWhere5.feature",
        scenario="[2] Filter out on null if the AND'd predicate evaluates to false",
        cypher="MATCH (:Root {name: 'x'})-->(i:TextNode)\nWITH i\nWHERE i.var > 'te' AND i:TextNode\nRETURN i",
        graph=graph_fixture_from_create(
            """
            CREATE (root:Root {name: 'x'}),
                   (child1:TextNode {var: 'text'}),
                   (child2:IntNode {var: 0})
            CREATE (root)-[:T]->(child1),
                   (root)-[:T]->(child2)
            """
        ),
        expected=Expected(
            rows=[
                {"i": "(:TextNode {var: 'text'})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, comparison predicates, label predicates, and null semantics are not supported",
        tags=("with", "null", "comparison", "label-predicate", "xfail"),
    ),
    Scenario(
        key="with-where5-3",
        feature_path="tck/features/clauses/with-where/WithWhere5.feature",
        scenario="[3] Filter out on null if the AND'd predicate evaluates to true",
        cypher="MATCH (:Root {name: 'x'})-->(i:TextNode)\nWITH i\nWHERE i.var > 'te' AND i.var IS NOT NULL\nRETURN i",
        graph=graph_fixture_from_create(
            """
            CREATE (root:Root {name: 'x'}),
                   (child1:TextNode {var: 'text'}),
                   (child2:IntNode {var: 0})
            CREATE (root)-[:T]->(child1),
                   (root)-[:T]->(child2)
            """
        ),
        expected=Expected(
            rows=[
                {"i": "(:TextNode {var: 'text'})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, comparison predicates, IS NOT NULL, and null semantics are not supported",
        tags=("with", "null", "comparison", "is-not-null", "xfail"),
    ),
    Scenario(
        key="with-where5-4",
        feature_path="tck/features/clauses/with-where/WithWhere5.feature",
        scenario="[4] Do not filter out on null if the OR'd predicate evaluates to true",
        cypher="MATCH (:Root {name: 'x'})-->(i)\nWITH i\nWHERE i.var > 'te' OR i.var IS NOT NULL\nRETURN i",
        graph=graph_fixture_from_create(
            """
            CREATE (root:Root {name: 'x'}),
                   (child1:TextNode {var: 'text'}),
                   (child2:IntNode {var: 0})
            CREATE (root)-[:T]->(child1),
                   (root)-[:T]->(child2)
            """
        ),
        expected=Expected(
            rows=[
                {"i": "(:TextNode {var: 'text'})"},
                {"i": "(:IntNode {var: 0})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, OR predicates, comparison predicates, and null semantics are not supported",
        tags=("with", "null", "or", "comparison", "xfail"),
    ),
    Scenario(
        key="with-where6-1",
        feature_path="tck/features/clauses/with-where/WithWhere6.feature",
        scenario="[1] Filter a single aggregate",
        cypher="MATCH (a)-->()\nWITH a, count(*) AS relCount\nWHERE relCount > 1\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (a {name: 'A'}),
                   (b {name: 'B'})
            CREATE (a)-[:REL]->(),
                   (a)-[:REL]->(),
                   (a)-[:REL]->(),
                   (b)-[:REL]->()
            """
        ),
        expected=Expected(
            rows=[
                {"a": "({name: 'A'})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, aggregations, and WHERE filtering are not supported",
        tags=("with", "aggregation", "where", "xfail"),
    ),
    Scenario(
        key="with-where7-1",
        feature_path="tck/features/clauses/with-where/WithWhere7.feature",
        scenario="[1] WHERE sees a variable bound before but not after WITH",
        cypher="MATCH (a)\nWITH a.name2 AS name\nWHERE a.name2 = 'B'\nRETURN *",
        graph=graph_fixture_from_create(
            """
            CREATE ({name2: 'A'}),
                   ({name2: 'B'}),
                   ({name2: 'C'})
            """
        ),
        expected=Expected(
            rows=[
                {"name": "'B'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines and variable scoping rules are not supported",
        tags=("with", "where", "xfail"),
    ),
    Scenario(
        key="with-where7-2",
        feature_path="tck/features/clauses/with-where/WithWhere7.feature",
        scenario="[2] WHERE sees a variable bound after but not before WITH",
        cypher="MATCH (a)\nWITH a.name2 AS name\nWHERE name = 'B'\nRETURN *",
        graph=graph_fixture_from_create(
            """
            CREATE ({name2: 'A'}),
                   ({name2: 'B'}),
                   ({name2: 'C'})
            """
        ),
        expected=Expected(
            rows=[
                {"name": "'B'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines and variable scoping rules are not supported",
        tags=("with", "where", "xfail"),
    ),
    Scenario(
        key="with-where7-3",
        feature_path="tck/features/clauses/with-where/WithWhere7.feature",
        scenario="[3] WHERE sees both, variable bound before but not after WITH and variable bound after but not before WITH",
        cypher="MATCH (a)\nWITH a.name2 AS name\nWHERE name = 'B' OR a.name2 = 'C'\nRETURN *",
        graph=graph_fixture_from_create(
            """
            CREATE ({name2: 'A'}),
                   ({name2: 'B'}),
                   ({name2: 'C'})
            """
        ),
        expected=Expected(
            rows=[
                {"name": "'B'"},
                {"name": "'C'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, variable scoping rules, and OR predicates are not supported",
        tags=("with", "where", "or", "xfail"),
    ),
    Scenario(
        key="with-skip-limit1-1",
        feature_path="tck/features/clauses/with-skip-limit/WithSkipLimit1.feature",
        scenario="[1] Handle dependencies across WITH with SKIP",
        cypher="MATCH (a)\nWITH a.name AS property, a.num AS idToUse\n  ORDER BY property\n  SKIP 1\nMATCH (b)\nWHERE b.id = idToUse\nRETURN DISTINCT b",
        graph=graph_fixture_from_create(
            """
            CREATE (a {name: 'A', num: 0, id: 0}),
                   ({name: 'B', num: a.id, id: 1}),
                   ({name: 'C', num: 0, id: 2})
            """
        ),
        expected=Expected(
            rows=[
                {"b": "({name: 'A', num: 0, id: 0})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, SKIP, and DISTINCT are not supported",
        tags=("with", "skip", "orderby", "distinct", "xfail"),
    ),
    Scenario(
        key="with-skip-limit1-2",
        feature_path="tck/features/clauses/with-skip-limit/WithSkipLimit1.feature",
        scenario="[2] Ordering and skipping on aggregate",
        cypher="MATCH ()-[r1]->(x)\nWITH x, sum(r1.num) AS c\n  ORDER BY c SKIP 1\nRETURN x, c",
        graph=graph_fixture_from_create(
            """
            CREATE ()-[:T1 {num: 3}]->(x:X),
                   ()-[:T2 {num: 2}]->(x),
                   ()-[:T3 {num: 1}]->(:Y)
            """
        ),
        expected=Expected(
            rows=[
                {"x": "(:X)", "c": 5},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, aggregations, ORDER BY, and SKIP are not supported",
        tags=("with", "skip", "orderby", "aggregation", "xfail"),
    ),
    Scenario(
        key="with-skip-limit2-1",
        feature_path="tck/features/clauses/with-skip-limit/WithSkipLimit2.feature",
        scenario="[1] ORDER BY and LIMIT can be used",
        cypher="MATCH (a:A)\nWITH a\nORDER BY a.name\nLIMIT 1\nMATCH (a)-->(b)\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (a:A), (), (), (),
                   (a)-[:REL]->()
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:A)"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, and LIMIT are not supported",
        tags=("with", "limit", "orderby", "xfail"),
    ),
    Scenario(
        key="with-skip-limit2-2",
        feature_path="tck/features/clauses/with-skip-limit/WithSkipLimit2.feature",
        scenario="[2] Handle dependencies across WITH with LIMIT",
        cypher="MATCH (a:Begin)\nWITH a.num AS property\n  LIMIT 1\nMATCH (b)\nWHERE b.id = property\nRETURN b",
        graph=graph_fixture_from_create(
            """
            CREATE (a:End {num: 42, id: 0}),
                   (:End {num: 3}),
                   (:Begin {num: a.id})
            """
        ),
        expected=Expected(
            rows=[
                {"b": "(:End {num: 42, id: 0})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, LIMIT, and joins are not supported",
        tags=("with", "limit", "join", "xfail"),
    ),
    Scenario(
        key="with-skip-limit2-3",
        feature_path="tck/features/clauses/with-skip-limit/WithSkipLimit2.feature",
        scenario="[3] Connected components succeeding WITH with LIMIT",
        cypher="MATCH (n:A)\nWITH n\nLIMIT 1\nMATCH (m:B), (n)-->(x:X)\nRETURN *",
        graph=graph_fixture_from_create(
            """
            CREATE (:A)-[:REL]->(:X)
            CREATE (:B)
            """
        ),
        expected=Expected(
            rows=[
                {"m": "(:B)", "n": "(:A)", "x": "(:X)"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, LIMIT, and RETURN * projections are not supported",
        tags=("with", "limit", "return-star", "xfail"),
    ),
    Scenario(
        key="with-skip-limit2-4",
        feature_path="tck/features/clauses/with-skip-limit/WithSkipLimit2.feature",
        scenario="[4] Ordering and limiting on aggregate",
        cypher="MATCH ()-[r1]->(x)\nWITH x, sum(r1.num) AS c\n  ORDER BY c LIMIT 1\nRETURN x, c",
        graph=graph_fixture_from_create(
            """
            CREATE ()-[:T1 {num: 3}]->(x:X),
                   ()-[:T2 {num: 2}]->(x),
                   ()-[:T3 {num: 1}]->(:Y)
            """
        ),
        expected=Expected(
            rows=[
                {"x": "(:Y)", "c": 1},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, aggregations, ORDER BY, and LIMIT are not supported",
        tags=("with", "limit", "orderby", "aggregation", "xfail"),
    ),
    Scenario(
        key="with-skip-limit3-1",
        feature_path="tck/features/clauses/with-skip-limit/WithSkipLimit3.feature",
        scenario="[1] Get rows in the middle",
        cypher="MATCH (n)\nWITH n\nORDER BY n.name ASC\nSKIP 2\nLIMIT 2\nRETURN n",
        graph=graph_fixture_from_create(
            """
            CREATE ({name: 'A'}),
              ({name: 'B'}),
              ({name: 'C'}),
              ({name: 'D'}),
              ({name: 'E'})
            """
        ),
        expected=Expected(
            rows=[
                {"n": "({name: 'C'})"},
                {"n": "({name: 'D'})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, SKIP/LIMIT, and ORDER BY are not supported",
        tags=("with", "skip", "limit", "orderby", "xfail"),
    ),
    Scenario(
        key="with-skip-limit3-2",
        feature_path="tck/features/clauses/with-skip-limit/WithSkipLimit3.feature",
        scenario="[2] Get rows in the middle by param",
        cypher="MATCH (n)\nWITH n\nORDER BY n.name ASC\nSKIP $s\nLIMIT $l\nRETURN n",
        graph=graph_fixture_from_create(
            """
            CREATE ({name: 'A'}),
              ({name: 'B'}),
              ({name: 'C'}),
              ({name: 'D'}),
              ({name: 'E'})
            """
        ),
        expected=Expected(
            rows=[
                {"n": "({name: 'C'})"},
                {"n": "({name: 'D'})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, SKIP/LIMIT, ORDER BY, and parameter binding are not supported",
        tags=("with", "skip", "limit", "orderby", "params", "xfail"),
    ),
    Scenario(
        key="with-skip-limit3-3",
        feature_path="tck/features/clauses/with-skip-limit/WithSkipLimit3.feature",
        scenario="[3] Limiting amount of rows when there are fewer left than the LIMIT argument",
        cypher="MATCH (a)\nWITH a.count AS count\n  ORDER BY a.count\n  SKIP 10\n  LIMIT 10\nRETURN count",
        graph=GraphFixture(
            nodes=[{"id": f"n{i}", "labels": [], "count": i} for i in range(16)],
            edges=[],
        ),
        expected=Expected(
            rows=[
                {"count": 10},
                {"count": 11},
                {"count": 12},
                {"count": 13},
                {"count": 14},
                {"count": 15},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, SKIP/LIMIT, and ORDER BY are not supported",
        tags=("with", "skip", "limit", "orderby", "xfail"),
    ),
    Scenario(
        key="with-orderby1-1",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy1.feature",
        scenario="[1] Sort booleans in ascending order",
        cypher="UNWIND [true, false] AS bools\nWITH bools\n  ORDER BY bools\n  LIMIT 1\nRETURN bools",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"bools": "false"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, UNWIND, ORDER BY, and LIMIT are not supported",
        tags=("with", "orderby", "unwind", "limit", "xfail"),
    ),
    Scenario(
        key="with-orderby1-2",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy1.feature",
        scenario="[2] Sort booleans in descending order",
        cypher="UNWIND [true, false] AS bools\nWITH bools\n  ORDER BY bools DESC\n  LIMIT 1\nRETURN bools",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"bools": "true"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, UNWIND, ORDER BY, and LIMIT are not supported",
        tags=("with", "orderby", "unwind", "limit", "xfail"),
    ),
    Scenario(
        key="with-orderby1-3",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy1.feature",
        scenario="[3] Sort integers in ascending order",
        cypher="UNWIND [1, 3, 2] AS ints\nWITH ints\n  ORDER BY ints\n  LIMIT 2\nRETURN ints",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"ints": 1},
                {"ints": 2},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, UNWIND, ORDER BY, and LIMIT are not supported",
        tags=("with", "orderby", "unwind", "limit", "xfail"),
    ),
    Scenario(
        key="with-orderby1-4",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy1.feature",
        scenario="[4] Sort integers in descending order",
        cypher="UNWIND [1, 3, 2] AS ints\nWITH ints\n  ORDER BY ints DESC\n  LIMIT 2\nRETURN ints",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"ints": 3},
                {"ints": 2},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, UNWIND, ORDER BY, and LIMIT are not supported",
        tags=("with", "orderby", "unwind", "limit", "xfail"),
    ),
    Scenario(
        key="with-orderby1-5",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy1.feature",
        scenario="[5] Sort floats in ascending order",
        cypher="UNWIND [1.5, 1.3, 999.99] AS floats\nWITH floats\n  ORDER BY floats\n  LIMIT 2\nRETURN floats",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"floats": 1.3},
                {"floats": 1.5},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, UNWIND, ORDER BY, and LIMIT are not supported",
        tags=("with", "orderby", "unwind", "limit", "xfail"),
    ),
    Scenario(
        key="with-orderby1-6",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy1.feature",
        scenario="[6] Sort floats in descending order",
        cypher="UNWIND [1.5, 1.3, 999.99] AS floats\nWITH floats\n  ORDER BY floats DESC\n  LIMIT 2\nRETURN floats",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"floats": 999.99},
                {"floats": 1.5},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, UNWIND, ORDER BY, and LIMIT are not supported",
        tags=("with", "orderby", "unwind", "limit", "xfail"),
    ),
    Scenario(
        key="with-orderby1-7",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy1.feature",
        scenario="[7] Sort strings in ascending order",
        cypher="UNWIND ['.*', '', ' ', 'one'] AS strings\nWITH strings\n  ORDER BY strings\n  LIMIT 2\nRETURN strings",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"strings": "''"},
                {"strings": "' '"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, UNWIND, ORDER BY, and LIMIT are not supported",
        tags=("with", "orderby", "unwind", "limit", "xfail"),
    ),
    Scenario(
        key="with-orderby1-8",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy1.feature",
        scenario="[8] Sort strings in descending order",
        cypher="UNWIND ['.*', '', ' ', 'one'] AS strings\nWITH strings\n  ORDER BY strings DESC\n  LIMIT 2\nRETURN strings",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"strings": "'one'"},
                {"strings": "'.*'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, UNWIND, ORDER BY, and LIMIT are not supported",
        tags=("with", "orderby", "unwind", "limit", "xfail"),
    ),
    Scenario(
        key="with-orderby1-9",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy1.feature",
        scenario="[9] Sort lists in ascending order",
        cypher="UNWIND [[], ['a'], ['a', 1], [1], [1, 'a'], [1, null], [null, 1], [null, 2]] AS lists\nWITH lists\n  ORDER BY lists\n  LIMIT 4\nRETURN lists",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"lists": "[]"},
                {"lists": "['a']"},
                {"lists": "['a', 1]"},
                {"lists": "[1]"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, UNWIND, ORDER BY, and LIMIT are not supported",
        tags=("with", "orderby", "unwind", "limit", "xfail"),
    ),
    Scenario(
        key="with-orderby1-10",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy1.feature",
        scenario="[10] Sort lists in descending order",
        cypher="UNWIND [[], ['a'], ['a', 1], [1], [1, 'a'], [1, null], [null, 1], [null, 2]] AS lists\nWITH lists\n  ORDER BY lists DESC\n  LIMIT 4\nRETURN lists",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"lists": "[null, 2]"},
                {"lists": "[null, 1]"},
                {"lists": "[1, null]"},
                {"lists": "[1, 'a']"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, UNWIND, ORDER BY, and LIMIT are not supported",
        tags=("with", "orderby", "unwind", "limit", "xfail"),
    ),
    Scenario(
        key="with-orderby1-11",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy1.feature",
        scenario="[11] Sort dates in ascending order",
        cypher="UNWIND [date({year: 1910, month: 5, day: 6}),\n        date({year: 1980, month: 12, day: 24}),\n        date({year: 1984, month: 10, day: 12}),\n        date({year: 1985, month: 5, day: 6}),\n        date({year: 1980, month: 10, day: 24}),\n        date({year: 1984, month: 10, day: 11})] AS dates\nWITH dates\n  ORDER BY dates\n  LIMIT 2\nRETURN dates",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"dates": "'1910-05-06'"},
                {"dates": "'1980-10-24'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, UNWIND, ORDER BY, LIMIT, and temporal values are not supported",
        tags=("with", "orderby", "unwind", "limit", "temporal", "xfail"),
    ),
    Scenario(
        key="with-orderby1-12",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy1.feature",
        scenario="[12] Sort dates in descending order",
        cypher="UNWIND [date({year: 1910, month: 5, day: 6}),\n        date({year: 1980, month: 12, day: 24}),\n        date({year: 1984, month: 10, day: 12}),\n        date({year: 1985, month: 5, day: 6}),\n        date({year: 1980, month: 10, day: 24}),\n        date({year: 1984, month: 10, day: 11})] AS dates\nWITH dates\n  ORDER BY dates DESC\n  LIMIT 2\nRETURN dates",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"dates": "'1985-05-06'"},
                {"dates": "'1984-10-12'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, UNWIND, ORDER BY, LIMIT, and temporal values are not supported",
        tags=("with", "orderby", "unwind", "limit", "temporal", "xfail"),
    ),
    Scenario(
        key="with-orderby1-13",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy1.feature",
        scenario="[13] Sort local times in ascending order",
        cypher="UNWIND [localtime({hour: 10, minute: 35}),\n        localtime({hour: 12, minute: 31, second: 14, nanosecond: 645876123}),\n        localtime({hour: 12, minute: 31, second: 14, nanosecond: 645876124}),\n        localtime({hour: 12, minute: 35, second: 13}),\n        localtime({hour: 12, minute: 30, second: 14, nanosecond: 645876123})] AS localtimes\nWITH localtimes\n  ORDER BY localtimes\n  LIMIT 3\nRETURN localtimes",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"localtimes": "'10:35'"},
                {"localtimes": "'12:30:14.645876123'"},
                {"localtimes": "'12:31:14.645876123'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, UNWIND, ORDER BY, LIMIT, and temporal values are not supported",
        tags=("with", "orderby", "unwind", "limit", "temporal", "xfail"),
    ),
    Scenario(
        key="with-orderby1-14",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy1.feature",
        scenario="[14] Sort local times in descending order",
        cypher="UNWIND [localtime({hour: 10, minute: 35}),\n        localtime({hour: 12, minute: 31, second: 14, nanosecond: 645876123}),\n        localtime({hour: 12, minute: 31, second: 14, nanosecond: 645876124}),\n        localtime({hour: 12, minute: 35, second: 13}),\n        localtime({hour: 12, minute: 30, second: 14, nanosecond: 645876123})] AS localtimes\nWITH localtimes\n  ORDER BY localtimes DESC\n  LIMIT 3\nRETURN localtimes",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"localtimes": "'12:35:13'"},
                {"localtimes": "'12:31:14.645876124'"},
                {"localtimes": "'12:31:14.645876123'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, UNWIND, ORDER BY, LIMIT, and temporal values are not supported",
        tags=("with", "orderby", "unwind", "limit", "temporal", "xfail"),
    ),
    Scenario(
        key="with-orderby1-15",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy1.feature",
        scenario="[15] Sort times in ascending order",
        cypher="UNWIND [time({hour: 10, minute: 35, timezone: '-08:00'}),\n        time({hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}),\n        time({hour: 12, minute: 31, second: 14, nanosecond: 645876124, timezone: '+01:00'}),\n        time({hour: 12, minute: 35, second: 15, timezone: '+05:00'}),\n        time({hour: 12, minute: 30, second: 14, nanosecond: 645876123, timezone: '+01:01'})] AS times\nWITH times\n  ORDER BY times\n  LIMIT 3\nRETURN times",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"times": "'12:35:15+05:00'"},
                {"times": "'12:30:14.645876123+01:01'"},
                {"times": "'12:31:14.645876123+01:00'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, UNWIND, ORDER BY, LIMIT, and temporal values are not supported",
        tags=("with", "orderby", "unwind", "limit", "temporal", "xfail"),
    ),
    Scenario(
        key="with-orderby1-16",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy1.feature",
        scenario="[16] Sort times in descending order",
        cypher="UNWIND [time({hour: 10, minute: 35, timezone: '-08:00'}),\n        time({hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}),\n        time({hour: 12, minute: 31, second: 14, nanosecond: 645876124, timezone: '+01:00'}),\n        time({hour: 12, minute: 35, second: 15, timezone: '+05:00'}),\n        time({hour: 12, minute: 30, second: 14, nanosecond: 645876123, timezone: '+01:01'})] AS times\nWITH times\n  ORDER BY times DESC\n  LIMIT 3\nRETURN times",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"times": "'10:35-08:00'"},
                {"times": "'12:31:14.645876124+01:00'"},
                {"times": "'12:31:14.645876123+01:00'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, UNWIND, ORDER BY, LIMIT, and temporal values are not supported",
        tags=("with", "orderby", "unwind", "limit", "temporal", "xfail"),
    ),
    Scenario(
        key="with-orderby1-17",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy1.feature",
        scenario="[17] Sort local date times in ascending order",
        cypher="UNWIND [localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 30, second: 14, nanosecond: 12}),\n        localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}),\n        localdatetime({year: 1, month: 1, day: 1, hour: 1, minute: 1, second: 1, nanosecond: 1}),\n        localdatetime({year: 9999, month: 9, day: 9, hour: 9, minute: 59, second: 59, nanosecond: 999999999}),\n        localdatetime({year: 1980, month: 12, day: 11, hour: 12, minute: 31, second: 14})] AS localdatetimes\nWITH localdatetimes\n  ORDER BY localdatetimes\n  LIMIT 3\nRETURN localdatetimes",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"localdatetimes": "'0001-01-01T01:01:01.000000001'"},
                {"localdatetimes": "'1980-12-11T12:31:14'"},
                {"localdatetimes": "'1984-10-11T12:30:14.000000012'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, UNWIND, ORDER BY, LIMIT, and temporal values are not supported",
        tags=("with", "orderby", "unwind", "limit", "temporal", "xfail"),
    ),
    Scenario(
        key="with-orderby1-18",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy1.feature",
        scenario="[18] Sort local date times in descending order",
        cypher="UNWIND [localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 30, second: 14, nanosecond: 12}),\n        localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}),\n        localdatetime({year: 1, month: 1, day: 1, hour: 1, minute: 1, second: 1, nanosecond: 1}),\n        localdatetime({year: 9999, month: 9, day: 9, hour: 9, minute: 59, second: 59, nanosecond: 999999999}),\n        localdatetime({year: 1980, month: 12, day: 11, hour: 12, minute: 31, second: 14})] AS localdatetimes\nWITH localdatetimes\n  ORDER BY localdatetimes DESC\n  LIMIT 3\nRETURN localdatetimes",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"localdatetimes": "'9999-09-09T09:59:59.999999999'"},
                {"localdatetimes": "'1984-10-11T12:31:14.645876123'"},
                {"localdatetimes": "'1984-10-11T12:30:14.000000012'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, UNWIND, ORDER BY, LIMIT, and temporal values are not supported",
        tags=("with", "orderby", "unwind", "limit", "temporal", "xfail"),
    ),
    Scenario(
        key="with-orderby1-19",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy1.feature",
        scenario="[19] Sort date times in ascending order",
        cypher="UNWIND [datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 30, second: 14, nanosecond: 12, timezone: '+00:15'}),\n        datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+00:17'}),\n        datetime({year: 1, month: 1, day: 1, hour: 1, minute: 1, second: 1, nanosecond: 1, timezone: '-11:59'}),\n        datetime({year: 9999, month: 9, day: 9, hour: 9, minute: 59, second: 59, nanosecond: 999999999, timezone: '+11:59'}),\n        datetime({year: 1980, month: 12, day: 11, hour: 12, minute: 31, second: 14, timezone: '-11:59'})] AS datetimes\nWITH datetimes\n  ORDER BY datetimes\n  LIMIT 3\nRETURN datetimes",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"datetimes": "'0001-01-01T01:01:01.000000001-11:59'"},
                {"datetimes": "'1980-12-11T12:31:14-11:59'"},
                {"datetimes": "'1984-10-11T12:31:14.645876123+00:17'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, UNWIND, ORDER BY, LIMIT, and temporal values are not supported",
        tags=("with", "orderby", "unwind", "limit", "temporal", "xfail"),
    ),
    Scenario(
        key="with-orderby1-20",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy1.feature",
        scenario="[20] Sort date times in descending order",
        cypher="UNWIND [datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 30, second: 14, nanosecond: 12, timezone: '+00:15'}),\n        datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+00:17'}),\n        datetime({year: 1, month: 1, day: 1, hour: 1, minute: 1, second: 1, nanosecond: 1, timezone: '-11:59'}),\n        datetime({year: 9999, month: 9, day: 9, hour: 9, minute: 59, second: 59, nanosecond: 999999999, timezone: '+11:59'}),\n        datetime({year: 1980, month: 12, day: 11, hour: 12, minute: 31, second: 14, timezone: '-11:59'})] AS datetimes\nWITH datetimes\n  ORDER BY datetimes DESC\n  LIMIT 3\nRETURN datetimes",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"datetimes": "'9999-09-09T09:59:59.999999999+11:59'"},
                {"datetimes": "'1984-10-11T12:30:14.000000012+00:15'"},
                {"datetimes": "'1984-10-11T12:31:14.645876123+00:17'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, UNWIND, ORDER BY, LIMIT, and temporal values are not supported",
        tags=("with", "orderby", "unwind", "limit", "temporal", "xfail"),
    ),
    Scenario(
        key="with-orderby1-21",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy1.feature",
        scenario="[21] Sort distinct types in ascending order",
        cypher="MATCH p = (n:N)-[r:REL]->()\nUNWIND [n, r, p, 1.5, ['list'], 'text', null, false, 0.0 / 0.0, {a: 'map'}] AS types\nWITH types\n  ORDER BY types\n  LIMIT 5\nRETURN types",
        graph=graph_fixture_from_create(
            """
            CREATE (:N)-[:REL]->()
            """
        ),
        expected=Expected(
            rows=[
                {"types": "{a: 'map'}"},
                {"types": "(:N)"},
                {"types": "[:REL]"},
                {"types": "['list']"},
                {"types": "<(:N)-[:REL]->()>"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, UNWIND, ORDER BY, and heterogeneous type ordering are not supported",
        tags=("with", "orderby", "unwind", "limit", "xfail"),
    ),
    Scenario(
        key="with-orderby1-22",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy1.feature",
        scenario="[22] Sort distinct types in descending order",
        cypher="MATCH p = (n:N)-[r:REL]->()\nUNWIND [n, r, p, 1.5, ['list'], 'text', null, false, 0.0 / 0.0, {a: 'map'}] AS types\nWITH types\n  ORDER BY types DESC\n  LIMIT 5\nRETURN types",
        graph=graph_fixture_from_create(
            """
            CREATE (:N)-[:REL]->()
            """
        ),
        expected=Expected(
            rows=[
                {"types": "null"},
                {"types": "NaN"},
                {"types": 1.5},
                {"types": "false"},
                {"types": "'text'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, UNWIND, ORDER BY, and heterogeneous type ordering are not supported",
        tags=("with", "orderby", "unwind", "limit", "xfail"),
    ),
    Scenario(
        key="with-orderby1-23-1",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy1.feature",
        scenario="[23] Sort by a boolean variable projected from a node property in ascending order (sort=bool)",
        cypher="MATCH (a)\nWITH a, a.bool AS bool\nWITH a, bool\n  ORDER BY bool\n  LIMIT 3\nRETURN a, bool",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {bool: true}),
                   (:B {bool: false}),
                   (:C {bool: false}),
                   (:D {bool: true}),
                   (:E {bool: false})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:B {bool: false})", "bool": "false"},
                {"a": "(:C {bool: false})", "bool": "false"},
                {"a": "(:E {bool: false})", "bool": "false"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression aliasing are not supported",
        tags=("with", "orderby", "limit", "alias", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby1-23-2",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy1.feature",
        scenario="[23] Sort by a boolean variable projected from a node property in ascending order (sort=bool ASC)",
        cypher="MATCH (a)\nWITH a, a.bool AS bool\nWITH a, bool\n  ORDER BY bool ASC\n  LIMIT 3\nRETURN a, bool",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {bool: true}),
                   (:B {bool: false}),
                   (:C {bool: false}),
                   (:D {bool: true}),
                   (:E {bool: false})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:B {bool: false})", "bool": "false"},
                {"a": "(:C {bool: false})", "bool": "false"},
                {"a": "(:E {bool: false})", "bool": "false"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression aliasing are not supported",
        tags=("with", "orderby", "limit", "alias", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby1-23-3",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy1.feature",
        scenario="[23] Sort by a boolean variable projected from a node property in ascending order (sort=bool ASCENDING)",
        cypher="MATCH (a)\nWITH a, a.bool AS bool\nWITH a, bool\n  ORDER BY bool ASCENDING\n  LIMIT 3\nRETURN a, bool",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {bool: true}),
                   (:B {bool: false}),
                   (:C {bool: false}),
                   (:D {bool: true}),
                   (:E {bool: false})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:B {bool: false})", "bool": "false"},
                {"a": "(:C {bool: false})", "bool": "false"},
                {"a": "(:E {bool: false})", "bool": "false"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression aliasing are not supported",
        tags=("with", "orderby", "limit", "alias", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby1-24-1",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy1.feature",
        scenario="[24] Sort by a boolean variable projected from a node property in descending order (sort=bool DESC)",
        cypher="MATCH (a)\nWITH a, a.bool AS bool\nWITH a, bool\n  ORDER BY bool DESC\n  LIMIT 2\nRETURN a, bool",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {bool: true}),
                   (:B {bool: false}),
                   (:C {bool: false}),
                   (:D {bool: true}),
                   (:E {bool: false})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:A {bool: true})", "bool": "true"},
                {"a": "(:D {bool: true})", "bool": "true"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression aliasing are not supported",
        tags=("with", "orderby", "limit", "alias", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby1-24-2",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy1.feature",
        scenario="[24] Sort by a boolean variable projected from a node property in descending order (sort=bool DESCENDING)",
        cypher="MATCH (a)\nWITH a, a.bool AS bool\nWITH a, bool\n  ORDER BY bool DESCENDING\n  LIMIT 2\nRETURN a, bool",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {bool: true}),
                   (:B {bool: false}),
                   (:C {bool: false}),
                   (:D {bool: true}),
                   (:E {bool: false})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:A {bool: true})", "bool": "true"},
                {"a": "(:D {bool: true})", "bool": "true"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression aliasing are not supported",
        tags=("with", "orderby", "limit", "alias", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby1-25-1",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy1.feature",
        scenario="[25] Sort by an integer variable projected from a node property in ascending order (sort=num)",
        cypher="MATCH (a)\nWITH a, a.num AS num\nWITH a, num\n  ORDER BY num\n  LIMIT 3\nRETURN a, num",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {num: 9}),
                   (:B {num: 5}),
                   (:C {num: 30}),
                   (:D {num: -11}),
                   (:E {num: 7054})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:D {num: -11})", "num": -11},
                {"a": "(:B {num: 5})", "num": 5},
                {"a": "(:A {num: 9})", "num": 9},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression aliasing are not supported",
        tags=("with", "orderby", "limit", "alias", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby1-25-2",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy1.feature",
        scenario="[25] Sort by an integer variable projected from a node property in ascending order (sort=num ASC)",
        cypher="MATCH (a)\nWITH a, a.num AS num\nWITH a, num\n  ORDER BY num ASC\n  LIMIT 3\nRETURN a, num",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {num: 9}),
                   (:B {num: 5}),
                   (:C {num: 30}),
                   (:D {num: -11}),
                   (:E {num: 7054})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:D {num: -11})", "num": -11},
                {"a": "(:B {num: 5})", "num": 5},
                {"a": "(:A {num: 9})", "num": 9},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression aliasing are not supported",
        tags=("with", "orderby", "limit", "alias", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby1-25-3",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy1.feature",
        scenario="[25] Sort by an integer variable projected from a node property in ascending order (sort=num ASCENDING)",
        cypher="MATCH (a)\nWITH a, a.num AS num\nWITH a, num\n  ORDER BY num ASCENDING\n  LIMIT 3\nRETURN a, num",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {num: 9}),
                   (:B {num: 5}),
                   (:C {num: 30}),
                   (:D {num: -11}),
                   (:E {num: 7054})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:D {num: -11})", "num": -11},
                {"a": "(:B {num: 5})", "num": 5},
                {"a": "(:A {num: 9})", "num": 9},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression aliasing are not supported",
        tags=("with", "orderby", "limit", "alias", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby1-26-1",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy1.feature",
        scenario="[26] Sort by an integer variable projected from a node property in descending order (sort=num DESC)",
        cypher="MATCH (a)\nWITH a, a.num AS num\nWITH a, num\n  ORDER BY num DESC\n  LIMIT 3\nRETURN a, num",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {num: 9}),
                   (:B {num: 5}),
                   (:C {num: 30}),
                   (:D {num: -11}),
                   (:E {num: 7054})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:E {num: 7054})", "num": 7054},
                {"a": "(:C {num: 30})", "num": 30},
                {"a": "(:A {num: 9})", "num": 9},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression aliasing are not supported",
        tags=("with", "orderby", "limit", "alias", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby1-26-2",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy1.feature",
        scenario="[26] Sort by an integer variable projected from a node property in descending order (sort=num DESCENDING)",
        cypher="MATCH (a)\nWITH a, a.num AS num\nWITH a, num\n  ORDER BY num DESCENDING\n  LIMIT 3\nRETURN a, num",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {num: 9}),
                   (:B {num: 5}),
                   (:C {num: 30}),
                   (:D {num: -11}),
                   (:E {num: 7054})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:E {num: 7054})", "num": 7054},
                {"a": "(:C {num: 30})", "num": 30},
                {"a": "(:A {num: 9})", "num": 9},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression aliasing are not supported",
        tags=("with", "orderby", "limit", "alias", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby1-27-1",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy1.feature",
        scenario="[27] Sort by a float variable projected from a node property in ascending order (sort=num)",
        cypher="MATCH (a)\nWITH a, a.num AS num\nWITH a, num\n  ORDER BY num\n  LIMIT 3\nRETURN a, num",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {num: 5.025648}),
                   (:B {num: 30.94857}),
                   (:C {num: 30.94856}),
                   (:D {num: -11.2943}),
                   (:E {num: 7054.008})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:D {num: -11.2943})", "num": -11.2943},
                {"a": "(:A {num: 5.025648})", "num": 5.025648},
                {"a": "(:C {num: 30.94856})", "num": 30.94856},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression aliasing are not supported",
        tags=("with", "orderby", "limit", "alias", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby1-27-2",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy1.feature",
        scenario="[27] Sort by a float variable projected from a node property in ascending order (sort=num ASC)",
        cypher="MATCH (a)\nWITH a, a.num AS num\nWITH a, num\n  ORDER BY num ASC\n  LIMIT 3\nRETURN a, num",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {num: 5.025648}),
                   (:B {num: 30.94857}),
                   (:C {num: 30.94856}),
                   (:D {num: -11.2943}),
                   (:E {num: 7054.008})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:D {num: -11.2943})", "num": -11.2943},
                {"a": "(:A {num: 5.025648})", "num": 5.025648},
                {"a": "(:C {num: 30.94856})", "num": 30.94856},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression aliasing are not supported",
        tags=("with", "orderby", "limit", "alias", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby1-27-3",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy1.feature",
        scenario="[27] Sort by a float variable projected from a node property in ascending order (sort=num ASCENDING)",
        cypher="MATCH (a)\nWITH a, a.num AS num\nWITH a, num\n  ORDER BY num ASCENDING\n  LIMIT 3\nRETURN a, num",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {num: 5.025648}),
                   (:B {num: 30.94857}),
                   (:C {num: 30.94856}),
                   (:D {num: -11.2943}),
                   (:E {num: 7054.008})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:D {num: -11.2943})", "num": -11.2943},
                {"a": "(:A {num: 5.025648})", "num": 5.025648},
                {"a": "(:C {num: 30.94856})", "num": 30.94856},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression aliasing are not supported",
        tags=("with", "orderby", "limit", "alias", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby1-28-1",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy1.feature",
        scenario="[28] Sort by a float variable projected from a node property in descending order (sort=num DESC)",
        cypher="MATCH (a)\nWITH a, a.num AS num\nWITH a, num\n  ORDER BY num DESC\n  LIMIT 3\nRETURN a, num",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {num: 5.025648}),
                   (:B {num: 30.94857}),
                   (:C {num: 30.94856}),
                   (:D {num: -11.2943}),
                   (:E {num: 7054.008})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:E {num: 7054.008})", "num": 7054.008},
                {"a": "(:B {num: 30.94857})", "num": 30.94857},
                {"a": "(:C {num: 30.94856})", "num": 30.94856},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression aliasing are not supported",
        tags=("with", "orderby", "limit", "alias", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby1-28-2",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy1.feature",
        scenario="[28] Sort by a float variable projected from a node property in descending order (sort=num DESCENDING)",
        cypher="MATCH (a)\nWITH a, a.num AS num\nWITH a, num\n  ORDER BY num DESCENDING\n  LIMIT 3\nRETURN a, num",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {num: 5.025648}),
                   (:B {num: 30.94857}),
                   (:C {num: 30.94856}),
                   (:D {num: -11.2943}),
                   (:E {num: 7054.008})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:E {num: 7054.008})", "num": 7054.008},
                {"a": "(:B {num: 30.94857})", "num": 30.94857},
                {"a": "(:C {num: 30.94856})", "num": 30.94856},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression aliasing are not supported",
        tags=("with", "orderby", "limit", "alias", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby1-29-1",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy1.feature",
        scenario="[29] Sort by a string variable projected from a node property in ascending order (sort=name)",
        cypher="MATCH (a)\nWITH a, a.name AS name\nWITH a, name\n  ORDER BY name\n  LIMIT 3\nRETURN a, name",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {name: 'lorem'}),
                   (:B {name: 'ipsum'}),
                   (:C {name: 'dolor'}),
                   (:D {name: 'sit'}),
                   (:E {name: 'amet'})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:E {name: 'amet'})", "name": "'amet'"},
                {"a": "(:C {name: 'dolor'})", "name": "'dolor'"},
                {"a": "(:B {name: 'ipsum'})", "name": "'ipsum'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression aliasing are not supported",
        tags=("with", "orderby", "limit", "alias", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby1-29-2",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy1.feature",
        scenario="[29] Sort by a string variable projected from a node property in ascending order (sort=name ASC)",
        cypher="MATCH (a)\nWITH a, a.name AS name\nWITH a, name\n  ORDER BY name ASC\n  LIMIT 3\nRETURN a, name",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {name: 'lorem'}),
                   (:B {name: 'ipsum'}),
                   (:C {name: 'dolor'}),
                   (:D {name: 'sit'}),
                   (:E {name: 'amet'})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:E {name: 'amet'})", "name": "'amet'"},
                {"a": "(:C {name: 'dolor'})", "name": "'dolor'"},
                {"a": "(:B {name: 'ipsum'})", "name": "'ipsum'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression aliasing are not supported",
        tags=("with", "orderby", "limit", "alias", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby1-29-3",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy1.feature",
        scenario="[29] Sort by a string variable projected from a node property in ascending order (sort=name ASCENDING)",
        cypher="MATCH (a)\nWITH a, a.name AS name\nWITH a, name\n  ORDER BY name ASCENDING\n  LIMIT 3\nRETURN a, name",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {name: 'lorem'}),
                   (:B {name: 'ipsum'}),
                   (:C {name: 'dolor'}),
                   (:D {name: 'sit'}),
                   (:E {name: 'amet'})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:E {name: 'amet'})", "name": "'amet'"},
                {"a": "(:C {name: 'dolor'})", "name": "'dolor'"},
                {"a": "(:B {name: 'ipsum'})", "name": "'ipsum'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression aliasing are not supported",
        tags=("with", "orderby", "limit", "alias", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby1-30-1",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy1.feature",
        scenario="[30] Sort by a string variable projected from a node property in descending order (sort=name DESC)",
        cypher="MATCH (a)\nWITH a, a.name AS name\nWITH a, name\n  ORDER BY name DESC\n  LIMIT 3\nRETURN a, name",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {name: 'lorem'}),
                   (:B {name: 'ipsum'}),
                   (:C {name: 'dolor'}),
                   (:D {name: 'sit'}),
                   (:E {name: 'amet'})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:D {name: 'sit'})", "name": "'sit'"},
                {"a": "(:A {name: 'lorem'})", "name": "'lorem'"},
                {"a": "(:B {name: 'ipsum'})", "name": "'ipsum'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression aliasing are not supported",
        tags=("with", "orderby", "limit", "alias", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby1-30-2",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy1.feature",
        scenario="[30] Sort by a string variable projected from a node property in descending order (sort=name DESCENDING)",
        cypher="MATCH (a)\nWITH a, a.name AS name\nWITH a, name\n  ORDER BY name DESCENDING\n  LIMIT 3\nRETURN a, name",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {name: 'lorem'}),
                   (:B {name: 'ipsum'}),
                   (:C {name: 'dolor'}),
                   (:D {name: 'sit'}),
                   (:E {name: 'amet'})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:D {name: 'sit'})", "name": "'sit'"},
                {"a": "(:A {name: 'lorem'})", "name": "'lorem'"},
                {"a": "(:B {name: 'ipsum'})", "name": "'ipsum'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression aliasing are not supported",
        tags=("with", "orderby", "limit", "alias", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby1-31-1",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy1.feature",
        scenario="[31] Sort by a list variable projected from a node property in ascending order (sort=list)",
        cypher="MATCH (a)\nWITH a, a.list AS list\nWITH a, list\n  ORDER BY list\n  LIMIT 3\nRETURN a, list",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {list: [2, -2]}),
                   (:B {list: [1, 2]}),
                   (:C {list: [300, 0]}),
                   (:D {list: [1, -20]}),
                   (:E {list: [2, -2, 100]})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:B {list: [1, 2]})", "list": "[1, 2]"},
                {"a": "(:D {list: [1, -20]})", "list": "[1, -20]"},
                {"a": "(:A {list: [2, -2]})", "list": "[2, -2]"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression aliasing are not supported",
        tags=("with", "orderby", "limit", "alias", "expression", "list", "xfail"),
    ),
    Scenario(
        key="with-orderby1-31-2",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy1.feature",
        scenario="[31] Sort by a list variable projected from a node property in ascending order (sort=list ASC)",
        cypher="MATCH (a)\nWITH a, a.list AS list\nWITH a, list\n  ORDER BY list ASC\n  LIMIT 3\nRETURN a, list",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {list: [2, -2]}),
                   (:B {list: [1, 2]}),
                   (:C {list: [300, 0]}),
                   (:D {list: [1, -20]}),
                   (:E {list: [2, -2, 100]})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:B {list: [1, 2]})", "list": "[1, 2]"},
                {"a": "(:D {list: [1, -20]})", "list": "[1, -20]"},
                {"a": "(:A {list: [2, -2]})", "list": "[2, -2]"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression aliasing are not supported",
        tags=("with", "orderby", "limit", "alias", "expression", "list", "xfail"),
    ),
    Scenario(
        key="with-orderby1-31-3",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy1.feature",
        scenario="[31] Sort by a list variable projected from a node property in ascending order (sort=list ASCENDING)",
        cypher="MATCH (a)\nWITH a, a.list AS list\nWITH a, list\n  ORDER BY list ASCENDING\n  LIMIT 3\nRETURN a, list",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {list: [2, -2]}),
                   (:B {list: [1, 2]}),
                   (:C {list: [300, 0]}),
                   (:D {list: [1, -20]}),
                   (:E {list: [2, -2, 100]})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:B {list: [1, 2]})", "list": "[1, 2]"},
                {"a": "(:D {list: [1, -20]})", "list": "[1, -20]"},
                {"a": "(:A {list: [2, -2]})", "list": "[2, -2]"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression aliasing are not supported",
        tags=("with", "orderby", "limit", "alias", "expression", "list", "xfail"),
    ),
    Scenario(
        key="with-orderby1-32-1",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy1.feature",
        scenario="[32] Sort by a list variable projected from a node property in descending order (sort=list DESC)",
        cypher="MATCH (a)\nWITH a, a.list AS list\nWITH a, list\n  ORDER BY list DESC\n  LIMIT 3\nRETURN a, list",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {list: [2, -2]}),
                   (:B {list: [1, 2]}),
                   (:C {list: [300, 0]}),
                   (:D {list: [1, -20]}),
                   (:E {list: [2, -2, 100]})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:C {list: [300, 0]})", "list": "[300, 0]"},
                {"a": "(:E {list: [2, -2, 100]})", "list": "[2, -2, 100]"},
                {"a": "(:A {list: [2, -2]})", "list": "[2, -2]"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression aliasing are not supported",
        tags=("with", "orderby", "limit", "alias", "expression", "list", "xfail"),
    ),
    Scenario(
        key="with-orderby1-32-2",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy1.feature",
        scenario="[32] Sort by a list variable projected from a node property in descending order (sort=list DESCENDING)",
        cypher="MATCH (a)\nWITH a, a.list AS list\nWITH a, list\n  ORDER BY list DESCENDING\n  LIMIT 3\nRETURN a, list",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {list: [2, -2]}),
                   (:B {list: [1, 2]}),
                   (:C {list: [300, 0]}),
                   (:D {list: [1, -20]}),
                   (:E {list: [2, -2, 100]})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:C {list: [300, 0]})", "list": "[300, 0]"},
                {"a": "(:E {list: [2, -2, 100]})", "list": "[2, -2, 100]"},
                {"a": "(:A {list: [2, -2]})", "list": "[2, -2]"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression aliasing are not supported",
        tags=("with", "orderby", "limit", "alias", "expression", "list", "xfail"),
    ),
    Scenario(
        key="with-orderby1-33-1",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy1.feature",
        scenario="[33] Sort by a date variable projected from a node property in ascending order (sort=date)",
        cypher="MATCH (a)\nWITH a, a.date AS date\nWITH a, date\n  ORDER BY date\n  LIMIT 2\nRETURN a, date",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {date: date({year: 1910, month: 5, day: 6})}),
                   (:B {date: date({year: 1980, month: 12, day: 24})}),
                   (:C {date: date({year: 1984, month: 10, day: 12})}),
                   (:D {date: date({year: 1985, month: 5, day: 6})}),
                   (:E {date: date({year: 1980, month: 10, day: 24})}),
                   (:F {date: date({year: 1984, month: 10, day: 11})})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:A {date: '1910-05-06'})", "date": "'1910-05-06'"},
                {"a": "(:E {date: '1980-10-24'})", "date": "'1980-10-24'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and temporal values are not supported",
        tags=("with", "orderby", "limit", "alias", "expression", "temporal", "xfail"),
    ),
    Scenario(
        key="with-orderby1-33-2",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy1.feature",
        scenario="[33] Sort by a date variable projected from a node property in ascending order (sort=date ASC)",
        cypher="MATCH (a)\nWITH a, a.date AS date\nWITH a, date\n  ORDER BY date ASC\n  LIMIT 2\nRETURN a, date",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {date: date({year: 1910, month: 5, day: 6})}),
                   (:B {date: date({year: 1980, month: 12, day: 24})}),
                   (:C {date: date({year: 1984, month: 10, day: 12})}),
                   (:D {date: date({year: 1985, month: 5, day: 6})}),
                   (:E {date: date({year: 1980, month: 10, day: 24})}),
                   (:F {date: date({year: 1984, month: 10, day: 11})})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:A {date: '1910-05-06'})", "date": "'1910-05-06'"},
                {"a": "(:E {date: '1980-10-24'})", "date": "'1980-10-24'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and temporal values are not supported",
        tags=("with", "orderby", "limit", "alias", "expression", "temporal", "xfail"),
    ),
    Scenario(
        key="with-orderby1-33-3",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy1.feature",
        scenario="[33] Sort by a date variable projected from a node property in ascending order (sort=date ASCENDING)",
        cypher="MATCH (a)\nWITH a, a.date AS date\nWITH a, date\n  ORDER BY date ASCENDING\n  LIMIT 2\nRETURN a, date",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {date: date({year: 1910, month: 5, day: 6})}),
                   (:B {date: date({year: 1980, month: 12, day: 24})}),
                   (:C {date: date({year: 1984, month: 10, day: 12})}),
                   (:D {date: date({year: 1985, month: 5, day: 6})}),
                   (:E {date: date({year: 1980, month: 10, day: 24})}),
                   (:F {date: date({year: 1984, month: 10, day: 11})})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:A {date: '1910-05-06'})", "date": "'1910-05-06'"},
                {"a": "(:E {date: '1980-10-24'})", "date": "'1980-10-24'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and temporal values are not supported",
        tags=("with", "orderby", "limit", "alias", "expression", "temporal", "xfail"),
    ),
    Scenario(
        key="with-orderby1-34-1",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy1.feature",
        scenario="[34] Sort by a date variable projected from a node property in descending order (sort=date DESC)",
        cypher="MATCH (a)\nWITH a, a.date AS date\nWITH a, date\n  ORDER BY date DESC\n  LIMIT 2\nRETURN a, date",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {date: date({year: 1910, month: 5, day: 6})}),
                   (:B {date: date({year: 1980, month: 12, day: 24})}),
                   (:C {date: date({year: 1984, month: 10, day: 12})}),
                   (:D {date: date({year: 1985, month: 5, day: 6})}),
                   (:E {date: date({year: 1980, month: 10, day: 24})}),
                   (:F {date: date({year: 1984, month: 10, day: 11})})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:D {date: '1985-05-06'})", "date": "'1985-05-06'"},
                {"a": "(:C {date: '1984-10-12'})", "date": "'1984-10-12'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and temporal values are not supported",
        tags=("with", "orderby", "limit", "alias", "expression", "temporal", "xfail"),
    ),
    Scenario(
        key="with-orderby1-34-2",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy1.feature",
        scenario="[34] Sort by a date variable projected from a node property in descending order (sort=date DESCENDING)",
        cypher="MATCH (a)\nWITH a, a.date AS date\nWITH a, date\n  ORDER BY date DESCENDING\n  LIMIT 2\nRETURN a, date",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {date: date({year: 1910, month: 5, day: 6})}),
                   (:B {date: date({year: 1980, month: 12, day: 24})}),
                   (:C {date: date({year: 1984, month: 10, day: 12})}),
                   (:D {date: date({year: 1985, month: 5, day: 6})}),
                   (:E {date: date({year: 1980, month: 10, day: 24})}),
                   (:F {date: date({year: 1984, month: 10, day: 11})})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:D {date: '1985-05-06'})", "date": "'1985-05-06'"},
                {"a": "(:C {date: '1984-10-12'})", "date": "'1984-10-12'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and temporal values are not supported",
        tags=("with", "orderby", "limit", "alias", "expression", "temporal", "xfail"),
    ),
    Scenario(
        key="with-orderby1-35-1",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy1.feature",
        scenario="[35] Sort by a local time variable projected from a node property in ascending order (sort=time)",
        cypher="MATCH (a)\nWITH a, a.time AS time\nWITH a, time\n  ORDER BY time\n  LIMIT 3\nRETURN a, time",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {time: localtime({hour: 10, minute: 35})}),
                   (:B {time: localtime({hour: 12, minute: 31, second: 14, nanosecond: 645876123})}),
                   (:C {time: localtime({hour: 12, minute: 31, second: 14, nanosecond: 645876124})}),
                   (:D {time: localtime({hour: 12, minute: 30, second: 14, nanosecond: 645876123})}),
                   (:E {time: localtime({hour: 12, minute: 31, second: 15})})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:A {time: '10:35'})", "time": "'10:35'"},
                {"a": "(:D {time: '12:30:14.645876123'})", "time": "'12:30:14.645876123'"},
                {"a": "(:B {time: '12:31:14.645876123'})", "time": "'12:31:14.645876123'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and temporal values are not supported",
        tags=("with", "orderby", "limit", "alias", "expression", "temporal", "xfail"),
    ),
    Scenario(
        key="with-orderby1-35-2",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy1.feature",
        scenario="[35] Sort by a local time variable projected from a node property in ascending order (sort=time ASC)",
        cypher="MATCH (a)\nWITH a, a.time AS time\nWITH a, time\n  ORDER BY time ASC\n  LIMIT 3\nRETURN a, time",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {time: localtime({hour: 10, minute: 35})}),
                   (:B {time: localtime({hour: 12, minute: 31, second: 14, nanosecond: 645876123})}),
                   (:C {time: localtime({hour: 12, minute: 31, second: 14, nanosecond: 645876124})}),
                   (:D {time: localtime({hour: 12, minute: 30, second: 14, nanosecond: 645876123})}),
                   (:E {time: localtime({hour: 12, minute: 31, second: 15})})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:A {time: '10:35'})", "time": "'10:35'"},
                {"a": "(:D {time: '12:30:14.645876123'})", "time": "'12:30:14.645876123'"},
                {"a": "(:B {time: '12:31:14.645876123'})", "time": "'12:31:14.645876123'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and temporal values are not supported",
        tags=("with", "orderby", "limit", "alias", "expression", "temporal", "xfail"),
    ),
    Scenario(
        key="with-orderby1-35-3",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy1.feature",
        scenario="[35] Sort by a local time variable projected from a node property in ascending order (sort=time ASCENDING)",
        cypher="MATCH (a)\nWITH a, a.time AS time\nWITH a, time\n  ORDER BY time ASCENDING\n  LIMIT 3\nRETURN a, time",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {time: localtime({hour: 10, minute: 35})}),
                   (:B {time: localtime({hour: 12, minute: 31, second: 14, nanosecond: 645876123})}),
                   (:C {time: localtime({hour: 12, minute: 31, second: 14, nanosecond: 645876124})}),
                   (:D {time: localtime({hour: 12, minute: 30, second: 14, nanosecond: 645876123})}),
                   (:E {time: localtime({hour: 12, minute: 31, second: 15})})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:A {time: '10:35'})", "time": "'10:35'"},
                {"a": "(:D {time: '12:30:14.645876123'})", "time": "'12:30:14.645876123'"},
                {"a": "(:B {time: '12:31:14.645876123'})", "time": "'12:31:14.645876123'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and temporal values are not supported",
        tags=("with", "orderby", "limit", "alias", "expression", "temporal", "xfail"),
    ),
    Scenario(
        key="with-orderby1-36-1",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy1.feature",
        scenario="[36] Sort by a local time variable projected from a node property in descending order (sort=time DESC)",
        cypher="MATCH (a)\nWITH a, a.time AS time\nWITH a, time\n  ORDER BY time DESC\n  LIMIT 3\nRETURN a, time",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {time: localtime({hour: 10, minute: 35})}),
                   (:B {time: localtime({hour: 12, minute: 31, second: 14, nanosecond: 645876123})}),
                   (:C {time: localtime({hour: 12, minute: 31, second: 14, nanosecond: 645876124})}),
                   (:D {time: localtime({hour: 12, minute: 30, second: 14, nanosecond: 645876123})}),
                   (:E {time: localtime({hour: 12, minute: 31, second: 15})})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:E {time: '12:31:15'})", "time": "'12:31:15'"},
                {"a": "(:C {time: '12:31:14.645876124'})", "time": "'12:31:14.645876124'"},
                {"a": "(:B {time: '12:31:14.645876123'})", "time": "'12:31:14.645876123'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and temporal values are not supported",
        tags=("with", "orderby", "limit", "alias", "expression", "temporal", "xfail"),
    ),
    Scenario(
        key="with-orderby1-36-2",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy1.feature",
        scenario="[36] Sort by a local time variable projected from a node property in descending order (sort=time DESCENDING)",
        cypher="MATCH (a)\nWITH a, a.time AS time\nWITH a, time\n  ORDER BY time DESCENDING\n  LIMIT 3\nRETURN a, time",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {time: localtime({hour: 10, minute: 35})}),
                   (:B {time: localtime({hour: 12, minute: 31, second: 14, nanosecond: 645876123})}),
                   (:C {time: localtime({hour: 12, minute: 31, second: 14, nanosecond: 645876124})}),
                   (:D {time: localtime({hour: 12, minute: 30, second: 14, nanosecond: 645876123})}),
                   (:E {time: localtime({hour: 12, minute: 31, second: 15})})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:E {time: '12:31:15'})", "time": "'12:31:15'"},
                {"a": "(:C {time: '12:31:14.645876124'})", "time": "'12:31:14.645876124'"},
                {"a": "(:B {time: '12:31:14.645876123'})", "time": "'12:31:14.645876123'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and temporal values are not supported",
        tags=("with", "orderby", "limit", "alias", "expression", "temporal", "xfail"),
    ),
    Scenario(
        key="with-orderby1-37-1",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy1.feature",
        scenario="[37] Sort by a time variable projected from a node property in ascending order (sort=time)",
        cypher="MATCH (a)\nWITH a, a.time AS time\nWITH a, time\n  ORDER BY time\n  LIMIT 3\nRETURN a, time",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {time: time({hour: 10, minute: 35, timezone: '-08:00'})}),
                   (:B {time: time({hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'})}),
                   (:C {time: time({hour: 12, minute: 31, second: 14, nanosecond: 645876124, timezone: '+01:00'})}),
                   (:D {time: time({hour: 12, minute: 35, second: 15, timezone: '+05:00'})}),
                   (:E {time: time({hour: 12, minute: 30, second: 14, nanosecond: 645876123, timezone: '+01:01'})})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:D {time: '12:35:15+05:00'})", "time": "'12:35:15+05:00'"},
                {"a": "(:E {time: '12:30:14.645876123+01:01'})", "time": "'12:30:14.645876123+01:01'"},
                {"a": "(:B {time: '12:31:14.645876123+01:00'})", "time": "'12:31:14.645876123+01:00'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and temporal values are not supported",
        tags=("with", "orderby", "limit", "alias", "expression", "temporal", "xfail"),
    ),
    Scenario(
        key="with-orderby1-37-2",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy1.feature",
        scenario="[37] Sort by a time variable projected from a node property in ascending order (sort=time ASC)",
        cypher="MATCH (a)\nWITH a, a.time AS time\nWITH a, time\n  ORDER BY time ASC\n  LIMIT 3\nRETURN a, time",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {time: time({hour: 10, minute: 35, timezone: '-08:00'})}),
                   (:B {time: time({hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'})}),
                   (:C {time: time({hour: 12, minute: 31, second: 14, nanosecond: 645876124, timezone: '+01:00'})}),
                   (:D {time: time({hour: 12, minute: 35, second: 15, timezone: '+05:00'})}),
                   (:E {time: time({hour: 12, minute: 30, second: 14, nanosecond: 645876123, timezone: '+01:01'})})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:D {time: '12:35:15+05:00'})", "time": "'12:35:15+05:00'"},
                {"a": "(:E {time: '12:30:14.645876123+01:01'})", "time": "'12:30:14.645876123+01:01'"},
                {"a": "(:B {time: '12:31:14.645876123+01:00'})", "time": "'12:31:14.645876123+01:00'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and temporal values are not supported",
        tags=("with", "orderby", "limit", "alias", "expression", "temporal", "xfail"),
    ),
    Scenario(
        key="with-orderby1-37-3",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy1.feature",
        scenario="[37] Sort by a time variable projected from a node property in ascending order (sort=time ASCENDING)",
        cypher="MATCH (a)\nWITH a, a.time AS time\nWITH a, time\n  ORDER BY time ASCENDING\n  LIMIT 3\nRETURN a, time",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {time: time({hour: 10, minute: 35, timezone: '-08:00'})}),
                   (:B {time: time({hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'})}),
                   (:C {time: time({hour: 12, minute: 31, second: 14, nanosecond: 645876124, timezone: '+01:00'})}),
                   (:D {time: time({hour: 12, minute: 35, second: 15, timezone: '+05:00'})}),
                   (:E {time: time({hour: 12, minute: 30, second: 14, nanosecond: 645876123, timezone: '+01:01'})})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:D {time: '12:35:15+05:00'})", "time": "'12:35:15+05:00'"},
                {"a": "(:E {time: '12:30:14.645876123+01:01'})", "time": "'12:30:14.645876123+01:01'"},
                {"a": "(:B {time: '12:31:14.645876123+01:00'})", "time": "'12:31:14.645876123+01:00'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and temporal values are not supported",
        tags=("with", "orderby", "limit", "alias", "expression", "temporal", "xfail"),
    ),
    Scenario(
        key="with-orderby1-38-1",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy1.feature",
        scenario="[38] Sort by a time variable projected from a node property in descending order (sort=time DESC)",
        cypher="MATCH (a)\nWITH a, a.time AS time\nWITH a, time\n  ORDER BY time DESC\n  LIMIT 3\nRETURN a, time",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {time: time({hour: 10, minute: 35, timezone: '-08:00'})}),
                   (:B {time: time({hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'})}),
                   (:C {time: time({hour: 12, minute: 31, second: 14, nanosecond: 645876124, timezone: '+01:00'})}),
                   (:D {time: time({hour: 12, minute: 35, second: 15, timezone: '+05:00'})}),
                   (:E {time: time({hour: 12, minute: 30, second: 14, nanosecond: 645876123, timezone: '+01:01'})})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:A {time: '10:35-08:00'})", "time": "'10:35-08:00'"},
                {"a": "(:C {time: '12:31:14.645876124+01:00'})", "time": "'12:31:14.645876124+01:00'"},
                {"a": "(:B {time: '12:31:14.645876123+01:00'})", "time": "'12:31:14.645876123+01:00'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and temporal values are not supported",
        tags=("with", "orderby", "limit", "alias", "expression", "temporal", "xfail"),
    ),
    Scenario(
        key="with-orderby1-38-2",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy1.feature",
        scenario="[38] Sort by a time variable projected from a node property in descending order (sort=time DESCENDING)",
        cypher="MATCH (a)\nWITH a, a.time AS time\nWITH a, time\n  ORDER BY time DESCENDING\n  LIMIT 3\nRETURN a, time",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {time: time({hour: 10, minute: 35, timezone: '-08:00'})}),
                   (:B {time: time({hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'})}),
                   (:C {time: time({hour: 12, minute: 31, second: 14, nanosecond: 645876124, timezone: '+01:00'})}),
                   (:D {time: time({hour: 12, minute: 35, second: 15, timezone: '+05:00'})}),
                   (:E {time: time({hour: 12, minute: 30, second: 14, nanosecond: 645876123, timezone: '+01:01'})})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:A {time: '10:35-08:00'})", "time": "'10:35-08:00'"},
                {"a": "(:C {time: '12:31:14.645876124+01:00'})", "time": "'12:31:14.645876124+01:00'"},
                {"a": "(:B {time: '12:31:14.645876123+01:00'})", "time": "'12:31:14.645876123+01:00'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and temporal values are not supported",
        tags=("with", "orderby", "limit", "alias", "expression", "temporal", "xfail"),
    ),
    Scenario(
        key="with-orderby1-39-1",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy1.feature",
        scenario="[39] Sort by a local date time variable projected from a node property in ascending order (sort=datetime)",
        cypher="MATCH (a)\nWITH a, a.datetime AS datetime\nWITH a, datetime\n  ORDER BY datetime\n  LIMIT 3\nRETURN a, datetime",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {datetime: localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 30, second: 14, nanosecond: 12})}),
                   (:B {datetime: localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123})}),
                   (:C {datetime: localdatetime({year: 1, month: 1, day: 1, hour: 1, minute: 1, second: 1, nanosecond: 1})}),
                   (:D {datetime: localdatetime({year: 9999, month: 9, day: 9, hour: 9, minute: 59, second: 59, nanosecond: 999999999})}),
                   (:E {datetime: localdatetime({year: 1980, month: 12, day: 11, hour: 12, minute: 31, second: 14})})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:C {datetime: '0001-01-01T01:01:01.000000001'})", "datetime": "'0001-01-01T01:01:01.000000001'"},
                {"a": "(:E {datetime: '1980-12-11T12:31:14'})", "datetime": "'1980-12-11T12:31:14'"},
                {"a": "(:A {datetime: '1984-10-11T12:30:14.000000012'})", "datetime": "'1984-10-11T12:30:14.000000012'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and temporal values are not supported",
        tags=("with", "orderby", "limit", "alias", "expression", "temporal", "xfail"),
    ),
    Scenario(
        key="with-orderby1-39-2",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy1.feature",
        scenario="[39] Sort by a local date time variable projected from a node property in ascending order (sort=datetime ASC)",
        cypher="MATCH (a)\nWITH a, a.datetime AS datetime\nWITH a, datetime\n  ORDER BY datetime ASC\n  LIMIT 3\nRETURN a, datetime",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {datetime: localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 30, second: 14, nanosecond: 12})}),
                   (:B {datetime: localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123})}),
                   (:C {datetime: localdatetime({year: 1, month: 1, day: 1, hour: 1, minute: 1, second: 1, nanosecond: 1})}),
                   (:D {datetime: localdatetime({year: 9999, month: 9, day: 9, hour: 9, minute: 59, second: 59, nanosecond: 999999999})}),
                   (:E {datetime: localdatetime({year: 1980, month: 12, day: 11, hour: 12, minute: 31, second: 14})})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:C {datetime: '0001-01-01T01:01:01.000000001'})", "datetime": "'0001-01-01T01:01:01.000000001'"},
                {"a": "(:E {datetime: '1980-12-11T12:31:14'})", "datetime": "'1980-12-11T12:31:14'"},
                {"a": "(:A {datetime: '1984-10-11T12:30:14.000000012'})", "datetime": "'1984-10-11T12:30:14.000000012'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and temporal values are not supported",
        tags=("with", "orderby", "limit", "alias", "expression", "temporal", "xfail"),
    ),
    Scenario(
        key="with-orderby1-39-3",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy1.feature",
        scenario="[39] Sort by a local date time variable projected from a node property in ascending order (sort=datetime ASCENDING)",
        cypher="MATCH (a)\nWITH a, a.datetime AS datetime\nWITH a, datetime\n  ORDER BY datetime ASCENDING\n  LIMIT 3\nRETURN a, datetime",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {datetime: localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 30, second: 14, nanosecond: 12})}),
                   (:B {datetime: localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123})}),
                   (:C {datetime: localdatetime({year: 1, month: 1, day: 1, hour: 1, minute: 1, second: 1, nanosecond: 1})}),
                   (:D {datetime: localdatetime({year: 9999, month: 9, day: 9, hour: 9, minute: 59, second: 59, nanosecond: 999999999})}),
                   (:E {datetime: localdatetime({year: 1980, month: 12, day: 11, hour: 12, minute: 31, second: 14})})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:C {datetime: '0001-01-01T01:01:01.000000001'})", "datetime": "'0001-01-01T01:01:01.000000001'"},
                {"a": "(:E {datetime: '1980-12-11T12:31:14'})", "datetime": "'1980-12-11T12:31:14'"},
                {"a": "(:A {datetime: '1984-10-11T12:30:14.000000012'})", "datetime": "'1984-10-11T12:30:14.000000012'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and temporal values are not supported",
        tags=("with", "orderby", "limit", "alias", "expression", "temporal", "xfail"),
    ),
    Scenario(
        key="with-orderby1-40-1",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy1.feature",
        scenario="[40] Sort by a local date time variable projected from a node property in descending order (sort=datetime DESC)",
        cypher="MATCH (a)\nWITH a, a.datetime AS datetime\nWITH a, datetime\n  ORDER BY datetime DESC\n  LIMIT 3\nRETURN a, datetime",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {datetime: localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 30, second: 14, nanosecond: 12})}),
                   (:B {datetime: localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123})}),
                   (:C {datetime: localdatetime({year: 1, month: 1, day: 1, hour: 1, minute: 1, second: 1, nanosecond: 1})}),
                   (:D {datetime: localdatetime({year: 9999, month: 9, day: 9, hour: 9, minute: 59, second: 59, nanosecond: 999999999})}),
                   (:E {datetime: localdatetime({year: 1980, month: 12, day: 11, hour: 12, minute: 31, second: 14})})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:D {datetime: '9999-09-09T09:59:59.999999999'})", "datetime": "'9999-09-09T09:59:59.999999999'"},
                {"a": "(:B {datetime: '1984-10-11T12:31:14.645876123'})", "datetime": "'1984-10-11T12:31:14.645876123'"},
                {"a": "(:A {datetime: '1984-10-11T12:30:14.000000012'})", "datetime": "'1984-10-11T12:30:14.000000012'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and temporal values are not supported",
        tags=("with", "orderby", "limit", "alias", "expression", "temporal", "xfail"),
    ),
    Scenario(
        key="with-orderby1-40-2",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy1.feature",
        scenario="[40] Sort by a local date time variable projected from a node property in descending order (sort=datetime DESCENDING)",
        cypher="MATCH (a)\nWITH a, a.datetime AS datetime\nWITH a, datetime\n  ORDER BY datetime DESCENDING\n  LIMIT 3\nRETURN a, datetime",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {datetime: localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 30, second: 14, nanosecond: 12})}),
                   (:B {datetime: localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123})}),
                   (:C {datetime: localdatetime({year: 1, month: 1, day: 1, hour: 1, minute: 1, second: 1, nanosecond: 1})}),
                   (:D {datetime: localdatetime({year: 9999, month: 9, day: 9, hour: 9, minute: 59, second: 59, nanosecond: 999999999})}),
                   (:E {datetime: localdatetime({year: 1980, month: 12, day: 11, hour: 12, minute: 31, second: 14})})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:D {datetime: '9999-09-09T09:59:59.999999999'})", "datetime": "'9999-09-09T09:59:59.999999999'"},
                {"a": "(:B {datetime: '1984-10-11T12:31:14.645876123'})", "datetime": "'1984-10-11T12:31:14.645876123'"},
                {"a": "(:A {datetime: '1984-10-11T12:30:14.000000012'})", "datetime": "'1984-10-11T12:30:14.000000012'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and temporal values are not supported",
        tags=("with", "orderby", "limit", "alias", "expression", "temporal", "xfail"),
    ),
    Scenario(
        key="with-orderby1-41-1",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy1.feature",
        scenario="[41] Sort by a date time variable projected from a node property in ascending order (sort=datetime)",
        cypher="MATCH (a)\nWITH a, a.datetime AS datetime\nWITH a, datetime\n  ORDER BY datetime\n  LIMIT 3\nRETURN a, datetime",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {datetime: datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 30, second: 14, nanosecond: 12, timezone: '+00:15'})}),
                   (:B {datetime: datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+00:17'})}),
                   (:C {datetime: datetime({year: 1, month: 1, day: 1, hour: 1, minute: 1, second: 1, nanosecond: 1, timezone: '-11:59'})}),
                   (:D {datetime: datetime({year: 9999, month: 9, day: 9, hour: 9, minute: 59, second: 59, nanosecond: 999999999, timezone: '+11:59'})}),
                   (:E {datetime: datetime({year: 1980, month: 12, day: 11, hour: 12, minute: 31, second: 14, timezone: '-11:59'})})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:C {datetime: '0001-01-01T01:01:01.000000001-11:59'})", "datetime": "'0001-01-01T01:01:01.000000001-11:59'"},
                {"a": "(:E {datetime: '1980-12-11T12:31:14-11:59'})", "datetime": "'1980-12-11T12:31:14-11:59'"},
                {"a": "(:B {datetime: '1984-10-11T12:31:14.645876123+00:17'})", "datetime": "'1984-10-11T12:31:14.645876123+00:17'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and temporal values are not supported",
        tags=("with", "orderby", "limit", "alias", "expression", "temporal", "xfail"),
    ),
    Scenario(
        key="with-orderby1-41-2",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy1.feature",
        scenario="[41] Sort by a date time variable projected from a node property in ascending order (sort=datetime ASC)",
        cypher="MATCH (a)\nWITH a, a.datetime AS datetime\nWITH a, datetime\n  ORDER BY datetime ASC\n  LIMIT 3\nRETURN a, datetime",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {datetime: datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 30, second: 14, nanosecond: 12, timezone: '+00:15'})}),
                   (:B {datetime: datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+00:17'})}),
                   (:C {datetime: datetime({year: 1, month: 1, day: 1, hour: 1, minute: 1, second: 1, nanosecond: 1, timezone: '-11:59'})}),
                   (:D {datetime: datetime({year: 9999, month: 9, day: 9, hour: 9, minute: 59, second: 59, nanosecond: 999999999, timezone: '+11:59'})}),
                   (:E {datetime: datetime({year: 1980, month: 12, day: 11, hour: 12, minute: 31, second: 14, timezone: '-11:59'})})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:C {datetime: '0001-01-01T01:01:01.000000001-11:59'})", "datetime": "'0001-01-01T01:01:01.000000001-11:59'"},
                {"a": "(:E {datetime: '1980-12-11T12:31:14-11:59'})", "datetime": "'1980-12-11T12:31:14-11:59'"},
                {"a": "(:B {datetime: '1984-10-11T12:31:14.645876123+00:17'})", "datetime": "'1984-10-11T12:31:14.645876123+00:17'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and temporal values are not supported",
        tags=("with", "orderby", "limit", "alias", "expression", "temporal", "xfail"),
    ),
    Scenario(
        key="with-orderby1-41-3",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy1.feature",
        scenario="[41] Sort by a date time variable projected from a node property in ascending order (sort=datetime ASCENDING)",
        cypher="MATCH (a)\nWITH a, a.datetime AS datetime\nWITH a, datetime\n  ORDER BY datetime ASCENDING\n  LIMIT 3\nRETURN a, datetime",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {datetime: datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 30, second: 14, nanosecond: 12, timezone: '+00:15'})}),
                   (:B {datetime: datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+00:17'})}),
                   (:C {datetime: datetime({year: 1, month: 1, day: 1, hour: 1, minute: 1, second: 1, nanosecond: 1, timezone: '-11:59'})}),
                   (:D {datetime: datetime({year: 9999, month: 9, day: 9, hour: 9, minute: 59, second: 59, nanosecond: 999999999, timezone: '+11:59'})}),
                   (:E {datetime: datetime({year: 1980, month: 12, day: 11, hour: 12, minute: 31, second: 14, timezone: '-11:59'})})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:C {datetime: '0001-01-01T01:01:01.000000001-11:59'})", "datetime": "'0001-01-01T01:01:01.000000001-11:59'"},
                {"a": "(:E {datetime: '1980-12-11T12:31:14-11:59'})", "datetime": "'1980-12-11T12:31:14-11:59'"},
                {"a": "(:B {datetime: '1984-10-11T12:31:14.645876123+00:17'})", "datetime": "'1984-10-11T12:31:14.645876123+00:17'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and temporal values are not supported",
        tags=("with", "orderby", "limit", "alias", "expression", "temporal", "xfail"),
    ),
    Scenario(
        key="with-orderby1-42-1",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy1.feature",
        scenario="[42] Sort by a date time variable projected from a node property in descending order (sort=datetime DESC)",
        cypher="MATCH (a)\nWITH a, a.datetime AS datetime\nWITH a, datetime\n  ORDER BY datetime DESC\n  LIMIT 3\nRETURN a, datetime",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {datetime: datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 30, second: 14, nanosecond: 12, timezone: '+00:15'})}),
                   (:B {datetime: datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+00:17'})}),
                   (:C {datetime: datetime({year: 1, month: 1, day: 1, hour: 1, minute: 1, second: 1, nanosecond: 1, timezone: '-11:59'})}),
                   (:D {datetime: datetime({year: 9999, month: 9, day: 9, hour: 9, minute: 59, second: 59, nanosecond: 999999999, timezone: '+11:59'})}),
                   (:E {datetime: datetime({year: 1980, month: 12, day: 11, hour: 12, minute: 31, second: 14, timezone: '-11:59'})})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:D {datetime: '9999-09-09T09:59:59.999999999+11:59'})", "datetime": "'9999-09-09T09:59:59.999999999+11:59'"},
                {"a": "(:A {datetime: '1984-10-11T12:30:14.000000012+00:15'})", "datetime": "'1984-10-11T12:30:14.000000012+00:15'"},
                {"a": "(:B {datetime: '1984-10-11T12:31:14.645876123+00:17'})", "datetime": "'1984-10-11T12:31:14.645876123+00:17'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and temporal values are not supported",
        tags=("with", "orderby", "limit", "alias", "expression", "temporal", "xfail"),
    ),
    Scenario(
        key="with-orderby1-42-2",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy1.feature",
        scenario="[42] Sort by a date time variable projected from a node property in descending order (sort=datetime DESCENDING)",
        cypher="MATCH (a)\nWITH a, a.datetime AS datetime\nWITH a, datetime\n  ORDER BY datetime DESCENDING\n  LIMIT 3\nRETURN a, datetime",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {datetime: datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 30, second: 14, nanosecond: 12, timezone: '+00:15'})}),
                   (:B {datetime: datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+00:17'})}),
                   (:C {datetime: datetime({year: 1, month: 1, day: 1, hour: 1, minute: 1, second: 1, nanosecond: 1, timezone: '-11:59'})}),
                   (:D {datetime: datetime({year: 9999, month: 9, day: 9, hour: 9, minute: 59, second: 59, nanosecond: 999999999, timezone: '+11:59'})}),
                   (:E {datetime: datetime({year: 1980, month: 12, day: 11, hour: 12, minute: 31, second: 14, timezone: '-11:59'})})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:D {datetime: '9999-09-09T09:59:59.999999999+11:59'})", "datetime": "'9999-09-09T09:59:59.999999999+11:59'"},
                {"a": "(:A {datetime: '1984-10-11T12:30:14.000000012+00:15'})", "datetime": "'1984-10-11T12:30:14.000000012+00:15'"},
                {"a": "(:B {datetime: '1984-10-11T12:31:14.645876123+00:17'})", "datetime": "'1984-10-11T12:31:14.645876123+00:17'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and temporal values are not supported",
        tags=("with", "orderby", "limit", "alias", "expression", "temporal", "xfail"),
    ),
    Scenario(
        key="with-orderby1-43-1",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy1.feature",
        scenario="[43] Sort by a variable that is only partially orderable on a non-distinct binding table (dir=ASC)",
        cypher="UNWIND [0, 2, 1, 2, 0, 1] AS x\nWITH x\n  ORDER BY x ASC\n  LIMIT 2\nRETURN x",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"x": 0},
                {"x": 0},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, UNWIND, ORDER BY, and LIMIT are not supported",
        tags=("with", "orderby", "unwind", "limit", "xfail"),
    ),
    Scenario(
        key="with-orderby1-43-2",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy1.feature",
        scenario="[43] Sort by a variable that is only partially orderable on a non-distinct binding table (dir=DESC)",
        cypher="UNWIND [0, 2, 1, 2, 0, 1] AS x\nWITH x\n  ORDER BY x DESC\n  LIMIT 2\nRETURN x",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"x": 2},
                {"x": 2},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, UNWIND, ORDER BY, and LIMIT are not supported",
        tags=("with", "orderby", "unwind", "limit", "xfail"),
    ),
    Scenario(
        key="with-orderby1-44-1",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy1.feature",
        scenario="[44] Sort by a variable that is only partially orderable on a non-distinct binding table, but made distinct (dir=ASC)",
        cypher="UNWIND [0, 2, 1, 2, 0, 1] AS x\nWITH DISTINCT x\n  ORDER BY x ASC\n  LIMIT 1\nRETURN x",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"x": 0},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, UNWIND, ORDER BY, LIMIT, and DISTINCT are not supported",
        tags=("with", "orderby", "unwind", "limit", "distinct", "xfail"),
    ),
    Scenario(
        key="with-orderby1-44-2",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy1.feature",
        scenario="[44] Sort by a variable that is only partially orderable on a non-distinct binding table, but made distinct (dir=DESC)",
        cypher="UNWIND [0, 2, 1, 2, 0, 1] AS x\nWITH DISTINCT x\n  ORDER BY x DESC\n  LIMIT 1\nRETURN x",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"x": 2},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, UNWIND, ORDER BY, LIMIT, and DISTINCT are not supported",
        tags=("with", "orderby", "unwind", "limit", "distinct", "xfail"),
    ),
    Scenario(
        key="with-orderby1-45-1",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy1.feature",
        scenario="[45] Sort order should be consistent with comparisons where comparisons are defined (example=booleans)",
        cypher="WITH [true, false] AS values\nWITH values, size(values) AS numOfValues\nUNWIND values AS value\nWITH size([ x IN values WHERE x < value ]) AS x, value, numOfValues\n  ORDER BY value\nWITH numOfValues, collect(x) AS orderedX\nRETURN orderedX = range(0, numOfValues-1) AS equal",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"equal": "true"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, list comprehensions, aggregation, ORDER BY, and comparisons are not supported",
        tags=("with", "orderby", "unwind", "aggregation", "expression", "list", "xfail"),
    ),
    Scenario(
        key="with-orderby1-45-2",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy1.feature",
        scenario="[45] Sort order should be consistent with comparisons where comparisons are defined (example=integers)",
        cypher="WITH [351, -3974856, 93, -3, 123, 0, 3, -2, 20934587, 1, 20934585, 20934586, -10] AS values\nWITH values, size(values) AS numOfValues\nUNWIND values AS value\nWITH size([ x IN values WHERE x < value ]) AS x, value, numOfValues\n  ORDER BY value\nWITH numOfValues, collect(x) AS orderedX\nRETURN orderedX = range(0, numOfValues-1) AS equal",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"equal": "true"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, list comprehensions, aggregation, ORDER BY, and comparisons are not supported",
        tags=("with", "orderby", "unwind", "aggregation", "expression", "list", "xfail"),
    ),
    Scenario(
        key="with-orderby1-45-3",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy1.feature",
        scenario="[45] Sort order should be consistent with comparisons where comparisons are defined (example=floats)",
        cypher="WITH [351.5, -3974856.01, -3.203957, 123.0002, 123.0001, 123.00013, 123.00011, 0.0100000, 0.0999999, 0.00000001, 3.0, 209345.87, -10.654] AS values\nWITH values, size(values) AS numOfValues\nUNWIND values AS value\nWITH size([ x IN values WHERE x < value ]) AS x, value, numOfValues\n  ORDER BY value\nWITH numOfValues, collect(x) AS orderedX\nRETURN orderedX = range(0, numOfValues-1) AS equal",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"equal": "true"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, list comprehensions, aggregation, ORDER BY, and comparisons are not supported",
        tags=("with", "orderby", "unwind", "aggregation", "expression", "list", "xfail"),
    ),
    Scenario(
        key="with-orderby1-45-4",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy1.feature",
        scenario="[45] Sort order should be consistent with comparisons where comparisons are defined (example=string)",
        cypher="WITH ['Sort', 'order', ' ', 'should', 'be', '', 'consistent', 'with', 'comparisons', ', ', 'where', 'comparisons are', 'defined', '!'] AS values\nWITH values, size(values) AS numOfValues\nUNWIND values AS value\nWITH size([ x IN values WHERE x < value ]) AS x, value, numOfValues\n  ORDER BY value\nWITH numOfValues, collect(x) AS orderedX\nRETURN orderedX = range(0, numOfValues-1) AS equal",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"equal": "true"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, list comprehensions, aggregation, ORDER BY, and comparisons are not supported",
        tags=("with", "orderby", "unwind", "aggregation", "expression", "list", "xfail"),
    ),
    Scenario(
        key="with-orderby1-45-5",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy1.feature",
        scenario="[45] Sort order should be consistent with comparisons where comparisons are defined (example=lists)",
        cypher="WITH [[2, 2], [2, -2], [1, 2], [], [1], [300, 0], [1, -20], [2, -2, 100]] AS values\nWITH values, size(values) AS numOfValues\nUNWIND values AS value\nWITH size([ x IN values WHERE x < value ]) AS x, value, numOfValues\n  ORDER BY value\nWITH numOfValues, collect(x) AS orderedX\nRETURN orderedX = range(0, numOfValues-1) AS equal",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"equal": "true"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, list comprehensions, aggregation, ORDER BY, and comparisons are not supported",
        tags=("with", "orderby", "unwind", "aggregation", "expression", "list", "xfail"),
    ),
    Scenario(
        key="with-orderby1-45-6",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy1.feature",
        scenario="[45] Sort order should be consistent with comparisons where comparisons are defined (example=dates)",
        cypher="WITH [date({year: 1910, month: 5, day: 6}), date({year: 1980, month: 12, day: 24}), date({year: 1984, month: 10, day: 12}), date({year: 1985, month: 5, day: 6}), date({year: 1980, month: 10, day: 24}), date({year: 1984, month: 10, day: 11})] AS values\nWITH values, size(values) AS numOfValues\nUNWIND values AS value\nWITH size([ x IN values WHERE x < value ]) AS x, value, numOfValues\n  ORDER BY value\nWITH numOfValues, collect(x) AS orderedX\nRETURN orderedX = range(0, numOfValues-1) AS equal",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"equal": "true"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, list comprehensions, aggregation, ORDER BY, and comparisons are not supported",
        tags=("with", "orderby", "unwind", "aggregation", "expression", "list", "temporal", "xfail"),
    ),
    Scenario(
        key="with-orderby1-45-7",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy1.feature",
        scenario="[45] Sort order should be consistent with comparisons where comparisons are defined (example=localtimes)",
        cypher="WITH [localtime({hour: 10, minute: 35}), localtime({hour: 12, minute: 31, second: 14, nanosecond: 645876123}), localtime({hour: 12, minute: 31, second: 14, nanosecond: 645876124}), localtime({hour: 12, minute: 35, second: 13}), localtime({hour: 12, minute: 30, second: 14, nanosecond: 645876123}), localtime({hour: 12, minute: 31, second: 15})] AS values\nWITH values, size(values) AS numOfValues\nUNWIND values AS value\nWITH size([ x IN values WHERE x < value ]) AS x, value, numOfValues\n  ORDER BY value\nWITH numOfValues, collect(x) AS orderedX\nRETURN orderedX = range(0, numOfValues-1) AS equal",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"equal": "true"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, list comprehensions, aggregation, ORDER BY, and comparisons are not supported",
        tags=("with", "orderby", "unwind", "aggregation", "expression", "list", "temporal", "xfail"),
    ),
    Scenario(
        key="with-orderby1-45-8",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy1.feature",
        scenario="[45] Sort order should be consistent with comparisons where comparisons are defined (example=times)",
        cypher="WITH [time({hour: 10, minute: 35, timezone: '-08:00'}), time({hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), time({hour: 12, minute: 31, second: 14, nanosecond: 645876124, timezone: '+01:00'}), time({hour: 12, minute: 35, second: 15, timezone: '+05:00'}), time({hour: 12, minute: 30, second: 14, nanosecond: 645876123, timezone: '+01:01'}), time({hour: 12, minute: 35, second: 15, timezone: '+01:00'})] AS values\nWITH values, size(values) AS numOfValues\nUNWIND values AS value\nWITH size([ x IN values WHERE x < value ]) AS x, value, numOfValues\n  ORDER BY value\nWITH numOfValues, collect(x) AS orderedX\nRETURN orderedX = range(0, numOfValues-1) AS equal",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"equal": "true"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, list comprehensions, aggregation, ORDER BY, and comparisons are not supported",
        tags=("with", "orderby", "unwind", "aggregation", "expression", "list", "temporal", "xfail"),
    ),
    Scenario(
        key="with-orderby1-45-9",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy1.feature",
        scenario="[45] Sort order should be consistent with comparisons where comparisons are defined (example=localdatetimes)",
        cypher="WITH [localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 30, second: 14, nanosecond: 12}), localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), localdatetime({year: 1, month: 1, day: 1, hour: 1, minute: 1, second: 1, nanosecond: 1}), localdatetime({year: 9999, month: 9, day: 9, hour: 9, minute: 59, second: 59, nanosecond: 999999999}), localdatetime({year: 1980, month: 12, day: 11, hour: 12, minute: 31, second: 14})] AS values\nWITH values, size(values) AS numOfValues\nUNWIND values AS value\nWITH size([ x IN values WHERE x < value ]) AS x, value, numOfValues\n  ORDER BY value\nWITH numOfValues, collect(x) AS orderedX\nRETURN orderedX = range(0, numOfValues-1) AS equal",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"equal": "true"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, list comprehensions, aggregation, ORDER BY, and comparisons are not supported",
        tags=("with", "orderby", "unwind", "aggregation", "expression", "list", "temporal", "xfail"),
    ),
    Scenario(
        key="with-orderby1-45-10",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy1.feature",
        scenario="[45] Sort order should be consistent with comparisons where comparisons are defined (example=datetimes)",
        cypher="WITH [datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 30, second: 14, nanosecond: 12, timezone: '+00:15'}), datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+00:17'}), datetime({year: 1, month: 1, day: 1, hour: 1, minute: 1, second: 1, nanosecond: 1, timezone: '-11:59'}), datetime({year: 9999, month: 9, day: 9, hour: 9, minute: 59, second: 59, nanosecond: 999999999, timezone: '+11:59'}), datetime({year: 1980, month: 12, day: 11, hour: 12, minute: 31, second: 14, timezone: '-11:59'})] AS values\nWITH values, size(values) AS numOfValues\nUNWIND values AS value\nWITH size([ x IN values WHERE x < value ]) AS x, value, numOfValues\n  ORDER BY value\nWITH numOfValues, collect(x) AS orderedX\nRETURN orderedX = range(0, numOfValues-1) AS equal",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"equal": "true"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, list comprehensions, aggregation, ORDER BY, and comparisons are not supported",
        tags=("with", "orderby", "unwind", "aggregation", "expression", "list", "temporal", "xfail"),
    ),
    Scenario(
        key="with-orderby1-46-1",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy1.feature",
        scenario="[46] Fail on sorting by an undefined variable (example=out of scope, sort=c)",
        cypher="MATCH (a:A), (b:B), (c:C)\nWITH a, b\nWITH a\n  ORDER BY c\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:A), (:A), (:B), (:B), (:C)
            """
        ),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Compile-time validation for ORDER BY variable scoping is not enforced",
        tags=("with", "orderby", "syntax-error", "xfail"),
    ),
    Scenario(
        key="with-orderby1-46-2",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy1.feature",
        scenario="[46] Fail on sorting by an undefined variable (example=out of scope, sort=c ASC)",
        cypher="MATCH (a:A), (b:B), (c:C)\nWITH a, b\nWITH a\n  ORDER BY c ASC\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:A), (:A), (:B), (:B), (:C)
            """
        ),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Compile-time validation for ORDER BY variable scoping is not enforced",
        tags=("with", "orderby", "syntax-error", "xfail"),
    ),
    Scenario(
        key="with-orderby1-46-3",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy1.feature",
        scenario="[46] Fail on sorting by an undefined variable (example=out of scope, sort=c ASCENDING)",
        cypher="MATCH (a:A), (b:B), (c:C)\nWITH a, b\nWITH a\n  ORDER BY c ASCENDING\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:A), (:A), (:B), (:B), (:C)
            """
        ),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Compile-time validation for ORDER BY variable scoping is not enforced",
        tags=("with", "orderby", "syntax-error", "xfail"),
    ),
    Scenario(
        key="with-orderby1-46-4",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy1.feature",
        scenario="[46] Fail on sorting by an undefined variable (example=out of scope, sort=c DESC)",
        cypher="MATCH (a:A), (b:B), (c:C)\nWITH a, b\nWITH a\n  ORDER BY c DESC\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:A), (:A), (:B), (:B), (:C)
            """
        ),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Compile-time validation for ORDER BY variable scoping is not enforced",
        tags=("with", "orderby", "syntax-error", "xfail"),
    ),
    Scenario(
        key="with-orderby1-46-5",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy1.feature",
        scenario="[46] Fail on sorting by an undefined variable (example=out of scope, sort=c DESCENDING)",
        cypher="MATCH (a:A), (b:B), (c:C)\nWITH a, b\nWITH a\n  ORDER BY c DESCENDING\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:A), (:A), (:B), (:B), (:C)
            """
        ),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Compile-time validation for ORDER BY variable scoping is not enforced",
        tags=("with", "orderby", "syntax-error", "xfail"),
    ),
    Scenario(
        key="with-orderby1-46-6",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy1.feature",
        scenario="[46] Fail on sorting by an undefined variable (example=never defined, sort=d)",
        cypher="MATCH (a:A), (b:B), (c:C)\nWITH a, b\nWITH a\n  ORDER BY d\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:A), (:A), (:B), (:B), (:C)
            """
        ),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Compile-time validation for ORDER BY variable scoping is not enforced",
        tags=("with", "orderby", "syntax-error", "xfail"),
    ),
    Scenario(
        key="with-orderby1-46-7",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy1.feature",
        scenario="[46] Fail on sorting by an undefined variable (example=never defined, sort=d ASC)",
        cypher="MATCH (a:A), (b:B), (c:C)\nWITH a, b\nWITH a\n  ORDER BY d ASC\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:A), (:A), (:B), (:B), (:C)
            """
        ),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Compile-time validation for ORDER BY variable scoping is not enforced",
        tags=("with", "orderby", "syntax-error", "xfail"),
    ),
    Scenario(
        key="with-orderby1-46-8",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy1.feature",
        scenario="[46] Fail on sorting by an undefined variable (example=never defined, sort=d ASCENDING)",
        cypher="MATCH (a:A), (b:B), (c:C)\nWITH a, b\nWITH a\n  ORDER BY d ASCENDING\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:A), (:A), (:B), (:B), (:C)
            """
        ),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Compile-time validation for ORDER BY variable scoping is not enforced",
        tags=("with", "orderby", "syntax-error", "xfail"),
    ),
    Scenario(
        key="with-orderby1-46-9",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy1.feature",
        scenario="[46] Fail on sorting by an undefined variable (example=never defined, sort=d DESC)",
        cypher="MATCH (a:A), (b:B), (c:C)\nWITH a, b\nWITH a\n  ORDER BY d DESC\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:A), (:A), (:B), (:B), (:C)
            """
        ),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Compile-time validation for ORDER BY variable scoping is not enforced",
        tags=("with", "orderby", "syntax-error", "xfail"),
    ),
    Scenario(
        key="with-orderby1-46-10",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy1.feature",
        scenario="[46] Fail on sorting by an undefined variable (example=never defined, sort=d DESCENDING)",
        cypher="MATCH (a:A), (b:B), (c:C)\nWITH a, b\nWITH a\n  ORDER BY d DESCENDING\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:A), (:A), (:B), (:B), (:C)
            """
        ),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Compile-time validation for ORDER BY variable scoping is not enforced",
        tags=("with", "orderby", "syntax-error", "xfail"),
    ),
    Scenario(
        key="with-orderby4-1",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy4.feature",
        scenario="[1] Sort by a projected expression",
        cypher="MATCH (a:A)\nWITH a, a.num + a.num2 AS sum\n  ORDER BY a.num + a.num2\n  LIMIT 3\nRETURN a, sum",
        graph=WITH_ORDERBY4_GRAPH,
        expected=Expected(
            rows=[
                {"a": "(:A {num: 1, num2: 4})", "sum": 5},
                {"a": "(:A {num: 3, num2: 3})", "sum": 6},
                {"a": "(:A {num: 5, num2: 2})", "sum": 7},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression aliasing are not supported",
        tags=("with", "orderby", "limit", "alias", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby4-2",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy4.feature",
        scenario="[2] Sort by an alias of a projected expression",
        cypher="MATCH (a:A)\nWITH a, a.num + a.num2 AS sum\n  ORDER BY sum\n  LIMIT 3\nRETURN a, sum",
        graph=WITH_ORDERBY4_GRAPH,
        expected=Expected(
            rows=[
                {"a": "(:A {num: 1, num2: 4})", "sum": 5},
                {"a": "(:A {num: 3, num2: 3})", "sum": 6},
                {"a": "(:A {num: 5, num2: 2})", "sum": 7},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression aliasing are not supported",
        tags=("with", "orderby", "limit", "alias", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby4-3",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy4.feature",
        scenario="[3] Sort by two projected expressions with order priority being different than projection order",
        cypher="MATCH (a:A)\nWITH a, a.num + a.num2 AS sum, a.num2 % 3 AS mod\n  ORDER BY a.num2 % 3, a.num + a.num2\n  LIMIT 3\nRETURN a, sum, mod",
        graph=WITH_ORDERBY4_GRAPH,
        expected=Expected(
            rows=[
                {"a": "(:A {num: 3, num2: 3})", "sum": 6, "mod": 0},
                {"a": "(:A {num: 9, num2: 0})", "sum": 9, "mod": 0},
                {"a": "(:A {num: 1, num2: 4})", "sum": 5, "mod": 1},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression aliasing are not supported",
        tags=("with", "orderby", "limit", "alias", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby4-4",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy4.feature",
        scenario="[4] Sort by one projected expression and one alias of a projected expression with order priority being different than projection order",
        cypher="MATCH (a:A)\nWITH a, a.num + a.num2 AS sum, a.num2 % 3 AS mod\n  ORDER BY a.num2 % 3, sum\n  LIMIT 3\nRETURN a, sum, mod",
        graph=WITH_ORDERBY4_GRAPH,
        expected=Expected(
            rows=[
                {"a": "(:A {num: 3, num2: 3})", "sum": 6, "mod": 0},
                {"a": "(:A {num: 9, num2: 0})", "sum": 9, "mod": 0},
                {"a": "(:A {num: 1, num2: 4})", "sum": 5, "mod": 1},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression aliasing are not supported",
        tags=("with", "orderby", "limit", "alias", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby4-5",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy4.feature",
        scenario="[5] Sort by one alias of a projected expression and one projected expression with order priority being different than projection order",
        cypher="MATCH (a:A)\nWITH a, a.num + a.num2 AS sum, a.num2 % 3 AS mod\n  ORDER BY mod, a.num + a.num2\n  LIMIT 3\nRETURN a, sum, mod",
        graph=WITH_ORDERBY4_GRAPH,
        expected=Expected(
            rows=[
                {"a": "(:A {num: 3, num2: 3})", "sum": 6, "mod": 0},
                {"a": "(:A {num: 9, num2: 0})", "sum": 9, "mod": 0},
                {"a": "(:A {num: 1, num2: 4})", "sum": 5, "mod": 1},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression aliasing are not supported",
        tags=("with", "orderby", "limit", "alias", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby4-6",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy4.feature",
        scenario="[6] Sort by aliases of two projected expressions with order priority being different than projection order",
        cypher="MATCH (a:A)\nWITH a, a.num + a.num2 AS sum, a.num2 % 3 AS mod\n  ORDER BY mod, sum\n  LIMIT 3\nRETURN a, sum, mod",
        graph=WITH_ORDERBY4_GRAPH,
        expected=Expected(
            rows=[
                {"a": "(:A {num: 3, num2: 3})", "sum": 6, "mod": 0},
                {"a": "(:A {num: 9, num2: 0})", "sum": 9, "mod": 0},
                {"a": "(:A {num: 1, num2: 4})", "sum": 5, "mod": 1},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression aliasing are not supported",
        tags=("with", "orderby", "limit", "alias", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby4-7",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy4.feature",
        scenario="[7] Sort by an alias of a projected expression where the alias shadows an existing variable",
        cypher="MATCH (a:A)\nWITH a, a.num2 % 3 AS x\nWITH a, a.num + a.num2 AS x\n  ORDER BY x\n  LIMIT 3\nRETURN a, x",
        graph=WITH_ORDERBY4_GRAPH,
        expected=Expected(
            rows=[
                {"a": "(:A {num: 1, num2: 4})", "x": 5},
                {"a": "(:A {num: 3, num2: 3})", "x": 6},
                {"a": "(:A {num: 5, num2: 2})", "x": 7},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression aliasing are not supported",
        tags=("with", "orderby", "limit", "alias", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby4-8",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy4.feature",
        scenario="[8] Sort by non-projected existing variable",
        cypher="MATCH (a:A)\nWITH a, a.num + a.num2 AS sum\nWITH a, a.num2 % 3 AS mod\n  ORDER BY sum\n  LIMIT 3\nRETURN a, mod",
        graph=WITH_ORDERBY4_GRAPH,
        expected=Expected(
            rows=[
                {"a": "(:A {num: 1, num2: 4})", "mod": 1},
                {"a": "(:A {num: 3, num2: 3})", "mod": 0},
                {"a": "(:A {num: 5, num2: 2})", "mod": 2},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression aliasing are not supported",
        tags=("with", "orderby", "limit", "alias", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby4-9",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy4.feature",
        scenario="[9] Sort by an alias of a projected expression containing the variable shadowed by the alias",
        cypher="MATCH (a:A)\nWITH a.num2 AS x\nWITH x % 3 AS x\n  ORDER BY x\n  LIMIT 3\nRETURN x",
        graph=WITH_ORDERBY4_GRAPH,
        expected=Expected(
            rows=[
                {"x": 0},
                {"x": 0},
                {"x": 1},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression aliasing are not supported",
        tags=("with", "orderby", "limit", "alias", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby2-1-1",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy2.feature",
        scenario="[1] Sort by a boolean expression in ascending order (sort=NOT (a.bool AND a.bool2))",
        cypher="MATCH (a)\nWITH a\n  ORDER BY NOT (a.bool AND a.bool2)\n  LIMIT 2\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {bool: true, bool2: true}),
                   (:B {bool: false, bool2: false}),
                   (:C {bool: false, bool2: true}),
                   (:D {bool: true, bool2: true}),
                   (:E {bool: true, bool2: false})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:A {bool: true, bool2: true})"},
                {"a": "(:D {bool: true, bool2: true})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression evaluation are not supported",
        tags=("with", "orderby", "limit", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby2-1-2",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy2.feature",
        scenario="[1] Sort by a boolean expression in ascending order (sort=NOT (a.bool AND a.bool2) ASC)",
        cypher="MATCH (a)\nWITH a\n  ORDER BY NOT (a.bool AND a.bool2) ASC\n  LIMIT 2\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {bool: true, bool2: true}),
                   (:B {bool: false, bool2: false}),
                   (:C {bool: false, bool2: true}),
                   (:D {bool: true, bool2: true}),
                   (:E {bool: true, bool2: false})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:A {bool: true, bool2: true})"},
                {"a": "(:D {bool: true, bool2: true})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression evaluation are not supported",
        tags=("with", "orderby", "limit", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby2-1-3",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy2.feature",
        scenario="[1] Sort by a boolean expression in ascending order (sort=NOT (a.bool AND a.bool2) ASCENDING)",
        cypher="MATCH (a)\nWITH a\n  ORDER BY NOT (a.bool AND a.bool2) ASCENDING\n  LIMIT 2\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {bool: true, bool2: true}),
                   (:B {bool: false, bool2: false}),
                   (:C {bool: false, bool2: true}),
                   (:D {bool: true, bool2: true}),
                   (:E {bool: true, bool2: false})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:A {bool: true, bool2: true})"},
                {"a": "(:D {bool: true, bool2: true})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression evaluation are not supported",
        tags=("with", "orderby", "limit", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby2-2-1",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy2.feature",
        scenario="[2] Sort by a boolean expression in descending order (sort=NOT (a.bool AND a.bool2) DESC)",
        cypher="MATCH (a)\nWITH a\n  ORDER BY NOT (a.bool AND a.bool2) DESC\n  LIMIT 3\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {bool: true, bool2: true}),
                   (:B {bool: false, bool2: false}),
                   (:C {bool: false, bool2: true}),
                   (:D {bool: true, bool2: true}),
                   (:E {bool: true, bool2: false})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:B {bool: false, bool2: false})"},
                {"a": "(:C {bool: false, bool2: true})"},
                {"a": "(:E {bool: true, bool2: false})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression evaluation are not supported",
        tags=("with", "orderby", "limit", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby2-2-2",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy2.feature",
        scenario="[2] Sort by a boolean expression in descending order (sort=NOT (a.bool AND a.bool2) DESCENDING)",
        cypher="MATCH (a)\nWITH a\n  ORDER BY NOT (a.bool AND a.bool2) DESCENDING\n  LIMIT 3\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {bool: true, bool2: true}),
                   (:B {bool: false, bool2: false}),
                   (:C {bool: false, bool2: true}),
                   (:D {bool: true, bool2: true}),
                   (:E {bool: true, bool2: false})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:B {bool: false, bool2: false})"},
                {"a": "(:C {bool: false, bool2: true})"},
                {"a": "(:E {bool: true, bool2: false})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression evaluation are not supported",
        tags=("with", "orderby", "limit", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby2-3-1",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy2.feature",
        scenario="[3] Sort by an integer expression in ascending order (sort=(a.num2 + (a.num * 2)) * -1)",
        cypher="MATCH (a)\nWITH a\n  ORDER BY (a.num2 + (a.num * 2)) * -1\n  LIMIT 3\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {num: 9, num2: 5}),
                   (:B {num: 5, num2: 4}),
                   (:C {num: 30, num2: 3}),
                   (:D {num: -11, num2: 2}),
                   (:E {num: 7054, num2: 1})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:E {num: 7054, num2: 1})"},
                {"a": "(:C {num: 30, num2: 3})"},
                {"a": "(:A {num: 9, num2: 5})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression evaluation are not supported",
        tags=("with", "orderby", "limit", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby2-3-2",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy2.feature",
        scenario="[3] Sort by an integer expression in ascending order (sort=(a.num2 + (a.num * 2)) * -1 ASC)",
        cypher="MATCH (a)\nWITH a\n  ORDER BY (a.num2 + (a.num * 2)) * -1 ASC\n  LIMIT 3\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {num: 9, num2: 5}),
                   (:B {num: 5, num2: 4}),
                   (:C {num: 30, num2: 3}),
                   (:D {num: -11, num2: 2}),
                   (:E {num: 7054, num2: 1})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:E {num: 7054, num2: 1})"},
                {"a": "(:C {num: 30, num2: 3})"},
                {"a": "(:A {num: 9, num2: 5})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression evaluation are not supported",
        tags=("with", "orderby", "limit", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby2-3-3",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy2.feature",
        scenario="[3] Sort by an integer expression in ascending order (sort=(a.num2 + (a.num * 2)) * -1 ASCENDING)",
        cypher="MATCH (a)\nWITH a\n  ORDER BY (a.num2 + (a.num * 2)) * -1 ASCENDING\n  LIMIT 3\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {num: 9, num2: 5}),
                   (:B {num: 5, num2: 4}),
                   (:C {num: 30, num2: 3}),
                   (:D {num: -11, num2: 2}),
                   (:E {num: 7054, num2: 1})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:E {num: 7054, num2: 1})"},
                {"a": "(:C {num: 30, num2: 3})"},
                {"a": "(:A {num: 9, num2: 5})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression evaluation are not supported",
        tags=("with", "orderby", "limit", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby2-4-1",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy2.feature",
        scenario="[4] Sort by an integer expression in descending order (sort=(a.num2 + (a.num * 2)) * -1 DESC)",
        cypher="MATCH (a)\nWITH a\n  ORDER BY (a.num2 + (a.num * 2)) * -1 DESC\n  LIMIT 3\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {num: 9, num2: 5}),
                   (:B {num: 5, num2: 4}),
                   (:C {num: 30, num2: 3}),
                   (:D {num: -11, num2: 2}),
                   (:E {num: 7054, num2: 1})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:D {num: -11, num2: 2})"},
                {"a": "(:B {num: 5, num2: 4})"},
                {"a": "(:A {num: 9, num2: 5})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression evaluation are not supported",
        tags=("with", "orderby", "limit", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby2-4-2",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy2.feature",
        scenario="[4] Sort by an integer expression in descending order (sort=(a.num2 + (a.num * 2)) * -1 DESCENDING)",
        cypher="MATCH (a)\nWITH a\n  ORDER BY (a.num2 + (a.num * 2)) * -1 DESCENDING\n  LIMIT 3\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {num: 9, num2: 5}),
                   (:B {num: 5, num2: 4}),
                   (:C {num: 30, num2: 3}),
                   (:D {num: -11, num2: 2}),
                   (:E {num: 7054, num2: 1})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:D {num: -11, num2: 2})"},
                {"a": "(:B {num: 5, num2: 4})"},
                {"a": "(:A {num: 9, num2: 5})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression evaluation are not supported",
        tags=("with", "orderby", "limit", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby2-5-1",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy2.feature",
        scenario="[5] Sort by a float expression in ascending order (sort=(a.num + a.num2 * 2) * -1.01)",
        cypher="MATCH (a)\nWITH a\n  ORDER BY (a.num + a.num2 * 2) * -1.01\n  LIMIT 3\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {num: 5.025648, num2: 1.96357}),
                   (:B {num: 30.94857, num2: 0.00002}),
                   (:C {num: 30.94856, num2: 0.00002}),
                   (:D {num: -11.2943, num2: -8.5007}),
                   (:E {num: 7054.008, num2: 948.841})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:E {num: 7054.008, num2: 948.841})"},
                {"a": "(:B {num: 30.94857, num2: 0.00002})"},
                {"a": "(:C {num: 30.94856, num2: 0.00002})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression evaluation are not supported",
        tags=("with", "orderby", "limit", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby2-5-2",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy2.feature",
        scenario="[5] Sort by a float expression in ascending order (sort=(a.num + a.num2 * 2) * -1.01 ASC)",
        cypher="MATCH (a)\nWITH a\n  ORDER BY (a.num + a.num2 * 2) * -1.01 ASC\n  LIMIT 3\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {num: 5.025648, num2: 1.96357}),
                   (:B {num: 30.94857, num2: 0.00002}),
                   (:C {num: 30.94856, num2: 0.00002}),
                   (:D {num: -11.2943, num2: -8.5007}),
                   (:E {num: 7054.008, num2: 948.841})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:E {num: 7054.008, num2: 948.841})"},
                {"a": "(:B {num: 30.94857, num2: 0.00002})"},
                {"a": "(:C {num: 30.94856, num2: 0.00002})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression evaluation are not supported",
        tags=("with", "orderby", "limit", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby2-5-3",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy2.feature",
        scenario="[5] Sort by a float expression in ascending order (sort=(a.num + a.num2 * 2) * -1.01 ASCENDING)",
        cypher="MATCH (a)\nWITH a\n  ORDER BY (a.num + a.num2 * 2) * -1.01 ASCENDING\n  LIMIT 3\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {num: 5.025648, num2: 1.96357}),
                   (:B {num: 30.94857, num2: 0.00002}),
                   (:C {num: 30.94856, num2: 0.00002}),
                   (:D {num: -11.2943, num2: -8.5007}),
                   (:E {num: 7054.008, num2: 948.841})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:E {num: 7054.008, num2: 948.841})"},
                {"a": "(:B {num: 30.94857, num2: 0.00002})"},
                {"a": "(:C {num: 30.94856, num2: 0.00002})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression evaluation are not supported",
        tags=("with", "orderby", "limit", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby2-6-1",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy2.feature",
        scenario="[6] Sort by a float expression in descending order (sort=(a.num + a.num2 * 2) * -1.01 DESC)",
        cypher="MATCH (a)\nWITH a\n  ORDER BY (a.num + a.num2 * 2) * -1.01 DESC\n  LIMIT 3\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {num: 5.025648, num2: 1.96357}),
                   (:B {num: 30.94857, num2: 0.00002}),
                   (:C {num: 30.94856, num2: 0.00002}),
                   (:D {num: -11.2943, num2: -8.5007}),
                   (:E {num: 7054.008, num2: 948.841})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:D {num: -11.2943, num2: -8.5007})"},
                {"a": "(:A {num: 5.025648, num2: 1.96357})"},
                {"a": "(:C {num: 30.94856, num2: 0.00002})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression evaluation are not supported",
        tags=("with", "orderby", "limit", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby2-6-2",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy2.feature",
        scenario="[6] Sort by a float expression in descending order (sort=(a.num + a.num2 * 2) * -1.01 DESCENDING)",
        cypher="MATCH (a)\nWITH a\n  ORDER BY (a.num + a.num2 * 2) * -1.01 DESCENDING\n  LIMIT 3\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {num: 5.025648, num2: 1.96357}),
                   (:B {num: 30.94857, num2: 0.00002}),
                   (:C {num: 30.94856, num2: 0.00002}),
                   (:D {num: -11.2943, num2: -8.5007}),
                   (:E {num: 7054.008, num2: 948.841})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:D {num: -11.2943, num2: -8.5007})"},
                {"a": "(:A {num: 5.025648, num2: 1.96357})"},
                {"a": "(:C {num: 30.94856, num2: 0.00002})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression evaluation are not supported",
        tags=("with", "orderby", "limit", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby2-7-1",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy2.feature",
        scenario="[7] Sort by a string expression in ascending order (sort=a.title + ' ' + a.name)",
        cypher="MATCH (a)\nWITH a\n  ORDER BY a.title + ' ' + a.name\n  LIMIT 3\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {name: 'lorem', title: 'dr.'}),
                   (:B {name: 'ipsum', title: 'dr.'}),
                   (:C {name: 'dolor', title: 'prof.'}),
                   (:D {name: 'sit', title: 'dr.'}),
                   (:E {name: 'amet', title: 'prof.'})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:A {name: 'lorem', title: 'dr.'})"},
                {"a": "(:B {name: 'ipsum', title: 'dr.'})"},
                {"a": "(:D {name: 'sit', title: 'dr.'})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression evaluation are not supported",
        tags=("with", "orderby", "limit", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby2-7-2",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy2.feature",
        scenario="[7] Sort by a string expression in ascending order (sort=a.title + ' ' + a.name ASC)",
        cypher="MATCH (a)\nWITH a\n  ORDER BY a.title + ' ' + a.name ASC\n  LIMIT 3\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {name: 'lorem', title: 'dr.'}),
                   (:B {name: 'ipsum', title: 'dr.'}),
                   (:C {name: 'dolor', title: 'prof.'}),
                   (:D {name: 'sit', title: 'dr.'}),
                   (:E {name: 'amet', title: 'prof.'})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:A {name: 'lorem', title: 'dr.'})"},
                {"a": "(:B {name: 'ipsum', title: 'dr.'})"},
                {"a": "(:D {name: 'sit', title: 'dr.'})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression evaluation are not supported",
        tags=("with", "orderby", "limit", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby2-7-3",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy2.feature",
        scenario="[7] Sort by a string expression in ascending order (sort=a.title + ' ' + a.name ASCENDING)",
        cypher="MATCH (a)\nWITH a\n  ORDER BY a.title + ' ' + a.name ASCENDING\n  LIMIT 3\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {name: 'lorem', title: 'dr.'}),
                   (:B {name: 'ipsum', title: 'dr.'}),
                   (:C {name: 'dolor', title: 'prof.'}),
                   (:D {name: 'sit', title: 'dr.'}),
                   (:E {name: 'amet', title: 'prof.'})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:A {name: 'lorem', title: 'dr.'})"},
                {"a": "(:B {name: 'ipsum', title: 'dr.'})"},
                {"a": "(:D {name: 'sit', title: 'dr.'})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression evaluation are not supported",
        tags=("with", "orderby", "limit", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby2-8-1",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy2.feature",
        scenario="[8] Sort by a string expression in descending order (sort=a.title + ' ' + a.name DESC)",
        cypher="MATCH (a)\nWITH a\n  ORDER BY a.title + ' ' + a.name DESC\n  LIMIT 3\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {name: 'lorem', title: 'dr.'}),
                   (:B {name: 'ipsum', title: 'dr.'}),
                   (:C {name: 'dolor', title: 'prof.'}),
                   (:D {name: 'sit', title: 'dr.'}),
                   (:E {name: 'amet', title: 'prof.'})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:C {name: 'dolor', title: 'prof.'})"},
                {"a": "(:E {name: 'amet', title: 'prof.'})"},
                {"a": "(:D {name: 'sit', title: 'dr.'})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression evaluation are not supported",
        tags=("with", "orderby", "limit", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby2-8-2",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy2.feature",
        scenario="[8] Sort by a string expression in descending order (sort=a.title + ' ' + a.name DESCENDING)",
        cypher="MATCH (a)\nWITH a\n  ORDER BY a.title + ' ' + a.name DESCENDING\n  LIMIT 3\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {name: 'lorem', title: 'dr.'}),
                   (:B {name: 'ipsum', title: 'dr.'}),
                   (:C {name: 'dolor', title: 'prof.'}),
                   (:D {name: 'sit', title: 'dr.'}),
                   (:E {name: 'amet', title: 'prof.'})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:C {name: 'dolor', title: 'prof.'})"},
                {"a": "(:E {name: 'amet', title: 'prof.'})"},
                {"a": "(:D {name: 'sit', title: 'dr.'})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression evaluation are not supported",
        tags=("with", "orderby", "limit", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby2-9-1",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy2.feature",
        scenario="[9] Sort by a list expression in ascending order (sort=[a.list2[1], a.list2[0], a.list[1]] + a.list + a.list2)",
        cypher="MATCH (a)\nWITH a\n  ORDER BY [a.list2[1], a.list2[0], a.list[1]] + a.list + a.list2\n  LIMIT 3\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {list: [2, -2], list2: [3, -2]}),
                   (:B {list: [1, 2], list2: [2, -2]}),
                   (:C {list: [300, 0], list2: [1, -2]}),
                   (:D {list: [1, -20], list2: [4, -2]}),
                   (:E {list: [2, -2, 100], list2: [5, -2]})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:C {list: [300, 0], list2: [1, -2]})"},
                {"a": "(:B {list: [1, 2], list2: [2, -2]})"},
                {"a": "(:A {list: [2, -2], list2: [3, -2]})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression evaluation are not supported",
        tags=("with", "orderby", "limit", "expression", "list", "xfail"),
    ),
    Scenario(
        key="with-orderby2-9-2",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy2.feature",
        scenario="[9] Sort by a list expression in ascending order (sort=[a.list2[1], a.list2[0], a.list[1]] + a.list + a.list2 ASC)",
        cypher="MATCH (a)\nWITH a\n  ORDER BY [a.list2[1], a.list2[0], a.list[1]] + a.list + a.list2 ASC\n  LIMIT 3\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {list: [2, -2], list2: [3, -2]}),
                   (:B {list: [1, 2], list2: [2, -2]}),
                   (:C {list: [300, 0], list2: [1, -2]}),
                   (:D {list: [1, -20], list2: [4, -2]}),
                   (:E {list: [2, -2, 100], list2: [5, -2]})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:C {list: [300, 0], list2: [1, -2]})"},
                {"a": "(:B {list: [1, 2], list2: [2, -2]})"},
                {"a": "(:A {list: [2, -2], list2: [3, -2]})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression evaluation are not supported",
        tags=("with", "orderby", "limit", "expression", "list", "xfail"),
    ),
    Scenario(
        key="with-orderby2-9-3",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy2.feature",
        scenario="[9] Sort by a list expression in ascending order (sort=[a.list2[1], a.list2[0], a.list[1]] + a.list + a.list2 ASCENDING)",
        cypher="MATCH (a)\nWITH a\n  ORDER BY [a.list2[1], a.list2[0], a.list[1]] + a.list + a.list2 ASCENDING\n  LIMIT 3\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {list: [2, -2], list2: [3, -2]}),
                   (:B {list: [1, 2], list2: [2, -2]}),
                   (:C {list: [300, 0], list2: [1, -2]}),
                   (:D {list: [1, -20], list2: [4, -2]}),
                   (:E {list: [2, -2, 100], list2: [5, -2]})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:C {list: [300, 0], list2: [1, -2]})"},
                {"a": "(:B {list: [1, 2], list2: [2, -2]})"},
                {"a": "(:A {list: [2, -2], list2: [3, -2]})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression evaluation are not supported",
        tags=("with", "orderby", "limit", "expression", "list", "xfail"),
    ),
    Scenario(
        key="with-orderby2-10-1",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy2.feature",
        scenario="[10] Sort by a list expression in descending order (sort=[a.list2[1], a.list2[0], a.list[1]] + a.list + a.list2 DESC)",
        cypher="MATCH (a)\nWITH a\n  ORDER BY [a.list2[1], a.list2[0], a.list[1]] + a.list + a.list2 DESC\n  LIMIT 3\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {list: [2, -2], list2: [3, -2]}),
                   (:B {list: [1, 2], list2: [2, -2]}),
                   (:C {list: [300, 0], list2: [1, -2]}),
                   (:D {list: [1, -20], list2: [4, -2]}),
                   (:E {list: [2, -2, 100], list2: [5, -2]})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:E {list: [2, -2, 100], list2: [5, -2]})"},
                {"a": "(:D {list: [1, -20], list2: [4, -2]})"},
                {"a": "(:A {list: [2, -2], list2: [3, -2]})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression evaluation are not supported",
        tags=("with", "orderby", "limit", "expression", "list", "xfail"),
    ),
    Scenario(
        key="with-orderby2-10-2",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy2.feature",
        scenario="[10] Sort by a list expression in descending order (sort=[a.list2[1], a.list2[0], a.list[1]] + a.list + a.list2 DESCENDING)",
        cypher="MATCH (a)\nWITH a\n  ORDER BY [a.list2[1], a.list2[0], a.list[1]] + a.list + a.list2 DESCENDING\n  LIMIT 3\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {list: [2, -2], list2: [3, -2]}),
                   (:B {list: [1, 2], list2: [2, -2]}),
                   (:C {list: [300, 0], list2: [1, -2]}),
                   (:D {list: [1, -20], list2: [4, -2]}),
                   (:E {list: [2, -2, 100], list2: [5, -2]})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:E {list: [2, -2, 100], list2: [5, -2]})"},
                {"a": "(:D {list: [1, -20], list2: [4, -2]})"},
                {"a": "(:A {list: [2, -2], list2: [3, -2]})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression evaluation are not supported",
        tags=("with", "orderby", "limit", "expression", "list", "xfail"),
    ),
    Scenario(
        key="with-orderby2-11-1",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy2.feature",
        scenario="[11] Sort by a date expression in ascending order (sort=a.date + duration({months: 1, days: 2}))",
        cypher="MATCH (a)\nWITH a\n  ORDER BY a.date + duration({months: 1, days: 2})\n  LIMIT 2\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {date: date({year: 1910, month: 5, day: 6})}),
                   (:B {date: date({year: 1980, month: 12, day: 24})}),
                   (:C {date: date({year: 1984, month: 10, day: 12})}),
                   (:D {date: date({year: 1985, month: 5, day: 6})}),
                   (:E {date: date({year: 1980, month: 10, day: 24})}),
                   (:F {date: date({year: 1984, month: 10, day: 11})})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:A {date: '1910-05-06'})"},
                {"a": "(:E {date: '1980-10-24'})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and temporal expressions are not supported",
        tags=("with", "orderby", "limit", "expression", "temporal", "xfail"),
    ),
    Scenario(
        key="with-orderby2-11-2",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy2.feature",
        scenario="[11] Sort by a date expression in ascending order (sort=a.date + duration({months: 1, days: 2}) ASC)",
        cypher="MATCH (a)\nWITH a\n  ORDER BY a.date + duration({months: 1, days: 2}) ASC\n  LIMIT 2\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {date: date({year: 1910, month: 5, day: 6})}),
                   (:B {date: date({year: 1980, month: 12, day: 24})}),
                   (:C {date: date({year: 1984, month: 10, day: 12})}),
                   (:D {date: date({year: 1985, month: 5, day: 6})}),
                   (:E {date: date({year: 1980, month: 10, day: 24})}),
                   (:F {date: date({year: 1984, month: 10, day: 11})})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:A {date: '1910-05-06'})"},
                {"a": "(:E {date: '1980-10-24'})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and temporal expressions are not supported",
        tags=("with", "orderby", "limit", "expression", "temporal", "xfail"),
    ),
    Scenario(
        key="with-orderby2-11-3",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy2.feature",
        scenario="[11] Sort by a date expression in ascending order (sort=a.date + duration({months: 1, days: 2}) ASCENDING)",
        cypher="MATCH (a)\nWITH a\n  ORDER BY a.date + duration({months: 1, days: 2}) ASCENDING\n  LIMIT 2\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {date: date({year: 1910, month: 5, day: 6})}),
                   (:B {date: date({year: 1980, month: 12, day: 24})}),
                   (:C {date: date({year: 1984, month: 10, day: 12})}),
                   (:D {date: date({year: 1985, month: 5, day: 6})}),
                   (:E {date: date({year: 1980, month: 10, day: 24})}),
                   (:F {date: date({year: 1984, month: 10, day: 11})})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:A {date: '1910-05-06'})"},
                {"a": "(:E {date: '1980-10-24'})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and temporal expressions are not supported",
        tags=("with", "orderby", "limit", "expression", "temporal", "xfail"),
    ),
    Scenario(
        key="with-orderby2-12-1",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy2.feature",
        scenario="[12] Sort by a date expression in descending order (sort=a.date + duration({months: 1, days: 2}) DESC)",
        cypher="MATCH (a)\nWITH a\n  ORDER BY a.date + duration({months: 1, days: 2}) DESC\n  LIMIT 2\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {date: date({year: 1910, month: 5, day: 6})}),
                   (:B {date: date({year: 1980, month: 12, day: 24})}),
                   (:C {date: date({year: 1984, month: 10, day: 12})}),
                   (:D {date: date({year: 1985, month: 5, day: 6})}),
                   (:E {date: date({year: 1980, month: 10, day: 24})}),
                   (:F {date: date({year: 1984, month: 10, day: 11})})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:D {date: '1985-05-06'})"},
                {"a": "(:C {date: '1984-10-12'})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and temporal expressions are not supported",
        tags=("with", "orderby", "limit", "expression", "temporal", "xfail"),
    ),
    Scenario(
        key="with-orderby2-12-2",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy2.feature",
        scenario="[12] Sort by a date expression in descending order (sort=a.date + duration({months: 1, days: 2}) DESCENDING)",
        cypher="MATCH (a)\nWITH a\n  ORDER BY a.date + duration({months: 1, days: 2}) DESCENDING\n  LIMIT 2\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {date: date({year: 1910, month: 5, day: 6})}),
                   (:B {date: date({year: 1980, month: 12, day: 24})}),
                   (:C {date: date({year: 1984, month: 10, day: 12})}),
                   (:D {date: date({year: 1985, month: 5, day: 6})}),
                   (:E {date: date({year: 1980, month: 10, day: 24})}),
                   (:F {date: date({year: 1984, month: 10, day: 11})})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:D {date: '1985-05-06'})"},
                {"a": "(:C {date: '1984-10-12'})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and temporal expressions are not supported",
        tags=("with", "orderby", "limit", "expression", "temporal", "xfail"),
    ),
    Scenario(
        key="with-orderby2-13-1",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy2.feature",
        scenario="[13] Sort by a local time expression in ascending order (sort=a.time + duration({minutes: 6}))",
        cypher="MATCH (a)\nWITH a\n  ORDER BY a.time + duration({minutes: 6})\n  LIMIT 3\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {time: localtime({hour: 10, minute: 35})}),
                   (:B {time: localtime({hour: 12, minute: 31, second: 14, nanosecond: 645876123})}),
                   (:C {time: localtime({hour: 12, minute: 31, second: 14, nanosecond: 645876124})}),
                   (:D {time: localtime({hour: 12, minute: 30, second: 14, nanosecond: 645876123})}),
                   (:E {time: localtime({hour: 12, minute: 31, second: 15})})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:A {time: '10:35'})"},
                {"a": "(:D {time: '12:30:14.645876123'})"},
                {"a": "(:B {time: '12:31:14.645876123'})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and temporal expressions are not supported",
        tags=("with", "orderby", "limit", "expression", "temporal", "xfail"),
    ),
    Scenario(
        key="with-orderby2-13-2",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy2.feature",
        scenario="[13] Sort by a local time expression in ascending order (sort=a.time + duration({minutes: 6}) ASC)",
        cypher="MATCH (a)\nWITH a\n  ORDER BY a.time + duration({minutes: 6}) ASC\n  LIMIT 3\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {time: localtime({hour: 10, minute: 35})}),
                   (:B {time: localtime({hour: 12, minute: 31, second: 14, nanosecond: 645876123})}),
                   (:C {time: localtime({hour: 12, minute: 31, second: 14, nanosecond: 645876124})}),
                   (:D {time: localtime({hour: 12, minute: 30, second: 14, nanosecond: 645876123})}),
                   (:E {time: localtime({hour: 12, minute: 31, second: 15})})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:A {time: '10:35'})"},
                {"a": "(:D {time: '12:30:14.645876123'})"},
                {"a": "(:B {time: '12:31:14.645876123'})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and temporal expressions are not supported",
        tags=("with", "orderby", "limit", "expression", "temporal", "xfail"),
    ),
    Scenario(
        key="with-orderby2-13-3",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy2.feature",
        scenario="[13] Sort by a local time expression in ascending order (sort=a.time + duration({minutes: 6}) ASCENDING)",
        cypher="MATCH (a)\nWITH a\n  ORDER BY a.time + duration({minutes: 6}) ASCENDING\n  LIMIT 3\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {time: localtime({hour: 10, minute: 35})}),
                   (:B {time: localtime({hour: 12, minute: 31, second: 14, nanosecond: 645876123})}),
                   (:C {time: localtime({hour: 12, minute: 31, second: 14, nanosecond: 645876124})}),
                   (:D {time: localtime({hour: 12, minute: 30, second: 14, nanosecond: 645876123})}),
                   (:E {time: localtime({hour: 12, minute: 31, second: 15})})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:A {time: '10:35'})"},
                {"a": "(:D {time: '12:30:14.645876123'})"},
                {"a": "(:B {time: '12:31:14.645876123'})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and temporal expressions are not supported",
        tags=("with", "orderby", "limit", "expression", "temporal", "xfail"),
    ),
    Scenario(
        key="with-orderby2-14-1",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy2.feature",
        scenario="[14] Sort by a local time expression in descending order (sort=a.time + duration({minutes: 6}) DESC)",
        cypher="MATCH (a)\nWITH a\n  ORDER BY a.time + duration({minutes: 6}) DESC\n  LIMIT 3\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {time: localtime({hour: 10, minute: 35})}),
                   (:B {time: localtime({hour: 12, minute: 31, second: 14, nanosecond: 645876123})}),
                   (:C {time: localtime({hour: 12, minute: 31, second: 14, nanosecond: 645876124})}),
                   (:D {time: localtime({hour: 12, minute: 30, second: 14, nanosecond: 645876123})}),
                   (:E {time: localtime({hour: 12, minute: 31, second: 15})})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:E {time: '12:31:15'})"},
                {"a": "(:C {time: '12:31:14.645876124'})"},
                {"a": "(:B {time: '12:31:14.645876123'})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and temporal expressions are not supported",
        tags=("with", "orderby", "limit", "expression", "temporal", "xfail"),
    ),
    Scenario(
        key="with-orderby2-14-2",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy2.feature",
        scenario="[14] Sort by a local time expression in descending order (sort=a.time + duration({minutes: 6}) DESCENDING)",
        cypher="MATCH (a)\nWITH a\n  ORDER BY a.time + duration({minutes: 6}) DESCENDING\n  LIMIT 3\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {time: localtime({hour: 10, minute: 35})}),
                   (:B {time: localtime({hour: 12, minute: 31, second: 14, nanosecond: 645876123})}),
                   (:C {time: localtime({hour: 12, minute: 31, second: 14, nanosecond: 645876124})}),
                   (:D {time: localtime({hour: 12, minute: 30, second: 14, nanosecond: 645876123})}),
                   (:E {time: localtime({hour: 12, minute: 31, second: 15})})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:E {time: '12:31:15'})"},
                {"a": "(:C {time: '12:31:14.645876124'})"},
                {"a": "(:B {time: '12:31:14.645876123'})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and temporal expressions are not supported",
        tags=("with", "orderby", "limit", "expression", "temporal", "xfail"),
    ),
    Scenario(
        key="with-orderby2-15-1",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy2.feature",
        scenario="[15] Sort by a time expression in ascending order (sort=a.time + duration({minutes: 6}))",
        cypher="MATCH (a)\nWITH a\n  ORDER BY a.time + duration({minutes: 6})\n  LIMIT 3\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {time: time({hour: 10, minute: 35, timezone: '-08:00'})}),
                   (:B {time: time({hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'})}),
                   (:C {time: time({hour: 12, minute: 31, second: 14, nanosecond: 645876124, timezone: '+01:00'})}),
                   (:D {time: time({hour: 12, minute: 35, second: 15, timezone: '+05:00'})}),
                   (:E {time: time({hour: 12, minute: 30, second: 14, nanosecond: 645876123, timezone: '+01:01'})})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:D {time: '12:35:15+05:00'})"},
                {"a": "(:E {time: '12:30:14.645876123+01:01'})"},
                {"a": "(:B {time: '12:31:14.645876123+01:00'})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and temporal expressions are not supported",
        tags=("with", "orderby", "limit", "expression", "temporal", "xfail"),
    ),
    Scenario(
        key="with-orderby2-15-2",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy2.feature",
        scenario="[15] Sort by a time expression in ascending order (sort=a.time + duration({minutes: 6}) ASC)",
        cypher="MATCH (a)\nWITH a\n  ORDER BY a.time + duration({minutes: 6}) ASC\n  LIMIT 3\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {time: time({hour: 10, minute: 35, timezone: '-08:00'})}),
                   (:B {time: time({hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'})}),
                   (:C {time: time({hour: 12, minute: 31, second: 14, nanosecond: 645876124, timezone: '+01:00'})}),
                   (:D {time: time({hour: 12, minute: 35, second: 15, timezone: '+05:00'})}),
                   (:E {time: time({hour: 12, minute: 30, second: 14, nanosecond: 645876123, timezone: '+01:01'})})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:D {time: '12:35:15+05:00'})"},
                {"a": "(:E {time: '12:30:14.645876123+01:01'})"},
                {"a": "(:B {time: '12:31:14.645876123+01:00'})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and temporal expressions are not supported",
        tags=("with", "orderby", "limit", "expression", "temporal", "xfail"),
    ),
    Scenario(
        key="with-orderby2-15-3",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy2.feature",
        scenario="[15] Sort by a time expression in ascending order (sort=a.time + duration({minutes: 6}) ASCENDING)",
        cypher="MATCH (a)\nWITH a\n  ORDER BY a.time + duration({minutes: 6}) ASCENDING\n  LIMIT 3\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {time: time({hour: 10, minute: 35, timezone: '-08:00'})}),
                   (:B {time: time({hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'})}),
                   (:C {time: time({hour: 12, minute: 31, second: 14, nanosecond: 645876124, timezone: '+01:00'})}),
                   (:D {time: time({hour: 12, minute: 35, second: 15, timezone: '+05:00'})}),
                   (:E {time: time({hour: 12, minute: 30, second: 14, nanosecond: 645876123, timezone: '+01:01'})})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:D {time: '12:35:15+05:00'})"},
                {"a": "(:E {time: '12:30:14.645876123+01:01'})"},
                {"a": "(:B {time: '12:31:14.645876123+01:00'})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and temporal expressions are not supported",
        tags=("with", "orderby", "limit", "expression", "temporal", "xfail"),
    ),
    Scenario(
        key="with-orderby2-16-1",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy2.feature",
        scenario="[16] Sort by a time expression in descending order (sort=a.time + duration({minutes: 6}) DESC)",
        cypher="MATCH (a)\nWITH a\n  ORDER BY a.time + duration({minutes: 6}) DESC\n  LIMIT 3\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {time: time({hour: 10, minute: 35, timezone: '-08:00'})}),
                   (:B {time: time({hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'})}),
                   (:C {time: time({hour: 12, minute: 31, second: 14, nanosecond: 645876124, timezone: '+01:00'})}),
                   (:D {time: time({hour: 12, minute: 35, second: 15, timezone: '+05:00'})}),
                   (:E {time: time({hour: 12, minute: 30, second: 14, nanosecond: 645876123, timezone: '+01:01'})})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:A {time: '10:35-08:00'})"},
                {"a": "(:C {time: '12:31:14.645876124+01:00'})"},
                {"a": "(:B {time: '12:31:14.645876123+01:00'})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and temporal expressions are not supported",
        tags=("with", "orderby", "limit", "expression", "temporal", "xfail"),
    ),
    Scenario(
        key="with-orderby2-16-2",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy2.feature",
        scenario="[16] Sort by a time expression in descending order (sort=a.time + duration({minutes: 6}) DESCENDING)",
        cypher="MATCH (a)\nWITH a\n  ORDER BY a.time + duration({minutes: 6}) DESCENDING\n  LIMIT 3\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {time: time({hour: 10, minute: 35, timezone: '-08:00'})}),
                   (:B {time: time({hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'})}),
                   (:C {time: time({hour: 12, minute: 31, second: 14, nanosecond: 645876124, timezone: '+01:00'})}),
                   (:D {time: time({hour: 12, minute: 35, second: 15, timezone: '+05:00'})}),
                   (:E {time: time({hour: 12, minute: 30, second: 14, nanosecond: 645876123, timezone: '+01:01'})})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:A {time: '10:35-08:00'})"},
                {"a": "(:C {time: '12:31:14.645876124+01:00'})"},
                {"a": "(:B {time: '12:31:14.645876123+01:00'})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and temporal expressions are not supported",
        tags=("with", "orderby", "limit", "expression", "temporal", "xfail"),
    ),
    Scenario(
        key="with-orderby2-17-1",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy2.feature",
        scenario="[17] Sort by a local date time expression in ascending order (sort=a.datetime + duration({days: 4, minutes: 6}))",
        cypher="MATCH (a)\nWITH a\n  ORDER BY a.datetime + duration({days: 4, minutes: 6})\n  LIMIT 3\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {datetime: localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 30, second: 14, nanosecond: 12})}),
                   (:B {datetime: localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123})}),
                   (:C {datetime: localdatetime({year: 1, month: 1, day: 1, hour: 1, minute: 1, second: 1, nanosecond: 1})}),
                   (:D {datetime: localdatetime({year: 9999, month: 9, day: 9, hour: 9, minute: 59, second: 59, nanosecond: 999999999})}),
                   (:E {datetime: localdatetime({year: 1980, month: 12, day: 11, hour: 12, minute: 31, second: 14})})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:C {datetime: '0001-01-01T01:01:01.000000001'})"},
                {"a": "(:E {datetime: '1980-12-11T12:31:14'})"},
                {"a": "(:A {datetime: '1984-10-11T12:30:14.000000012'})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and temporal expressions are not supported",
        tags=("with", "orderby", "limit", "expression", "temporal", "xfail"),
    ),
    Scenario(
        key="with-orderby2-17-2",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy2.feature",
        scenario="[17] Sort by a local date time expression in ascending order (sort=a.datetime + duration({days: 4, minutes: 6}) ASC)",
        cypher="MATCH (a)\nWITH a\n  ORDER BY a.datetime + duration({days: 4, minutes: 6}) ASC\n  LIMIT 3\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {datetime: localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 30, second: 14, nanosecond: 12})}),
                   (:B {datetime: localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123})}),
                   (:C {datetime: localdatetime({year: 1, month: 1, day: 1, hour: 1, minute: 1, second: 1, nanosecond: 1})}),
                   (:D {datetime: localdatetime({year: 9999, month: 9, day: 9, hour: 9, minute: 59, second: 59, nanosecond: 999999999})}),
                   (:E {datetime: localdatetime({year: 1980, month: 12, day: 11, hour: 12, minute: 31, second: 14})})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:C {datetime: '0001-01-01T01:01:01.000000001'})"},
                {"a": "(:E {datetime: '1980-12-11T12:31:14'})"},
                {"a": "(:A {datetime: '1984-10-11T12:30:14.000000012'})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and temporal expressions are not supported",
        tags=("with", "orderby", "limit", "expression", "temporal", "xfail"),
    ),
    Scenario(
        key="with-orderby2-17-3",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy2.feature",
        scenario="[17] Sort by a local date time expression in ascending order (sort=a.datetime + duration({days: 4, minutes: 6}) ASCENDING)",
        cypher="MATCH (a)\nWITH a\n  ORDER BY a.datetime + duration({days: 4, minutes: 6}) ASCENDING\n  LIMIT 3\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {datetime: localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 30, second: 14, nanosecond: 12})}),
                   (:B {datetime: localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123})}),
                   (:C {datetime: localdatetime({year: 1, month: 1, day: 1, hour: 1, minute: 1, second: 1, nanosecond: 1})}),
                   (:D {datetime: localdatetime({year: 9999, month: 9, day: 9, hour: 9, minute: 59, second: 59, nanosecond: 999999999})}),
                   (:E {datetime: localdatetime({year: 1980, month: 12, day: 11, hour: 12, minute: 31, second: 14})})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:C {datetime: '0001-01-01T01:01:01.000000001'})"},
                {"a": "(:E {datetime: '1980-12-11T12:31:14'})"},
                {"a": "(:A {datetime: '1984-10-11T12:30:14.000000012'})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and temporal expressions are not supported",
        tags=("with", "orderby", "limit", "expression", "temporal", "xfail"),
    ),
    Scenario(
        key="with-orderby2-18-1",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy2.feature",
        scenario="[18] Sort by a local date time expression in descending order (sort=a.datetime + duration({days: 4, minutes: 6}) DESC)",
        cypher="MATCH (a)\nWITH a\n  ORDER BY a.datetime + duration({days: 4, minutes: 6}) DESC\n  LIMIT 3\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {datetime: localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 30, second: 14, nanosecond: 12})}),
                   (:B {datetime: localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123})}),
                   (:C {datetime: localdatetime({year: 1, month: 1, day: 1, hour: 1, minute: 1, second: 1, nanosecond: 1})}),
                   (:D {datetime: localdatetime({year: 9999, month: 9, day: 9, hour: 9, minute: 59, second: 59, nanosecond: 999999999})}),
                   (:E {datetime: localdatetime({year: 1980, month: 12, day: 11, hour: 12, minute: 31, second: 14})})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:D {datetime: '9999-09-09T09:59:59.999999999'})"},
                {"a": "(:B {datetime: '1984-10-11T12:31:14.645876123'})"},
                {"a": "(:A {datetime: '1984-10-11T12:30:14.000000012'})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and temporal expressions are not supported",
        tags=("with", "orderby", "limit", "expression", "temporal", "xfail"),
    ),
    Scenario(
        key="with-orderby2-18-2",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy2.feature",
        scenario="[18] Sort by a local date time expression in descending order (sort=a.datetime + duration({days: 4, minutes: 6}) DESCENDING)",
        cypher="MATCH (a)\nWITH a\n  ORDER BY a.datetime + duration({days: 4, minutes: 6}) DESCENDING\n  LIMIT 3\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {datetime: localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 30, second: 14, nanosecond: 12})}),
                   (:B {datetime: localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123})}),
                   (:C {datetime: localdatetime({year: 1, month: 1, day: 1, hour: 1, minute: 1, second: 1, nanosecond: 1})}),
                   (:D {datetime: localdatetime({year: 9999, month: 9, day: 9, hour: 9, minute: 59, second: 59, nanosecond: 999999999})}),
                   (:E {datetime: localdatetime({year: 1980, month: 12, day: 11, hour: 12, minute: 31, second: 14})})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:D {datetime: '9999-09-09T09:59:59.999999999'})"},
                {"a": "(:B {datetime: '1984-10-11T12:31:14.645876123'})"},
                {"a": "(:A {datetime: '1984-10-11T12:30:14.000000012'})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and temporal expressions are not supported",
        tags=("with", "orderby", "limit", "expression", "temporal", "xfail"),
    ),
    Scenario(
        key="with-orderby2-19-1",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy2.feature",
        scenario="[19] Sort by a date time expression in ascending order (sort=a.datetime + duration({days: 4, minutes: 6}))",
        cypher="MATCH (a)\nWITH a\n  ORDER BY a.datetime + duration({days: 4, minutes: 6})\n  LIMIT 3\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {datetime: datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 30, second: 14, nanosecond: 12, timezone: '+00:15'})}),
                   (:B {datetime: datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+00:17'})}),
                   (:C {datetime: datetime({year: 1, month: 1, day: 1, hour: 1, minute: 1, second: 1, nanosecond: 1, timezone: '-11:59'})}),
                   (:D {datetime: datetime({year: 9999, month: 9, day: 9, hour: 9, minute: 59, second: 59, nanosecond: 999999999, timezone: '+11:59'})}),
                   (:E {datetime: datetime({year: 1980, month: 12, day: 11, hour: 12, minute: 31, second: 14, timezone: '-11:59'})})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:C {datetime: '0001-01-01T01:01:01.000000001-11:59'})"},
                {"a": "(:E {datetime: '1980-12-11T12:31:14-11:59'})"},
                {"a": "(:B {datetime: '1984-10-11T12:31:14.645876123+00:17'})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and temporal expressions are not supported",
        tags=("with", "orderby", "limit", "expression", "temporal", "xfail"),
    ),
    Scenario(
        key="with-orderby2-19-2",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy2.feature",
        scenario="[19] Sort by a date time expression in ascending order (sort=a.datetime + duration({days: 4, minutes: 6}) ASC)",
        cypher="MATCH (a)\nWITH a\n  ORDER BY a.datetime + duration({days: 4, minutes: 6}) ASC\n  LIMIT 3\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {datetime: datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 30, second: 14, nanosecond: 12, timezone: '+00:15'})}),
                   (:B {datetime: datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+00:17'})}),
                   (:C {datetime: datetime({year: 1, month: 1, day: 1, hour: 1, minute: 1, second: 1, nanosecond: 1, timezone: '-11:59'})}),
                   (:D {datetime: datetime({year: 9999, month: 9, day: 9, hour: 9, minute: 59, second: 59, nanosecond: 999999999, timezone: '+11:59'})}),
                   (:E {datetime: datetime({year: 1980, month: 12, day: 11, hour: 12, minute: 31, second: 14, timezone: '-11:59'})})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:C {datetime: '0001-01-01T01:01:01.000000001-11:59'})"},
                {"a": "(:E {datetime: '1980-12-11T12:31:14-11:59'})"},
                {"a": "(:B {datetime: '1984-10-11T12:31:14.645876123+00:17'})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and temporal expressions are not supported",
        tags=("with", "orderby", "limit", "expression", "temporal", "xfail"),
    ),
    Scenario(
        key="with-orderby2-19-3",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy2.feature",
        scenario="[19] Sort by a date time expression in ascending order (sort=a.datetime + duration({days: 4, minutes: 6}) ASCENDING)",
        cypher="MATCH (a)\nWITH a\n  ORDER BY a.datetime + duration({days: 4, minutes: 6}) ASCENDING\n  LIMIT 3\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {datetime: datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 30, second: 14, nanosecond: 12, timezone: '+00:15'})}),
                   (:B {datetime: datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+00:17'})}),
                   (:C {datetime: datetime({year: 1, month: 1, day: 1, hour: 1, minute: 1, second: 1, nanosecond: 1, timezone: '-11:59'})}),
                   (:D {datetime: datetime({year: 9999, month: 9, day: 9, hour: 9, minute: 59, second: 59, nanosecond: 999999999, timezone: '+11:59'})}),
                   (:E {datetime: datetime({year: 1980, month: 12, day: 11, hour: 12, minute: 31, second: 14, timezone: '-11:59'})})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:C {datetime: '0001-01-01T01:01:01.000000001-11:59'})"},
                {"a": "(:E {datetime: '1980-12-11T12:31:14-11:59'})"},
                {"a": "(:B {datetime: '1984-10-11T12:31:14.645876123+00:17'})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and temporal expressions are not supported",
        tags=("with", "orderby", "limit", "expression", "temporal", "xfail"),
    ),
    Scenario(
        key="with-orderby2-20-1",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy2.feature",
        scenario="[20] Sort by a date time expression in descending order (sort=a.datetime + duration({days: 4, minutes: 6}) DESC)",
        cypher="MATCH (a)\nWITH a\n  ORDER BY a.datetime + duration({days: 4, minutes: 6}) DESC\n  LIMIT 3\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {datetime: datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 30, second: 14, nanosecond: 12, timezone: '+00:15'})}),
                   (:B {datetime: datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+00:17'})}),
                   (:C {datetime: datetime({year: 1, month: 1, day: 1, hour: 1, minute: 1, second: 1, nanosecond: 1, timezone: '-11:59'})}),
                   (:D {datetime: datetime({year: 9999, month: 9, day: 9, hour: 9, minute: 59, second: 59, nanosecond: 999999999, timezone: '+11:59'})}),
                   (:E {datetime: datetime({year: 1980, month: 12, day: 11, hour: 12, minute: 31, second: 14, timezone: '-11:59'})})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:D {datetime: '9999-09-09T09:59:59.999999999+11:59'})"},
                {"a": "(:A {datetime: '1984-10-11T12:30:14.000000012+00:15'})"},
                {"a": "(:B {datetime: '1984-10-11T12:31:14.645876123+00:17'})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and temporal expressions are not supported",
        tags=("with", "orderby", "limit", "expression", "temporal", "xfail"),
    ),
    Scenario(
        key="with-orderby2-20-2",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy2.feature",
        scenario="[20] Sort by a date time expression in descending order (sort=a.datetime + duration({days: 4, minutes: 6}) DESCENDING)",
        cypher="MATCH (a)\nWITH a\n  ORDER BY a.datetime + duration({days: 4, minutes: 6}) DESCENDING\n  LIMIT 3\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {datetime: datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 30, second: 14, nanosecond: 12, timezone: '+00:15'})}),
                   (:B {datetime: datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+00:17'})}),
                   (:C {datetime: datetime({year: 1, month: 1, day: 1, hour: 1, minute: 1, second: 1, nanosecond: 1, timezone: '-11:59'})}),
                   (:D {datetime: datetime({year: 9999, month: 9, day: 9, hour: 9, minute: 59, second: 59, nanosecond: 999999999, timezone: '+11:59'})}),
                   (:E {datetime: datetime({year: 1980, month: 12, day: 11, hour: 12, minute: 31, second: 14, timezone: '-11:59'})})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:D {datetime: '9999-09-09T09:59:59.999999999+11:59'})"},
                {"a": "(:A {datetime: '1984-10-11T12:30:14.000000012+00:15'})"},
                {"a": "(:B {datetime: '1984-10-11T12:31:14.645876123+00:17'})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and temporal expressions are not supported",
        tags=("with", "orderby", "limit", "expression", "temporal", "xfail"),
    ),
    Scenario(
        key="with-orderby2-21-1",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy2.feature",
        scenario="[21] Sort by an expression that is only partially orderable on a non-distinct binding table (dir=ASC)",
        cypher="MATCH (a)\nWITH a.name AS name\n  ORDER BY a.name + 'C' ASC\n  LIMIT 2\nRETURN name",
        graph=graph_fixture_from_create(
            """
            CREATE ({name: 'A'}),
                   ({name: 'A'}),
                   ({name: 'B'}),
                   ({name: 'C'}),
                   ({name: 'C'})
            """
        ),
        expected=Expected(
            rows=[
                {"name": "'A'"},
                {"name": "'A'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression evaluation are not supported",
        tags=("with", "orderby", "limit", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby2-21-2",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy2.feature",
        scenario="[21] Sort by an expression that is only partially orderable on a non-distinct binding table (dir=DESC)",
        cypher="MATCH (a)\nWITH a.name AS name\n  ORDER BY a.name + 'C' DESC\n  LIMIT 2\nRETURN name",
        graph=graph_fixture_from_create(
            """
            CREATE ({name: 'A'}),
                   ({name: 'A'}),
                   ({name: 'B'}),
                   ({name: 'C'}),
                   ({name: 'C'})
            """
        ),
        expected=Expected(
            rows=[
                {"name": "'C'"},
                {"name": "'C'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression evaluation are not supported",
        tags=("with", "orderby", "limit", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby2-22-1",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy2.feature",
        scenario="[22] Sort by an expression that is only partially orderable on a non-distinct binding table, but used as a grouping key (dir=ASC)",
        cypher="MATCH (a)\nWITH a.name AS name, count(*) AS cnt\n  ORDER BY a.name ASC\n  LIMIT 1\nRETURN name, cnt",
        graph=graph_fixture_from_create(
            """
            CREATE ({name: 'A'}),
                   ({name: 'A'}),
                   ({name: 'B'}),
                   ({name: 'C'}),
                   ({name: 'C'})
            """
        ),
        expected=Expected(
            rows=[
                {"name": "'A'", "cnt": 2},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and aggregation are not supported",
        tags=("with", "orderby", "limit", "aggregation", "xfail"),
    ),
    Scenario(
        key="with-orderby2-22-2",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy2.feature",
        scenario="[22] Sort by an expression that is only partially orderable on a non-distinct binding table, but used as a grouping key (dir=DESC)",
        cypher="MATCH (a)\nWITH a.name AS name, count(*) AS cnt\n  ORDER BY a.name DESC\n  LIMIT 1\nRETURN name, cnt",
        graph=graph_fixture_from_create(
            """
            CREATE ({name: 'A'}),
                   ({name: 'A'}),
                   ({name: 'B'}),
                   ({name: 'C'}),
                   ({name: 'C'})
            """
        ),
        expected=Expected(
            rows=[
                {"name": "'C'", "cnt": 2},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and aggregation are not supported",
        tags=("with", "orderby", "limit", "aggregation", "xfail"),
    ),
    Scenario(
        key="with-orderby2-23-1",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy2.feature",
        scenario="[23] Sort by an expression that is only partially orderable on a non-distinct binding table, but used in parts as a grouping key (dir=ASC)",
        cypher="MATCH (a)\nWITH a.name AS name, count(*) AS cnt\n  ORDER BY a.name + 'C' ASC\n  LIMIT 1\nRETURN name, cnt",
        graph=graph_fixture_from_create(
            """
            CREATE ({name: 'A'}),
                   ({name: 'A'}),
                   ({name: 'B'}),
                   ({name: 'C'}),
                   ({name: 'C'})
            """
        ),
        expected=Expected(
            rows=[
                {"name": "'A'", "cnt": 2},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, aggregation, and expression evaluation are not supported",
        tags=("with", "orderby", "limit", "aggregation", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby2-23-2",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy2.feature",
        scenario="[23] Sort by an expression that is only partially orderable on a non-distinct binding table, but used in parts as a grouping key (dir=DESC)",
        cypher="MATCH (a)\nWITH a.name AS name, count(*) AS cnt\n  ORDER BY a.name + 'C' DESC\n  LIMIT 1\nRETURN name, cnt",
        graph=graph_fixture_from_create(
            """
            CREATE ({name: 'A'}),
                   ({name: 'A'}),
                   ({name: 'B'}),
                   ({name: 'C'}),
                   ({name: 'C'})
            """
        ),
        expected=Expected(
            rows=[
                {"name": "'C'", "cnt": 2},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, aggregation, and expression evaluation are not supported",
        tags=("with", "orderby", "limit", "aggregation", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby2-24-1",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy2.feature",
        scenario="[24] Sort by an expression that is only partially orderable on a non-distinct binding table, but made distinct (dir=ASC)",
        cypher="MATCH (a)\nWITH DISTINCT a.name AS name\n  ORDER BY a.name ASC\n  LIMIT 1\nRETURN *",
        graph=graph_fixture_from_create(
            """
            CREATE ({name: 'A'}),
                   ({name: 'A'}),
                   ({name: 'B'}),
                   ({name: 'C'}),
                   ({name: 'C'})
            """
        ),
        expected=Expected(
            rows=[
                {"name": "'A'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH DISTINCT projections, ORDER BY, and LIMIT are not supported",
        tags=("with", "orderby", "limit", "distinct", "xfail"),
    ),
    Scenario(
        key="with-orderby2-24-2",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy2.feature",
        scenario="[24] Sort by an expression that is only partially orderable on a non-distinct binding table, but made distinct (dir=DESC)",
        cypher="MATCH (a)\nWITH DISTINCT a.name AS name\n  ORDER BY a.name DESC\n  LIMIT 1\nRETURN *",
        graph=graph_fixture_from_create(
            """
            CREATE ({name: 'A'}),
                   ({name: 'A'}),
                   ({name: 'B'}),
                   ({name: 'C'}),
                   ({name: 'C'})
            """
        ),
        expected=Expected(
            rows=[
                {"name": "'C'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH DISTINCT projections, ORDER BY, and LIMIT are not supported",
        tags=("with", "orderby", "limit", "distinct", "xfail"),
    ),
    Scenario(
        key="with-orderby2-25-1",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy2.feature",
        scenario="[25] Fail on sorting by an aggregation (sort=count(1))",
        cypher="MATCH (n)\nWITH n.num1 AS foo\n  ORDER BY count(1)\nRETURN foo AS foo",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Compile-time validation for ORDER BY aggregation is not enforced",
        tags=("with", "orderby", "aggregation", "syntax-error", "xfail"),
    ),
    Scenario(
        key="with-orderby2-25-2",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy2.feature",
        scenario="[25] Fail on sorting by an aggregation (sort=count(n))",
        cypher="MATCH (n)\nWITH n.num1 AS foo\n  ORDER BY count(n)\nRETURN foo AS foo",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Compile-time validation for ORDER BY aggregation is not enforced",
        tags=("with", "orderby", "aggregation", "syntax-error", "xfail"),
    ),
    Scenario(
        key="with-orderby2-25-3",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy2.feature",
        scenario="[25] Fail on sorting by an aggregation (sort=count(n.num1))",
        cypher="MATCH (n)\nWITH n.num1 AS foo\n  ORDER BY count(n.num1)\nRETURN foo AS foo",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Compile-time validation for ORDER BY aggregation is not enforced",
        tags=("with", "orderby", "aggregation", "syntax-error", "xfail"),
    ),
    Scenario(
        key="with-orderby2-25-4",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy2.feature",
        scenario="[25] Fail on sorting by an aggregation (sort=count(1 + n.num1))",
        cypher="MATCH (n)\nWITH n.num1 AS foo\n  ORDER BY count(1 + n.num1)\nRETURN foo AS foo",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Compile-time validation for ORDER BY aggregation is not enforced",
        tags=("with", "orderby", "aggregation", "syntax-error", "xfail"),
    ),
    Scenario(
        key="with-orderby2-25-5",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy2.feature",
        scenario="[25] Fail on sorting by an aggregation (sort=max(n.num2))",
        cypher="MATCH (n)\nWITH n.num1 AS foo\n  ORDER BY max(n.num2)\nRETURN foo AS foo",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Compile-time validation for ORDER BY aggregation is not enforced",
        tags=("with", "orderby", "aggregation", "syntax-error", "xfail"),
    ),
    Scenario(
        key="with-orderby2-25-6",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy2.feature",
        scenario="[25] Fail on sorting by an aggregation (sort=max(n.num2) ASC)",
        cypher="MATCH (n)\nWITH n.num1 AS foo\n  ORDER BY max(n.num2) ASC\nRETURN foo AS foo",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Compile-time validation for ORDER BY aggregation is not enforced",
        tags=("with", "orderby", "aggregation", "syntax-error", "xfail"),
    ),
    Scenario(
        key="with-orderby2-25-7",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy2.feature",
        scenario="[25] Fail on sorting by an aggregation (sort=max(n.num2) ASCENDING)",
        cypher="MATCH (n)\nWITH n.num1 AS foo\n  ORDER BY max(n.num2) ASCENDING\nRETURN foo AS foo",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Compile-time validation for ORDER BY aggregation is not enforced",
        tags=("with", "orderby", "aggregation", "syntax-error", "xfail"),
    ),
    Scenario(
        key="with-orderby2-25-8",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy2.feature",
        scenario="[25] Fail on sorting by an aggregation (sort=max(n.num2) DESC)",
        cypher="MATCH (n)\nWITH n.num1 AS foo\n  ORDER BY max(n.num2) DESC\nRETURN foo AS foo",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Compile-time validation for ORDER BY aggregation is not enforced",
        tags=("with", "orderby", "aggregation", "syntax-error", "xfail"),
    ),
    Scenario(
        key="with-orderby2-25-9",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy2.feature",
        scenario="[25] Fail on sorting by an aggregation (sort=max(n.num2) DESCENDING)",
        cypher="MATCH (n)\nWITH n.num1 AS foo\n  ORDER BY max(n.num2) DESCENDING\nRETURN foo AS foo",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Compile-time validation for ORDER BY aggregation is not enforced",
        tags=("with", "orderby", "aggregation", "syntax-error", "xfail"),
    ),
    Scenario(
        key="with-orderby2-25-10",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy2.feature",
        scenario="[25] Fail on sorting by an aggregation (sort=max(n.num2), n.name)",
        cypher="MATCH (n)\nWITH n.num1 AS foo\n  ORDER BY max(n.num2), n.name\nRETURN foo AS foo",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Compile-time validation for ORDER BY aggregation is not enforced",
        tags=("with", "orderby", "aggregation", "syntax-error", "xfail"),
    ),
    Scenario(
        key="with-orderby2-25-11",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy2.feature",
        scenario="[25] Fail on sorting by an aggregation (sort=max(n.num2) ASC, n.name)",
        cypher="MATCH (n)\nWITH n.num1 AS foo\n  ORDER BY max(n.num2) ASC, n.name\nRETURN foo AS foo",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Compile-time validation for ORDER BY aggregation is not enforced",
        tags=("with", "orderby", "aggregation", "syntax-error", "xfail"),
    ),
    Scenario(
        key="with-orderby2-25-12",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy2.feature",
        scenario="[25] Fail on sorting by an aggregation (sort=max(n.num2) ASCENDING, n.name)",
        cypher="MATCH (n)\nWITH n.num1 AS foo\n  ORDER BY max(n.num2) ASCENDING, n.name\nRETURN foo AS foo",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Compile-time validation for ORDER BY aggregation is not enforced",
        tags=("with", "orderby", "aggregation", "syntax-error", "xfail"),
    ),
    Scenario(
        key="with-orderby2-25-13",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy2.feature",
        scenario="[25] Fail on sorting by an aggregation (sort=max(n.num2) DESC, n.name)",
        cypher="MATCH (n)\nWITH n.num1 AS foo\n  ORDER BY max(n.num2) DESC, n.name\nRETURN foo AS foo",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Compile-time validation for ORDER BY aggregation is not enforced",
        tags=("with", "orderby", "aggregation", "syntax-error", "xfail"),
    ),
    Scenario(
        key="with-orderby2-25-14",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy2.feature",
        scenario="[25] Fail on sorting by an aggregation (sort=max(n.num2) DESCENDING, n.name)",
        cypher="MATCH (n)\nWITH n.num1 AS foo\n  ORDER BY max(n.num2) DESCENDING, n.name\nRETURN foo AS foo",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Compile-time validation for ORDER BY aggregation is not enforced",
        tags=("with", "orderby", "aggregation", "syntax-error", "xfail"),
    ),
    Scenario(
        key="with-orderby2-25-15",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy2.feature",
        scenario="[25] Fail on sorting by an aggregation (sort=n.name, max(n.num2))",
        cypher="MATCH (n)\nWITH n.num1 AS foo\n  ORDER BY n.name, max(n.num2)\nRETURN foo AS foo",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Compile-time validation for ORDER BY aggregation is not enforced",
        tags=("with", "orderby", "aggregation", "syntax-error", "xfail"),
    ),
    Scenario(
        key="with-orderby2-25-16",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy2.feature",
        scenario="[25] Fail on sorting by an aggregation (sort=n.name ASC, max(n.num2) ASC)",
        cypher="MATCH (n)\nWITH n.num1 AS foo\n  ORDER BY n.name ASC, max(n.num2) ASC\nRETURN foo AS foo",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Compile-time validation for ORDER BY aggregation is not enforced",
        tags=("with", "orderby", "aggregation", "syntax-error", "xfail"),
    ),
    Scenario(
        key="with-orderby2-25-17",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy2.feature",
        scenario="[25] Fail on sorting by an aggregation (sort=n.name ASC, max(n.num2) DESC)",
        cypher="MATCH (n)\nWITH n.num1 AS foo\n  ORDER BY n.name ASC, max(n.num2) DESC\nRETURN foo AS foo",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Compile-time validation for ORDER BY aggregation is not enforced",
        tags=("with", "orderby", "aggregation", "syntax-error", "xfail"),
    ),
    Scenario(
        key="with-orderby2-25-18",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy2.feature",
        scenario="[25] Fail on sorting by an aggregation (sort=n.name DESC, max(n.num2) ASC)",
        cypher="MATCH (n)\nWITH n.num1 AS foo\n  ORDER BY n.name DESC, max(n.num2) ASC\nRETURN foo AS foo",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Compile-time validation for ORDER BY aggregation is not enforced",
        tags=("with", "orderby", "aggregation", "syntax-error", "xfail"),
    ),
    Scenario(
        key="with-orderby2-25-19",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy2.feature",
        scenario="[25] Fail on sorting by an aggregation (sort=n.name DESC, max(n.num2) DESC)",
        cypher="MATCH (n)\nWITH n.num1 AS foo\n  ORDER BY n.name DESC, max(n.num2) DESC\nRETURN foo AS foo",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Compile-time validation for ORDER BY aggregation is not enforced",
        tags=("with", "orderby", "aggregation", "syntax-error", "xfail"),
    ),
    Scenario(
        key="with-orderby2-25-20",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy2.feature",
        scenario="[25] Fail on sorting by an aggregation (sort=n.name, max(n.num2), n.name2)",
        cypher="MATCH (n)\nWITH n.num1 AS foo\n  ORDER BY n.name, max(n.num2), n.name2\nRETURN foo AS foo",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Compile-time validation for ORDER BY aggregation is not enforced",
        tags=("with", "orderby", "aggregation", "syntax-error", "xfail"),
    ),
    Scenario(
        key="with-orderby2-25-21",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy2.feature",
        scenario="[25] Fail on sorting by an aggregation (sort=n.name, n.name2, max(n.num2))",
        cypher="MATCH (n)\nWITH n.num1 AS foo\n  ORDER BY n.name, n.name2, max(n.num2)\nRETURN foo AS foo",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Compile-time validation for ORDER BY aggregation is not enforced",
        tags=("with", "orderby", "aggregation", "syntax-error", "xfail"),
    ),
    Scenario(
        key="with-orderby2-25-22",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy2.feature",
        scenario="[25] Fail on sorting by an aggregation (sort=n, max(n.num2))",
        cypher="MATCH (n)\nWITH n.num1 AS foo\n  ORDER BY n, max(n.num2)\nRETURN foo AS foo",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Compile-time validation for ORDER BY aggregation is not enforced",
        tags=("with", "orderby", "aggregation", "syntax-error", "xfail"),
    ),
    Scenario(
        key="with-orderby2-25-23",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy2.feature",
        scenario="[25] Fail on sorting by an aggregation (sort=n.num1, max(n.num2))",
        cypher="MATCH (n)\nWITH n.num1 AS foo\n  ORDER BY n.num1, max(n.num2)\nRETURN foo AS foo",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Compile-time validation for ORDER BY aggregation is not enforced",
        tags=("with", "orderby", "aggregation", "syntax-error", "xfail"),
    ),
    Scenario(
        key="with-orderby2-25-24",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy2.feature",
        scenario="[25] Fail on sorting by an aggregation (sort=n, max(n.num2), n.num1)",
        cypher="MATCH (n)\nWITH n.num1 AS foo\n  ORDER BY n, max(n.num2), n.num1\nRETURN foo AS foo",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Compile-time validation for ORDER BY aggregation is not enforced",
        tags=("with", "orderby", "aggregation", "syntax-error", "xfail"),
    ),
    Scenario(
        key="with-orderby2-25-25",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy2.feature",
        scenario="[25] Fail on sorting by an aggregation (sort=n, count(n.num1), max(n.num2), n.num1)",
        cypher="MATCH (n)\nWITH n.num1 AS foo\n  ORDER BY n, count(n.num1), max(n.num2), n.num1\nRETURN foo AS foo",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Compile-time validation for ORDER BY aggregation is not enforced",
        tags=("with", "orderby", "aggregation", "syntax-error", "xfail"),
    ),
    Scenario(
        key="with-orderby3-1-1",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy3.feature",
        scenario="[1] Sort by two expressions, both in ascending order (sort=a.bool, a.num)",
        cypher="MATCH (a)\nWITH a\n  ORDER BY a.bool, a.num\n  LIMIT 4\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {num: 9, bool: true}),
                   (:B {num: 5, bool: false}),
                   (:C {num: -30, bool: false}),
                   (:D {num: -41, bool: true}),
                   (:E {num: 7054, bool: false})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:C {num: -30, bool: false})"},
                {"a": "(:B {num: 5, bool: false})"},
                {"a": "(:E {num: 7054, bool: false})"},
                {"a": "(:D {num: -41, bool: true})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression evaluation are not supported",
        tags=("with", "orderby", "limit", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby3-1-2",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy3.feature",
        scenario="[1] Sort by two expressions, both in ascending order (sort=a.bool, a.num ASC)",
        cypher="MATCH (a)\nWITH a\n  ORDER BY a.bool, a.num ASC\n  LIMIT 4\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {num: 9, bool: true}),
                   (:B {num: 5, bool: false}),
                   (:C {num: -30, bool: false}),
                   (:D {num: -41, bool: true}),
                   (:E {num: 7054, bool: false})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:C {num: -30, bool: false})"},
                {"a": "(:B {num: 5, bool: false})"},
                {"a": "(:E {num: 7054, bool: false})"},
                {"a": "(:D {num: -41, bool: true})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression evaluation are not supported",
        tags=("with", "orderby", "limit", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby3-1-3",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy3.feature",
        scenario="[1] Sort by two expressions, both in ascending order (sort=a.bool, a.num ASCENDING)",
        cypher="MATCH (a)\nWITH a\n  ORDER BY a.bool, a.num ASCENDING\n  LIMIT 4\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {num: 9, bool: true}),
                   (:B {num: 5, bool: false}),
                   (:C {num: -30, bool: false}),
                   (:D {num: -41, bool: true}),
                   (:E {num: 7054, bool: false})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:C {num: -30, bool: false})"},
                {"a": "(:B {num: 5, bool: false})"},
                {"a": "(:E {num: 7054, bool: false})"},
                {"a": "(:D {num: -41, bool: true})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression evaluation are not supported",
        tags=("with", "orderby", "limit", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby3-1-4",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy3.feature",
        scenario="[1] Sort by two expressions, both in ascending order (sort=a.bool ASC, a.num)",
        cypher="MATCH (a)\nWITH a\n  ORDER BY a.bool ASC, a.num\n  LIMIT 4\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {num: 9, bool: true}),
                   (:B {num: 5, bool: false}),
                   (:C {num: -30, bool: false}),
                   (:D {num: -41, bool: true}),
                   (:E {num: 7054, bool: false})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:C {num: -30, bool: false})"},
                {"a": "(:B {num: 5, bool: false})"},
                {"a": "(:E {num: 7054, bool: false})"},
                {"a": "(:D {num: -41, bool: true})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression evaluation are not supported",
        tags=("with", "orderby", "limit", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby3-1-5",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy3.feature",
        scenario="[1] Sort by two expressions, both in ascending order (sort=a.bool ASC, a.num ASC)",
        cypher="MATCH (a)\nWITH a\n  ORDER BY a.bool ASC, a.num ASC\n  LIMIT 4\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {num: 9, bool: true}),
                   (:B {num: 5, bool: false}),
                   (:C {num: -30, bool: false}),
                   (:D {num: -41, bool: true}),
                   (:E {num: 7054, bool: false})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:C {num: -30, bool: false})"},
                {"a": "(:B {num: 5, bool: false})"},
                {"a": "(:E {num: 7054, bool: false})"},
                {"a": "(:D {num: -41, bool: true})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression evaluation are not supported",
        tags=("with", "orderby", "limit", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby3-1-6",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy3.feature",
        scenario="[1] Sort by two expressions, both in ascending order (sort=a.bool ASC, a.num ASCENDING)",
        cypher="MATCH (a)\nWITH a\n  ORDER BY a.bool ASC, a.num ASCENDING\n  LIMIT 4\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {num: 9, bool: true}),
                   (:B {num: 5, bool: false}),
                   (:C {num: -30, bool: false}),
                   (:D {num: -41, bool: true}),
                   (:E {num: 7054, bool: false})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:C {num: -30, bool: false})"},
                {"a": "(:B {num: 5, bool: false})"},
                {"a": "(:E {num: 7054, bool: false})"},
                {"a": "(:D {num: -41, bool: true})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression evaluation are not supported",
        tags=("with", "orderby", "limit", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby3-1-7",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy3.feature",
        scenario="[1] Sort by two expressions, both in ascending order (sort=a.bool ASCENDING, a.num)",
        cypher="MATCH (a)\nWITH a\n  ORDER BY a.bool ASCENDING, a.num\n  LIMIT 4\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {num: 9, bool: true}),
                   (:B {num: 5, bool: false}),
                   (:C {num: -30, bool: false}),
                   (:D {num: -41, bool: true}),
                   (:E {num: 7054, bool: false})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:C {num: -30, bool: false})"},
                {"a": "(:B {num: 5, bool: false})"},
                {"a": "(:E {num: 7054, bool: false})"},
                {"a": "(:D {num: -41, bool: true})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression evaluation are not supported",
        tags=("with", "orderby", "limit", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby3-1-8",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy3.feature",
        scenario="[1] Sort by two expressions, both in ascending order (sort=a.bool ASCENDING, a.num ASC)",
        cypher="MATCH (a)\nWITH a\n  ORDER BY a.bool ASCENDING, a.num ASC\n  LIMIT 4\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {num: 9, bool: true}),
                   (:B {num: 5, bool: false}),
                   (:C {num: -30, bool: false}),
                   (:D {num: -41, bool: true}),
                   (:E {num: 7054, bool: false})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:C {num: -30, bool: false})"},
                {"a": "(:B {num: 5, bool: false})"},
                {"a": "(:E {num: 7054, bool: false})"},
                {"a": "(:D {num: -41, bool: true})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression evaluation are not supported",
        tags=("with", "orderby", "limit", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby3-1-9",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy3.feature",
        scenario="[1] Sort by two expressions, both in ascending order (sort=a.bool ASCENDING, a.num ASCENDING)",
        cypher="MATCH (a)\nWITH a\n  ORDER BY a.bool ASCENDING, a.num ASCENDING\n  LIMIT 4\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {num: 9, bool: true}),
                   (:B {num: 5, bool: false}),
                   (:C {num: -30, bool: false}),
                   (:D {num: -41, bool: true}),
                   (:E {num: 7054, bool: false})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:C {num: -30, bool: false})"},
                {"a": "(:B {num: 5, bool: false})"},
                {"a": "(:E {num: 7054, bool: false})"},
                {"a": "(:D {num: -41, bool: true})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression evaluation are not supported",
        tags=("with", "orderby", "limit", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby3-2-1",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy3.feature",
        scenario="[2] Sort by two expressions, first in ascending order, second in descending order (sort=a.bool, a.num DESC)",
        cypher="MATCH (a)\nWITH a\n  ORDER BY a.bool, a.num DESC\n  LIMIT 4\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {num: 9, bool: true}),
                   (:B {num: 5, bool: false}),
                   (:C {num: -30, bool: false}),
                   (:D {num: -41, bool: true}),
                   (:E {num: 7054, bool: false})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:C {num: -30, bool: false})"},
                {"a": "(:B {num: 5, bool: false})"},
                {"a": "(:E {num: 7054, bool: false})"},
                {"a": "(:A {num: 9, bool: true})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression evaluation are not supported",
        tags=("with", "orderby", "limit", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby3-2-2",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy3.feature",
        scenario="[2] Sort by two expressions, first in ascending order, second in descending order (sort=a.bool, a.num DESCENDING)",
        cypher="MATCH (a)\nWITH a\n  ORDER BY a.bool, a.num DESCENDING\n  LIMIT 4\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {num: 9, bool: true}),
                   (:B {num: 5, bool: false}),
                   (:C {num: -30, bool: false}),
                   (:D {num: -41, bool: true}),
                   (:E {num: 7054, bool: false})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:C {num: -30, bool: false})"},
                {"a": "(:B {num: 5, bool: false})"},
                {"a": "(:E {num: 7054, bool: false})"},
                {"a": "(:A {num: 9, bool: true})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression evaluation are not supported",
        tags=("with", "orderby", "limit", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby3-2-3",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy3.feature",
        scenario="[2] Sort by two expressions, first in ascending order, second in descending order (sort=a.bool ASC, a.num DESC)",
        cypher="MATCH (a)\nWITH a\n  ORDER BY a.bool ASC, a.num DESC\n  LIMIT 4\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {num: 9, bool: true}),
                   (:B {num: 5, bool: false}),
                   (:C {num: -30, bool: false}),
                   (:D {num: -41, bool: true}),
                   (:E {num: 7054, bool: false})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:C {num: -30, bool: false})"},
                {"a": "(:B {num: 5, bool: false})"},
                {"a": "(:E {num: 7054, bool: false})"},
                {"a": "(:A {num: 9, bool: true})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression evaluation are not supported",
        tags=("with", "orderby", "limit", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby3-2-4",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy3.feature",
        scenario="[2] Sort by two expressions, first in ascending order, second in descending order (sort=a.bool ASC, a.num DESCENDING)",
        cypher="MATCH (a)\nWITH a\n  ORDER BY a.bool ASC, a.num DESCENDING\n  LIMIT 4\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {num: 9, bool: true}),
                   (:B {num: 5, bool: false}),
                   (:C {num: -30, bool: false}),
                   (:D {num: -41, bool: true}),
                   (:E {num: 7054, bool: false})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:C {num: -30, bool: false})"},
                {"a": "(:B {num: 5, bool: false})"},
                {"a": "(:E {num: 7054, bool: false})"},
                {"a": "(:A {num: 9, bool: true})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression evaluation are not supported",
        tags=("with", "orderby", "limit", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby3-2-5",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy3.feature",
        scenario="[2] Sort by two expressions, first in ascending order, second in descending order (sort=a.bool ASCENDING, a.num DESC)",
        cypher="MATCH (a)\nWITH a\n  ORDER BY a.bool ASCENDING, a.num DESC\n  LIMIT 4\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {num: 9, bool: true}),
                   (:B {num: 5, bool: false}),
                   (:C {num: -30, bool: false}),
                   (:D {num: -41, bool: true}),
                   (:E {num: 7054, bool: false})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:C {num: -30, bool: false})"},
                {"a": "(:B {num: 5, bool: false})"},
                {"a": "(:E {num: 7054, bool: false})"},
                {"a": "(:A {num: 9, bool: true})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression evaluation are not supported",
        tags=("with", "orderby", "limit", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby3-2-6",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy3.feature",
        scenario="[2] Sort by two expressions, first in ascending order, second in descending order (sort=a.bool ASCENDING, a.num DESCENDING)",
        cypher="MATCH (a)\nWITH a\n  ORDER BY a.bool ASCENDING, a.num DESCENDING\n  LIMIT 4\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {num: 9, bool: true}),
                   (:B {num: 5, bool: false}),
                   (:C {num: -30, bool: false}),
                   (:D {num: -41, bool: true}),
                   (:E {num: 7054, bool: false})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:C {num: -30, bool: false})"},
                {"a": "(:B {num: 5, bool: false})"},
                {"a": "(:E {num: 7054, bool: false})"},
                {"a": "(:A {num: 9, bool: true})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression evaluation are not supported",
        tags=("with", "orderby", "limit", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby3-3-1",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy3.feature",
        scenario="[3] Sort by two expressions, first in descending order, second in ascending order (sort=a.bool DESC, a.num)",
        cypher="MATCH (a)\nWITH a\n  ORDER BY a.bool DESC, a.num\n  LIMIT 4\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {num: 9, bool: true}),
                   (:B {num: 5, bool: false}),
                   (:C {num: -30, bool: false}),
                   (:D {num: -41, bool: true}),
                   (:E {num: 7054, bool: false})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:D {num: -41, bool: true})"},
                {"a": "(:A {num: 9, bool: true})"},
                {"a": "(:C {num: -30, bool: false})"},
                {"a": "(:B {num: 5, bool: false})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression evaluation are not supported",
        tags=("with", "orderby", "limit", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby3-3-2",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy3.feature",
        scenario="[3] Sort by two expressions, first in descending order, second in ascending order (sort=a.bool DESC, a.num ASC)",
        cypher="MATCH (a)\nWITH a\n  ORDER BY a.bool DESC, a.num ASC\n  LIMIT 4\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {num: 9, bool: true}),
                   (:B {num: 5, bool: false}),
                   (:C {num: -30, bool: false}),
                   (:D {num: -41, bool: true}),
                   (:E {num: 7054, bool: false})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:D {num: -41, bool: true})"},
                {"a": "(:A {num: 9, bool: true})"},
                {"a": "(:C {num: -30, bool: false})"},
                {"a": "(:B {num: 5, bool: false})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression evaluation are not supported",
        tags=("with", "orderby", "limit", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby3-3-3",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy3.feature",
        scenario="[3] Sort by two expressions, first in descending order, second in ascending order (sort=a.bool DESC, a.num ASCENDING)",
        cypher="MATCH (a)\nWITH a\n  ORDER BY a.bool DESC, a.num ASCENDING\n  LIMIT 4\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {num: 9, bool: true}),
                   (:B {num: 5, bool: false}),
                   (:C {num: -30, bool: false}),
                   (:D {num: -41, bool: true}),
                   (:E {num: 7054, bool: false})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:D {num: -41, bool: true})"},
                {"a": "(:A {num: 9, bool: true})"},
                {"a": "(:C {num: -30, bool: false})"},
                {"a": "(:B {num: 5, bool: false})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression evaluation are not supported",
        tags=("with", "orderby", "limit", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby3-3-4",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy3.feature",
        scenario="[3] Sort by two expressions, first in descending order, second in ascending order (sort=a.bool DESCENDING, a.num)",
        cypher="MATCH (a)\nWITH a\n  ORDER BY a.bool DESCENDING, a.num\n  LIMIT 4\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {num: 9, bool: true}),
                   (:B {num: 5, bool: false}),
                   (:C {num: -30, bool: false}),
                   (:D {num: -41, bool: true}),
                   (:E {num: 7054, bool: false})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:D {num: -41, bool: true})"},
                {"a": "(:A {num: 9, bool: true})"},
                {"a": "(:C {num: -30, bool: false})"},
                {"a": "(:B {num: 5, bool: false})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression evaluation are not supported",
        tags=("with", "orderby", "limit", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby3-3-5",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy3.feature",
        scenario="[3] Sort by two expressions, first in descending order, second in ascending order (sort=a.bool DESCENDING, a.num ASC)",
        cypher="MATCH (a)\nWITH a\n  ORDER BY a.bool DESCENDING, a.num ASC\n  LIMIT 4\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {num: 9, bool: true}),
                   (:B {num: 5, bool: false}),
                   (:C {num: -30, bool: false}),
                   (:D {num: -41, bool: true}),
                   (:E {num: 7054, bool: false})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:D {num: -41, bool: true})"},
                {"a": "(:A {num: 9, bool: true})"},
                {"a": "(:C {num: -30, bool: false})"},
                {"a": "(:B {num: 5, bool: false})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression evaluation are not supported",
        tags=("with", "orderby", "limit", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby3-3-6",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy3.feature",
        scenario="[3] Sort by two expressions, first in descending order, second in ascending order (sort=a.bool DESCENDING, a.num ASCENDING)",
        cypher="MATCH (a)\nWITH a\n  ORDER BY a.bool DESCENDING, a.num ASCENDING\n  LIMIT 4\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {num: 9, bool: true}),
                   (:B {num: 5, bool: false}),
                   (:C {num: -30, bool: false}),
                   (:D {num: -41, bool: true}),
                   (:E {num: 7054, bool: false})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:D {num: -41, bool: true})"},
                {"a": "(:A {num: 9, bool: true})"},
                {"a": "(:C {num: -30, bool: false})"},
                {"a": "(:B {num: 5, bool: false})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression evaluation are not supported",
        tags=("with", "orderby", "limit", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby3-4-1",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy3.feature",
        scenario="[4] Sort by two expressions, both in descending order (sort=a.bool DESC, a.num DESC)",
        cypher="MATCH (a)\nWITH a\n  ORDER BY a.bool DESC, a.num DESC\n  LIMIT 4\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {num: 9, bool: true}),
                   (:B {num: 5, bool: false}),
                   (:C {num: -30, bool: false}),
                   (:D {num: -41, bool: true}),
                   (:E {num: 7054, bool: false})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:A {num: 9, bool: true})"},
                {"a": "(:D {num: -41, bool: true})"},
                {"a": "(:E {num: 7054, bool: false})"},
                {"a": "(:B {num: 5, bool: false})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression evaluation are not supported",
        tags=("with", "orderby", "limit", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby3-4-2",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy3.feature",
        scenario="[4] Sort by two expressions, both in descending order (sort=a.bool DESC, a.num DESCENDING)",
        cypher="MATCH (a)\nWITH a\n  ORDER BY a.bool DESC, a.num DESCENDING\n  LIMIT 4\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {num: 9, bool: true}),
                   (:B {num: 5, bool: false}),
                   (:C {num: -30, bool: false}),
                   (:D {num: -41, bool: true}),
                   (:E {num: 7054, bool: false})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:A {num: 9, bool: true})"},
                {"a": "(:D {num: -41, bool: true})"},
                {"a": "(:E {num: 7054, bool: false})"},
                {"a": "(:B {num: 5, bool: false})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression evaluation are not supported",
        tags=("with", "orderby", "limit", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby3-4-3",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy3.feature",
        scenario="[4] Sort by two expressions, both in descending order (sort=a.bool DESCENDING, a.num DESC)",
        cypher="MATCH (a)\nWITH a\n  ORDER BY a.bool DESCENDING, a.num DESC\n  LIMIT 4\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {num: 9, bool: true}),
                   (:B {num: 5, bool: false}),
                   (:C {num: -30, bool: false}),
                   (:D {num: -41, bool: true}),
                   (:E {num: 7054, bool: false})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:A {num: 9, bool: true})"},
                {"a": "(:D {num: -41, bool: true})"},
                {"a": "(:E {num: 7054, bool: false})"},
                {"a": "(:B {num: 5, bool: false})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression evaluation are not supported",
        tags=("with", "orderby", "limit", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby3-4-4",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy3.feature",
        scenario="[4] Sort by two expressions, both in descending order (sort=a.bool DESCENDING, a.num DESCENDING)",
        cypher="MATCH (a)\nWITH a\n  ORDER BY a.bool DESCENDING, a.num DESCENDING\n  LIMIT 4\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {num: 9, bool: true}),
                   (:B {num: 5, bool: false}),
                   (:C {num: -30, bool: false}),
                   (:D {num: -41, bool: true}),
                   (:E {num: 7054, bool: false})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:A {num: 9, bool: true})"},
                {"a": "(:D {num: -41, bool: true})"},
                {"a": "(:E {num: 7054, bool: false})"},
                {"a": "(:B {num: 5, bool: false})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression evaluation are not supported",
        tags=("with", "orderby", "limit", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby3-5-1",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy3.feature",
        scenario="[5] An expression without explicit sort direction is sorted in ascending order (sort=a.num % 2 ASC, a.num, a.text ASC)",
        cypher="MATCH (a)\nWITH a\n  ORDER BY a.num % 2 ASC, a.num, a.text ASC\n  LIMIT 1\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE ({num: 3, text: 'a'}),
                   ({num: 3, text: 'b'}),
                   ({num: 1, text: 'a'}),
                   ({num: 1, text: 'b'}),
                   ({num: 2, text: 'a'}),
                   ({num: 2, text: 'b'}),
                   ({num: 4, text: 'a'}),
                   ({num: 4, text: 'b'})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "({num: 2, text: 'a'})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression evaluation are not supported",
        tags=("with", "orderby", "limit", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby3-5-2",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy3.feature",
        scenario="[5] An expression without explicit sort direction is sorted in ascending order (sort=a.num % 2 ASC, a.num, a.text DESC)",
        cypher="MATCH (a)\nWITH a\n  ORDER BY a.num % 2 ASC, a.num, a.text DESC\n  LIMIT 1\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE ({num: 3, text: 'a'}),
                   ({num: 3, text: 'b'}),
                   ({num: 1, text: 'a'}),
                   ({num: 1, text: 'b'}),
                   ({num: 2, text: 'a'}),
                   ({num: 2, text: 'b'}),
                   ({num: 4, text: 'a'}),
                   ({num: 4, text: 'b'})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "({num: 2, text: 'b'})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression evaluation are not supported",
        tags=("with", "orderby", "limit", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby3-5-3",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy3.feature",
        scenario="[5] An expression without explicit sort direction is sorted in ascending order (sort=a.num % 2 DESC, a.num, a.text DESC)",
        cypher="MATCH (a)\nWITH a\n  ORDER BY a.num % 2 DESC, a.num, a.text DESC\n  LIMIT 1\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE ({num: 3, text: 'a'}),
                   ({num: 3, text: 'b'}),
                   ({num: 1, text: 'a'}),
                   ({num: 1, text: 'b'}),
                   ({num: 2, text: 'a'}),
                   ({num: 2, text: 'b'}),
                   ({num: 4, text: 'a'}),
                   ({num: 4, text: 'b'})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "({num: 1, text: 'b'})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression evaluation are not supported",
        tags=("with", "orderby", "limit", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby3-5-4",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy3.feature",
        scenario="[5] An expression without explicit sort direction is sorted in ascending order (sort=a.num % 2 DESC, a.num, a.text ASC)",
        cypher="MATCH (a)\nWITH a\n  ORDER BY a.num % 2 DESC, a.num, a.text ASC\n  LIMIT 1\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE ({num: 3, text: 'a'}),
                   ({num: 3, text: 'b'}),
                   ({num: 1, text: 'a'}),
                   ({num: 1, text: 'b'}),
                   ({num: 2, text: 'a'}),
                   ({num: 2, text: 'b'}),
                   ({num: 4, text: 'a'}),
                   ({num: 4, text: 'b'})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "({num: 1, text: 'a'})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression evaluation are not supported",
        tags=("with", "orderby", "limit", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby3-6-1",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy3.feature",
        scenario="[6] An constant expression does not influence the order determined by other expression before and after the constant expression (sort=4 + ((a.num * 2) % 2) ASC, a.num ASC, a.text ASC)",
        cypher="MATCH (a)\nWITH a\n  ORDER BY 4 + ((a.num * 2) % 2) ASC, a.num ASC, a.text ASC\n  LIMIT 1\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE ({num: 3, text: 'a'}),
                   ({num: 3, text: 'b'}),
                   ({num: 1, text: 'a'}),
                   ({num: 1, text: 'b'}),
                   ({num: 2, text: 'a'}),
                   ({num: 2, text: 'b'}),
                   ({num: 4, text: 'a'}),
                   ({num: 4, text: 'b'})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "({num: 1, text: 'a'})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression evaluation are not supported",
        tags=("with", "orderby", "limit", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby3-6-2",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy3.feature",
        scenario="[6] An constant expression does not influence the order determined by other expression before and after the constant expression (sort=4 + ((a.num * 2) % 2) DESC, a.num ASC, a.text ASC)",
        cypher="MATCH (a)\nWITH a\n  ORDER BY 4 + ((a.num * 2) % 2) DESC, a.num ASC, a.text ASC\n  LIMIT 1\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE ({num: 3, text: 'a'}),
                   ({num: 3, text: 'b'}),
                   ({num: 1, text: 'a'}),
                   ({num: 1, text: 'b'}),
                   ({num: 2, text: 'a'}),
                   ({num: 2, text: 'b'}),
                   ({num: 4, text: 'a'}),
                   ({num: 4, text: 'b'})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "({num: 1, text: 'a'})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression evaluation are not supported",
        tags=("with", "orderby", "limit", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby3-6-3",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy3.feature",
        scenario="[6] An constant expression does not influence the order determined by other expression before and after the constant expression (sort=a.num ASC, 4 + ((a.num * 2) % 2) ASC, a.text ASC)",
        cypher="MATCH (a)\nWITH a\n  ORDER BY a.num ASC, 4 + ((a.num * 2) % 2) ASC, a.text ASC\n  LIMIT 1\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE ({num: 3, text: 'a'}),
                   ({num: 3, text: 'b'}),
                   ({num: 1, text: 'a'}),
                   ({num: 1, text: 'b'}),
                   ({num: 2, text: 'a'}),
                   ({num: 2, text: 'b'}),
                   ({num: 4, text: 'a'}),
                   ({num: 4, text: 'b'})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "({num: 1, text: 'a'})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression evaluation are not supported",
        tags=("with", "orderby", "limit", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby3-6-4",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy3.feature",
        scenario="[6] An constant expression does not influence the order determined by other expression before and after the constant expression (sort=a.num ASC, 4 + ((a.num * 2) % 2) DESC, a.text ASC)",
        cypher="MATCH (a)\nWITH a\n  ORDER BY a.num ASC, 4 + ((a.num * 2) % 2) DESC, a.text ASC\n  LIMIT 1\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE ({num: 3, text: 'a'}),
                   ({num: 3, text: 'b'}),
                   ({num: 1, text: 'a'}),
                   ({num: 1, text: 'b'}),
                   ({num: 2, text: 'a'}),
                   ({num: 2, text: 'b'}),
                   ({num: 4, text: 'a'}),
                   ({num: 4, text: 'b'})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "({num: 1, text: 'a'})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression evaluation are not supported",
        tags=("with", "orderby", "limit", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby3-6-5",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy3.feature",
        scenario="[6] An constant expression does not influence the order determined by other expression before and after the constant expression (sort=a.num ASC, a.text ASC, 4 + ((a.num * 2) % 2) ASC)",
        cypher="MATCH (a)\nWITH a\n  ORDER BY a.num ASC, a.text ASC, 4 + ((a.num * 2) % 2) ASC\n  LIMIT 1\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE ({num: 3, text: 'a'}),
                   ({num: 3, text: 'b'}),
                   ({num: 1, text: 'a'}),
                   ({num: 1, text: 'b'}),
                   ({num: 2, text: 'a'}),
                   ({num: 2, text: 'b'}),
                   ({num: 4, text: 'a'}),
                   ({num: 4, text: 'b'})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "({num: 1, text: 'a'})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression evaluation are not supported",
        tags=("with", "orderby", "limit", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby3-6-6",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy3.feature",
        scenario="[6] An constant expression does not influence the order determined by other expression before and after the constant expression (sort=a.num ASC, a.text ASC, 4 + ((a.num * 2) % 2) DESC)",
        cypher="MATCH (a)\nWITH a\n  ORDER BY a.num ASC, a.text ASC, 4 + ((a.num * 2) % 2) DESC\n  LIMIT 1\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE ({num: 3, text: 'a'}),
                   ({num: 3, text: 'b'}),
                   ({num: 1, text: 'a'}),
                   ({num: 1, text: 'b'}),
                   ({num: 2, text: 'a'}),
                   ({num: 2, text: 'b'}),
                   ({num: 4, text: 'a'}),
                   ({num: 4, text: 'b'})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "({num: 1, text: 'a'})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression evaluation are not supported",
        tags=("with", "orderby", "limit", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby3-6-7",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy3.feature",
        scenario="[6] An constant expression does not influence the order determined by other expression before and after the constant expression (sort=4 + ((a.num * 2) % 2) ASC, a.num ASC, a.text DESC)",
        cypher="MATCH (a)\nWITH a\n  ORDER BY 4 + ((a.num * 2) % 2) ASC, a.num ASC, a.text DESC\n  LIMIT 1\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE ({num: 3, text: 'a'}),
                   ({num: 3, text: 'b'}),
                   ({num: 1, text: 'a'}),
                   ({num: 1, text: 'b'}),
                   ({num: 2, text: 'a'}),
                   ({num: 2, text: 'b'}),
                   ({num: 4, text: 'a'}),
                   ({num: 4, text: 'b'})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "({num: 1, text: 'b'})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression evaluation are not supported",
        tags=("with", "orderby", "limit", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby3-6-8",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy3.feature",
        scenario="[6] An constant expression does not influence the order determined by other expression before and after the constant expression (sort=4 + ((a.num * 2) % 2) DESC, a.num ASC, a.text DESC)",
        cypher="MATCH (a)\nWITH a\n  ORDER BY 4 + ((a.num * 2) % 2) DESC, a.num ASC, a.text DESC\n  LIMIT 1\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE ({num: 3, text: 'a'}),
                   ({num: 3, text: 'b'}),
                   ({num: 1, text: 'a'}),
                   ({num: 1, text: 'b'}),
                   ({num: 2, text: 'a'}),
                   ({num: 2, text: 'b'}),
                   ({num: 4, text: 'a'}),
                   ({num: 4, text: 'b'})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "({num: 1, text: 'b'})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression evaluation are not supported",
        tags=("with", "orderby", "limit", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby3-6-9",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy3.feature",
        scenario="[6] An constant expression does not influence the order determined by other expression before and after the constant expression (sort=a.num ASC, 4 + ((a.num * 2) % 2) ASC, a.text DESC)",
        cypher="MATCH (a)\nWITH a\n  ORDER BY a.num ASC, 4 + ((a.num * 2) % 2) ASC, a.text DESC\n  LIMIT 1\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE ({num: 3, text: 'a'}),
                   ({num: 3, text: 'b'}),
                   ({num: 1, text: 'a'}),
                   ({num: 1, text: 'b'}),
                   ({num: 2, text: 'a'}),
                   ({num: 2, text: 'b'}),
                   ({num: 4, text: 'a'}),
                   ({num: 4, text: 'b'})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "({num: 1, text: 'b'})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression evaluation are not supported",
        tags=("with", "orderby", "limit", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby3-6-10",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy3.feature",
        scenario="[6] An constant expression does not influence the order determined by other expression before and after the constant expression (sort=a.num ASC, 4 + ((a.num * 2) % 2) DESC, a.text DESC)",
        cypher="MATCH (a)\nWITH a\n  ORDER BY a.num ASC, 4 + ((a.num * 2) % 2) DESC, a.text DESC\n  LIMIT 1\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE ({num: 3, text: 'a'}),
                   ({num: 3, text: 'b'}),
                   ({num: 1, text: 'a'}),
                   ({num: 1, text: 'b'}),
                   ({num: 2, text: 'a'}),
                   ({num: 2, text: 'b'}),
                   ({num: 4, text: 'a'}),
                   ({num: 4, text: 'b'})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "({num: 1, text: 'b'})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression evaluation are not supported",
        tags=("with", "orderby", "limit", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby3-6-11",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy3.feature",
        scenario="[6] An constant expression does not influence the order determined by other expression before and after the constant expression (sort=a.num ASC, a.text DESC, 4 + ((a.num * 2) % 2) ASC)",
        cypher="MATCH (a)\nWITH a\n  ORDER BY a.num ASC, a.text DESC, 4 + ((a.num * 2) % 2) ASC\n  LIMIT 1\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE ({num: 3, text: 'a'}),
                   ({num: 3, text: 'b'}),
                   ({num: 1, text: 'a'}),
                   ({num: 1, text: 'b'}),
                   ({num: 2, text: 'a'}),
                   ({num: 2, text: 'b'}),
                   ({num: 4, text: 'a'}),
                   ({num: 4, text: 'b'})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "({num: 1, text: 'b'})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression evaluation are not supported",
        tags=("with", "orderby", "limit", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby3-6-12",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy3.feature",
        scenario="[6] An constant expression does not influence the order determined by other expression before and after the constant expression (sort=a.num ASC, a.text DESC, 4 + ((a.num * 2) % 2) DESC)",
        cypher="MATCH (a)\nWITH a\n  ORDER BY a.num ASC, a.text DESC, 4 + ((a.num * 2) % 2) DESC\n  LIMIT 1\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE ({num: 3, text: 'a'}),
                   ({num: 3, text: 'b'}),
                   ({num: 1, text: 'a'}),
                   ({num: 1, text: 'b'}),
                   ({num: 2, text: 'a'}),
                   ({num: 2, text: 'b'}),
                   ({num: 4, text: 'a'}),
                   ({num: 4, text: 'b'})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "({num: 1, text: 'b'})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression evaluation are not supported",
        tags=("with", "orderby", "limit", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby3-6-13",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy3.feature",
        scenario="[6] An constant expression does not influence the order determined by other expression before and after the constant expression (sort=4 + ((a.num * 2) % 2) ASC, a.num DESC, a.text DESC)",
        cypher="MATCH (a)\nWITH a\n  ORDER BY 4 + ((a.num * 2) % 2) ASC, a.num DESC, a.text DESC\n  LIMIT 1\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE ({num: 3, text: 'a'}),
                   ({num: 3, text: 'b'}),
                   ({num: 1, text: 'a'}),
                   ({num: 1, text: 'b'}),
                   ({num: 2, text: 'a'}),
                   ({num: 2, text: 'b'}),
                   ({num: 4, text: 'a'}),
                   ({num: 4, text: 'b'})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "({num: 4, text: 'b'})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression evaluation are not supported",
        tags=("with", "orderby", "limit", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby3-6-14",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy3.feature",
        scenario="[6] An constant expression does not influence the order determined by other expression before and after the constant expression (sort=4 + ((a.num * 2) % 2) DESC, a.num DESC, a.text DESC)",
        cypher="MATCH (a)\nWITH a\n  ORDER BY 4 + ((a.num * 2) % 2) DESC, a.num DESC, a.text DESC\n  LIMIT 1\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE ({num: 3, text: 'a'}),
                   ({num: 3, text: 'b'}),
                   ({num: 1, text: 'a'}),
                   ({num: 1, text: 'b'}),
                   ({num: 2, text: 'a'}),
                   ({num: 2, text: 'b'}),
                   ({num: 4, text: 'a'}),
                   ({num: 4, text: 'b'})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "({num: 4, text: 'b'})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression evaluation are not supported",
        tags=("with", "orderby", "limit", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby3-6-15",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy3.feature",
        scenario="[6] An constant expression does not influence the order determined by other expression before and after the constant expression (sort=a.num DESC, 4 + ((a.num * 2) % 2) ASC, a.text DESC)",
        cypher="MATCH (a)\nWITH a\n  ORDER BY a.num DESC, 4 + ((a.num * 2) % 2) ASC, a.text DESC\n  LIMIT 1\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE ({num: 3, text: 'a'}),
                   ({num: 3, text: 'b'}),
                   ({num: 1, text: 'a'}),
                   ({num: 1, text: 'b'}),
                   ({num: 2, text: 'a'}),
                   ({num: 2, text: 'b'}),
                   ({num: 4, text: 'a'}),
                   ({num: 4, text: 'b'})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "({num: 4, text: 'b'})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression evaluation are not supported",
        tags=("with", "orderby", "limit", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby3-6-16",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy3.feature",
        scenario="[6] An constant expression does not influence the order determined by other expression before and after the constant expression (sort=a.num DESC, 4 + ((a.num * 2) % 2) DESC, a.text DESC)",
        cypher="MATCH (a)\nWITH a\n  ORDER BY a.num DESC, 4 + ((a.num * 2) % 2) DESC, a.text DESC\n  LIMIT 1\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE ({num: 3, text: 'a'}),
                   ({num: 3, text: 'b'}),
                   ({num: 1, text: 'a'}),
                   ({num: 1, text: 'b'}),
                   ({num: 2, text: 'a'}),
                   ({num: 2, text: 'b'}),
                   ({num: 4, text: 'a'}),
                   ({num: 4, text: 'b'})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "({num: 4, text: 'b'})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression evaluation are not supported",
        tags=("with", "orderby", "limit", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby3-6-17",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy3.feature",
        scenario="[6] An constant expression does not influence the order determined by other expression before and after the constant expression (sort=a.num DESC, a.text DESC, 4 + ((a.num * 2) % 2) ASC)",
        cypher="MATCH (a)\nWITH a\n  ORDER BY a.num DESC, a.text DESC, 4 + ((a.num * 2) % 2) ASC\n  LIMIT 1\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE ({num: 3, text: 'a'}),
                   ({num: 3, text: 'b'}),
                   ({num: 1, text: 'a'}),
                   ({num: 1, text: 'b'}),
                   ({num: 2, text: 'a'}),
                   ({num: 2, text: 'b'}),
                   ({num: 4, text: 'a'}),
                   ({num: 4, text: 'b'})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "({num: 4, text: 'b'})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression evaluation are not supported",
        tags=("with", "orderby", "limit", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby3-6-18",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy3.feature",
        scenario="[6] An constant expression does not influence the order determined by other expression before and after the constant expression (sort=a.num DESC, a.text DESC, 4 + ((a.num * 2) % 2) DESC)",
        cypher="MATCH (a)\nWITH a\n  ORDER BY a.num DESC, a.text DESC, 4 + ((a.num * 2) % 2) DESC\n  LIMIT 1\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE ({num: 3, text: 'a'}),
                   ({num: 3, text: 'b'}),
                   ({num: 1, text: 'a'}),
                   ({num: 1, text: 'b'}),
                   ({num: 2, text: 'a'}),
                   ({num: 2, text: 'b'}),
                   ({num: 4, text: 'a'}),
                   ({num: 4, text: 'b'})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "({num: 4, text: 'b'})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression evaluation are not supported",
        tags=("with", "orderby", "limit", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby3-6-19",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy3.feature",
        scenario="[6] An constant expression does not influence the order determined by other expression before and after the constant expression (sort=4 + ((a.num * 2) % 2) ASC, a.num DESC, a.text ASC)",
        cypher="MATCH (a)\nWITH a\n  ORDER BY 4 + ((a.num * 2) % 2) ASC, a.num DESC, a.text ASC\n  LIMIT 1\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE ({num: 3, text: 'a'}),
                   ({num: 3, text: 'b'}),
                   ({num: 1, text: 'a'}),
                   ({num: 1, text: 'b'}),
                   ({num: 2, text: 'a'}),
                   ({num: 2, text: 'b'}),
                   ({num: 4, text: 'a'}),
                   ({num: 4, text: 'b'})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "({num: 4, text: 'a'})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression evaluation are not supported",
        tags=("with", "orderby", "limit", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby3-6-20",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy3.feature",
        scenario="[6] An constant expression does not influence the order determined by other expression before and after the constant expression (sort=4 + ((a.num * 2) % 2) DESC, a.num DESC, a.text ASC)",
        cypher="MATCH (a)\nWITH a\n  ORDER BY 4 + ((a.num * 2) % 2) DESC, a.num DESC, a.text ASC\n  LIMIT 1\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE ({num: 3, text: 'a'}),
                   ({num: 3, text: 'b'}),
                   ({num: 1, text: 'a'}),
                   ({num: 1, text: 'b'}),
                   ({num: 2, text: 'a'}),
                   ({num: 2, text: 'b'}),
                   ({num: 4, text: 'a'}),
                   ({num: 4, text: 'b'})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "({num: 4, text: 'a'})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression evaluation are not supported",
        tags=("with", "orderby", "limit", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby3-6-21",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy3.feature",
        scenario="[6] An constant expression does not influence the order determined by other expression before and after the constant expression (sort=a.num DESC, 4 + ((a.num * 2) % 2) ASC, a.text ASC)",
        cypher="MATCH (a)\nWITH a\n  ORDER BY a.num DESC, 4 + ((a.num * 2) % 2) ASC, a.text ASC\n  LIMIT 1\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE ({num: 3, text: 'a'}),
                   ({num: 3, text: 'b'}),
                   ({num: 1, text: 'a'}),
                   ({num: 1, text: 'b'}),
                   ({num: 2, text: 'a'}),
                   ({num: 2, text: 'b'}),
                   ({num: 4, text: 'a'}),
                   ({num: 4, text: 'b'})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "({num: 4, text: 'a'})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression evaluation are not supported",
        tags=("with", "orderby", "limit", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby3-6-22",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy3.feature",
        scenario="[6] An constant expression does not influence the order determined by other expression before and after the constant expression (sort=a.num DESC, 4 + ((a.num * 2) % 2) DESC, a.text ASC)",
        cypher="MATCH (a)\nWITH a\n  ORDER BY a.num DESC, 4 + ((a.num * 2) % 2) DESC, a.text ASC\n  LIMIT 1\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE ({num: 3, text: 'a'}),
                   ({num: 3, text: 'b'}),
                   ({num: 1, text: 'a'}),
                   ({num: 1, text: 'b'}),
                   ({num: 2, text: 'a'}),
                   ({num: 2, text: 'b'}),
                   ({num: 4, text: 'a'}),
                   ({num: 4, text: 'b'})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "({num: 4, text: 'a'})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression evaluation are not supported",
        tags=("with", "orderby", "limit", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby3-6-23",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy3.feature",
        scenario="[6] An constant expression does not influence the order determined by other expression before and after the constant expression (sort=a.num DESC, a.text ASC, 4 + ((a.num * 2) % 2) ASC)",
        cypher="MATCH (a)\nWITH a\n  ORDER BY a.num DESC, a.text ASC, 4 + ((a.num * 2) % 2) ASC\n  LIMIT 1\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE ({num: 3, text: 'a'}),
                   ({num: 3, text: 'b'}),
                   ({num: 1, text: 'a'}),
                   ({num: 1, text: 'b'}),
                   ({num: 2, text: 'a'}),
                   ({num: 2, text: 'b'}),
                   ({num: 4, text: 'a'}),
                   ({num: 4, text: 'b'})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "({num: 4, text: 'a'})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression evaluation are not supported",
        tags=("with", "orderby", "limit", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby3-6-24",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy3.feature",
        scenario="[6] An constant expression does not influence the order determined by other expression before and after the constant expression (sort=a.num DESC, a.text ASC, 4 + ((a.num * 2) % 2) DESC)",
        cypher="MATCH (a)\nWITH a\n  ORDER BY a.num DESC, a.text ASC, 4 + ((a.num * 2) % 2) DESC\n  LIMIT 1\nRETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE ({num: 3, text: 'a'}),
                   ({num: 3, text: 'b'}),
                   ({num: 1, text: 'a'}),
                   ({num: 1, text: 'b'}),
                   ({num: 2, text: 'a'}),
                   ({num: 2, text: 'b'}),
                   ({num: 4, text: 'a'}),
                   ({num: 4, text: 'b'})
            """
        ),
        expected=Expected(
            rows=[
                {"a": "({num: 4, text: 'a'})"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, ORDER BY, LIMIT, and expression evaluation are not supported",
        tags=("with", "orderby", "limit", "expression", "xfail"),
    ),
    Scenario(
        key="with-orderby3-7-1",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy3.feature",
        scenario="[7] The order direction cannot be overwritten (sort=a ASC, a DESC)",
        cypher="UNWIND [1, 2, 3] AS a\nWITH a\n  ORDER BY a ASC, a DESC\n  LIMIT 1\nRETURN a",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"a": 1},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, UNWIND, ORDER BY, and LIMIT are not supported",
        tags=("with", "orderby", "unwind", "limit", "xfail"),
    ),
    Scenario(
        key="with-orderby3-7-2",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy3.feature",
        scenario="[7] The order direction cannot be overwritten (sort=a + 2 ASC, a + 2 DESC)",
        cypher="UNWIND [1, 2, 3] AS a\nWITH a\n  ORDER BY a + 2 ASC, a + 2 DESC\n  LIMIT 1\nRETURN a",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"a": 1},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, UNWIND, ORDER BY, and LIMIT are not supported",
        tags=("with", "orderby", "unwind", "limit", "xfail"),
    ),
    Scenario(
        key="with-orderby3-7-3",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy3.feature",
        scenario="[7] The order direction cannot be overwritten (sort=a * a ASC, a * a DESC)",
        cypher="UNWIND [1, 2, 3] AS a\nWITH a\n  ORDER BY a * a ASC, a * a DESC\n  LIMIT 1\nRETURN a",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"a": 1},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, UNWIND, ORDER BY, and LIMIT are not supported",
        tags=("with", "orderby", "unwind", "limit", "xfail"),
    ),
    Scenario(
        key="with-orderby3-7-4",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy3.feature",
        scenario="[7] The order direction cannot be overwritten (sort=a ASC, -1 * a ASC)",
        cypher="UNWIND [1, 2, 3] AS a\nWITH a\n  ORDER BY a ASC, -1 * a ASC\n  LIMIT 1\nRETURN a",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"a": 1},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, UNWIND, ORDER BY, and LIMIT are not supported",
        tags=("with", "orderby", "unwind", "limit", "xfail"),
    ),
    Scenario(
        key="with-orderby3-7-5",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy3.feature",
        scenario="[7] The order direction cannot be overwritten (sort=-1 * a DESC, a ASC)",
        cypher="UNWIND [1, 2, 3] AS a\nWITH a\n  ORDER BY -1 * a DESC, a ASC\n  LIMIT 1\nRETURN a",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"a": 1},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, UNWIND, ORDER BY, and LIMIT are not supported",
        tags=("with", "orderby", "unwind", "limit", "xfail"),
    ),
    Scenario(
        key="with-orderby3-7-6",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy3.feature",
        scenario="[7] The order direction cannot be overwritten (sort=a DESC, a ASC)",
        cypher="UNWIND [1, 2, 3] AS a\nWITH a\n  ORDER BY a DESC, a ASC\n  LIMIT 1\nRETURN a",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"a": 3},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, UNWIND, ORDER BY, and LIMIT are not supported",
        tags=("with", "orderby", "unwind", "limit", "xfail"),
    ),
    Scenario(
        key="with-orderby3-7-7",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy3.feature",
        scenario="[7] The order direction cannot be overwritten (sort=a + 2 DESC, a + 2 ASC)",
        cypher="UNWIND [1, 2, 3] AS a\nWITH a\n  ORDER BY a + 2 DESC, a + 2 ASC\n  LIMIT 1\nRETURN a",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"a": 3},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, UNWIND, ORDER BY, and LIMIT are not supported",
        tags=("with", "orderby", "unwind", "limit", "xfail"),
    ),
    Scenario(
        key="with-orderby3-7-8",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy3.feature",
        scenario="[7] The order direction cannot be overwritten (sort=a * a DESC, a * a ASC)",
        cypher="UNWIND [1, 2, 3] AS a\nWITH a\n  ORDER BY a * a DESC, a * a ASC\n  LIMIT 1\nRETURN a",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"a": 3},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, UNWIND, ORDER BY, and LIMIT are not supported",
        tags=("with", "orderby", "unwind", "limit", "xfail"),
    ),
    Scenario(
        key="with-orderby3-7-9",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy3.feature",
        scenario="[7] The order direction cannot be overwritten (sort=a DESC, -1 * a DESC)",
        cypher="UNWIND [1, 2, 3] AS a\nWITH a\n  ORDER BY a DESC, -1 * a DESC\n  LIMIT 1\nRETURN a",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"a": 3},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, UNWIND, ORDER BY, and LIMIT are not supported",
        tags=("with", "orderby", "unwind", "limit", "xfail"),
    ),
    Scenario(
        key="with-orderby3-7-10",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy3.feature",
        scenario="[7] The order direction cannot be overwritten (sort=-1 * a ASC, a DESC)",
        cypher="UNWIND [1, 2, 3] AS a\nWITH a\n  ORDER BY -1 * a ASC, a DESC\n  LIMIT 1\nRETURN a",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"a": 3},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, UNWIND, ORDER BY, and LIMIT are not supported",
        tags=("with", "orderby", "unwind", "limit", "xfail"),
    ),
    Scenario(
        key="with-orderby3-8-1",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy3.feature",
        scenario="[8] Fail on sorting by any number of undefined variables in any position (example=out of scope, sort=a, c)",
        cypher="WITH 1 AS a, 'b' AS b, 3 AS c, true AS d\nWITH a, b\nWITH a\n  ORDER BY a, c\nRETURN a",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Compile-time validation for ORDER BY variable scoping is not enforced",
        tags=("with", "orderby", "syntax-error", "xfail"),
    ),
    Scenario(
        key="with-orderby3-8-2",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy3.feature",
        scenario="[8] Fail on sorting by any number of undefined variables in any position (example=out of scope, sort=a, c ASC)",
        cypher="WITH 1 AS a, 'b' AS b, 3 AS c, true AS d\nWITH a, b\nWITH a\n  ORDER BY a, c ASC\nRETURN a",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Compile-time validation for ORDER BY variable scoping is not enforced",
        tags=("with", "orderby", "syntax-error", "xfail"),
    ),
    Scenario(
        key="with-orderby3-8-3",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy3.feature",
        scenario="[8] Fail on sorting by any number of undefined variables in any position (example=out of scope, sort=a, c DESC)",
        cypher="WITH 1 AS a, 'b' AS b, 3 AS c, true AS d\nWITH a, b\nWITH a\n  ORDER BY a, c DESC\nRETURN a",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Compile-time validation for ORDER BY variable scoping is not enforced",
        tags=("with", "orderby", "syntax-error", "xfail"),
    ),
    Scenario(
        key="with-orderby3-8-4",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy3.feature",
        scenario="[8] Fail on sorting by any number of undefined variables in any position (example=out of scope, sort=a, c, d)",
        cypher="WITH 1 AS a, 'b' AS b, 3 AS c, true AS d\nWITH a, b\nWITH a\n  ORDER BY a, c, d\nRETURN a",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Compile-time validation for ORDER BY variable scoping is not enforced",
        tags=("with", "orderby", "syntax-error", "xfail"),
    ),
    Scenario(
        key="with-orderby3-8-5",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy3.feature",
        scenario="[8] Fail on sorting by any number of undefined variables in any position (example=out of scope, sort=a, c ASC, d)",
        cypher="WITH 1 AS a, 'b' AS b, 3 AS c, true AS d\nWITH a, b\nWITH a\n  ORDER BY a, c ASC, d\nRETURN a",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Compile-time validation for ORDER BY variable scoping is not enforced",
        tags=("with", "orderby", "syntax-error", "xfail"),
    ),
    Scenario(
        key="with-orderby3-8-6",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy3.feature",
        scenario="[8] Fail on sorting by any number of undefined variables in any position (example=out of scope, sort=a, c DESC, d)",
        cypher="WITH 1 AS a, 'b' AS b, 3 AS c, true AS d\nWITH a, b\nWITH a\n  ORDER BY a, c DESC, d\nRETURN a",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Compile-time validation for ORDER BY variable scoping is not enforced",
        tags=("with", "orderby", "syntax-error", "xfail"),
    ),
    Scenario(
        key="with-orderby3-8-7",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy3.feature",
        scenario="[8] Fail on sorting by any number of undefined variables in any position (example=out of scope, sort=c, a, d)",
        cypher="WITH 1 AS a, 'b' AS b, 3 AS c, true AS d\nWITH a, b\nWITH a\n  ORDER BY c, a, d\nRETURN a",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Compile-time validation for ORDER BY variable scoping is not enforced",
        tags=("with", "orderby", "syntax-error", "xfail"),
    ),
    Scenario(
        key="with-orderby3-8-8",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy3.feature",
        scenario="[8] Fail on sorting by any number of undefined variables in any position (example=out of scope, sort=c ASC, a, d)",
        cypher="WITH 1 AS a, 'b' AS b, 3 AS c, true AS d\nWITH a, b\nWITH a\n  ORDER BY c ASC, a, d\nRETURN a",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Compile-time validation for ORDER BY variable scoping is not enforced",
        tags=("with", "orderby", "syntax-error", "xfail"),
    ),
    Scenario(
        key="with-orderby3-8-9",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy3.feature",
        scenario="[8] Fail on sorting by any number of undefined variables in any position (example=out of scope, sort=c DESC, a, d)",
        cypher="WITH 1 AS a, 'b' AS b, 3 AS c, true AS d\nWITH a, b\nWITH a\n  ORDER BY c DESC, a, d\nRETURN a",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Compile-time validation for ORDER BY variable scoping is not enforced",
        tags=("with", "orderby", "syntax-error", "xfail"),
    ),
    Scenario(
        key="with-orderby3-8-10",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy3.feature",
        scenario="[8] Fail on sorting by any number of undefined variables in any position (example=out of scope, sort=c, d, a)",
        cypher="WITH 1 AS a, 'b' AS b, 3 AS c, true AS d\nWITH a, b\nWITH a\n  ORDER BY c, d, a\nRETURN a",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Compile-time validation for ORDER BY variable scoping is not enforced",
        tags=("with", "orderby", "syntax-error", "xfail"),
    ),
    Scenario(
        key="with-orderby3-8-11",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy3.feature",
        scenario="[8] Fail on sorting by any number of undefined variables in any position (example=out of scope, sort=b, c, d, a)",
        cypher="WITH 1 AS a, 'b' AS b, 3 AS c, true AS d\nWITH a, b\nWITH a\n  ORDER BY b, c, d, a\nRETURN a",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Compile-time validation for ORDER BY variable scoping is not enforced",
        tags=("with", "orderby", "syntax-error", "xfail"),
    ),
    Scenario(
        key="with-orderby3-8-12",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy3.feature",
        scenario="[8] Fail on sorting by any number of undefined variables in any position (example=out of scope, sort=c, b, c, d, a)",
        cypher="WITH 1 AS a, 'b' AS b, 3 AS c, true AS d\nWITH a, b\nWITH a\n  ORDER BY c, b, c, d, a\nRETURN a",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Compile-time validation for ORDER BY variable scoping is not enforced",
        tags=("with", "orderby", "syntax-error", "xfail"),
    ),
    Scenario(
        key="with-orderby3-8-13",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy3.feature",
        scenario="[8] Fail on sorting by any number of undefined variables in any position (example=out of scope, sort=c, d, b, b, d, c, a)",
        cypher="WITH 1 AS a, 'b' AS b, 3 AS c, true AS d\nWITH a, b\nWITH a\n  ORDER BY c, d, b, b, d, c, a\nRETURN a",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Compile-time validation for ORDER BY variable scoping is not enforced",
        tags=("with", "orderby", "syntax-error", "xfail"),
    ),
    Scenario(
        key="with-orderby3-8-14",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy3.feature",
        scenario="[8] Fail on sorting by any number of undefined variables in any position (example=never defined, sort=a, e)",
        cypher="WITH 1 AS a, 'b' AS b, 3 AS c, true AS d\nWITH a, b\nWITH a\n  ORDER BY a, e\nRETURN a",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Compile-time validation for ORDER BY variable scoping is not enforced",
        tags=("with", "orderby", "syntax-error", "xfail"),
    ),
    Scenario(
        key="with-orderby3-8-15",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy3.feature",
        scenario="[8] Fail on sorting by any number of undefined variables in any position (example=never defined, sort=a, e ASC)",
        cypher="WITH 1 AS a, 'b' AS b, 3 AS c, true AS d\nWITH a, b\nWITH a\n  ORDER BY a, e ASC\nRETURN a",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Compile-time validation for ORDER BY variable scoping is not enforced",
        tags=("with", "orderby", "syntax-error", "xfail"),
    ),
    Scenario(
        key="with-orderby3-8-16",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy3.feature",
        scenario="[8] Fail on sorting by any number of undefined variables in any position (example=never defined, sort=a, e DESC)",
        cypher="WITH 1 AS a, 'b' AS b, 3 AS c, true AS d\nWITH a, b\nWITH a\n  ORDER BY a, e DESC\nRETURN a",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Compile-time validation for ORDER BY variable scoping is not enforced",
        tags=("with", "orderby", "syntax-error", "xfail"),
    ),
    Scenario(
        key="with-orderby3-8-17",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy3.feature",
        scenario="[8] Fail on sorting by any number of undefined variables in any position (example=never defined, sort=a, e, f)",
        cypher="WITH 1 AS a, 'b' AS b, 3 AS c, true AS d\nWITH a, b\nWITH a\n  ORDER BY a, e, f\nRETURN a",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Compile-time validation for ORDER BY variable scoping is not enforced",
        tags=("with", "orderby", "syntax-error", "xfail"),
    ),
    Scenario(
        key="with-orderby3-8-18",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy3.feature",
        scenario="[8] Fail on sorting by any number of undefined variables in any position (example=never defined, sort=a, e ASC, f)",
        cypher="WITH 1 AS a, 'b' AS b, 3 AS c, true AS d\nWITH a, b\nWITH a\n  ORDER BY a, e ASC, f\nRETURN a",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Compile-time validation for ORDER BY variable scoping is not enforced",
        tags=("with", "orderby", "syntax-error", "xfail"),
    ),
    Scenario(
        key="with-orderby3-8-19",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy3.feature",
        scenario="[8] Fail on sorting by any number of undefined variables in any position (example=never defined, sort=a, e DESC, f)",
        cypher="WITH 1 AS a, 'b' AS b, 3 AS c, true AS d\nWITH a, b\nWITH a\n  ORDER BY a, e DESC, f\nRETURN a",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Compile-time validation for ORDER BY variable scoping is not enforced",
        tags=("with", "orderby", "syntax-error", "xfail"),
    ),
    Scenario(
        key="with-orderby3-8-20",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy3.feature",
        scenario="[8] Fail on sorting by any number of undefined variables in any position (example=never defined, sort=e, a, f)",
        cypher="WITH 1 AS a, 'b' AS b, 3 AS c, true AS d\nWITH a, b\nWITH a\n  ORDER BY e, a, f\nRETURN a",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Compile-time validation for ORDER BY variable scoping is not enforced",
        tags=("with", "orderby", "syntax-error", "xfail"),
    ),
    Scenario(
        key="with-orderby3-8-21",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy3.feature",
        scenario="[8] Fail on sorting by any number of undefined variables in any position (example=never defined, sort=e ASC, a, f)",
        cypher="WITH 1 AS a, 'b' AS b, 3 AS c, true AS d\nWITH a, b\nWITH a\n  ORDER BY e ASC, a, f\nRETURN a",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Compile-time validation for ORDER BY variable scoping is not enforced",
        tags=("with", "orderby", "syntax-error", "xfail"),
    ),
    Scenario(
        key="with-orderby3-8-22",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy3.feature",
        scenario="[8] Fail on sorting by any number of undefined variables in any position (example=never defined, sort=e DESC, a, f)",
        cypher="WITH 1 AS a, 'b' AS b, 3 AS c, true AS d\nWITH a, b\nWITH a\n  ORDER BY e DESC, a, f\nRETURN a",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Compile-time validation for ORDER BY variable scoping is not enforced",
        tags=("with", "orderby", "syntax-error", "xfail"),
    ),
    Scenario(
        key="with-orderby3-8-23",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy3.feature",
        scenario="[8] Fail on sorting by any number of undefined variables in any position (example=never defined, sort=e, f, a)",
        cypher="WITH 1 AS a, 'b' AS b, 3 AS c, true AS d\nWITH a, b\nWITH a\n  ORDER BY e, f, a\nRETURN a",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Compile-time validation for ORDER BY variable scoping is not enforced",
        tags=("with", "orderby", "syntax-error", "xfail"),
    ),
    Scenario(
        key="with-orderby3-8-24",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy3.feature",
        scenario="[8] Fail on sorting by any number of undefined variables in any position (example=never defined, sort=b, e, f, a)",
        cypher="WITH 1 AS a, 'b' AS b, 3 AS c, true AS d\nWITH a, b\nWITH a\n  ORDER BY b, e, f, a\nRETURN a",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Compile-time validation for ORDER BY variable scoping is not enforced",
        tags=("with", "orderby", "syntax-error", "xfail"),
    ),
    Scenario(
        key="with-orderby3-8-25",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy3.feature",
        scenario="[8] Fail on sorting by any number of undefined variables in any position (example=never defined, sort=e, b, e, f, a)",
        cypher="WITH 1 AS a, 'b' AS b, 3 AS c, true AS d\nWITH a, b\nWITH a\n  ORDER BY e, b, e, f, a\nRETURN a",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Compile-time validation for ORDER BY variable scoping is not enforced",
        tags=("with", "orderby", "syntax-error", "xfail"),
    ),
    Scenario(
        key="with-orderby3-8-26",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy3.feature",
        scenario="[8] Fail on sorting by any number of undefined variables in any position (example=never defined, sort=e, f, b, b, f, e, a)",
        cypher="WITH 1 AS a, 'b' AS b, 3 AS c, true AS d\nWITH a, b\nWITH a\n  ORDER BY e, f, b, b, f, e, a\nRETURN a",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Compile-time validation for ORDER BY variable scoping is not enforced",
        tags=("with", "orderby", "syntax-error", "xfail"),
    ),
    Scenario(
        key="with-orderby3-8-27",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy3.feature",
        scenario="[8] Fail on sorting by any number of undefined variables in any position (example=mixed, sort=a, c, e)",
        cypher="WITH 1 AS a, 'b' AS b, 3 AS c, true AS d\nWITH a, b\nWITH a\n  ORDER BY a, c, e\nRETURN a",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Compile-time validation for ORDER BY variable scoping is not enforced",
        tags=("with", "orderby", "syntax-error", "xfail"),
    ),
    Scenario(
        key="with-orderby3-8-28",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy3.feature",
        scenario="[8] Fail on sorting by any number of undefined variables in any position (example=mixed, sort=a, c, e, b)",
        cypher="WITH 1 AS a, 'b' AS b, 3 AS c, true AS d\nWITH a, b\nWITH a\n  ORDER BY a, c, e, b\nRETURN a",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Compile-time validation for ORDER BY variable scoping is not enforced",
        tags=("with", "orderby", "syntax-error", "xfail"),
    ),
    Scenario(
        key="with-orderby3-8-29",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy3.feature",
        scenario="[8] Fail on sorting by any number of undefined variables in any position (example=mixed, sort=b, c, a, f, a)",
        cypher="WITH 1 AS a, 'b' AS b, 3 AS c, true AS d\nWITH a, b\nWITH a\n  ORDER BY b, c, a, f, a\nRETURN a",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Compile-time validation for ORDER BY variable scoping is not enforced",
        tags=("with", "orderby", "syntax-error", "xfail"),
    ),
    Scenario(
        key="with-orderby3-8-30",
        feature_path="tck/features/clauses/with-orderBy/WithOrderBy3.feature",
        scenario="[8] Fail on sorting by any number of undefined variables in any position (example=mixed, sort=d, f, b, b, f, c, a)",
        cypher="WITH 1 AS a, 'b' AS b, 3 AS c, true AS d\nWITH a, b\nWITH a\n  ORDER BY d, f, b, b, f, c, a\nRETURN a",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="Compile-time validation for ORDER BY variable scoping is not enforced",
        tags=("with", "orderby", "syntax-error", "xfail"),
    ),
    Scenario(
        key="unwind1-1",
        feature_path="tck/features/clauses/unwind/Unwind1.feature",
        scenario="[1] Unwinding a list",
        cypher="UNWIND [1, 2, 3] AS x\nRETURN x",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"x": 1},
                {"x": 2},
                {"x": 3},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="UNWIND is not supported",
        tags=("unwind", "xfail"),
    ),
    Scenario(
        key="unwind1-2",
        feature_path="tck/features/clauses/unwind/Unwind1.feature",
        scenario="[2] Unwinding a range",
        cypher="UNWIND range(1, 3) AS x\nRETURN x",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"x": 1},
                {"x": 2},
                {"x": 3},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="UNWIND and range() expressions are not supported",
        tags=("unwind", "expression", "xfail"),
    ),
    Scenario(
        key="unwind1-3",
        feature_path="tck/features/clauses/unwind/Unwind1.feature",
        scenario="[3] Unwinding a concatenation of lists",
        cypher="WITH [1, 2, 3] AS first, [4, 5, 6] AS second\nUNWIND (first + second) AS x\nRETURN x",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"x": 1},
                {"x": 2},
                {"x": 3},
                {"x": 4},
                {"x": 5},
                {"x": 6},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, UNWIND, and list concatenation are not supported",
        tags=("unwind", "with", "expression", "xfail"),
    ),
    Scenario(
        key="unwind1-4",
        feature_path="tck/features/clauses/unwind/Unwind1.feature",
        scenario="[4] Unwinding a collected unwound expression",
        cypher="UNWIND RANGE(1, 2) AS row\nWITH collect(row) AS rows\nUNWIND rows AS x\nRETURN x",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"x": 1},
                {"x": 2},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="UNWIND, aggregation, and range() expressions are not supported",
        tags=("unwind", "aggregation", "expression", "xfail"),
    ),
    Scenario(
        key="unwind1-5",
        feature_path="tck/features/clauses/unwind/Unwind1.feature",
        scenario="[5] Unwinding a collected expression",
        cypher="MATCH (row)\nWITH collect(row) AS rows\nUNWIND rows AS node\nRETURN node.id",
        graph=graph_fixture_from_create(
            """
            CREATE ({id: 1}), ({id: 2})
            """
        ),
        expected=Expected(
            rows=[
                {"node.id": 1},
                {"node.id": 2},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="UNWIND, aggregation, and projection evaluation are not supported",
        tags=("unwind", "aggregation", "projection", "xfail"),
    ),
    Scenario(
        key="unwind1-6",
        feature_path="tck/features/clauses/unwind/Unwind1.feature",
        scenario="[6] Creating nodes from an unwound parameter list",
        cypher="UNWIND $events AS event\nMATCH (y:Year {year: event.year})\nMERGE (e:Event {id: event.id})\nMERGE (y)<-[:IN]-(e)\nRETURN e.id AS x\nORDER BY x",
        graph=graph_fixture_from_create(
            """
            CREATE (:Year {year: 2016})
            """
        ),
        expected=Expected(
            rows=[
                {"x": 1},
                {"x": 2},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="UNWIND, parameters, MERGE, ORDER BY, and side-effect validation are not supported",
        tags=("unwind", "params", "merge", "orderby", "xfail"),
    ),
    Scenario(
        key="unwind1-7",
        feature_path="tck/features/clauses/unwind/Unwind1.feature",
        scenario="[7] Double unwinding a list of lists",
        cypher="WITH [[1, 2, 3], [4, 5, 6]] AS lol\nUNWIND lol AS x\nUNWIND x AS y\nRETURN y",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"y": 1},
                {"y": 2},
                {"y": 3},
                {"y": 4},
                {"y": 5},
                {"y": 6},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines and UNWIND are not supported",
        tags=("unwind", "with", "xfail"),
    ),
    Scenario(
        key="unwind1-8",
        feature_path="tck/features/clauses/unwind/Unwind1.feature",
        scenario="[8] Unwinding the empty list",
        cypher="UNWIND [] AS empty\nRETURN empty",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason="UNWIND is not supported",
        tags=("unwind", "xfail"),
    ),
    Scenario(
        key="unwind1-9",
        feature_path="tck/features/clauses/unwind/Unwind1.feature",
        scenario="[9] Unwinding null",
        cypher="UNWIND null AS nil\nRETURN nil",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason="UNWIND is not supported",
        tags=("unwind", "xfail"),
    ),
    Scenario(
        key="unwind1-10",
        feature_path="tck/features/clauses/unwind/Unwind1.feature",
        scenario="[10] Unwinding list with duplicates",
        cypher="UNWIND [1, 1, 2, 2, 3, 3, 4, 4, 5, 5] AS duplicate\nRETURN duplicate",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"duplicate": 1},
                {"duplicate": 1},
                {"duplicate": 2},
                {"duplicate": 2},
                {"duplicate": 3},
                {"duplicate": 3},
                {"duplicate": 4},
                {"duplicate": 4},
                {"duplicate": 5},
                {"duplicate": 5},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="UNWIND is not supported",
        tags=("unwind", "xfail"),
    ),
    Scenario(
        key="unwind1-11",
        feature_path="tck/features/clauses/unwind/Unwind1.feature",
        scenario="[11] Unwind does not prune context",
        cypher="WITH [1, 2, 3] AS list\nUNWIND list AS x\nRETURN *",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"list": "[1, 2, 3]", "x": 1},
                {"list": "[1, 2, 3]", "x": 2},
                {"list": "[1, 2, 3]", "x": 3},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, UNWIND, and projection expansion are not supported",
        tags=("unwind", "with", "projection", "xfail"),
    ),
    Scenario(
        key="unwind1-12",
        feature_path="tck/features/clauses/unwind/Unwind1.feature",
        scenario="[12] Unwind does not remove variables from scope",
        cypher="MATCH (a:S)-[:X]->(b1)\nWITH a, collect(b1) AS bees\nUNWIND bees AS b2\nMATCH (a)-[:Y]->(b2)\nRETURN a, b2",
        graph=graph_fixture_from_create(
            """
            CREATE (s:S),
              (n),
              (e:E),
              (s)-[:X]->(e),
              (s)-[:Y]->(e),
              (n)-[:Y]->(e)
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:S)", "b2": "(:E)"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines, UNWIND, aggregation, and multi-step MATCH are not supported",
        tags=("unwind", "with", "aggregation", "match", "xfail"),
    ),
    Scenario(
        key="unwind1-13",
        feature_path="tck/features/clauses/unwind/Unwind1.feature",
        scenario="[13] Multiple unwinds after each other",
        cypher="WITH [1, 2] AS xs, [3, 4] AS ys, [5, 6] AS zs\nUNWIND xs AS x\nUNWIND ys AS y\nUNWIND zs AS z\nRETURN *",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"x": 1, "xs": "[1, 2]", "y": 3, "ys": "[3, 4]", "z": 5, "zs": "[5, 6]"},
                {"x": 1, "xs": "[1, 2]", "y": 3, "ys": "[3, 4]", "z": 6, "zs": "[5, 6]"},
                {"x": 1, "xs": "[1, 2]", "y": 4, "ys": "[3, 4]", "z": 5, "zs": "[5, 6]"},
                {"x": 1, "xs": "[1, 2]", "y": 4, "ys": "[3, 4]", "z": 6, "zs": "[5, 6]"},
                {"x": 2, "xs": "[1, 2]", "y": 3, "ys": "[3, 4]", "z": 5, "zs": "[5, 6]"},
                {"x": 2, "xs": "[1, 2]", "y": 3, "ys": "[3, 4]", "z": 6, "zs": "[5, 6]"},
                {"x": 2, "xs": "[1, 2]", "y": 4, "ys": "[3, 4]", "z": 5, "zs": "[5, 6]"},
                {"x": 2, "xs": "[1, 2]", "y": 4, "ys": "[3, 4]", "z": 6, "zs": "[5, 6]"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="WITH pipelines and UNWIND are not supported",
        tags=("unwind", "with", "xfail"),
    ),
    Scenario(
        key="call1-1",
        feature_path="tck/features/clauses/call/Call1.feature",
        scenario="[1] Standalone call to procedure that takes no arguments and yields no results",
        cypher="CALL test.doNothing()",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason="CALL procedures are not supported",
        tags=("call", "xfail"),
    ),
    Scenario(
        key="call1-2",
        feature_path="tck/features/clauses/call/Call1.feature",
        scenario="[2] Standalone call to procedure that takes no arguments and yields no results, called with implicit arguments",
        cypher="CALL test.doNothing",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason="CALL procedures are not supported",
        tags=("call", "xfail"),
    ),
    Scenario(
        key="call1-3",
        feature_path="tck/features/clauses/call/Call1.feature",
        scenario="[3] In-query call to procedure that takes no arguments and yields no results",
        cypher="MATCH (n)\nCALL test.doNothing()\nRETURN n",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason="CALL procedures are not supported",
        tags=("call", "xfail"),
    ),
    Scenario(
        key="call1-4",
        feature_path="tck/features/clauses/call/Call1.feature",
        scenario="[4] In-query call to procedure that takes no arguments and yields no results and consumes no rows",
        cypher="MATCH (n)\nCALL test.doNothing()\nRETURN n.name AS `name`",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {name: 'a'})
            CREATE (:B {name: 'b'})
            CREATE (:C {name: 'c'})
            """
        ),
        expected=Expected(
            rows=[
                {"name": "'a'"},
                {"name": "'b'"},
                {"name": "'c'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="CALL procedures are not supported",
        tags=("call", "xfail"),
    ),
    Scenario(
        key="call1-5",
        feature_path="tck/features/clauses/call/Call1.feature",
        scenario="[5] Standalone call to STRING procedure that takes no arguments",
        cypher="CALL test.labels()",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"label": "'A'"},
                {"label": "'B'"},
                {"label": "'C'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="CALL procedures are not supported",
        tags=("call", "xfail"),
    ),
    Scenario(
        key="call1-6",
        feature_path="tck/features/clauses/call/Call1.feature",
        scenario="[6] In-query call to STRING procedure that takes no arguments",
        cypher="CALL test.labels() YIELD label\nRETURN label",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"label": "'A'"},
                {"label": "'B'"},
                {"label": "'C'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="CALL procedures and YIELD projections are not supported",
        tags=("call", "xfail"),
    ),
    Scenario(
        key="call1-7",
        feature_path="tck/features/clauses/call/Call1.feature",
        scenario="[7] Standalone call to procedure should fail if explicit argument is missing",
        cypher="CALL test.my.proc('Dobby')",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="CALL procedure validation is not supported",
        tags=("call", "syntax-error", "xfail"),
    ),
    Scenario(
        key="call1-8",
        feature_path="tck/features/clauses/call/Call1.feature",
        scenario="[8] In-query call to procedure should fail if explicit argument is missing",
        cypher="CALL test.my.proc('Dobby') YIELD out\nRETURN out",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="CALL procedure validation is not supported",
        tags=("call", "syntax-error", "xfail"),
    ),
    Scenario(
        key="call1-9",
        feature_path="tck/features/clauses/call/Call1.feature",
        scenario="[9] Standalone call to procedure should fail if too many explicit argument are given",
        cypher="CALL test.my.proc(1, 2, 3, 4)",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="CALL procedure validation is not supported",
        tags=("call", "syntax-error", "xfail"),
    ),
    Scenario(
        key="call1-10",
        feature_path="tck/features/clauses/call/Call1.feature",
        scenario="[10] In-query call to procedure should fail if too many explicit argument are given",
        cypher="CALL test.my.proc(1, 2, 3, 4) YIELD out\nRETURN out",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="CALL procedure validation is not supported",
        tags=("call", "syntax-error", "xfail"),
    ),
    Scenario(
        key="call1-11",
        feature_path="tck/features/clauses/call/Call1.feature",
        scenario="[11] Standalone call to procedure should fail if implicit argument is missing",
        cypher="CALL test.my.proc",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="CALL procedures and parameter binding are not supported",
        tags=("call", "params", "syntax-error", "xfail"),
    ),
    Scenario(
        key="call1-12",
        feature_path="tck/features/clauses/call/Call1.feature",
        scenario="[12] In-query call to procedure that has outputs fails if no outputs are yielded",
        cypher="CALL test.my.proc(1)\nRETURN out",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="CALL procedure validation is not supported",
        tags=("call", "syntax-error", "xfail"),
    ),
    Scenario(
        key="call1-13",
        feature_path="tck/features/clauses/call/Call1.feature",
        scenario="[13] Standalone call to unknown procedure should fail",
        cypher="CALL test.my.proc",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="CALL procedure registry is not supported",
        tags=("call", "procedure-error", "xfail"),
    ),
    Scenario(
        key="call2-1",
        feature_path="tck/features/clauses/call/Call2.feature",
        scenario="[1] In-query call to procedure with explicit arguments",
        cypher="CALL test.my.proc('Stefan', 1) YIELD city, country_code\nRETURN city, country_code",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"city": "'Berlin'", "country_code": 49},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="CALL procedures are not supported",
        tags=("call", "xfail"),
    ),
    Scenario(
        key="call2-2",
        feature_path="tck/features/clauses/call/Call2.feature",
        scenario="[2] Standalone call to procedure with explicit arguments",
        cypher="CALL test.my.proc('Stefan', 1)",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"city": "'Berlin'", "country_code": 49},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="CALL procedures are not supported",
        tags=("call", "xfail"),
    ),
    Scenario(
        key="call2-3",
        feature_path="tck/features/clauses/call/Call2.feature",
        scenario="[3] Standalone call to procedure with implicit arguments",
        cypher="CALL test.my.proc",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"city": "'Berlin'", "country_code": 49},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="CALL procedures and parameter binding are not supported",
        tags=("call", "params", "xfail"),
    ),
    Scenario(
        key="call2-4",
        feature_path="tck/features/clauses/call/Call2.feature",
        scenario="[4] In-query call to procedure that takes arguments fails when trying to pass them implicitly",
        cypher="CALL test.my.proc YIELD out\nRETURN out",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="CALL procedure validation is not supported",
        tags=("call", "syntax-error", "xfail"),
    ),
    Scenario(
        key="call2-5",
        feature_path="tck/features/clauses/call/Call2.feature",
        scenario="[5] Standalone call to procedure should fail if input type is wrong",
        cypher="CALL test.my.proc(true)",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="CALL procedure validation is not supported",
        tags=("call", "syntax-error", "xfail"),
    ),
    Scenario(
        key="call2-6",
        feature_path="tck/features/clauses/call/Call2.feature",
        scenario="[6] In-query call to procedure should fail if input type is wrong",
        cypher="CALL test.my.proc(true) YIELD out\nRETURN out",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="CALL procedure validation is not supported",
        tags=("call", "syntax-error", "xfail"),
    ),
    Scenario(
        key="call3-1",
        feature_path="tck/features/clauses/call/Call3.feature",
        scenario="[1] Standalone call to procedure with argument of type NUMBER accepts value of type INTEGER",
        cypher="CALL test.my.proc(42)",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"out": "'wisdom'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="CALL procedures are not supported",
        tags=("call", "xfail"),
    ),
    Scenario(
        key="call3-2",
        feature_path="tck/features/clauses/call/Call3.feature",
        scenario="[2] In-query call to procedure with argument of type NUMBER accepts value of type INTEGER",
        cypher="CALL test.my.proc(42) YIELD out\nRETURN out",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"out": "'wisdom'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="CALL procedures are not supported",
        tags=("call", "xfail"),
    ),
    Scenario(
        key="call3-3",
        feature_path="tck/features/clauses/call/Call3.feature",
        scenario="[3] Standalone call to procedure with argument of type NUMBER accepts value of type FLOAT",
        cypher="CALL test.my.proc(42.3)",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"out": "'about right'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="CALL procedures are not supported",
        tags=("call", "xfail"),
    ),
    Scenario(
        key="call3-4",
        feature_path="tck/features/clauses/call/Call3.feature",
        scenario="[4] In-query call to procedure with argument of type NUMBER accepts value of type FLOAT",
        cypher="CALL test.my.proc(42.3) YIELD out\nRETURN out",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"out": "'about right'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="CALL procedures are not supported",
        tags=("call", "xfail"),
    ),
    Scenario(
        key="call3-5",
        feature_path="tck/features/clauses/call/Call3.feature",
        scenario="[5] Standalone call to procedure with argument of type FLOAT accepts value of type INTEGER",
        cypher="CALL test.my.proc(42)",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"out": "'close enough'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="CALL procedures are not supported",
        tags=("call", "xfail"),
    ),
    Scenario(
        key="call3-6",
        feature_path="tck/features/clauses/call/Call3.feature",
        scenario="[6] In-query call to procedure with argument of type FLOAT accepts value of type INTEGER",
        cypher="CALL test.my.proc(42) YIELD out\nRETURN out",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"out": "'close enough'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="CALL procedures are not supported",
        tags=("call", "xfail"),
    ),
    Scenario(
        key="call4-1",
        feature_path="tck/features/clauses/call/Call4.feature",
        scenario="[1] Standalone call to procedure with null argument",
        cypher="CALL test.my.proc(null)",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"out": "'nix'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="CALL procedures are not supported",
        tags=("call", "xfail"),
    ),
    Scenario(
        key="call4-2",
        feature_path="tck/features/clauses/call/Call4.feature",
        scenario="[2] In-query call to procedure with null argument",
        cypher="CALL test.my.proc(null) YIELD out\nRETURN out",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"out": "'nix'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="CALL procedures are not supported",
        tags=("call", "xfail"),
    ),
    Scenario(
        key="call5-1",
        feature_path="tck/features/clauses/call/Call5.feature",
        scenario="[1] Explicit procedure result projection",
        cypher="CALL test.my.proc(null) YIELD out\nRETURN out",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"out": "'nix'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="CALL procedures are not supported",
        tags=("call", "xfail"),
    ),
    Scenario(
        key="call5-2",
        feature_path="tck/features/clauses/call/Call5.feature",
        scenario="[2] Explicit procedure result projection with RETURN *",
        cypher="CALL test.my.proc(null) YIELD out\nRETURN *",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"out": "'nix'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="CALL procedures are not supported",
        tags=("call", "xfail"),
    ),
    Scenario(
        key="call5-3-1",
        feature_path="tck/features/clauses/call/Call5.feature",
        scenario="[3] The order of yield items is irrelevant (example=1, yield=a, b)",
        cypher="CALL test.my.proc(null) YIELD a, b\nRETURN a, b",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"a": 1, "b": 2},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="CALL procedures and YIELD projections are not supported",
        tags=("call", "xfail"),
    ),
    Scenario(
        key="call5-3-2",
        feature_path="tck/features/clauses/call/Call5.feature",
        scenario="[3] The order of yield items is irrelevant (example=2, yield=b, a)",
        cypher="CALL test.my.proc(null) YIELD b, a\nRETURN a, b",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"a": 1, "b": 2},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="CALL procedures and YIELD projections are not supported",
        tags=("call", "xfail"),
    ),
    Scenario(
        key="call5-4-1",
        feature_path="tck/features/clauses/call/Call5.feature",
        scenario="[4] Rename outputs to unbound variable names (example=1, rename=a AS c, b AS d)",
        cypher="CALL test.my.proc(null) YIELD a AS c, b AS d\nRETURN c, d",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"c": 1, "d": 2},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="CALL procedures and YIELD projections are not supported",
        tags=("call", "xfail"),
    ),
    Scenario(
        key="call5-4-2",
        feature_path="tck/features/clauses/call/Call5.feature",
        scenario="[4] Rename outputs to unbound variable names (example=2, rename=a AS b, b AS d)",
        cypher="CALL test.my.proc(null) YIELD a AS b, b AS d\nRETURN b, d",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"b": 1, "d": 2},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="CALL procedures and YIELD projections are not supported",
        tags=("call", "xfail"),
    ),
    Scenario(
        key="call5-4-3",
        feature_path="tck/features/clauses/call/Call5.feature",
        scenario="[4] Rename outputs to unbound variable names (example=3, rename=a AS c, b AS a)",
        cypher="CALL test.my.proc(null) YIELD a AS c, b AS a\nRETURN c, a",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"c": 1, "a": 2},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="CALL procedures and YIELD projections are not supported",
        tags=("call", "xfail"),
    ),
    Scenario(
        key="call5-4-4",
        feature_path="tck/features/clauses/call/Call5.feature",
        scenario="[4] Rename outputs to unbound variable names (example=4, rename=a AS b, b AS a)",
        cypher="CALL test.my.proc(null) YIELD a AS b, b AS a\nRETURN b, a",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"b": 1, "a": 2},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="CALL procedures and YIELD projections are not supported",
        tags=("call", "xfail"),
    ),
    Scenario(
        key="call5-4-5",
        feature_path="tck/features/clauses/call/Call5.feature",
        scenario="[4] Rename outputs to unbound variable names (example=5, rename=a AS c, b AS b)",
        cypher="CALL test.my.proc(null) YIELD a AS c, b AS b\nRETURN c, b",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"c": 1, "b": 2},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="CALL procedures and YIELD projections are not supported",
        tags=("call", "xfail"),
    ),
    Scenario(
        key="call5-4-6",
        feature_path="tck/features/clauses/call/Call5.feature",
        scenario="[4] Rename outputs to unbound variable names (example=6, rename=a AS c, b)",
        cypher="CALL test.my.proc(null) YIELD a AS c, b\nRETURN c, b",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"c": 1, "b": 2},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="CALL procedures and YIELD projections are not supported",
        tags=("call", "xfail"),
    ),
    Scenario(
        key="call5-4-7",
        feature_path="tck/features/clauses/call/Call5.feature",
        scenario="[4] Rename outputs to unbound variable names (example=7, rename=a AS a, b AS d)",
        cypher="CALL test.my.proc(null) YIELD a AS a, b AS d\nRETURN a, d",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"a": 1, "d": 2},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="CALL procedures and YIELD projections are not supported",
        tags=("call", "xfail"),
    ),
    Scenario(
        key="call5-4-8",
        feature_path="tck/features/clauses/call/Call5.feature",
        scenario="[4] Rename outputs to unbound variable names (example=8, rename=a, b AS d)",
        cypher="CALL test.my.proc(null) YIELD a, b AS d\nRETURN a, d",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"a": 1, "d": 2},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="CALL procedures and YIELD projections are not supported",
        tags=("call", "xfail"),
    ),
    Scenario(
        key="call5-4-9",
        feature_path="tck/features/clauses/call/Call5.feature",
        scenario="[4] Rename outputs to unbound variable names (example=9, rename=a AS a, b AS b)",
        cypher="CALL test.my.proc(null) YIELD a AS a, b AS b\nRETURN a, b",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"a": 1, "b": 2},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="CALL procedures and YIELD projections are not supported",
        tags=("call", "xfail"),
    ),
    Scenario(
        key="call5-4-10",
        feature_path="tck/features/clauses/call/Call5.feature",
        scenario="[4] Rename outputs to unbound variable names (example=10, rename=a AS a, b)",
        cypher="CALL test.my.proc(null) YIELD a AS a, b\nRETURN a, b",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"a": 1, "b": 2},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="CALL procedures and YIELD projections are not supported",
        tags=("call", "xfail"),
    ),
    Scenario(
        key="call5-4-11",
        feature_path="tck/features/clauses/call/Call5.feature",
        scenario="[4] Rename outputs to unbound variable names (example=11, rename=a, b AS b)",
        cypher="CALL test.my.proc(null) YIELD a, b AS b\nRETURN a, b",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"a": 1, "b": 2},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="CALL procedures and YIELD projections are not supported",
        tags=("call", "xfail"),
    ),
    Scenario(
        key="call5-5",
        feature_path="tck/features/clauses/call/Call5.feature",
        scenario="[5] Fail on renaming to an already bound variable name",
        cypher="CALL test.my.proc(null) YIELD a, b AS a\nRETURN a",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="CALL procedure validation is not supported",
        tags=("call", "syntax-error", "xfail"),
    ),
    Scenario(
        key="call5-6",
        feature_path="tck/features/clauses/call/Call5.feature",
        scenario="[6] Fail on renaming all outputs to the same variable name",
        cypher="CALL test.my.proc(null) YIELD a AS c, b AS c\nRETURN c",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="CALL procedure validation is not supported",
        tags=("call", "syntax-error", "xfail"),
    ),
    Scenario(
        key="call5-7",
        feature_path="tck/features/clauses/call/Call5.feature",
        scenario="[7] Fail on in-query call to procedure with YIELD *",
        cypher="CALL test.my.proc('Stefan', 1) YIELD *\nRETURN city, country_code",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="CALL procedure validation is not supported",
        tags=("call", "syntax-error", "xfail"),
    ),
    Scenario(
        key="call5-8",
        feature_path="tck/features/clauses/call/Call5.feature",
        scenario="[8] Allow standalone call to procedure with YIELD *",
        cypher="CALL test.my.proc('Stefan', 1) YIELD *",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"city": "'Berlin'", "country_code": 49},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="CALL procedures are not supported",
        tags=("call", "xfail"),
    ),
    Scenario(
        key="call6-1",
        feature_path="tck/features/clauses/call/Call6.feature",
        scenario="[1] Calling the same STRING procedure twice using the same outputs in each call",
        cypher="CALL test.labels() YIELD label\nWITH count(*) AS c\nCALL test.labels() YIELD label\nRETURN *",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"c": 3, "label": "'A'"},
                {"c": 3, "label": "'B'"},
                {"c": 3, "label": "'C'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="CALL procedures are not supported",
        tags=("call", "xfail"),
    ),
    Scenario(
        key="call6-2",
        feature_path="tck/features/clauses/call/Call6.feature",
        scenario="[2] Project procedure results between query scopes with WITH clause",
        cypher="CALL test.my.proc(null) YIELD out\nWITH out RETURN out",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"out": "'nix'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="CALL procedures are not supported",
        tags=("call", "xfail"),
    ),
    Scenario(
        key="call6-3",
        feature_path="tck/features/clauses/call/Call6.feature",
        scenario="[3] Project procedure results between query scopes with WITH clause and rename the projection",
        cypher="CALL test.my.proc(null) YIELD out\nWITH out AS a RETURN a",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"a": "'nix'"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="CALL procedures are not supported",
        tags=("call", "xfail"),
    ),
    Scenario(
        key="union1-1",
        feature_path="tck/features/clauses/union/Union1.feature",
        scenario="[1] Two elements, both unique, distinct",
        cypher="RETURN 1 AS x\nUNION\nRETURN 2 AS x",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"x": 1},
                {"x": 2},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="UNION is not supported",
        tags=("union", "xfail"),
    ),
    Scenario(
        key="union1-2",
        feature_path="tck/features/clauses/union/Union1.feature",
        scenario="[2] Three elements, two unique, distinct",
        cypher="RETURN 2 AS x\nUNION\nRETURN 1 AS x\nUNION\nRETURN 2 AS x",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"x": 2},
                {"x": 1},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="UNION is not supported",
        tags=("union", "xfail"),
    ),
    Scenario(
        key="union1-3",
        feature_path="tck/features/clauses/union/Union1.feature",
        scenario="[3] Two single-column inputs, one with duplicates, distinct",
        cypher="UNWIND [2, 1, 2, 3] AS x\nRETURN x\nUNION\nUNWIND [3, 4] AS x\nRETURN x",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"x": 2},
                {"x": 1},
                {"x": 3},
                {"x": 4},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="UNION and UNWIND are not supported",
        tags=("union", "unwind", "xfail"),
    ),
    Scenario(
        key="union1-4",
        feature_path="tck/features/clauses/union/Union1.feature",
        scenario="[4] Should be able to create text output from union queries",
        cypher="MATCH (a:A)\nRETURN a AS a\nUNION\nMATCH (b:B)\nRETURN b AS a",
        graph=graph_fixture_from_create(
            """
            CREATE (:A), (:B)
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:A)"},
                {"a": "(:B)"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="UNION is not supported",
        tags=("union", "xfail"),
    ),
    Scenario(
        key="union1-5",
        feature_path="tck/features/clauses/union/Union1.feature",
        scenario="[5] Failing when UNION has different columns",
        cypher="RETURN 1 AS a\nUNION\nRETURN 2 AS b",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="UNION validation is not supported",
        tags=("union", "syntax-error", "xfail"),
    ),
    Scenario(
        key="union2-1",
        feature_path="tck/features/clauses/union/Union2.feature",
        scenario="[1] Two elements, both unique, not distinct",
        cypher="RETURN 1 AS x\nUNION ALL\nRETURN 2 AS x",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"x": 1},
                {"x": 2},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="UNION ALL is not supported",
        tags=("union", "union-all", "xfail"),
    ),
    Scenario(
        key="union2-2",
        feature_path="tck/features/clauses/union/Union2.feature",
        scenario="[2] Three elements, two unique, not distinct",
        cypher="RETURN 2 AS x\nUNION ALL\nRETURN 1 AS x\nUNION ALL\nRETURN 2 AS x",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"x": 2},
                {"x": 1},
                {"x": 2},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="UNION ALL is not supported",
        tags=("union", "union-all", "xfail"),
    ),
    Scenario(
        key="union2-3",
        feature_path="tck/features/clauses/union/Union2.feature",
        scenario="[3] Two single-column inputs, one with duplicates, not distinct",
        cypher="UNWIND [2, 1, 2, 3] AS x\nRETURN x\nUNION ALL\nUNWIND [3, 4] AS x\nRETURN x",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
                {"x": 2},
                {"x": 1},
                {"x": 2},
                {"x": 3},
                {"x": 3},
                {"x": 4},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="UNION ALL and UNWIND are not supported",
        tags=("union", "union-all", "unwind", "xfail"),
    ),
    Scenario(
        key="union2-4",
        feature_path="tck/features/clauses/union/Union2.feature",
        scenario="[4] Should be able to create text output from union all queries",
        cypher="MATCH (a:A)\nRETURN a AS a\nUNION ALL\nMATCH (b:B)\nRETURN b AS a",
        graph=graph_fixture_from_create(
            """
            CREATE (:A), (:B)
            """
        ),
        expected=Expected(
            rows=[
                {"a": "(:A)"},
                {"a": "(:B)"},
            ],
        ),
        gfql=None,
        status="xfail",
        reason="UNION ALL is not supported",
        tags=("union", "union-all", "xfail"),
    ),
    Scenario(
        key="union2-5",
        feature_path="tck/features/clauses/union/Union2.feature",
        scenario="[5] Failing when UNION ALL has different columns",
        cypher="RETURN 1 AS a\nUNION ALL\nRETURN 2 AS b",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="UNION ALL validation is not supported",
        tags=("union", "union-all", "syntax-error", "xfail"),
    ),
    Scenario(
        key="union3-1",
        feature_path="tck/features/clauses/union/Union3.feature",
        scenario="[1] Failing when mixing UNION and UNION ALL",
        cypher="RETURN 1 AS a\nUNION\nRETURN 2 AS a\nUNION ALL\nRETURN 3 AS a",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="UNION clause composition validation is not supported",
        tags=("union", "syntax-error", "xfail"),
    ),
    Scenario(
        key="union3-2",
        feature_path="tck/features/clauses/union/Union3.feature",
        scenario="[2] Failing when mixing UNION ALL and UNION",
        cypher="RETURN 1 AS a\nUNION ALL\nRETURN 2 AS a\nUNION\nRETURN 3 AS a",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason="UNION clause composition validation is not supported",
        tags=("union", "syntax-error", "xfail"),
    ),

    Scenario(
        key='create1-1',
        feature_path='tck/features/clauses/create/Create1.feature',
        scenario='[1] Create a single node',
        cypher='CREATE ()',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason='CREATE clause semantics are not supported',
        tags=('create', 'xfail'),
    ),
    Scenario(
        key='create1-2',
        feature_path='tck/features/clauses/create/Create1.feature',
        scenario='[2] Create two nodes',
        cypher='CREATE (), ()',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason='CREATE clause semantics are not supported',
        tags=('create', 'xfail'),
    ),
    Scenario(
        key='create1-3',
        feature_path='tck/features/clauses/create/Create1.feature',
        scenario='[3] Create a single node with a label',
        cypher='CREATE (:Label)',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason='CREATE clause semantics are not supported',
        tags=('create', 'xfail'),
    ),
    Scenario(
        key='create1-4',
        feature_path='tck/features/clauses/create/Create1.feature',
        scenario='[4] Create two nodes with same label',
        cypher='CREATE (:Label), (:Label)',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason='CREATE clause semantics are not supported',
        tags=('create', 'xfail'),
    ),
    Scenario(
        key='create1-5',
        feature_path='tck/features/clauses/create/Create1.feature',
        scenario='[5] Create a single node with multiple labels',
        cypher='CREATE (:A:B:C:D)',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason='CREATE clause semantics are not supported',
        tags=('create', 'xfail'),
    ),
    Scenario(
        key='create1-6',
        feature_path='tck/features/clauses/create/Create1.feature',
        scenario='[6] Create three nodes with multiple labels',
        cypher='CREATE (:B:A:D), (:B:C), (:D:E:B)',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason='CREATE clause semantics are not supported',
        tags=('create', 'xfail'),
    ),
    Scenario(
        key='create1-7',
        feature_path='tck/features/clauses/create/Create1.feature',
        scenario='[7] Create a single node with a property',
        cypher='CREATE ({created: true})',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason='CREATE clause semantics are not supported',
        tags=('create', 'xfail'),
    ),
    Scenario(
        key='create1-8',
        feature_path='tck/features/clauses/create/Create1.feature',
        scenario='[8] Create a single node with a property and return it',
        cypher="CREATE (n {name: 'foo'})\n      RETURN n.name AS p",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'p': "'foo'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='CREATE clause semantics are not supported',
        tags=('create', 'xfail'),
    ),
    Scenario(
        key='create1-9',
        feature_path='tck/features/clauses/create/Create1.feature',
        scenario='[9] Create a single node with two properties',
        cypher="CREATE (n {id: 12, name: 'foo'})",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason='CREATE clause semantics are not supported',
        tags=('create', 'xfail'),
    ),
    Scenario(
        key='create1-10',
        feature_path='tck/features/clauses/create/Create1.feature',
        scenario='[10] Create a single node with two properties and return them',
        cypher="CREATE (n {id: 12, name: 'foo'})\n      RETURN n.id AS id, n.name AS p",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'id': 12, 'p': "'foo'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='CREATE clause semantics are not supported',
        tags=('create', 'xfail'),
    ),
    Scenario(
        key='create1-11',
        feature_path='tck/features/clauses/create/Create1.feature',
        scenario='[11] Create a single node with null properties should not return those properties',
        cypher='CREATE (n {id: 12, name: null})\n      RETURN n.id AS id, n.name AS p',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'id': 12, 'p': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='CREATE clause semantics are not supported',
        tags=('create', 'xfail'),
    ),
    Scenario(
        key='create1-12',
        feature_path='tck/features/clauses/create/Create1.feature',
        scenario='[12] CREATE does not lose precision on large integers',
        cypher='CREATE (p:TheLabel {id: 4611686018427387905})\n      RETURN p.id',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'p.id': 4611686018427387905}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='CREATE clause semantics are not supported',
        tags=('create', 'xfail'),
    ),
    Scenario(
        key='create1-13',
        feature_path='tck/features/clauses/create/Create1.feature',
        scenario='[13] Fail when creating a node that is already bound',
        cypher='MATCH (a)\n      CREATE (a)',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('create', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='create1-14',
        feature_path='tck/features/clauses/create/Create1.feature',
        scenario='[14] Fail when creating a node with properties that is already bound',
        cypher="MATCH (a)\n      CREATE (a {name: 'foo'})\n      RETURN a",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('create', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='create1-15',
        feature_path='tck/features/clauses/create/Create1.feature',
        scenario='[15] Fail when adding a new label predicate on a node that is already bound 1',
        cypher='CREATE (n:Foo)-[:T1]->(),\n             (n:Bar)-[:T2]->()',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('create', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='create1-16',
        feature_path='tck/features/clauses/create/Create1.feature',
        scenario='[16] Fail when adding new label predicate on a node that is already bound 2',
        cypher='CREATE ()<-[:T2]-(n:Foo),\n             (n:Bar)<-[:T1]-()',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('create', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='create1-17',
        feature_path='tck/features/clauses/create/Create1.feature',
        scenario='[17] Fail when adding new label predicate on a node that is already bound 3',
        cypher='CREATE (n:Foo)\n      CREATE (n:Bar)-[:OWNS]->(:Dog)',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('create', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='create1-18',
        feature_path='tck/features/clauses/create/Create1.feature',
        scenario='[18] Fail when adding new label predicate on a node that is already bound 4',
        cypher='CREATE (n {})\n      CREATE (n:Bar)-[:OWNS]->(:Dog)',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('create', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='create1-19',
        feature_path='tck/features/clauses/create/Create1.feature',
        scenario='[19] Fail when adding new label predicate on a node that is already bound 5',
        cypher='CREATE (n:Foo)\n      CREATE (n {})-[:OWNS]->(:Dog)',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('create', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='create1-20',
        feature_path='tck/features/clauses/create/Create1.feature',
        scenario='[20] Fail when creating a node using undefined variable in pattern',
        cypher='CREATE (b {name: missing})\n      RETURN b',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('create', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='create2-1',
        feature_path='tck/features/clauses/create/Create2.feature',
        scenario='[1] Create two nodes and a single relationship in a single pattern',
        cypher='CREATE ()-[:R]->()',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason='CREATE clause semantics are not supported',
        tags=('create', 'xfail'),
    ),
    Scenario(
        key='create2-2',
        feature_path='tck/features/clauses/create/Create2.feature',
        scenario='[2] Create two nodes and a single relationship in separate patterns',
        cypher='CREATE (a), (b),\n             (a)-[:R]->(b)',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason='CREATE clause semantics are not supported',
        tags=('create', 'xfail'),
    ),
    Scenario(
        key='create2-3',
        feature_path='tck/features/clauses/create/Create2.feature',
        scenario='[3] Create two nodes and a single relationship in separate clauses',
        cypher='CREATE (a)\n      CREATE (b)\n      CREATE (a)-[:R]->(b)',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason='CREATE clause semantics are not supported',
        tags=('create', 'xfail'),
    ),
    Scenario(
        key='create2-4',
        feature_path='tck/features/clauses/create/Create2.feature',
        scenario='[4] Create two nodes and a single relationship in the reverse direction',
        cypher='CREATE (:A)<-[:R]-(:B)',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason='CREATE clause semantics are not supported',
        tags=('create', 'xfail'),
    ),
    Scenario(
        key='create2-5',
        feature_path='tck/features/clauses/create/Create2.feature',
        scenario='[5] Create a single relationship between two existing nodes',
        cypher='MATCH (x:X), (y:Y)\n      CREATE (x)-[:R]->(y)',
        graph=graph_fixture_from_create(
            """
            CREATE (:X)
                  CREATE (:Y)
            """
        ),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason='CREATE clause semantics are not supported',
        tags=('create', 'xfail'),
    ),
    Scenario(
        key='create2-6',
        feature_path='tck/features/clauses/create/Create2.feature',
        scenario='[6] Create a single relationship between two existing nodes in the reverse direction',
        cypher='MATCH (x:X), (y:Y)\n      CREATE (x)<-[:R]-(y)',
        graph=graph_fixture_from_create(
            """
            CREATE (:X)
                  CREATE (:Y)
            """
        ),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason='CREATE clause semantics are not supported',
        tags=('create', 'xfail'),
    ),
    Scenario(
        key='create2-7',
        feature_path='tck/features/clauses/create/Create2.feature',
        scenario='[7] Create a single node and a single self loop in a single pattern',
        cypher='CREATE (root)-[:LINK]->(root)',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason='CREATE clause semantics are not supported',
        tags=('create', 'xfail'),
    ),
    Scenario(
        key='create2-8',
        feature_path='tck/features/clauses/create/Create2.feature',
        scenario='[8] Create a single node and a single self loop in separate patterns',
        cypher='CREATE (root),\n             (root)-[:LINK]->(root)',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason='CREATE clause semantics are not supported',
        tags=('create', 'xfail'),
    ),
    Scenario(
        key='create2-9',
        feature_path='tck/features/clauses/create/Create2.feature',
        scenario='[9] Create a single node and a single self loop in separate clauses',
        cypher='CREATE (root)\n      CREATE (root)-[:LINK]->(root)',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason='CREATE clause semantics are not supported',
        tags=('create', 'xfail'),
    ),
    Scenario(
        key='create2-10',
        feature_path='tck/features/clauses/create/Create2.feature',
        scenario='[10] Create a single self loop on an existing node',
        cypher='MATCH (root:Root)\n      CREATE (root)-[:LINK]->(root)',
        graph=graph_fixture_from_create(
            """
            CREATE (:Root)
            """
        ),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason='CREATE clause semantics are not supported',
        tags=('create', 'xfail'),
    ),
    Scenario(
        key='create2-11',
        feature_path='tck/features/clauses/create/Create2.feature',
        scenario='[11] Create a single relationship and an end node on an existing starting node',
        cypher='MATCH (x:Begin)\n      CREATE (x)-[:TYPE]->(:End)',
        graph=graph_fixture_from_create(
            """
            CREATE (:Begin)
            """
        ),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason='CREATE clause semantics are not supported',
        tags=('create', 'xfail'),
    ),
    Scenario(
        key='create2-12',
        feature_path='tck/features/clauses/create/Create2.feature',
        scenario='[12] Create a single relationship and a starting node on an existing end node',
        cypher='MATCH (x:End)\n      CREATE (:Begin)-[:TYPE]->(x)',
        graph=graph_fixture_from_create(
            """
            CREATE (:End)
            """
        ),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason='CREATE clause semantics are not supported',
        tags=('create', 'xfail'),
    ),
    Scenario(
        key='create2-13',
        feature_path='tck/features/clauses/create/Create2.feature',
        scenario='[13] Create a single relationship with a property',
        cypher='CREATE ()-[:R {num: 42}]->()',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason='CREATE clause semantics are not supported',
        tags=('create', 'xfail'),
    ),
    Scenario(
        key='create2-14',
        feature_path='tck/features/clauses/create/Create2.feature',
        scenario='[14] Create a single relationship with a property and return it',
        cypher='CREATE ()-[r:R {num: 42}]->()\n      RETURN r.num AS num',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'num': 42}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='CREATE clause semantics are not supported',
        tags=('create', 'xfail'),
    ),
    Scenario(
        key='create2-15',
        feature_path='tck/features/clauses/create/Create2.feature',
        scenario='[15] Create a single relationship with two properties',
        cypher="CREATE ()-[:R {id: 12, name: 'foo'}]->()",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason='CREATE clause semantics are not supported',
        tags=('create', 'xfail'),
    ),
    Scenario(
        key='create2-16',
        feature_path='tck/features/clauses/create/Create2.feature',
        scenario='[16] Create a single relationship with two properties and return them',
        cypher="CREATE ()-[r:R {id: 12, name: 'foo'}]->()\n      RETURN r.id AS id, r.name AS name",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'id': 12, 'name': "'foo'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='CREATE clause semantics are not supported',
        tags=('create', 'xfail'),
    ),
    Scenario(
        key='create2-17',
        feature_path='tck/features/clauses/create/Create2.feature',
        scenario='[17] Create a single relationship with null properties should not return those properties',
        cypher='CREATE ()-[r:X {id: 12, name: null}]->()\n      RETURN r.id, r.name AS name',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'r.id': 12, 'name': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='CREATE clause semantics are not supported',
        tags=('create', 'xfail'),
    ),
    Scenario(
        key='create2-18',
        feature_path='tck/features/clauses/create/Create2.feature',
        scenario='[18] Fail when creating a relationship without a type',
        cypher='CREATE ()-->()',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('create', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='create2-19',
        feature_path='tck/features/clauses/create/Create2.feature',
        scenario='[19] Fail when creating a relationship without a direction',
        cypher='CREATE (a)-[:FOO]-(b)',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('create', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='create2-20',
        feature_path='tck/features/clauses/create/Create2.feature',
        scenario='[20] Fail when creating a relationship with two directions',
        cypher='CREATE (a)<-[:FOO]->(b)',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('create', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='create2-21',
        feature_path='tck/features/clauses/create/Create2.feature',
        scenario='[21] Fail when creating a relationship with more than one type',
        cypher='CREATE ()-[:A|:B]->()',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('create', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='create2-22',
        feature_path='tck/features/clauses/create/Create2.feature',
        scenario='[22] Fail when creating a variable-length relationship',
        cypher='CREATE ()-[:FOO*2]->()',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('create', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='create2-23',
        feature_path='tck/features/clauses/create/Create2.feature',
        scenario='[23] Fail when creating a relationship that is already bound',
        cypher='MATCH ()-[r]->()\n      CREATE ()-[r]->()',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('create', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='create2-24',
        feature_path='tck/features/clauses/create/Create2.feature',
        scenario='[24] Fail when creating a relationship using undefined variable in pattern',
        cypher='MATCH (a)\n      CREATE (a)-[:KNOWS]->(b {name: missing})\n      RETURN b',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('create', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='create3-1',
        feature_path='tck/features/clauses/create/Create3.feature',
        scenario='[1] MATCH-CREATE',
        cypher='MATCH ()\n      CREATE ()',
        graph=graph_fixture_from_create(
            """
            CREATE (), ()
            """
        ),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason='CREATE clause semantics are not supported',
        tags=('create', 'xfail'),
    ),
    Scenario(
        key='create3-2',
        feature_path='tck/features/clauses/create/Create3.feature',
        scenario='[2] WITH-CREATE',
        cypher='MATCH ()\n      CREATE ()\n      WITH *\n      CREATE ()',
        graph=graph_fixture_from_create(
            """
            CREATE (), ()
            """
        ),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason='CREATE clause semantics are not supported',
        tags=('create', 'xfail'),
    ),
    Scenario(
        key='create3-3',
        feature_path='tck/features/clauses/create/Create3.feature',
        scenario='[3] MATCH-CREATE-WITH-CREATE',
        cypher='MATCH ()\n      CREATE ()\n      WITH *\n      MATCH ()\n      CREATE ()',
        graph=graph_fixture_from_create(
            """
            CREATE (), ()
            """
        ),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason='CREATE clause semantics are not supported',
        tags=('create', 'xfail'),
    ),
    Scenario(
        key='create3-4',
        feature_path='tck/features/clauses/create/Create3.feature',
        scenario='[4] MATCH-CREATE: Newly-created nodes not visible to preceding MATCH',
        cypher='MATCH ()\n      CREATE ()',
        graph=graph_fixture_from_create(
            """
            CREATE ()
            """
        ),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason='CREATE clause semantics are not supported',
        tags=('create', 'xfail'),
    ),
    Scenario(
        key='create3-5',
        feature_path='tck/features/clauses/create/Create3.feature',
        scenario='[5] WITH-CREATE: Nodes are not created when aliases are applied to variable names',
        cypher='MATCH (n)\n      MATCH (m)\n      WITH n AS a, m AS b\n      CREATE (a)-[:T]->(b)\n      RETURN a, b',
        graph=graph_fixture_from_create(
            """
            CREATE ({num: 1})
            """
        ),
        expected=Expected(
            rows=[
            {'a': '({num: 1})', 'b': '({num: 1})'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='CREATE clause semantics are not supported',
        tags=('create', 'xfail'),
    ),
    Scenario(
        key='create3-6',
        feature_path='tck/features/clauses/create/Create3.feature',
        scenario='[6] WITH-CREATE: Only a single node is created when an alias is applied to a variable name',
        cypher='MATCH (n)\n      WITH n AS a\n      CREATE (a)-[:T]->()\n      RETURN a',
        graph=graph_fixture_from_create(
            """
            CREATE (:X)
            """
        ),
        expected=Expected(
            rows=[
            {'a': '(:X)'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='CREATE clause semantics are not supported',
        tags=('create', 'xfail'),
    ),
    Scenario(
        key='create3-7',
        feature_path='tck/features/clauses/create/Create3.feature',
        scenario='[7] WITH-CREATE: Nodes are not created when aliases are applied to variable names multiple times',
        cypher='MATCH (n)\n      MATCH (m)\n      WITH n AS a, m AS b\n      CREATE (a)-[:T]->(b)\n      WITH a AS x, b AS y\n      CREATE (x)-[:T]->(y)\n      RETURN x, y',
        graph=graph_fixture_from_create(
            """
            CREATE ({name: 'A'})
            """
        ),
        expected=Expected(
            rows=[
            {'x': "({name: 'A'})", 'y': "({name: 'A'})"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='CREATE clause semantics are not supported',
        tags=('create', 'xfail'),
    ),
    Scenario(
        key='create3-8',
        feature_path='tck/features/clauses/create/Create3.feature',
        scenario='[8] WITH-CREATE: Only a single node is created when an alias is applied to a variable name multiple times',
        cypher='MATCH (n)\n      WITH n AS a\n      CREATE (a)-[:T]->()\n      WITH a AS x\n      CREATE (x)-[:T]->()\n      RETURN x',
        graph=graph_fixture_from_create(
            """
            CREATE ({num: 5})
            """
        ),
        expected=Expected(
            rows=[
            {'x': '({num: 5})'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='CREATE clause semantics are not supported',
        tags=('create', 'xfail'),
    ),
    Scenario(
        key='create3-9',
        feature_path='tck/features/clauses/create/Create3.feature',
        scenario='[9] WITH-CREATE: A bound node should be recognized after projection with WITH + WITH',
        cypher='CREATE (a)\n      WITH a\n      WITH *\n      CREATE (b)\n      CREATE (a)<-[:T]-(b)',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason='CREATE clause semantics are not supported',
        tags=('create', 'xfail'),
    ),
    Scenario(
        key='create3-10',
        feature_path='tck/features/clauses/create/Create3.feature',
        scenario='[10] WITH-UNWIND-CREATE: A bound node should be recognized after projection with WITH + UNWIND',
        cypher='CREATE (a)\n      WITH a\n      UNWIND [0] AS i\n      CREATE (b)\n      CREATE (a)<-[:T]-(b)',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason='CREATE clause semantics are not supported',
        tags=('create', 'xfail'),
    ),
    Scenario(
        key='create3-11',
        feature_path='tck/features/clauses/create/Create3.feature',
        scenario='[11] WITH-MERGE-CREATE: A bound node should be recognized after projection with WITH + MERGE node',
        cypher='CREATE (a)\n      WITH a\n      MERGE ()\n      CREATE (b)\n      CREATE (a)<-[:T]-(b)',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason='CREATE clause semantics are not supported',
        tags=('create', 'xfail'),
    ),
    Scenario(
        key='create3-12',
        feature_path='tck/features/clauses/create/Create3.feature',
        scenario='[12] WITH-MERGE-CREATE: A bound node should be recognized after projection with WITH + MERGE pattern',
        cypher='CREATE (a)\n      WITH a\n      MERGE (x)\n      MERGE (y)\n      MERGE (x)-[:T]->(y)\n      CREATE (b)\n      CREATE (a)<-[:T]-(b)',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason='CREATE clause semantics are not supported',
        tags=('create', 'xfail'),
    ),
    Scenario(
        key='create3-13',
        feature_path='tck/features/clauses/create/Create3.feature',
        scenario='[13] Merge followed by multiple creates',
        cypher='MERGE (t:T {id: 42})\n      CREATE (f:R)\n      CREATE (t)-[:REL]->(f)',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason='CREATE clause semantics are not supported',
        tags=('create', 'xfail'),
    ),
    Scenario(
        key='create4-1',
        feature_path='tck/features/clauses/create/Create4.feature',
        scenario='[1] Generate the movie graph',
        cypher='CREATE (theMatrix:Movie {title: \'The Matrix\', released: 1999, tagline: \'Welcome to the Real World\'})\n      CREATE (keanu:Person {name: \'Keanu Reeves\', born: 1964})\n      CREATE (carrie:Person {name: \'Carrie-Anne Moss\', born: 1967})\n      CREATE (laurence:Person {name: \'Laurence Fishburne\', born: 1961})\n      CREATE (hugo:Person {name: \'Hugo Weaving\', born: 1960})\n      CREATE (andyW:Person {name: \'Andy Wachowski\', born: 1967})\n      CREATE (lanaW:Person {name: \'Lana Wachowski\', born: 1965})\n      CREATE (joelS:Person {name: \'Joel Silver\', born: 1952})\n      CREATE\n        (keanu)-[:ACTED_IN {roles: [\'Neo\']}]->(theMatrix),\n        (carrie)-[:ACTED_IN {roles: [\'Trinity\']}]->(theMatrix),\n        (laurence)-[:ACTED_IN {roles: [\'Morpheus\']}]->(theMatrix),\n        (hugo)-[:ACTED_IN {roles: [\'Agent Smith\']}]->(theMatrix),\n        (andyW)-[:DIRECTED]->(theMatrix),\n        (lanaW)-[:DIRECTED]->(theMatrix),\n        (joelS)-[:PRODUCED]->(theMatrix)\n\n      CREATE (emil:Person {name: \'Emil Eifrem\', born: 1978})\n      CREATE (emil)-[:ACTED_IN {roles: [\'Emil\']}]->(theMatrix)\n\n      CREATE (theMatrixReloaded:Movie {title: \'The Matrix Reloaded\', released: 2003,\n              tagline: \'Free your mind\'})\n      CREATE\n        (keanu)-[:ACTED_IN {roles: [\'Neo\'] }]->(theMatrixReloaded),\n        (carrie)-[:ACTED_IN {roles: [\'Trinity\']}]->(theMatrixReloaded),\n        (laurence)-[:ACTED_IN {roles: [\'Morpheus\']}]->(theMatrixReloaded),\n        (hugo)-[:ACTED_IN {roles: [\'Agent Smith\']}]->(theMatrixReloaded),\n        (andyW)-[:DIRECTED]->(theMatrixReloaded),\n        (lanaW)-[:DIRECTED]->(theMatrixReloaded),\n        (joelS)-[:PRODUCED]->(theMatrixReloaded)\n\n      CREATE (theMatrixRevolutions:Movie {title: \'The Matrix Revolutions\', released: 2003,\n        tagline: \'Everything that has a beginning has an end\'})\n      CREATE\n        (keanu)-[:ACTED_IN {roles: [\'Neo\']}]->(theMatrixRevolutions),\n        (carrie)-[:ACTED_IN {roles: [\'Trinity\']}]->(theMatrixRevolutions),\n        (laurence)-[:ACTED_IN {roles: [\'Morpheus\']}]->(theMatrixRevolutions),\n        (hugo)-[:ACTED_IN {roles: [\'Agent Smith\']}]->(theMatrixRevolutions),\n        (andyW)-[:DIRECTED]->(theMatrixRevolutions),\n        (lanaW)-[:DIRECTED]->(theMatrixRevolutions),\n        (joelS)-[:PRODUCED]->(theMatrixRevolutions)\n\n      CREATE (theDevilsAdvocate:Movie {title: \'The Devil\\\'s Advocate\', released: 1997,\n        tagline: \'Evil has its winning ways\'})\n      CREATE (charlize:Person {name: \'Charlize Theron\', born: 1975})\n      CREATE (al:Person {name: \'Al Pacino\', born: 1940})\n      CREATE (taylor:Person {name: \'Taylor Hackford\', born: 1944})\n      CREATE\n        (keanu)-[:ACTED_IN {roles: [\'Kevin Lomax\']}]->(theDevilsAdvocate),\n        (charlize)-[:ACTED_IN {roles: [\'Mary Ann Lomax\']}]->(theDevilsAdvocate),\n        (al)-[:ACTED_IN {roles: [\'John Milton\']}]->(theDevilsAdvocate),\n        (taylor)-[:DIRECTED]->(theDevilsAdvocate)\n\n      CREATE (aFewGoodMen:Movie {title: \'A Few Good Men\', released: 1992,\n        tagline: \'Deep within the heart of the nation\\\'s capital, one man will stop at nothing to keep his honor, ...\'})\n      CREATE (tomC:Person {name: \'Tom Cruise\', born: 1962})\n      CREATE (jackN:Person {name: \'Jack Nicholson\', born: 1937})\n      CREATE (demiM:Person {name: \'Demi Moore\', born: 1962})\n      CREATE (kevinB:Person {name: \'Kevin Bacon\', born: 1958})\n      CREATE (kieferS:Person {name: \'Kiefer Sutherland\', born: 1966})\n      CREATE (noahW:Person {name: \'Noah Wyle\', born: 1971})\n      CREATE (cubaG:Person {name: \'Cuba Gooding Jr.\', born: 1968})\n      CREATE (kevinP:Person {name: \'Kevin Pollak\', born: 1957})\n      CREATE (jTW:Person {name: \'J.T. Walsh\', born: 1943})\n      CREATE (jamesM:Person {name: \'James Marshall\', born: 1967})\n      CREATE (christopherG:Person {name: \'Christopher Guest\', born: 1948})\n      CREATE (robR:Person {name: \'Rob Reiner\', born: 1947})\n      CREATE (aaronS:Person {name: \'Aaron Sorkin\', born: 1961})\n      CREATE\n        (tomC)-[:ACTED_IN {roles: [\'Lt. Daniel Kaffee\']}]->(aFewGoodMen),\n        (jackN)-[:ACTED_IN {roles: [\'Col. Nathan R. Jessup\']}]->(aFewGoodMen),\n        (demiM)-[:ACTED_IN {roles: [\'Lt. Cdr. JoAnne Galloway\']}]->(aFewGoodMen),\n        (kevinB)-[:ACTED_IN {roles: [\'Capt. Jack Ross\']}]->(aFewGoodMen),\n        (kieferS)-[:ACTED_IN {roles: [\'Lt. Jonathan Kendrick\']}]->(aFewGoodMen),\n        (noahW)-[:ACTED_IN {roles: [\'Cpl. Jeffrey Barnes\']}]->(aFewGoodMen),\n        (cubaG)-[:ACTED_IN {roles: [\'Cpl. Carl Hammaker\']}]->(aFewGoodMen),\n        (kevinP)-[:ACTED_IN {roles: [\'Lt. Sam Weinberg\']}]->(aFewGoodMen),\n        (jTW)-[:ACTED_IN {roles: [\'Lt. Col. Matthew Andrew Markinson\']}]->(aFewGoodMen),\n        (jamesM)-[:ACTED_IN {roles: [\'Pfc. Louden Downey\']}]->(aFewGoodMen),\n        (christopherG)-[:ACTED_IN {roles: [\'Dr. Stone\']}]->(aFewGoodMen),\n        (aaronS)-[:ACTED_IN {roles: [\'Bar patron\']}]->(aFewGoodMen),\n        (robR)-[:DIRECTED]->(aFewGoodMen),\n        (aaronS)-[:WROTE]->(aFewGoodMen)\n\n      CREATE (topGun:Movie {title: \'Top Gun\', released: 1986,\n          tagline: \'I feel the need, the need for speed.\'})\n      CREATE (kellyM:Person {name: \'Kelly McGillis\', born: 1957})\n      CREATE (valK:Person {name: \'Val Kilmer\', born: 1959})\n      CREATE (anthonyE:Person {name: \'Anthony Edwards\', born: 1962})\n      CREATE (tomS:Person {name: \'Tom Skerritt\', born: 1933})\n      CREATE (megR:Person {name: \'Meg Ryan\', born: 1961})\n      CREATE (tonyS:Person {name: \'Tony Scott\', born: 1944})\n      CREATE (jimC:Person {name: \'Jim Cash\', born: 1941})\n      CREATE\n        (tomC)-[:ACTED_IN {roles: [\'Maverick\']}]->(topGun),\n        (kellyM)-[:ACTED_IN {roles: [\'Charlie\']}]->(topGun),\n        (valK)-[:ACTED_IN {roles: [\'Iceman\']}]->(topGun),\n        (anthonyE)-[:ACTED_IN {roles: [\'Goose\']}]->(topGun),\n        (tomS)-[:ACTED_IN {roles: [\'Viper\']}]->(topGun),\n        (megR)-[:ACTED_IN {roles: [\'Carole\']}]->(topGun),\n        (tonyS)-[:DIRECTED]->(topGun),\n        (jimC)-[:WROTE]->(topGun)\n\n      CREATE (jerryMaguire:Movie {title: \'Jerry Maguire\', released: 2000,\n          tagline: \'The rest of his life begins now.\'})\n      CREATE (reneeZ:Person {name: \'Renee Zellweger\', born: 1969})\n      CREATE (kellyP:Person {name: \'Kelly Preston\', born: 1962})\n      CREATE (jerryO:Person {name: \'Jerry O\\\'Connell\', born: 1974})\n      CREATE (jayM:Person {name: \'Jay Mohr\', born: 1970})\n      CREATE (bonnieH:Person {name: \'Bonnie Hunt\', born: 1961})\n      CREATE (reginaK:Person {name: \'Regina King\', born: 1971})\n      CREATE (jonathanL:Person {name: \'Jonathan Lipnicki\', born: 1996})\n      CREATE (cameronC:Person {name: \'Cameron Crowe\', born: 1957})\n      CREATE\n        (tomC)-[:ACTED_IN {roles: [\'Jerry Maguire\']}]->(jerryMaguire),\n        (cubaG)-[:ACTED_IN {roles: [\'Rod Tidwell\']}]->(jerryMaguire),\n        (reneeZ)-[:ACTED_IN {roles: [\'Dorothy Boyd\']}]->(jerryMaguire),\n        (kellyP)-[:ACTED_IN {roles: [\'Avery Bishop\']}]->(jerryMaguire),\n        (jerryO)-[:ACTED_IN {roles: [\'Frank Cushman\']}]->(jerryMaguire),\n        (jayM)-[:ACTED_IN {roles: [\'Bob Sugar\']}]->(jerryMaguire),\n        (bonnieH)-[:ACTED_IN {roles: [\'Laurel Boyd\']}]->(jerryMaguire),\n        (reginaK)-[:ACTED_IN {roles: [\'Marcee Tidwell\']}]->(jerryMaguire),\n        (jonathanL)-[:ACTED_IN {roles: [\'Ray Boyd\']}]->(jerryMaguire),\n        (cameronC)-[:DIRECTED]->(jerryMaguire),\n        (cameronC)-[:PRODUCED]->(jerryMaguire),\n        (cameronC)-[:WROTE]->(jerryMaguire)\n\n      CREATE (standByMe:Movie {title: \'Stand-By-Me\', released: 1986,\n          tagline: \'The last real taste of innocence\'})\n      CREATE (riverP:Person {name: \'River Phoenix\', born: 1970})\n      CREATE (coreyF:Person {name: \'Corey Feldman\', born: 1971})\n      CREATE (wilW:Person {name: \'Wil Wheaton\', born: 1972})\n      CREATE (johnC:Person {name: \'John Cusack\', born: 1966})\n      CREATE (marshallB:Person {name: \'Marshall Bell\', born: 1942})\n      CREATE\n        (wilW)-[:ACTED_IN {roles: [\'Gordie Lachance\']}]->(standByMe),\n        (riverP)-[:ACTED_IN {roles: [\'Chris Chambers\']}]->(standByMe),\n        (jerryO)-[:ACTED_IN {roles: [\'Vern Tessio\']}]->(standByMe),\n        (coreyF)-[:ACTED_IN {roles: [\'Teddy Duchamp\']}]->(standByMe),\n        (johnC)-[:ACTED_IN {roles: [\'Denny Lachance\']}]->(standByMe),\n        (kieferS)-[:ACTED_IN {roles: [\'Ace Merrill\']}]->(standByMe),\n        (marshallB)-[:ACTED_IN {roles: [\'Mr. Lachance\']}]->(standByMe),\n        (robR)-[:DIRECTED]->(standByMe)\n\n      CREATE (asGoodAsItGets:Movie {title: \'As-good-as-it-gets\', released: 1997,\n          tagline: \'A comedy from the heart that goes for the throat\'})\n      CREATE (helenH:Person {name: \'Helen Hunt\', born: 1963})\n      CREATE (gregK:Person {name: \'Greg Kinnear\', born: 1963})\n      CREATE (jamesB:Person {name: \'James L. Brooks\', born: 1940})\n      CREATE\n        (jackN)-[:ACTED_IN {roles: [\'Melvin Udall\']}]->(asGoodAsItGets),\n        (helenH)-[:ACTED_IN {roles: [\'Carol Connelly\']}]->(asGoodAsItGets),\n        (gregK)-[:ACTED_IN {roles: [\'Simon Bishop\']}]->(asGoodAsItGets),\n        (cubaG)-[:ACTED_IN {roles: [\'Frank Sachs\']}]->(asGoodAsItGets),\n        (jamesB)-[:DIRECTED]->(asGoodAsItGets)\n\n      CREATE (whatDreamsMayCome:Movie {title: \'What Dreams May Come\', released: 1998,\n          tagline: \'After life there is more. The end is just the beginning.\'})\n      CREATE (annabellaS:Person {name: \'Annabella Sciorra\', born: 1960})\n      CREATE (maxS:Person {name: \'Max von Sydow\', born: 1929})\n      CREATE (wernerH:Person {name: \'Werner Herzog\', born: 1942})\n      CREATE (robin:Person {name: \'Robin Williams\', born: 1951})\n      CREATE (vincentW:Person {name: \'Vincent Ward\', born: 1956})\n      CREATE\n        (robin)-[:ACTED_IN {roles: [\'Chris Nielsen\']}]->(whatDreamsMayCome),\n        (cubaG)-[:ACTED_IN {roles: [\'Albert Lewis\']}]->(whatDreamsMayCome),\n        (annabellaS)-[:ACTED_IN {roles: [\'Annie Collins-Nielsen\']}]->(whatDreamsMayCome),\n        (maxS)-[:ACTED_IN {roles: [\'The Tracker\']}]->(whatDreamsMayCome),\n        (wernerH)-[:ACTED_IN {roles: [\'The Face\']}]->(whatDreamsMayCome),\n        (vincentW)-[:DIRECTED]->(whatDreamsMayCome)\n\n      CREATE (snowFallingonCedars:Movie {title: \'Snow-Falling-on-Cedars\', released: 1999,\n        tagline: \'First loves last. Forever.\'})\n      CREATE (ethanH:Person {name: \'Ethan Hawke\', born: 1970})\n      CREATE (rickY:Person {name: \'Rick Yune\', born: 1971})\n      CREATE (jamesC:Person {name: \'James Cromwell\', born: 1940})\n      CREATE (scottH:Person {name: \'Scott Hicks\', born: 1953})\n      CREATE\n        (ethanH)-[:ACTED_IN {roles: [\'Ishmael Chambers\']}]->(snowFallingonCedars),\n        (rickY)-[:ACTED_IN {roles: [\'Kazuo Miyamoto\']}]->(snowFallingonCedars),\n        (maxS)-[:ACTED_IN {roles: [\'Nels Gudmundsson\']}]->(snowFallingonCedars),\n        (jamesC)-[:ACTED_IN {roles: [\'Judge Fielding\']}]->(snowFallingonCedars),\n        (scottH)-[:DIRECTED]->(snowFallingonCedars)\n\n      CREATE (youveGotMail:Movie {title: \'You\\\'ve Got Mail\', released: 1998,\n          tagline: \'At-odds-in-life, in-love-on-line\'})\n      CREATE (parkerP:Person {name: \'Parker Posey\', born: 1968})\n      CREATE (daveC:Person {name: \'Dave Chappelle\', born: 1973})\n      CREATE (steveZ:Person {name: \'Steve Zahn\', born: 1967})\n      CREATE (tomH:Person {name: \'Tom Hanks\', born: 1956})\n      CREATE (noraE:Person {name: \'Nora Ephron\', born: 1941})\n      CREATE\n        (tomH)-[:ACTED_IN {roles: [\'Joe Fox\']}]->(youveGotMail),\n        (megR)-[:ACTED_IN {roles: [\'Kathleen Kelly\']}]->(youveGotMail),\n        (gregK)-[:ACTED_IN {roles: [\'Frank Navasky\']}]->(youveGotMail),\n        (parkerP)-[:ACTED_IN {roles: [\'Patricia Eden\']}]->(youveGotMail),\n        (daveC)-[:ACTED_IN {roles: [\'Kevin Jackson\']}]->(youveGotMail),\n        (steveZ)-[:ACTED_IN {roles: [\'George Pappas\']}]->(youveGotMail),\n        (noraE)-[:DIRECTED]->(youveGotMail)\n\n      CREATE (sleeplessInSeattle:Movie {title: \'Sleepless-in-Seattle\', released: 1993,\n          tagline: \'What if someone you never met, someone you never saw, someone you never knew was the only someone for you?\'})\n      CREATE (ritaW:Person {name: \'Rita Wilson\', born: 1956})\n      CREATE (billPull:Person {name: \'Bill Pullman\', born: 1953})\n      CREATE (victorG:Person {name: \'Victor Garber\', born: 1949})\n      CREATE (rosieO:Person {name: \'Rosie O\\\'Donnell\', born: 1962})\n      CREATE\n        (tomH)-[:ACTED_IN {roles: [\'Sam Baldwin\']}]->(sleeplessInSeattle),\n        (megR)-[:ACTED_IN {roles: [\'Annie Reed\']}]->(sleeplessInSeattle),\n        (ritaW)-[:ACTED_IN {roles: [\'Suzy\']}]->(sleeplessInSeattle),\n        (billPull)-[:ACTED_IN {roles: [\'Walter\']}]->(sleeplessInSeattle),\n        (victorG)-[:ACTED_IN {roles: [\'Greg\']}]->(sleeplessInSeattle),\n        (rosieO)-[:ACTED_IN {roles: [\'Becky\']}]->(sleeplessInSeattle),\n        (noraE)-[:DIRECTED]->(sleeplessInSeattle)\n\n      CREATE (joeVersustheVolcano:Movie {title: \'Joe-Versus-the-Volcano\', released: 1990,\n          tagline: \'A story of love\'})\n      CREATE (johnS:Person {name: \'John Patrick Stanley\', born: 1950})\n      CREATE (nathan:Person {name: \'Nathan Lane\', born: 1956})\n      CREATE\n        (tomH)-[:ACTED_IN {roles: [\'Joe Banks\']}]->(joeVersustheVolcano),\n        (megR)-[:ACTED_IN {roles: [\'DeDe\', \'Angelica Graynamore\', \'Patricia Graynamore\']}]->(joeVersustheVolcano),\n        (nathan)-[:ACTED_IN {roles: [\'Baw\']}]->(joeVersustheVolcano),\n        (johnS)-[:DIRECTED]->(joeVersustheVolcano)\n\n      CREATE (whenHarryMetSally:Movie {title: \'When-Harry-Met-Sally\', released: 1998,\n          tagline: \'When-Harry-Met-Sally\'})\n      CREATE (billyC:Person {name: \'Billy Crystal\', born: 1948})\n      CREATE (carrieF:Person {name: \'Carrie Fisher\', born: 1956})\n      CREATE (brunoK:Person {name: \'Bruno Kirby\', born: 1949})\n      CREATE\n        (billyC)-[:ACTED_IN {roles: [\'Harry Burns\']}]->(whenHarryMetSally),\n        (megR)-[:ACTED_IN {roles: [\'Sally Albright\']}]->(whenHarryMetSally),\n        (carrieF)-[:ACTED_IN {roles: [\'Marie\']}]->(whenHarryMetSally),\n        (brunoK)-[:ACTED_IN {roles: [\'Jess\']}]->(whenHarryMetSally),\n        (robR)-[:DIRECTED]->(whenHarryMetSally),\n        (robR)-[:PRODUCED]->(whenHarryMetSally),\n        (noraE)-[:PRODUCED]->(whenHarryMetSally),\n        (noraE)-[:WROTE]->(whenHarryMetSally)\n\n      CREATE (thatThingYouDo:Movie {title: \'That-Thing-You-Do\', released: 1996,\n          tagline: \'There comes a time...\'})\n      CREATE (livT:Person {name: \'Liv Tyler\', born: 1977})\n      CREATE\n        (tomH)-[:ACTED_IN {roles: [\'Mr. White\']}]->(thatThingYouDo),\n        (livT)-[:ACTED_IN {roles: [\'Faye Dolan\']}]->(thatThingYouDo),\n        (charlize)-[:ACTED_IN {roles: [\'Tina\']}]->(thatThingYouDo),\n        (tomH)-[:DIRECTED]->(thatThingYouDo)\n\n      CREATE (theReplacements:Movie {title: \'The Replacements\', released: 2000,\n          tagline: \'Pain heals, Chicks dig scars... Glory lasts forever\'})\n      CREATE (brooke:Person {name: \'Brooke Langton\', born: 1970})\n      CREATE (gene:Person {name: \'Gene Hackman\', born: 1930})\n      CREATE (orlando:Person {name: \'Orlando Jones\', born: 1968})\n      CREATE (howard:Person {name: \'Howard Deutch\', born: 1950})\n      CREATE\n        (keanu)-[:ACTED_IN {roles: [\'Shane Falco\']}]->(theReplacements),\n        (brooke)-[:ACTED_IN {roles: [\'Annabelle Farrell\']}]->(theReplacements),\n        (gene)-[:ACTED_IN {roles: [\'Jimmy McGinty\']}]->(theReplacements),\n        (orlando)-[:ACTED_IN {roles: [\'Clifford Franklin\']}]->(theReplacements),\n        (howard)-[:DIRECTED]->(theReplacements)\n\n      CREATE (rescueDawn:Movie {title: \'RescueDawn\', released: 2006,\n          tagline: \'The extraordinary true story\'})\n      CREATE (christianB:Person {name: \'Christian Bale\', born: 1974})\n      CREATE (zachG:Person {name: \'Zach Grenier\', born: 1954})\n      CREATE\n        (marshallB)-[:ACTED_IN {roles: [\'Admiral\']}]->(rescueDawn),\n        (christianB)-[:ACTED_IN {roles: [\'Dieter Dengler\']}]->(rescueDawn),\n        (zachG)-[:ACTED_IN {roles: [\'Squad Leader\']}]->(rescueDawn),\n        (steveZ)-[:ACTED_IN {roles: [\'Duane\']}]->(rescueDawn),\n        (wernerH)-[:DIRECTED]->(rescueDawn)\n\n      CREATE (theBirdcage:Movie {title: \'The-Birdcage\', released: 1996, tagline: \'Come-as-you-are\'})\n      CREATE (mikeN:Person {name: \'Mike Nichols\', born: 1931})\n      CREATE\n        (robin)-[:ACTED_IN {roles: [\'Armand Goldman\']}]->(theBirdcage),\n        (nathan)-[:ACTED_IN {roles: [\'Albert Goldman\']}]->(theBirdcage),\n        (gene)-[:ACTED_IN {roles: [\'Sen. Kevin Keeley\']}]->(theBirdcage),\n        (mikeN)-[:DIRECTED]->(theBirdcage)\n\n      CREATE (unforgiven:Movie {title: \'Unforgiven\', released: 1992,\n          tagline: \'It\\\'s a hell of a thing, killing a man\'})\n      CREATE (richardH:Person {name: \'Richard Harris\', born: 1930})\n      CREATE (clintE:Person {name: \'Clint Eastwood\', born: 1930})\n      CREATE\n        (richardH)-[:ACTED_IN {roles: [\'English Bob\']}]->(unforgiven),\n        (clintE)-[:ACTED_IN {roles: [\'Bill Munny\']}]->(unforgiven),\n        (gene)-[:ACTED_IN {roles: [\'Little Bill Daggett\']}]->(unforgiven),\n        (clintE)-[:DIRECTED]->(unforgiven)\n\n      CREATE (johnnyMnemonic:Movie {title: \'Johnny-Mnemonic\', released: 1995,\n          tagline: \'The-hottest-data-in-the-coolest-head\'})\n      CREATE (takeshi:Person {name: \'Takeshi Kitano\', born: 1947})\n      CREATE (dina:Person {name: \'Dina Meyer\', born: 1968})\n      CREATE (iceT:Person {name: \'Ice-T\', born: 1958})\n      CREATE (robertL:Person {name: \'Robert Longo\', born: 1953})\n      CREATE\n        (keanu)-[:ACTED_IN {roles: [\'Johnny Mnemonic\']}]->(johnnyMnemonic),\n        (takeshi)-[:ACTED_IN {roles: [\'Takahashi\']}]->(johnnyMnemonic),\n        (dina)-[:ACTED_IN {roles: [\'Jane\']}]->(johnnyMnemonic),\n        (iceT)-[:ACTED_IN {roles: [\'J-Bone\']}]->(johnnyMnemonic),\n        (robertL)-[:DIRECTED]->(johnnyMnemonic)\n\n      CREATE (cloudAtlas:Movie {title: \'Cloud Atlas\', released: 2012, tagline: \'Everything is connected\'})\n      CREATE (halleB:Person {name: \'Halle Berry\', born: 1966})\n      CREATE (jimB:Person {name: \'Jim Broadbent\', born: 1949})\n      CREATE (tomT:Person {name: \'Tom Tykwer\', born: 1965})\n      CREATE (davidMitchell:Person {name: \'David Mitchell\', born: 1969})\n      CREATE (stefanArndt:Person {name: \'Stefan Arndt\', born: 1961})\n      CREATE\n        (tomH)-[:ACTED_IN {roles: [\'Zachry\', \'Dr. Henry Goose\', \'Isaac Sachs\', \'Dermot Hoggins\']}]->(cloudAtlas),\n        (hugo)-[:ACTED_IN {roles: [\'Bill Smoke\', \'Haskell Moore\', \'Tadeusz Kesselring\', \'Nurse Noakes\', \'Boardman Mephi\', \'Old Georgie\']}]->(cloudAtlas),\n        (halleB)-[:ACTED_IN {roles: [\'Luisa Rey\', \'Jocasta Ayrs\', \'Ovid\', \'Meronym\']}]->(cloudAtlas),\n        (jimB)-[:ACTED_IN {roles: [\'Vyvyan Ayrs\', \'Captain Molyneux\', \'Timothy Cavendish\']}]->(cloudAtlas),\n        (tomT)-[:DIRECTED]->(cloudAtlas),\n        (andyW)-[:DIRECTED]->(cloudAtlas),\n        (lanaW)-[:DIRECTED]->(cloudAtlas),\n        (davidMitchell)-[:WROTE]->(cloudAtlas),\n        (stefanArndt)-[:PRODUCED]->(cloudAtlas)\n\n      CREATE (theDaVinciCode:Movie {title: \'The Da Vinci Code\', released: 2006, tagline: \'Break The Codes\'})\n      CREATE (ianM:Person {name: \'Ian McKellen\', born: 1939})\n      CREATE (audreyT:Person {name: \'Audrey Tautou\', born: 1976})\n      CREATE (paulB:Person {name: \'Paul Bettany\', born: 1971})\n      CREATE (ronH:Person {name: \'Ron Howard\', born: 1954})\n      CREATE\n        (tomH)-[:ACTED_IN {roles: [\'Dr. Robert Langdon\']}]->(theDaVinciCode),\n        (ianM)-[:ACTED_IN {roles: [\'Sir Leight Teabing\']}]->(theDaVinciCode),\n        (audreyT)-[:ACTED_IN {roles: [\'Sophie Neveu\']}]->(theDaVinciCode),\n        (paulB)-[:ACTED_IN {roles: [\'Silas\']}]->(theDaVinciCode),\n        (ronH)-[:DIRECTED]->(theDaVinciCode)\n\n      CREATE (vforVendetta:Movie {title: \'V for Vendetta\', released: 2006, tagline: \'Freedom! Forever!\'})\n      CREATE (natalieP:Person {name: \'Natalie Portman\', born: 1981})\n      CREATE (stephenR:Person {name: \'Stephen Rea\', born: 1946})\n      CREATE (johnH:Person {name: \'John Hurt\', born: 1940})\n      CREATE (benM:Person {name: \'Ben Miles\', born: 1967})\n      CREATE\n        (hugo)-[:ACTED_IN {roles: [\'V\']}]->(vforVendetta),\n        (natalieP)-[:ACTED_IN {roles: [\'Evey Hammond\']}]->(vforVendetta),\n        (stephenR)-[:ACTED_IN {roles: [\'Eric Finch\']}]->(vforVendetta),\n        (johnH)-[:ACTED_IN {roles: [\'High Chancellor Adam Sutler\']}]->(vforVendetta),\n        (benM)-[:ACTED_IN {roles: [\'Dascomb\']}]->(vforVendetta),\n        (jamesM)-[:DIRECTED]->(vforVendetta),\n        (andyW)-[:PRODUCED]->(vforVendetta),\n        (lanaW)-[:PRODUCED]->(vforVendetta),\n        (joelS)-[:PRODUCED]->(vforVendetta),\n        (andyW)-[:WROTE]->(vforVendetta),\n        (lanaW)-[:WROTE]->(vforVendetta)\n\n      CREATE (speedRacer:Movie {title: \'Speed Racer\', released: 2008, tagline: \'Speed has no limits\'})\n      CREATE (emileH:Person {name: \'Emile Hirsch\', born: 1985})\n      CREATE (johnG:Person {name: \'John Goodman\', born: 1960})\n      CREATE (susanS:Person {name: \'Susan Sarandon\', born: 1946})\n      CREATE (matthewF:Person {name: \'Matthew Fox\', born: 1966})\n      CREATE (christinaR:Person {name: \'Christina Ricci\', born: 1980})\n      CREATE (rain:Person {name: \'Rain\', born: 1982})\n      CREATE\n        (emileH)-[:ACTED_IN {roles: [\'Speed Racer\']}]->(speedRacer),\n        (johnG)-[:ACTED_IN {roles: [\'Pops\']}]->(speedRacer),\n        (susanS)-[:ACTED_IN {roles: [\'Mom\']}]->(speedRacer),\n        (matthewF)-[:ACTED_IN {roles: [\'Racer X\']}]->(speedRacer),\n        (christinaR)-[:ACTED_IN {roles: [\'Trixie\']}]->(speedRacer),\n        (rain)-[:ACTED_IN {roles: [\'Taejo Togokahn\']}]->(speedRacer),\n        (benM)-[:ACTED_IN {roles: [\'Cass Jones\']}]->(speedRacer),\n        (andyW)-[:DIRECTED]->(speedRacer),\n        (lanaW)-[:DIRECTED]->(speedRacer),\n        (andyW)-[:WROTE]->(speedRacer),\n        (lanaW)-[:WROTE]->(speedRacer),\n        (joelS)-[:PRODUCED]->(speedRacer)\n\n      CREATE (ninjaAssassin:Movie {title: \'Ninja Assassin\', released: 2009,\n          tagline: \'Prepare to enter a secret world of assassins\'})\n      CREATE (naomieH:Person {name: \'Naomie Harris\'})\n      CREATE\n        (rain)-[:ACTED_IN {roles: [\'Raizo\']}]->(ninjaAssassin),\n        (naomieH)-[:ACTED_IN {roles: [\'Mika Coretti\']}]->(ninjaAssassin),\n        (rickY)-[:ACTED_IN {roles: [\'Takeshi\']}]->(ninjaAssassin),\n        (benM)-[:ACTED_IN {roles: [\'Ryan Maslow\']}]->(ninjaAssassin),\n        (jamesM)-[:DIRECTED]->(ninjaAssassin),\n        (andyW)-[:PRODUCED]->(ninjaAssassin),\n        (lanaW)-[:PRODUCED]->(ninjaAssassin),\n        (joelS)-[:PRODUCED]->(ninjaAssassin)\n\n      CREATE (theGreenMile:Movie {title: \'The Green Mile\', released: 1999,\n          tagline: \'Walk a mile you\\\'ll never forget.\'})\n      CREATE (michaelD:Person {name: \'Michael Clarke Duncan\', born: 1957})\n      CREATE (davidM:Person {name: \'David Morse\', born: 1953})\n      CREATE (samR:Person {name: \'Sam Rockwell\', born: 1968})\n      CREATE (garyS:Person {name: \'Gary Sinise\', born: 1955})\n      CREATE (patriciaC:Person {name: \'Patricia Clarkson\', born: 1959})\n      CREATE (frankD:Person {name: \'Frank Darabont\', born: 1959})\n      CREATE\n        (tomH)-[:ACTED_IN {roles: [\'Paul Edgecomb\']}]->(theGreenMile),\n        (michaelD)-[:ACTED_IN {roles: [\'John Coffey\']}]->(theGreenMile),\n        (davidM)-[:ACTED_IN {roles: [\'Brutus Brutal Howell\']}]->(theGreenMile),\n        (bonnieH)-[:ACTED_IN {roles: [\'Jan Edgecomb\']}]->(theGreenMile),\n        (jamesC)-[:ACTED_IN {roles: [\'Warden Hal Moores\']}]->(theGreenMile),\n        (samR)-[:ACTED_IN {roles: [\'Wild Bill Wharton\']}]->(theGreenMile),\n        (garyS)-[:ACTED_IN {roles: [\'Burt Hammersmith\']}]->(theGreenMile),\n        (patriciaC)-[:ACTED_IN {roles: [\'Melinda Moores\']}]->(theGreenMile),\n        (frankD)-[:DIRECTED]->(theGreenMile)\n\n      CREATE (frostNixon:Movie {title: \'Frost/Nixon\', released: 2008,\n          tagline: \'400 million people were waiting for the truth.\'})\n      CREATE (frankL:Person {name: \'Frank Langella\', born: 1938})\n      CREATE (michaelS:Person {name: \'Michael Sheen\', born: 1969})\n      CREATE (oliverP:Person {name: \'Oliver Platt\', born: 1960})\n      CREATE\n        (frankL)-[:ACTED_IN {roles: [\'Richard Nixon\']}]->(frostNixon),\n        (michaelS)-[:ACTED_IN {roles: [\'David Frost\']}]->(frostNixon),\n        (kevinB)-[:ACTED_IN {roles: [\'Jack Brennan\']}]->(frostNixon),\n        (oliverP)-[:ACTED_IN {roles: [\'Bob Zelnick\']}]->(frostNixon),\n        (samR)-[:ACTED_IN {roles: [\'James Reston, Jr.\']}]->(frostNixon),\n        (ronH)-[:DIRECTED]->(frostNixon)\n\n      CREATE (hoffa:Movie {title: \'Hoffa\', released: 1992, tagline: "He didn\'t want law. He wanted justice."})\n      CREATE (dannyD:Person {name: \'Danny DeVito\', born: 1944})\n      CREATE (johnR:Person {name: \'John C. Reilly\', born: 1965})\n      CREATE\n        (jackN)-[:ACTED_IN {roles: [\'Hoffa\']}]->(hoffa),\n        (dannyD)-[:ACTED_IN {roles: [\'Robert Bobby Ciaro\']}]->(hoffa),\n        (jTW)-[:ACTED_IN {roles: [\'Frank Fitzsimmons\']}]->(hoffa),\n        (johnR)-[:ACTED_IN {roles: [\'Peter Connelly\']}]->(hoffa),\n        (dannyD)-[:DIRECTED]->(hoffa)\n\n      CREATE (apollo13:Movie {title: \'Apollo 13\', released: 1995, tagline: \'Houston, we have a problem.\'})\n      CREATE (edH:Person {name: \'Ed Harris\', born: 1950})\n      CREATE (billPax:Person {name: \'Bill Paxton\', born: 1955})\n      CREATE\n        (tomH)-[:ACTED_IN {roles: [\'Jim Lovell\']}]->(apollo13),\n        (kevinB)-[:ACTED_IN {roles: [\'Jack Swigert\']}]->(apollo13),\n        (edH)-[:ACTED_IN {roles: [\'Gene Kranz\']}]->(apollo13),\n        (billPax)-[:ACTED_IN {roles: [\'Fred Haise\']}]->(apollo13),\n        (garyS)-[:ACTED_IN {roles: [\'Ken Mattingly\']}]->(apollo13),\n        (ronH)-[:DIRECTED]->(apollo13)\n\n      CREATE (twister:Movie {title: \'Twister\', released: 1996, tagline: \'Don\\\'t Breathe. Don\\\'t Look Back.\'})\n      CREATE (philipH:Person {name: \'Philip Seymour Hoffman\', born: 1967})\n      CREATE (janB:Person {name: \'Jan de Bont\', born: 1943})\n      CREATE\n        (billPax)-[:ACTED_IN {roles: [\'Bill Harding\']}]->(twister),\n        (helenH)-[:ACTED_IN {roles: [\'Dr. Jo Harding\']}]->(twister),\n        (zachG)-[:ACTED_IN {roles: [\'Eddie\']}]->(twister),\n        (philipH)-[:ACTED_IN {roles: [\'Dustin Davis\']}]->(twister),\n        (janB)-[:DIRECTED]->(twister)\n\n      CREATE (castAway:Movie {title: \'Cast Away\', released: 2000,\n          tagline: \'At the edge of the world, his journey begins.\'})\n      CREATE (robertZ:Person {name: \'Robert Zemeckis\', born: 1951})\n      CREATE\n        (tomH)-[:ACTED_IN {roles: [\'Chuck Noland\']}]->(castAway),\n        (helenH)-[:ACTED_IN {roles: [\'Kelly Frears\']}]->(castAway),\n        (robertZ)-[:DIRECTED]->(castAway)\n\n      CREATE (oneFlewOvertheCuckoosNest:Movie {title: \'One Flew Over the Cuckoo\\\'s Nest\', released: 1975,\n          tagline: \'If he is crazy, what does that make you?\'})\n      CREATE (milosF:Person {name: \'Milos Forman\', born: 1932})\n      CREATE\n        (jackN)-[:ACTED_IN {roles: [\'Randle McMurphy\']}]->(oneFlewOvertheCuckoosNest),\n        (dannyD)-[:ACTED_IN {roles: [\'Martini\']}]->(oneFlewOvertheCuckoosNest),\n        (milosF)-[:DIRECTED]->(oneFlewOvertheCuckoosNest)\n\n      CREATE (somethingsGottaGive:Movie {title: \'Something\\\'s Gotta Give\', released: 2003})\n      CREATE (dianeK:Person {name: \'Diane Keaton\', born: 1946})\n      CREATE (nancyM:Person {name: \'Nancy Meyers\', born: 1949})\n      CREATE\n        (jackN)-[:ACTED_IN {roles: [\'Harry Sanborn\']}]->(somethingsGottaGive),\n        (dianeK)-[:ACTED_IN {roles: [\'Erica Barry\']}]->(somethingsGottaGive),\n        (keanu)-[:ACTED_IN {roles: [\'Julian Mercer\']}]->(somethingsGottaGive),\n        (nancyM)-[:DIRECTED]->(somethingsGottaGive),\n        (nancyM)-[:PRODUCED]->(somethingsGottaGive),\n        (nancyM)-[:WROTE]->(somethingsGottaGive)\n\n      CREATE (bicentennialMan:Movie {title: \'Bicentennial Man\', released: 1999,\n          tagline: \'One robot\\\'s 200 year journey to become an ordinary man.\'})\n      CREATE (chrisC:Person {name: \'Chris Columbus\', born: 1958})\n      CREATE\n        (robin)-[:ACTED_IN {roles: [\'Andrew Marin\']}]->(bicentennialMan),\n        (oliverP)-[:ACTED_IN {roles: [\'Rupert Burns\']}]->(bicentennialMan),\n        (chrisC)-[:DIRECTED]->(bicentennialMan)\n\n      CREATE (charlieWilsonsWar:Movie {title: \'Charlie Wilson\\\'s War\', released: 2007,\n          tagline: \'A stiff drink. A little mascara. A lot of nerve. Who said they could not bring down the Soviet empire.\'})\n      CREATE (juliaR:Person {name: \'Julia Roberts\', born: 1967})\n      CREATE\n        (tomH)-[:ACTED_IN {roles: [\'Rep. Charlie Wilson\']}]->(charlieWilsonsWar),\n        (juliaR)-[:ACTED_IN {roles: [\'Joanne Herring\']}]->(charlieWilsonsWar),\n        (philipH)-[:ACTED_IN {roles: [\'Gust Avrakotos\']}]->(charlieWilsonsWar),\n        (mikeN)-[:DIRECTED]->(charlieWilsonsWar)\n\n      CREATE (thePolarExpress:Movie {title: \'The Polar Express\', released: 2004,\n          tagline: \'This Holiday Season... Believe\'})\n      CREATE\n        (tomH)-[:ACTED_IN {roles: [\'Hero Boy\', \'Father\', \'Conductor\', \'Hobo\', \'Scrooge\', \'Santa Claus\']}]->(thePolarExpress),\n        (robertZ)-[:DIRECTED]->(thePolarExpress)\n\n      CREATE (aLeagueofTheirOwn:Movie {title: \'A League of Their Own\', released: 1992,\n          tagline: \'A league of their own\'})\n      CREATE (madonna:Person {name: \'Madonna\', born: 1954})\n      CREATE (geenaD:Person {name: \'Geena Davis\', born: 1956})\n      CREATE (loriP:Person {name: \'Lori Petty\', born: 1963})\n      CREATE (pennyM:Person {name: \'Penny Marshall\', born: 1943})\n      CREATE\n        (tomH)-[:ACTED_IN {roles: [\'Jimmy Dugan\']}]->(aLeagueofTheirOwn),\n        (geenaD)-[:ACTED_IN {roles: [\'Dottie Hinson\']}]->(aLeagueofTheirOwn),\n        (loriP)-[:ACTED_IN {roles: [\'Kit Keller\']}]->(aLeagueofTheirOwn),\n        (rosieO)-[:ACTED_IN {roles: [\'Doris Murphy\']}]->(aLeagueofTheirOwn),\n        (madonna)-[:ACTED_IN {roles: [\'Mae Mordabito\']}]->(aLeagueofTheirOwn),\n        (billPax)-[:ACTED_IN {roles: [\'Bob Hinson\']}]->(aLeagueofTheirOwn),\n        (pennyM)-[:DIRECTED]->(aLeagueofTheirOwn)\n\n      CREATE (paulBlythe:Person {name: \'Paul Blythe\'})\n      CREATE (angelaScope:Person {name: \'Angela Scope\'})\n      CREATE (jessicaThompson:Person {name: \'Jessica Thompson\'})\n      CREATE (jamesThompson:Person {name: \'James Thompson\'})\n\n      CREATE\n        (jamesThompson)-[:FOLLOWS]->(jessicaThompson),\n        (angelaScope)-[:FOLLOWS]->(jessicaThompson),\n        (paulBlythe)-[:FOLLOWS]->(angelaScope)\n\n      CREATE\n        (jessicaThompson)-[:REVIEWED {summary: \'An amazing journey\', rating: 95}]->(cloudAtlas),\n        (jessicaThompson)-[:REVIEWED {summary: \'Silly, but fun\', rating: 65}]->(theReplacements),\n        (jamesThompson)-[:REVIEWED {summary: \'The coolest football movie ever\', rating: 100}]->(theReplacements),\n        (angelaScope)-[:REVIEWED {summary: \'Pretty funny at times\', rating: 62}]->(theReplacements),\n        (jessicaThompson)-[:REVIEWED {summary: \'Dark, but compelling\', rating: 85}]->(unforgiven),\n        (jessicaThompson)-[:REVIEWED {summary: \'Slapstick\', rating: 45}]->(theBirdcage),\n        (jessicaThompson)-[:REVIEWED {summary: \'A solid romp\', rating: 68}]->(theDaVinciCode),\n        (jamesThompson)-[:REVIEWED {summary: \'Fun, but a little far fetched\', rating: 65}]->(theDaVinciCode),\n        (jessicaThompson)-[:REVIEWED {summary: \'You had me at Jerry\', rating: 92}]->(jerryMaguire)',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason='CREATE clause semantics are not supported',
        tags=('create', 'xfail'),
    ),
    Scenario(
        key='create4-2',
        feature_path='tck/features/clauses/create/Create4.feature',
        scenario='[2] Many CREATE clauses',
        cypher="CREATE (hf:School {name: 'Hilly Fields Technical College'})\n      CREATE (hf)-[:STAFF]->(mrb:Teacher {name: 'Mr Balls'})\n      CREATE (hf)-[:STAFF]->(mrspb:Teacher {name: 'Ms Packard-Bell'})\n      CREATE (hf)-[:STAFF]->(mrs:Teacher {name: 'Mr Smith'})\n      CREATE (hf)-[:STAFF]->(mrsa:Teacher {name: 'Mrs Adenough'})\n      CREATE (hf)-[:STAFF]->(mrvdg:Teacher {name: 'Mr Van der Graaf'})\n      CREATE (hf)-[:STAFF]->(msn:Teacher {name: 'Ms Noethe'})\n      CREATE (hf)-[:STAFF]->(mrsn:Teacher {name: 'Mrs Noakes'})\n      CREATE (hf)-[:STAFF]->(mrm:Teacher {name: 'Mr Marker'})\n      CREATE (hf)-[:STAFF]->(msd:Teacher {name: 'Ms Delgado'})\n      CREATE (hf)-[:STAFF]->(mrsg:Teacher {name: 'Mrs Glass'})\n      CREATE (hf)-[:STAFF]->(mrf:Teacher {name: 'Mr Flint'})\n      CREATE (hf)-[:STAFF]->(mrk:Teacher {name: 'Mr Kearney'})\n      CREATE (hf)-[:STAFF]->(msf:Teacher {name: 'Mrs Forrester'})\n      CREATE (hf)-[:STAFF]->(mrsf:Teacher {name: 'Mrs Fischer'})\n      CREATE (hf)-[:STAFF]->(mrj:Teacher {name: 'Mr Jameson'})\n\n      CREATE (hf)-[:STUDENT]->(_001:Student {name: 'Portia Vasquez'})\n      CREATE (hf)-[:STUDENT]->(_002:Student {name: 'Andrew Parks'})\n      CREATE (hf)-[:STUDENT]->(_003:Student {name: 'Germane Frye'})\n      CREATE (hf)-[:STUDENT]->(_004:Student {name: 'Yuli Gutierrez'})\n      CREATE (hf)-[:STUDENT]->(_005:Student {name: 'Kamal Solomon'})\n      CREATE (hf)-[:STUDENT]->(_006:Student {name: 'Lysandra Porter'})\n      CREATE (hf)-[:STUDENT]->(_007:Student {name: 'Stella Santiago'})\n      CREATE (hf)-[:STUDENT]->(_008:Student {name: 'Brenda Torres'})\n      CREATE (hf)-[:STUDENT]->(_009:Student {name: 'Heidi Dunlap'})\n\n      CREATE (hf)-[:STUDENT]->(_010:Student {name: 'Halee Taylor'})\n      CREATE (hf)-[:STUDENT]->(_011:Student {name: 'Brennan Crosby'})\n      CREATE (hf)-[:STUDENT]->(_012:Student {name: 'Rooney Cook'})\n      CREATE (hf)-[:STUDENT]->(_013:Student {name: 'Xavier Morrison'})\n      CREATE (hf)-[:STUDENT]->(_014:Student {name: 'Zelenia Santana'})\n      CREATE (hf)-[:STUDENT]->(_015:Student {name: 'Eaton Bonner'})\n      CREATE (hf)-[:STUDENT]->(_016:Student {name: 'Leilani Bishop'})\n      CREATE (hf)-[:STUDENT]->(_017:Student {name: 'Jamalia Pickett'})\n      CREATE (hf)-[:STUDENT]->(_018:Student {name: 'Wynter Russell'})\n      CREATE (hf)-[:STUDENT]->(_019:Student {name: 'Liberty Melton'})\n\n      CREATE (hf)-[:STUDENT]->(_020:Student {name: 'MacKensie Obrien'})\n      CREATE (hf)-[:STUDENT]->(_021:Student {name: 'Oprah Maynard'})\n      CREATE (hf)-[:STUDENT]->(_022:Student {name: 'Lyle Parks'})\n      CREATE (hf)-[:STUDENT]->(_023:Student {name: 'Madonna Justice'})\n      CREATE (hf)-[:STUDENT]->(_024:Student {name: 'Herman Frederick'})\n      CREATE (hf)-[:STUDENT]->(_025:Student {name: 'Preston Stevenson'})\n      CREATE (hf)-[:STUDENT]->(_026:Student {name: 'Drew Carrillo'})\n      CREATE (hf)-[:STUDENT]->(_027:Student {name: 'Hamilton Woodward'})\n      CREATE (hf)-[:STUDENT]->(_028:Student {name: 'Buckminster Bradley'})\n      CREATE (hf)-[:STUDENT]->(_029:Student {name: 'Shea Cote'})\n\n      CREATE (hf)-[:STUDENT]->(_030:Student {name: 'Raymond Leonard'})\n      CREATE (hf)-[:STUDENT]->(_031:Student {name: 'Gavin Branch'})\n      CREATE (hf)-[:STUDENT]->(_032:Student {name: 'Kylan Powers'})\n      CREATE (hf)-[:STUDENT]->(_033:Student {name: 'Hedy Bowers'})\n      CREATE (hf)-[:STUDENT]->(_034:Student {name: 'Derek Church'})\n      CREATE (hf)-[:STUDENT]->(_035:Student {name: 'Silas Santiago'})\n      CREATE (hf)-[:STUDENT]->(_036:Student {name: 'Elton Bright'})\n      CREATE (hf)-[:STUDENT]->(_037:Student {name: 'Dora Schmidt'})\n      CREATE (hf)-[:STUDENT]->(_038:Student {name: 'Julian Sullivan'})\n      CREATE (hf)-[:STUDENT]->(_039:Student {name: 'Willow Morton'})\n\n      CREATE (hf)-[:STUDENT]->(_040:Student {name: 'Blaze Hines'})\n      CREATE (hf)-[:STUDENT]->(_041:Student {name: 'Felicia Tillman'})\n      CREATE (hf)-[:STUDENT]->(_042:Student {name: 'Ralph Webb'})\n      CREATE (hf)-[:STUDENT]->(_043:Student {name: 'Roth Gilmore'})\n      CREATE (hf)-[:STUDENT]->(_044:Student {name: 'Dorothy Burgess'})\n      CREATE (hf)-[:STUDENT]->(_045:Student {name: 'Lana Sandoval'})\n      CREATE (hf)-[:STUDENT]->(_046:Student {name: 'Nevada Strickland'})\n      CREATE (hf)-[:STUDENT]->(_047:Student {name: 'Lucian Franco'})\n      CREATE (hf)-[:STUDENT]->(_048:Student {name: 'Jasper Talley'})\n      CREATE (hf)-[:STUDENT]->(_049:Student {name: 'Madaline Spears'})\n\n      CREATE (hf)-[:STUDENT]->(_050:Student {name: 'Upton Browning'})\n      CREATE (hf)-[:STUDENT]->(_051:Student {name: 'Cooper Leon'})\n      CREATE (hf)-[:STUDENT]->(_052:Student {name: 'Celeste Ortega'})\n      CREATE (hf)-[:STUDENT]->(_053:Student {name: 'Willa Hewitt'})\n      CREATE (hf)-[:STUDENT]->(_054:Student {name: 'Rooney Bryan'})\n      CREATE (hf)-[:STUDENT]->(_055:Student {name: 'Nayda Hays'})\n      CREATE (hf)-[:STUDENT]->(_056:Student {name: 'Kadeem Salazar'})\n      CREATE (hf)-[:STUDENT]->(_057:Student {name: 'Halee Allen'})\n      CREATE (hf)-[:STUDENT]->(_058:Student {name: 'Odysseus Mayo'})\n      CREATE (hf)-[:STUDENT]->(_059:Student {name: 'Kato Merrill'})\n\n      CREATE (hf)-[:STUDENT]->(_060:Student {name: 'Halee Juarez'})\n      CREATE (hf)-[:STUDENT]->(_061:Student {name: 'Chloe Charles'})\n      CREATE (hf)-[:STUDENT]->(_062:Student {name: 'Abel Montoya'})\n      CREATE (hf)-[:STUDENT]->(_063:Student {name: 'Hilda Welch'})\n      CREATE (hf)-[:STUDENT]->(_064:Student {name: 'Britanni Bean'})\n      CREATE (hf)-[:STUDENT]->(_065:Student {name: 'Joelle Beach'})\n      CREATE (hf)-[:STUDENT]->(_066:Student {name: 'Ciara Odom'})\n      CREATE (hf)-[:STUDENT]->(_067:Student {name: 'Zia Williams'})\n      CREATE (hf)-[:STUDENT]->(_068:Student {name: 'Darrel Bailey'})\n      CREATE (hf)-[:STUDENT]->(_069:Student {name: 'Lance Mcdowell'})\n\n      CREATE (hf)-[:STUDENT]->(_070:Student {name: 'Clayton Bullock'})\n      CREATE (hf)-[:STUDENT]->(_071:Student {name: 'Roanna Mosley'})\n      CREATE (hf)-[:STUDENT]->(_072:Student {name: 'Amethyst Mcclure'})\n      CREATE (hf)-[:STUDENT]->(_073:Student {name: 'Hanae Mann'})\n      CREATE (hf)-[:STUDENT]->(_074:Student {name: 'Graiden Haynes'})\n      CREATE (hf)-[:STUDENT]->(_075:Student {name: 'Marcia Byrd'})\n      CREATE (hf)-[:STUDENT]->(_076:Student {name: 'Yoshi Joyce'})\n      CREATE (hf)-[:STUDENT]->(_077:Student {name: 'Gregory Sexton'})\n      CREATE (hf)-[:STUDENT]->(_078:Student {name: 'Nash Carey'})\n      CREATE (hf)-[:STUDENT]->(_079:Student {name: 'Rae Stevens'})\n\n      CREATE (hf)-[:STUDENT]->(_080:Student {name: 'Blossom Fulton'})\n      CREATE (hf)-[:STUDENT]->(_081:Student {name: 'Lev Curry'})\n      CREATE (hf)-[:STUDENT]->(_082:Student {name: 'Margaret Gamble'})\n      CREATE (hf)-[:STUDENT]->(_083:Student {name: 'Rylee Patterson'})\n      CREATE (hf)-[:STUDENT]->(_084:Student {name: 'Harper Perkins'})\n      CREATE (hf)-[:STUDENT]->(_085:Student {name: 'Kennan Murphy'})\n      CREATE (hf)-[:STUDENT]->(_086:Student {name: 'Hilda Coffey'})\n      CREATE (hf)-[:STUDENT]->(_087:Student {name: 'Marah Reed'})\n      CREATE (hf)-[:STUDENT]->(_088:Student {name: 'Blaine Wade'})\n      CREATE (hf)-[:STUDENT]->(_089:Student {name: 'Geraldine Sanders'})\n\n      CREATE (hf)-[:STUDENT]->(_090:Student {name: 'Kerry Rollins'})\n      CREATE (hf)-[:STUDENT]->(_091:Student {name: 'Virginia Sweet'})\n      CREATE (hf)-[:STUDENT]->(_092:Student {name: 'Sophia Merrill'})\n      CREATE (hf)-[:STUDENT]->(_093:Student {name: 'Hedda Carson'})\n      CREATE (hf)-[:STUDENT]->(_094:Student {name: 'Tamekah Charles'})\n      CREATE (hf)-[:STUDENT]->(_095:Student {name: 'Knox Barton'})\n      CREATE (hf)-[:STUDENT]->(_096:Student {name: 'Ariel Porter'})\n      CREATE (hf)-[:STUDENT]->(_097:Student {name: 'Berk Wooten'})\n      CREATE (hf)-[:STUDENT]->(_098:Student {name: 'Galena Glenn'})\n      CREATE (hf)-[:STUDENT]->(_099:Student {name: 'Jolene Anderson'})\n\n      CREATE (hf)-[:STUDENT]->(_100:Student {name: 'Leonard Hewitt'})\n      CREATE (hf)-[:STUDENT]->(_101:Student {name: 'Maris Salazar'})\n      CREATE (hf)-[:STUDENT]->(_102:Student {name: 'Brian Frost'})\n      CREATE (hf)-[:STUDENT]->(_103:Student {name: 'Zane Moses'})\n      CREATE (hf)-[:STUDENT]->(_104:Student {name: 'Serina Finch'})\n      CREATE (hf)-[:STUDENT]->(_105:Student {name: 'Anastasia Fletcher'})\n      CREATE (hf)-[:STUDENT]->(_106:Student {name: 'Glenna Chapman'})\n      CREATE (hf)-[:STUDENT]->(_107:Student {name: 'Mufutau Gillespie'})\n      CREATE (hf)-[:STUDENT]->(_108:Student {name: 'Basil Guthrie'})\n      CREATE (hf)-[:STUDENT]->(_109:Student {name: 'Theodore Marsh'})\n\n      CREATE (hf)-[:STUDENT]->(_110:Student {name: 'Jaime Contreras'})\n      CREATE (hf)-[:STUDENT]->(_111:Student {name: 'Irma Poole'})\n      CREATE (hf)-[:STUDENT]->(_112:Student {name: 'Buckminster Bender'})\n      CREATE (hf)-[:STUDENT]->(_113:Student {name: 'Elton Morris'})\n      CREATE (hf)-[:STUDENT]->(_114:Student {name: 'Barbara Nguyen'})\n      CREATE (hf)-[:STUDENT]->(_115:Student {name: 'Tanya Kidd'})\n      CREATE (hf)-[:STUDENT]->(_116:Student {name: 'Kaden Hoover'})\n      CREATE (hf)-[:STUDENT]->(_117:Student {name: 'Christopher Bean'})\n      CREATE (hf)-[:STUDENT]->(_118:Student {name: 'Trevor Daugherty'})\n      CREATE (hf)-[:STUDENT]->(_119:Student {name: 'Rudyard Bates'})\n\n      CREATE (hf)-[:STUDENT]->(_120:Student {name: 'Stacy Monroe'})\n      CREATE (hf)-[:STUDENT]->(_121:Student {name: 'Kieran Keller'})\n      CREATE (hf)-[:STUDENT]->(_122:Student {name: 'Ivy Garrison'})\n      CREATE (hf)-[:STUDENT]->(_123:Student {name: 'Miranda Haynes'})\n      CREATE (hf)-[:STUDENT]->(_124:Student {name: 'Abigail Heath'})\n      CREATE (hf)-[:STUDENT]->(_125:Student {name: 'Margaret Santiago'})\n      CREATE (hf)-[:STUDENT]->(_126:Student {name: 'Cade Floyd'})\n      CREATE (hf)-[:STUDENT]->(_127:Student {name: 'Allen Crane'})\n      CREATE (hf)-[:STUDENT]->(_128:Student {name: 'Stella Gilliam'})\n      CREATE (hf)-[:STUDENT]->(_129:Student {name: 'Rashad Miller'})\n\n      CREATE (hf)-[:STUDENT]->(_130:Student {name: 'Francis Cox'})\n      CREATE (hf)-[:STUDENT]->(_131:Student {name: 'Darryl Rosario'})\n      CREATE (hf)-[:STUDENT]->(_132:Student {name: 'Michael Daniels'})\n      CREATE (hf)-[:STUDENT]->(_133:Student {name: 'Aretha Henderson'})\n      CREATE (hf)-[:STUDENT]->(_134:Student {name: 'Roth Barrera'})\n      CREATE (hf)-[:STUDENT]->(_135:Student {name: 'Yael Day'})\n      CREATE (hf)-[:STUDENT]->(_136:Student {name: 'Wynter Richmond'})\n      CREATE (hf)-[:STUDENT]->(_137:Student {name: 'Quyn Flowers'})\n      CREATE (hf)-[:STUDENT]->(_138:Student {name: 'Yvette Marquez'})\n      CREATE (hf)-[:STUDENT]->(_139:Student {name: 'Teagan Curry'})\n\n      CREATE (hf)-[:STUDENT]->(_140:Student {name: 'Brenden Bishop'})\n      CREATE (hf)-[:STUDENT]->(_141:Student {name: 'Montana Black'})\n      CREATE (hf)-[:STUDENT]->(_142:Student {name: 'Ramona Parker'})\n      CREATE (hf)-[:STUDENT]->(_143:Student {name: 'Merritt Hansen'})\n      CREATE (hf)-[:STUDENT]->(_144:Student {name: 'Melvin Vang'})\n      CREATE (hf)-[:STUDENT]->(_145:Student {name: 'Samantha Perez'})\n      CREATE (hf)-[:STUDENT]->(_146:Student {name: 'Thane Porter'})\n      CREATE (hf)-[:STUDENT]->(_147:Student {name: 'Vaughan Haynes'})\n      CREATE (hf)-[:STUDENT]->(_148:Student {name: 'Irma Miles'})\n      CREATE (hf)-[:STUDENT]->(_149:Student {name: 'Amery Jensen'})\n\n      CREATE (hf)-[:STUDENT]->(_150:Student {name: 'Montana Holman'})\n      CREATE (hf)-[:STUDENT]->(_151:Student {name: 'Kimberly Langley'})\n      CREATE (hf)-[:STUDENT]->(_152:Student {name: 'Ebony Bray'})\n      CREATE (hf)-[:STUDENT]->(_153:Student {name: 'Ishmael Pollard'})\n      CREATE (hf)-[:STUDENT]->(_154:Student {name: 'Illana Thompson'})\n      CREATE (hf)-[:STUDENT]->(_155:Student {name: 'Rhona Bowers'})\n      CREATE (hf)-[:STUDENT]->(_156:Student {name: 'Lilah Dotson'})\n      CREATE (hf)-[:STUDENT]->(_157:Student {name: 'Shelly Roach'})\n      CREATE (hf)-[:STUDENT]->(_158:Student {name: 'Celeste Woodward'})\n      CREATE (hf)-[:STUDENT]->(_159:Student {name: 'Christen Lynn'})\n\n      CREATE (hf)-[:STUDENT]->(_160:Student {name: 'Miranda Slater'})\n      CREATE (hf)-[:STUDENT]->(_161:Student {name: 'Lunea Clements'})\n      CREATE (hf)-[:STUDENT]->(_162:Student {name: 'Lester Francis'})\n      CREATE (hf)-[:STUDENT]->(_163:Student {name: 'David Fischer'})\n      CREATE (hf)-[:STUDENT]->(_164:Student {name: 'Kyra Bean'})\n      CREATE (hf)-[:STUDENT]->(_165:Student {name: 'Imelda Alston'})\n      CREATE (hf)-[:STUDENT]->(_166:Student {name: 'Finn Farrell'})\n      CREATE (hf)-[:STUDENT]->(_167:Student {name: 'Kirby House'})\n      CREATE (hf)-[:STUDENT]->(_168:Student {name: 'Amanda Zamora'})\n      CREATE (hf)-[:STUDENT]->(_169:Student {name: 'Rina Franco'})\n\n      CREATE (hf)-[:STUDENT]->(_170:Student {name: 'Sonia Lane'})\n      CREATE (hf)-[:STUDENT]->(_171:Student {name: 'Nora Jefferson'})\n      CREATE (hf)-[:STUDENT]->(_172:Student {name: 'Colton Ortiz'})\n      CREATE (hf)-[:STUDENT]->(_173:Student {name: 'Alden Munoz'})\n      CREATE (hf)-[:STUDENT]->(_174:Student {name: 'Ferdinand Cline'})\n      CREATE (hf)-[:STUDENT]->(_175:Student {name: 'Cynthia Prince'})\n      CREATE (hf)-[:STUDENT]->(_176:Student {name: 'Asher Hurst'})\n      CREATE (hf)-[:STUDENT]->(_177:Student {name: 'MacKensie Stevenson'})\n      CREATE (hf)-[:STUDENT]->(_178:Student {name: 'Sydnee Sosa'})\n      CREATE (hf)-[:STUDENT]->(_179:Student {name: 'Dante Callahan'})\n\n      CREATE (hf)-[:STUDENT]->(_180:Student {name: 'Isabella Santana'})\n      CREATE (hf)-[:STUDENT]->(_181:Student {name: 'Raven Bowman'})\n      CREATE (hf)-[:STUDENT]->(_182:Student {name: 'Kirby Bolton'})\n      CREATE (hf)-[:STUDENT]->(_183:Student {name: 'Peter Shaffer'})\n      CREATE (hf)-[:STUDENT]->(_184:Student {name: 'Fletcher Beard'})\n      CREATE (hf)-[:STUDENT]->(_185:Student {name: 'Irene Lowe'})\n      CREATE (hf)-[:STUDENT]->(_186:Student {name: 'Ella Talley'})\n      CREATE (hf)-[:STUDENT]->(_187:Student {name: 'Jorden Kerr'})\n      CREATE (hf)-[:STUDENT]->(_188:Student {name: 'Macey Delgado'})\n      CREATE (hf)-[:STUDENT]->(_189:Student {name: 'Ulysses Graves'})\n\n      CREATE (hf)-[:STUDENT]->(_190:Student {name: 'Declan Blake'})\n      CREATE (hf)-[:STUDENT]->(_191:Student {name: 'Lila Hurst'})\n      CREATE (hf)-[:STUDENT]->(_192:Student {name: 'David Rasmussen'})\n      CREATE (hf)-[:STUDENT]->(_193:Student {name: 'Desiree Cortez'})\n      CREATE (hf)-[:STUDENT]->(_194:Student {name: 'Myles Horton'})\n      CREATE (hf)-[:STUDENT]->(_195:Student {name: 'Rylee Willis'})\n      CREATE (hf)-[:STUDENT]->(_196:Student {name: 'Kelsey Yates'})\n      CREATE (hf)-[:STUDENT]->(_197:Student {name: 'Alika Stanton'})\n      CREATE (hf)-[:STUDENT]->(_198:Student {name: 'Ria Campos'})\n      CREATE (hf)-[:STUDENT]->(_199:Student {name: 'Elijah Hendricks'})\n\n      CREATE (hf)-[:STUDENT]->(_200:Student {name: 'Hayes House'})\n\n      CREATE (hf)-[:DEPARTMENT]->(md:Department {name: 'Mathematics'})\n      CREATE (hf)-[:DEPARTMENT]->(sd:Department {name: 'Science'})\n      CREATE (hf)-[:DEPARTMENT]->(ed:Department {name: 'Engineering'})\n\n      CREATE (pm:Subject {name: 'Pure Mathematics'})\n      CREATE (am:Subject {name: 'Applied Mathematics'})\n      CREATE (ph:Subject {name: 'Physics'})\n      CREATE (ch:Subject {name: 'Chemistry'})\n      CREATE (bi:Subject {name: 'Biology'})\n      CREATE (es:Subject {name: 'Earth Science'})\n      CREATE (me:Subject {name: 'Mechanical Engineering'})\n      CREATE (ce:Subject {name: 'Chemical Engineering'})\n      CREATE (se:Subject {name: 'Systems Engineering'})\n      CREATE (ve:Subject {name: 'Civil Engineering'})\n      CREATE (ee:Subject {name: 'Electrical Engineering'})\n\n      CREATE (sd)-[:CURRICULUM]->(ph)\n      CREATE (sd)-[:CURRICULUM]->(ch)\n      CREATE (sd)-[:CURRICULUM]->(bi)\n      CREATE (sd)-[:CURRICULUM]->(es)\n      CREATE (md)-[:CURRICULUM]->(pm)\n      CREATE (md)-[:CURRICULUM]->(am)\n      CREATE (ed)-[:CURRICULUM]->(me)\n      CREATE (ed)-[:CURRICULUM]->(se)\n      CREATE (ed)-[:CURRICULUM]->(ce)\n      CREATE (ed)-[:CURRICULUM]->(ee)\n      CREATE (ed)-[:CURRICULUM]->(ve)\n\n      CREATE (ph)-[:TAUGHT_BY]->(mrb)\n      CREATE (ph)-[:TAUGHT_BY]->(mrk)\n      CREATE (ch)-[:TAUGHT_BY]->(mrk)\n      CREATE (ch)-[:TAUGHT_BY]->(mrsn)\n      CREATE (bi)-[:TAUGHT_BY]->(mrsn)\n      CREATE (bi)-[:TAUGHT_BY]->(mrsf)\n      CREATE (es)-[:TAUGHT_BY]->(msn)\n      CREATE (pm)-[:TAUGHT_BY]->(mrf)\n      CREATE (pm)-[:TAUGHT_BY]->(mrm)\n      CREATE (pm)-[:TAUGHT_BY]->(mrvdg)\n      CREATE (am)-[:TAUGHT_BY]->(mrsg)\n      CREATE (am)-[:TAUGHT_BY]->(mrspb)\n      CREATE (am)-[:TAUGHT_BY]->(mrvdg)\n      CREATE (me)-[:TAUGHT_BY]->(mrj)\n      CREATE (ce)-[:TAUGHT_BY]->(mrsa)\n      CREATE (se)-[:TAUGHT_BY]->(mrs)\n      CREATE (ve)-[:TAUGHT_BY]->(msd)\n      CREATE (ee)-[:TAUGHT_BY]->(mrsf)\n\n      CREATE(_001)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_188)\n      CREATE(_002)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_198)\n      CREATE(_003)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_106)\n      CREATE(_004)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_029)\n      CREATE(_005)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_153)\n      CREATE(_006)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_061)\n      CREATE(_007)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_177)\n      CREATE(_008)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_115)\n      CREATE(_009)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_131)\n      CREATE(_010)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_142)\n      CREATE(_011)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_043)\n      CREATE(_012)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_065)\n      CREATE(_013)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_074)\n      CREATE(_014)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_165)\n      CREATE(_015)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_117)\n      CREATE(_016)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_086)\n      CREATE(_017)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_062)\n      CREATE(_018)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_033)\n      CREATE(_019)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_171)\n      CREATE(_020)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_117)\n      CREATE(_021)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_086)\n      CREATE(_022)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_121)\n      CREATE(_023)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_049)\n      CREATE(_024)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_152)\n      CREATE(_025)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_152)\n      CREATE(_026)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_085)\n      CREATE(_027)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_084)\n      CREATE(_028)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_143)\n      CREATE(_029)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_099)\n      CREATE(_030)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_094)\n      CREATE(_031)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_125)\n      CREATE(_032)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_024)\n      CREATE(_033)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_075)\n      CREATE(_034)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_161)\n      CREATE(_035)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_197)\n      CREATE(_036)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_067)\n      CREATE(_037)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_049)\n      CREATE(_038)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_038)\n      CREATE(_039)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_116)\n      CREATE(_040)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_149)\n      CREATE(_041)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_044)\n      CREATE(_042)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_150)\n      CREATE(_043)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_095)\n      CREATE(_044)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_016)\n      CREATE(_045)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_021)\n      CREATE(_046)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_123)\n      CREATE(_047)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_189)\n      CREATE(_048)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_094)\n      CREATE(_049)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_161)\n      CREATE(_050)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_098)\n      CREATE(_051)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_145)\n      CREATE(_052)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_148)\n      CREATE(_053)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_123)\n      CREATE(_054)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_196)\n      CREATE(_055)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_175)\n      CREATE(_056)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_010)\n      CREATE(_057)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_042)\n      CREATE(_058)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_196)\n      CREATE(_059)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_067)\n      CREATE(_060)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_034)\n      CREATE(_061)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_002)\n      CREATE(_062)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_088)\n      CREATE(_063)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_142)\n      CREATE(_064)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_88)\n      CREATE(_065)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_099)\n      CREATE(_066)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_178)\n      CREATE(_067)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_041)\n      CREATE(_068)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_022)\n      CREATE(_069)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_109)\n      CREATE(_070)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_045)\n      CREATE(_071)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_182)\n      CREATE(_072)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_144)\n      CREATE(_073)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_140)\n      CREATE(_074)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_128)\n      CREATE(_075)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_149)\n      CREATE(_076)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_038)\n      CREATE(_077)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_104)\n      CREATE(_078)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_032)\n      CREATE(_079)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_123)\n      CREATE(_080)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_117)\n      CREATE(_081)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_174)\n      CREATE(_082)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_162)\n      CREATE(_083)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_011)\n      CREATE(_084)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_145)\n      CREATE(_085)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_003)\n      CREATE(_086)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_067)\n      CREATE(_087)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_173)\n      CREATE(_088)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_128)\n      CREATE(_089)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_177)\n      CREATE(_090)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_076)\n      CREATE(_091)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_137)\n      CREATE(_092)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_024)\n      CREATE(_093)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_156)\n      CREATE(_094)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_020)\n      CREATE(_095)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_112)\n      CREATE(_096)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_193)\n      CREATE(_097)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_006)\n      CREATE(_098)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_117)\n      CREATE(_099)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_141)\n      CREATE(_100)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_001)\n      CREATE(_101)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_169)\n      CREATE(_102)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_161)\n      CREATE(_103)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_136)\n      CREATE(_104)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_125)\n      CREATE(_105)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_127)\n      CREATE(_106)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_095)\n      CREATE(_107)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_036)\n      CREATE(_108)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_074)\n      CREATE(_109)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_150)\n      CREATE(_110)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_191)\n      CREATE(_111)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_068)\n      CREATE(_112)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_019)\n      CREATE(_113)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_035)\n      CREATE(_114)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_061)\n      CREATE(_115)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_070)\n      CREATE(_116)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_069)\n      CREATE(_117)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_096)\n      CREATE(_118)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_107)\n      CREATE(_119)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_140)\n      CREATE(_120)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_167)\n      CREATE(_121)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_120)\n      CREATE(_122)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_090)\n      CREATE(_123)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_004)\n      CREATE(_124)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_083)\n      CREATE(_125)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_094)\n      CREATE(_126)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_174)\n      CREATE(_127)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_168)\n      CREATE(_128)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_084)\n      CREATE(_129)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_186)\n      CREATE(_130)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_090)\n      CREATE(_131)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_010)\n      CREATE(_132)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_031)\n      CREATE(_133)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_059)\n      CREATE(_134)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_037)\n      CREATE(_135)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_012)\n      CREATE(_136)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_197)\n      CREATE(_137)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_059)\n      CREATE(_138)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_065)\n      CREATE(_139)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_175)\n      CREATE(_140)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_170)\n      CREATE(_141)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_191)\n      CREATE(_142)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_139)\n      CREATE(_143)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_054)\n      CREATE(_144)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_176)\n      CREATE(_145)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_188)\n      CREATE(_146)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_072)\n      CREATE(_147)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_096)\n      CREATE(_148)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_108)\n      CREATE(_149)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_155)\n      CREATE(_150)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_002)\n      CREATE(_151)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_076)\n      CREATE(_152)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_169)\n      CREATE(_153)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_179)\n      CREATE(_154)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_186)\n      CREATE(_155)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_058)\n      CREATE(_156)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_071)\n      CREATE(_157)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_073)\n      CREATE(_158)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_003)\n      CREATE(_159)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_182)\n      CREATE(_160)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_199)\n      CREATE(_161)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_072)\n      CREATE(_162)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_014)\n      CREATE(_163)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_163)\n      CREATE(_164)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_038)\n      CREATE(_165)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_044)\n      CREATE(_166)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_136)\n      CREATE(_167)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_038)\n      CREATE(_168)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_110)\n      CREATE(_169)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_198)\n      CREATE(_170)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_178)\n      CREATE(_171)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_022)\n      CREATE(_172)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_020)\n      CREATE(_173)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_164)\n      CREATE(_174)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_075)\n      CREATE(_175)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_175)\n      CREATE(_176)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_003)\n      CREATE(_177)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_120)\n      CREATE(_178)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_006)\n      CREATE(_179)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_057)\n      CREATE(_180)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_185)\n      CREATE(_181)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_074)\n      CREATE(_182)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_120)\n      CREATE(_183)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_131)\n      CREATE(_184)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_045)\n      CREATE(_185)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_200)\n      CREATE(_186)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_140)\n      CREATE(_187)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_150)\n      CREATE(_188)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_014)\n      CREATE(_189)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_096)\n      CREATE(_190)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_063)\n      CREATE(_191)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_079)\n      CREATE(_192)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_121)\n      CREATE(_193)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_196)\n      CREATE(_194)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_029)\n      CREATE(_195)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_164)\n      CREATE(_196)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_083)\n      CREATE(_197)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_101)\n      CREATE(_198)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_039)\n      CREATE(_199)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_011)\n      CREATE(_200)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_073)\n      CREATE(_001)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_129)\n      CREATE(_002)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_078)\n      CREATE(_003)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_181)\n      CREATE(_004)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_162)\n      CREATE(_005)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_057)\n      CREATE(_006)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_111)\n      CREATE(_007)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_027)\n      CREATE(_008)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_123)\n      CREATE(_009)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_132)\n      CREATE(_010)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_147)\n      CREATE(_011)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_083)\n      CREATE(_012)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_118)\n      CREATE(_013)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_099)\n      CREATE(_014)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_140)\n      CREATE(_015)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_107)\n      CREATE(_016)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_116)\n      CREATE(_017)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_002)\n      CREATE(_018)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_069)\n      CREATE(_019)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_024)\n      CREATE(_020)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_022)\n      CREATE(_021)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_184)\n      CREATE(_022)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_200)\n      CREATE(_023)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_200)\n      CREATE(_024)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_075)\n      CREATE(_025)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_087)\n      CREATE(_026)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_163)\n      CREATE(_027)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_115)\n      CREATE(_028)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_042)\n      CREATE(_029)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_058)\n      CREATE(_030)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_188)\n      CREATE(_031)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_123)\n      CREATE(_032)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_015)\n      CREATE(_033)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_130)\n      CREATE(_034)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_141)\n      CREATE(_035)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_158)\n      CREATE(_036)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_020)\n      CREATE(_037)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_102)\n      CREATE(_038)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_184)\n      CREATE(_039)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_196)\n      CREATE(_040)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_003)\n      CREATE(_041)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_171)\n      CREATE(_042)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_050)\n      CREATE(_043)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_085)\n      CREATE(_044)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_025)\n      CREATE(_045)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_084)\n      CREATE(_046)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_118)\n      CREATE(_047)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_002)\n      CREATE(_048)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_099)\n      CREATE(_049)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_071)\n      CREATE(_050)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_178)\n      CREATE(_051)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_200)\n      CREATE(_052)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_059)\n      CREATE(_053)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_095)\n      CREATE(_054)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_185)\n      CREATE(_055)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_108)\n      CREATE(_056)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_083)\n      CREATE(_057)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_031)\n      CREATE(_058)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_054)\n      CREATE(_059)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_198)\n      CREATE(_060)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_138)\n      CREATE(_061)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_176)\n      CREATE(_062)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_086)\n      CREATE(_063)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_032)\n      CREATE(_064)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_101)\n      CREATE(_065)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_181)\n      CREATE(_066)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_153)\n      CREATE(_067)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_166)\n      CREATE(_068)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_003)\n      CREATE(_069)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_027)\n      CREATE(_070)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_021)\n      CREATE(_071)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_193)\n      CREATE(_072)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_022)\n      CREATE(_073)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_108)\n      CREATE(_074)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_174)\n      CREATE(_075)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_019)\n      CREATE(_076)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_179)\n      CREATE(_077)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_005)\n      CREATE(_078)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_014)\n      CREATE(_079)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_017)\n      CREATE(_080)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_146)\n      CREATE(_081)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_098)\n      CREATE(_082)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_171)\n      CREATE(_083)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_099)\n      CREATE(_084)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_161)\n      CREATE(_085)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_098)\n      CREATE(_086)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_199)\n      CREATE(_087)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_057)\n      CREATE(_088)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_164)\n      CREATE(_089)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_064)\n      CREATE(_090)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_109)\n      CREATE(_091)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_077)\n      CREATE(_092)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_124)\n      CREATE(_093)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_181)\n      CREATE(_094)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_142)\n      CREATE(_095)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_191)\n      CREATE(_096)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_093)\n      CREATE(_097)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_031)\n      CREATE(_098)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_045)\n      CREATE(_099)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_182)\n      CREATE(_100)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_043)\n      CREATE(_101)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_146)\n      CREATE(_102)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_141)\n      CREATE(_103)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_040)\n      CREATE(_104)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_199)\n      CREATE(_105)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_063)\n      CREATE(_106)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_180)\n      CREATE(_107)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_010)\n      CREATE(_108)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_122)\n      CREATE(_109)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_111)\n      CREATE(_110)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_065)\n      CREATE(_111)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_199)\n      CREATE(_112)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_135)\n      CREATE(_113)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_172)\n      CREATE(_114)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_096)\n      CREATE(_115)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_028)\n      CREATE(_116)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_109)\n      CREATE(_117)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_191)\n      CREATE(_118)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_169)\n      CREATE(_119)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_101)\n      CREATE(_120)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_184)\n      CREATE(_121)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_032)\n      CREATE(_122)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_127)\n      CREATE(_123)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_129)\n      CREATE(_124)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_116)\n      CREATE(_125)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_150)\n      CREATE(_126)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_175)\n      CREATE(_127)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_018)\n      CREATE(_128)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_165)\n      CREATE(_129)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_117)\n      CREATE(_130)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_066)\n      CREATE(_131)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_050)\n      CREATE(_132)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_197)\n      CREATE(_133)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_111)\n      CREATE(_134)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_125)\n      CREATE(_135)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_112)\n      CREATE(_136)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_173)\n      CREATE(_137)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_181)\n      CREATE(_138)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_072)\n      CREATE(_139)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_115)\n      CREATE(_140)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_013)\n      CREATE(_141)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_140)\n      CREATE(_142)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_003)\n      CREATE(_143)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_144)\n      CREATE(_144)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_002)\n      CREATE(_145)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_015)\n      CREATE(_146)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_061)\n      CREATE(_147)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_009)\n      CREATE(_148)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_145)\n      CREATE(_149)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_176)\n      CREATE(_150)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_152)\n      CREATE(_151)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_055)\n      CREATE(_152)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_157)\n      CREATE(_153)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_090)\n      CREATE(_154)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_162)\n      CREATE(_155)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_146)\n      CREATE(_156)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_073)\n      CREATE(_157)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_044)\n      CREATE(_158)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_154)\n      CREATE(_159)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_123)\n      CREATE(_160)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_168)\n      CREATE(_161)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_122)\n      CREATE(_162)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_015)\n      CREATE(_163)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_041)\n      CREATE(_164)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_087)\n      CREATE(_165)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_104)\n      CREATE(_166)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_116)\n      CREATE(_167)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_019)\n      CREATE(_168)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_021)\n      CREATE(_169)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_065)\n      CREATE(_170)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_183)\n      CREATE(_171)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_147)\n      CREATE(_172)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_045)\n      CREATE(_173)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_172)\n      CREATE(_174)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_137)\n      CREATE(_175)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_145)\n      CREATE(_176)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_138)\n      CREATE(_177)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_078)\n      CREATE(_178)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_176)\n      CREATE(_179)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_062)\n      CREATE(_180)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_145)\n      CREATE(_181)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_178)\n      CREATE(_182)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_173)\n      CREATE(_183)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_107)\n      CREATE(_184)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_198)\n      CREATE(_185)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_057)\n      CREATE(_186)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_041)\n      CREATE(_187)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_076)\n      CREATE(_188)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_132)\n      CREATE(_189)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_093)\n      CREATE(_190)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_002)\n      CREATE(_191)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_183)\n      CREATE(_192)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_140)\n      CREATE(_193)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_196)\n      CREATE(_194)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_117)\n      CREATE(_195)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_054)\n      CREATE(_196)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_197)\n      CREATE(_197)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_086)\n      CREATE(_198)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_190)\n      CREATE(_199)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_143)\n      CREATE(_200)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_144)\n      CREATE(_001)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_050)\n      CREATE(_002)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_024)\n      CREATE(_003)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_135)\n      CREATE(_004)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_094)\n      CREATE(_005)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_143)\n      CREATE(_006)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_066)\n      CREATE(_007)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_193)\n      CREATE(_008)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_022)\n      CREATE(_009)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_074)\n      CREATE(_010)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_166)\n      CREATE(_011)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_131)\n      CREATE(_012)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_036)\n      CREATE(_013)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_016)\n      CREATE(_014)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_108)\n      CREATE(_015)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_083)\n      CREATE(_016)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_120)\n      CREATE(_017)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_016)\n      CREATE(_018)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_130)\n      CREATE(_019)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_013)\n      CREATE(_020)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_186)\n      CREATE(_021)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_026)\n      CREATE(_022)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_040)\n      CREATE(_023)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_064)\n      CREATE(_024)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_072)\n      CREATE(_025)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_017)\n      CREATE(_026)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_159)\n      CREATE(_027)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_076)\n      CREATE(_028)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_014)\n      CREATE(_029)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_089)\n      CREATE(_030)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_157)\n      CREATE(_031)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_029)\n      CREATE(_032)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_184)\n      CREATE(_033)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_131)\n      CREATE(_034)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_171)\n      CREATE(_035)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_051)\n      CREATE(_036)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_031)\n      CREATE(_037)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_200)\n      CREATE(_038)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_057)\n      CREATE(_039)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_023)\n      CREATE(_040)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_109)\n      CREATE(_041)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_177)\n      CREATE(_042)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_020)\n      CREATE(_043)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_069)\n      CREATE(_044)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_068)\n      CREATE(_045)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_027)\n      CREATE(_046)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_018)\n      CREATE(_047)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_154)\n      CREATE(_048)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_090)\n      CREATE(_049)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_166)\n      CREATE(_050)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_150)\n      CREATE(_051)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_045)\n      CREATE(_052)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_123)\n      CREATE(_053)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_160)\n      CREATE(_054)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_088)\n      CREATE(_055)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_196)\n      CREATE(_056)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_120)\n      CREATE(_057)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_110)\n      CREATE(_058)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_060)\n      CREATE(_059)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_084)\n      CREATE(_060)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_030)\n      CREATE(_061)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_170)\n      CREATE(_062)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_027)\n      CREATE(_063)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_018)\n      CREATE(_064)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_004)\n      CREATE(_065)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_138)\n      CREATE(_066)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_009)\n      CREATE(_067)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_172)\n      CREATE(_068)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_077)\n      CREATE(_069)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_112)\n      CREATE(_070)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_069)\n      CREATE(_071)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_018)\n      CREATE(_072)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_172)\n      CREATE(_073)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_053)\n      CREATE(_074)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_098)\n      CREATE(_075)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_068)\n      CREATE(_076)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_132)\n      CREATE(_077)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_134)\n      CREATE(_078)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_138)\n      CREATE(_079)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_002)\n      CREATE(_080)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_125)\n      CREATE(_081)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_129)\n      CREATE(_082)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_048)\n      CREATE(_083)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_145)\n      CREATE(_084)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_101)\n      CREATE(_085)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_131)\n      CREATE(_086)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_011)\n      CREATE(_087)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_200)\n      CREATE(_088)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_070)\n      CREATE(_089)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_008)\n      CREATE(_090)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_107)\n      CREATE(_091)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_002)\n      CREATE(_092)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_180)\n      CREATE(_093)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_001)\n      CREATE(_094)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_120)\n      CREATE(_095)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_135)\n      CREATE(_096)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_116)\n      CREATE(_097)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_171)\n      CREATE(_098)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_122)\n      CREATE(_099)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_100)\n      CREATE(_100)-[:BUDDY]->(:StudyBuddy)<-[:BUDDY]-(_130)",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason='CREATE clause semantics are not supported',
        tags=('create', 'xfail'),
    ),
    Scenario(
        key='create5-1',
        feature_path='tck/features/clauses/create/Create5.feature',
        scenario='[1] Create a pattern with multiple hops',
        cypher='CREATE (:A)-[:R]->(:B)-[:R]->(:C)',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason='CREATE clause semantics are not supported',
        tags=('create', 'xfail'),
    ),
    Scenario(
        key='create5-2',
        feature_path='tck/features/clauses/create/Create5.feature',
        scenario='[2] Create a pattern with multiple hops in the reverse direction',
        cypher='CREATE (:A)<-[:R]-(:B)<-[:R]-(:C)',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason='CREATE clause semantics are not supported',
        tags=('create', 'xfail'),
    ),
    Scenario(
        key='create5-3',
        feature_path='tck/features/clauses/create/Create5.feature',
        scenario='[3] Create a pattern with multiple hops in varying directions',
        cypher='CREATE (:A)-[:R]->(:B)<-[:R]-(:C)',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason='CREATE clause semantics are not supported',
        tags=('create', 'xfail'),
    ),
    Scenario(
        key='create5-4',
        feature_path='tck/features/clauses/create/Create5.feature',
        scenario='[4] Create a pattern with multiple hops with multiple types and varying directions',
        cypher='CREATE ()-[:R1]->()<-[:R2]-()-[:R3]->()',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason='CREATE clause semantics are not supported',
        tags=('create', 'xfail'),
    ),
    Scenario(
        key='create5-5',
        feature_path='tck/features/clauses/create/Create5.feature',
        scenario='[5] Create a pattern with multiple hops and varying directions',
        cypher='CREATE (:A)<-[:R1]-(:B)-[:R2]->(:C)',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason='CREATE clause semantics are not supported',
        tags=('create', 'xfail'),
    ),
    Scenario(
        key='create6-1',
        feature_path='tck/features/clauses/create/Create6.feature',
        scenario='[1] Limiting to zero results after creating nodes affects the result set but not the side effects',
        cypher='CREATE (n:N {num: 42})\n      RETURN n\n      LIMIT 0',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[

            ],
        ),
        gfql=None,
        status="xfail",
        reason='CREATE clause semantics are not supported',
        tags=('create', 'xfail'),
    ),
    Scenario(
        key='create6-2',
        feature_path='tck/features/clauses/create/Create6.feature',
        scenario='[2] Skipping all results after creating nodes affects the result set but not the side effects',
        cypher='CREATE (n:N {num: 42})\n      RETURN n\n      SKIP 1',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[

            ],
        ),
        gfql=None,
        status="xfail",
        reason='CREATE clause semantics are not supported',
        tags=('create', 'xfail'),
    ),
    Scenario(
        key='create6-3',
        feature_path='tck/features/clauses/create/Create6.feature',
        scenario='[3] Skipping and limiting to a few results after creating nodes does not affect the result set nor the side effects',
        cypher='UNWIND [42, 42, 42, 42, 42] AS x\n      CREATE (n:N {num: x})\n      RETURN n.num AS num\n      SKIP 2 LIMIT 2',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'num': 42},
            {'num': 42}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='CREATE clause semantics are not supported',
        tags=('create', 'xfail'),
    ),
    Scenario(
        key='create6-4',
        feature_path='tck/features/clauses/create/Create6.feature',
        scenario='[4] Skipping zero result and limiting to all results after creating nodes does not affect the result set nor the side effects',
        cypher='UNWIND [42, 42, 42, 42, 42] AS x\n      CREATE (n:N {num: x})\n      RETURN n.num AS num\n      SKIP 0 LIMIT 5',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'num': 42},
            {'num': 42},
            {'num': 42},
            {'num': 42},
            {'num': 42}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='CREATE clause semantics are not supported',
        tags=('create', 'xfail'),
    ),
    Scenario(
        key='create6-5',
        feature_path='tck/features/clauses/create/Create6.feature',
        scenario='[5] Filtering after creating nodes affects the result set but not the side effects',
        cypher='UNWIND [1, 2, 3, 4, 5] AS x\n      CREATE (n:N {num: x})\n      WITH n\n      WHERE n.num % 2 = 0\n      RETURN n.num AS num',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'num': 2},
            {'num': 4}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='CREATE clause semantics are not supported',
        tags=('create', 'xfail'),
    ),
    Scenario(
        key='create6-6',
        feature_path='tck/features/clauses/create/Create6.feature',
        scenario='[6] Aggregating in `RETURN` after creating nodes affects the result set but not the side effects',
        cypher='UNWIND [1, 2, 3, 4, 5] AS x\n      CREATE (n:N {num: x})\n      RETURN sum(n.num) AS sum',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'sum': 15}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='CREATE clause semantics are not supported',
        tags=('create', 'xfail'),
    ),
    Scenario(
        key='create6-7',
        feature_path='tck/features/clauses/create/Create6.feature',
        scenario='[7] Aggregating in `WITH` after creating nodes affects the result set but not the side effects',
        cypher='UNWIND [1, 2, 3, 4, 5] AS x\n      CREATE (n:N {num: x})\n      WITH sum(n.num) AS sum\n      RETURN sum',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'sum': 15}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='CREATE clause semantics are not supported',
        tags=('create', 'xfail'),
    ),
    Scenario(
        key='create6-8',
        feature_path='tck/features/clauses/create/Create6.feature',
        scenario='[8] Limiting to zero results after creating relationships affects the result set but not the side effects',
        cypher='CREATE ()-[r:R {num: 42}]->()\n      RETURN r\n      LIMIT 0',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[

            ],
        ),
        gfql=None,
        status="xfail",
        reason='CREATE clause semantics are not supported',
        tags=('create', 'xfail'),
    ),
    Scenario(
        key='create6-9',
        feature_path='tck/features/clauses/create/Create6.feature',
        scenario='[9] Skipping all results after creating relationships affects the result set but not the side effects',
        cypher='CREATE ()-[r:R {num: 42}]->()\n      RETURN r\n      SKIP 1',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[

            ],
        ),
        gfql=None,
        status="xfail",
        reason='CREATE clause semantics are not supported',
        tags=('create', 'xfail'),
    ),
    Scenario(
        key='create6-10',
        feature_path='tck/features/clauses/create/Create6.feature',
        scenario='[10] Skipping and limiting to a few results after creating relationships does not affect the result set nor the side effects',
        cypher='UNWIND [42, 42, 42, 42, 42] AS x\n      CREATE ()-[r:R {num: x}]->()\n      RETURN r.num AS num\n      SKIP 2 LIMIT 2',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'num': 42},
            {'num': 42}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='CREATE clause semantics are not supported',
        tags=('create', 'xfail'),
    ),
    Scenario(
        key='create6-11',
        feature_path='tck/features/clauses/create/Create6.feature',
        scenario='[11] Skipping zero result and limiting to all results after creating relationships does not affect the result set nor the side effects',
        cypher='UNWIND [42, 42, 42, 42, 42] AS x\n      CREATE ()-[r:R {num: x}]->()\n      RETURN r.num AS num\n      SKIP 0 LIMIT 5',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'num': 42},
            {'num': 42},
            {'num': 42},
            {'num': 42},
            {'num': 42}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='CREATE clause semantics are not supported',
        tags=('create', 'xfail'),
    ),
    Scenario(
        key='create6-12',
        feature_path='tck/features/clauses/create/Create6.feature',
        scenario='[12] Filtering after creating relationships affects the result set but not the side effects',
        cypher='UNWIND [1, 2, 3, 4, 5] AS x\n      CREATE ()-[r:R {num: x}]->()\n      WITH r\n      WHERE r.num % 2 = 0\n      RETURN r.num AS num',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'num': 2},
            {'num': 4}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='CREATE clause semantics are not supported',
        tags=('create', 'xfail'),
    ),
    Scenario(
        key='create6-13',
        feature_path='tck/features/clauses/create/Create6.feature',
        scenario='[13] Aggregating in `RETURN` after creating relationships affects the result set but not the side effects',
        cypher='UNWIND [1, 2, 3, 4, 5] AS x\n      CREATE ()-[r:R {num: x}]->()\n      RETURN sum(r.num) AS sum',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'sum': 15}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='CREATE clause semantics are not supported',
        tags=('create', 'xfail'),
    ),
    Scenario(
        key='create6-14',
        feature_path='tck/features/clauses/create/Create6.feature',
        scenario='[14] Aggregating in `WITH` after creating relationships affects the result set but not the side effects',
        cypher='UNWIND [1, 2, 3, 4, 5] AS x\n      CREATE ()-[r:R {num: x}]->()\n      WITH sum(r.num) AS sum\n      RETURN sum',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'sum': 15}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='CREATE clause semantics are not supported',
        tags=('create', 'xfail'),
    ),
    Scenario(
        key='delete1-1',
        feature_path='tck/features/clauses/delete/Delete1.feature',
        scenario='[1] Delete nodes',
        cypher='MATCH (n)\n      DELETE n',
        graph=graph_fixture_from_create(
            """
            CREATE ()
            """
        ),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason='DELETE clause semantics are not supported',
        tags=('delete', 'xfail'),
    ),
    Scenario(
        key='delete1-2',
        feature_path='tck/features/clauses/delete/Delete1.feature',
        scenario='[2] Detach delete node',
        cypher='MATCH (n)\n      DETACH DELETE n',
        graph=graph_fixture_from_create(
            """
            CREATE ()
            """
        ),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason='DELETE clause semantics are not supported',
        tags=('delete', 'xfail'),
    ),
    Scenario(
        key='delete1-3',
        feature_path='tck/features/clauses/delete/Delete1.feature',
        scenario='[3] Detach deleting connected nodes and relationships',
        cypher='MATCH (n:X)\n      DETACH DELETE n',
        graph=graph_fixture_from_create(
            """
            CREATE (x:X)
                  CREATE (x)-[:R]->()
                  CREATE (x)-[:R]->()
                  CREATE (x)-[:R]->()
            """
        ),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason='DELETE clause semantics are not supported',
        tags=('delete', 'xfail'),
    ),
    Scenario(
        key='delete1-4',
        feature_path='tck/features/clauses/delete/Delete1.feature',
        scenario='[4] Delete on null node',
        cypher='OPTIONAL MATCH (n)\n      DELETE n',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason='DELETE clause semantics are not supported',
        tags=('delete', 'xfail'),
    ),
    Scenario(
        key='delete1-5',
        feature_path='tck/features/clauses/delete/Delete1.feature',
        scenario='[5] Ignore null when deleting node',
        cypher='OPTIONAL MATCH (a:DoesNotExist)\n      DELETE a\n      RETURN a',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'a': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='DELETE clause semantics are not supported',
        tags=('delete', 'xfail'),
    ),
    Scenario(
        key='delete1-6',
        feature_path='tck/features/clauses/delete/Delete1.feature',
        scenario='[6] Detach delete on null node',
        cypher='OPTIONAL MATCH (n)\n      DETACH DELETE n',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason='DELETE clause semantics are not supported',
        tags=('delete', 'xfail'),
    ),
    Scenario(
        key='delete1-7',
        feature_path='tck/features/clauses/delete/Delete1.feature',
        scenario='[7] Failing when deleting connected nodes',
        cypher='MATCH (n:X)\n      DELETE n',
        graph=graph_fixture_from_create(
            """
            CREATE (x:X)
                  CREATE (x)-[:R]->()
                  CREATE (x)-[:R]->()
                  CREATE (x)-[:R]->()
            """
        ),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Runtime error semantics are not supported',
        tags=('delete', 'runtime-error', 'xfail'),
    ),
    Scenario(
        key='delete1-8',
        feature_path='tck/features/clauses/delete/Delete1.feature',
        scenario='[8] Failing when deleting a label',
        cypher='MATCH (n)\n      DELETE n:Person',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('delete', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='delete2-1',
        feature_path='tck/features/clauses/delete/Delete2.feature',
        scenario='[1] Delete relationships',
        cypher='MATCH ()-[r]-()\n      DELETE r',
        graph=graph_fixture_from_create(
            """
            UNWIND range(0, 2) AS i
                  CREATE ()-[:R]->()
            """
        ),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason='DELETE clause semantics are not supported',
        tags=('delete', 'xfail'),
    ),
    Scenario(
        key='delete2-2',
        feature_path='tck/features/clauses/delete/Delete2.feature',
        scenario='[2] Delete optionally matched relationship',
        cypher='MATCH (n)\n      OPTIONAL MATCH (n)-[r]-()\n      DELETE n, r',
        graph=graph_fixture_from_create(
            """
            CREATE ()
            """
        ),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason='DELETE clause semantics are not supported',
        tags=('delete', 'xfail'),
    ),
    Scenario(
        key='delete2-3',
        feature_path='tck/features/clauses/delete/Delete2.feature',
        scenario='[3] Delete relationship with bidirectional matching',
        cypher='MATCH p = ()-[r:T]-()\n      WHERE r.id = 42\n      DELETE r',
        graph=graph_fixture_from_create(
            """
            CREATE ()-[:T {id: 42}]->()
            """
        ),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason='DELETE clause semantics are not supported',
        tags=('delete', 'xfail'),
    ),
    Scenario(
        key='delete2-4',
        feature_path='tck/features/clauses/delete/Delete2.feature',
        scenario='[4] Ignore null when deleting relationship',
        cypher='OPTIONAL MATCH ()-[r:DoesNotExist]-()\n      DELETE r\n      RETURN r',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'r': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='DELETE clause semantics are not supported',
        tags=('delete', 'xfail'),
    ),
    Scenario(
        key='delete2-5',
        feature_path='tck/features/clauses/delete/Delete2.feature',
        scenario='[5] Failing when deleting a relationship type',
        cypher='MATCH ()-[r:T]-()\n      DELETE r:T',
        graph=graph_fixture_from_create(
            """
            CREATE ()-[:T {id: 42}]->()
            """
        ),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('delete', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='delete3-1',
        feature_path='tck/features/clauses/delete/Delete3.feature',
        scenario='[1] Detach deleting paths',
        cypher='MATCH p = (:X)-->()-->()-->()\n      DETACH DELETE p',
        graph=graph_fixture_from_create(
            """
            CREATE (x:X), (n1), (n2), (n3)
                  CREATE (x)-[:R]->(n1)
                  CREATE (n1)-[:R]->(n2)
                  CREATE (n2)-[:R]->(n3)
            """
        ),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason='DELETE clause semantics are not supported',
        tags=('delete', 'xfail'),
    ),
    Scenario(
        key='delete3-2',
        feature_path='tck/features/clauses/delete/Delete3.feature',
        scenario='[2] Delete on null path',
        cypher='OPTIONAL MATCH p = ()-->()\n      DETACH DELETE p',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason='DELETE clause semantics are not supported',
        tags=('delete', 'xfail'),
    ),
    Scenario(
        key='delete4-1',
        feature_path='tck/features/clauses/delete/Delete4.feature',
        scenario='[1] Undirected expand followed by delete and count',
        cypher='MATCH (a)-[r]-(b)\n      DELETE r, a, b\n      RETURN count(*) AS c',
        graph=graph_fixture_from_create(
            """
            CREATE ()-[:R]->()
            """
        ),
        expected=Expected(
            rows=[
            {'c': 2}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='DELETE clause semantics are not supported',
        tags=('delete', 'xfail'),
    ),
    Scenario(
        key='delete4-2',
        feature_path='tck/features/clauses/delete/Delete4.feature',
        scenario='[2] Undirected variable length expand followed by delete and count',
        cypher='MATCH (a)-[*]-(b)\n      DETACH DELETE a, b\n      RETURN count(*) AS c',
        graph=graph_fixture_from_create(
            """
            CREATE (n1), (n2), (n3)
                  CREATE (n1)-[:R]->(n2)
                  CREATE (n2)-[:R]->(n3)
            """
        ),
        expected=Expected(
            rows=[
            {'c': 6}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='DELETE clause semantics are not supported',
        tags=('delete', 'xfail'),
    ),
    Scenario(
        key='delete4-3',
        feature_path='tck/features/clauses/delete/Delete4.feature',
        scenario='[3] Create and delete in same query',
        cypher='MATCH ()\n      CREATE (n)\n      DELETE n',
        graph=graph_fixture_from_create(
            """
            CREATE ()
            """
        ),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason='DELETE clause semantics are not supported',
        tags=('delete', 'xfail'),
    ),
    Scenario(
        key='delete5-1',
        feature_path='tck/features/clauses/delete/Delete5.feature',
        scenario='[1] Delete node from a list',
        cypher='MATCH (:User)-[:FRIEND]->(n)\n      WITH collect(n) AS friends\n      DETACH DELETE friends[$friendIndex]',
        graph=graph_fixture_from_create(
            """
            CREATE (u:User)
                  CREATE (u)-[:FRIEND]->()
                  CREATE (u)-[:FRIEND]->()
                  CREATE (u)-[:FRIEND]->()
                  CREATE (u)-[:FRIEND]->()
            """
        ),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason='Parameter binding is not supported',
        tags=('delete', 'params', 'xfail'),
    ),
    Scenario(
        key='delete5-2',
        feature_path='tck/features/clauses/delete/Delete5.feature',
        scenario='[2] Delete relationship from a list',
        cypher='MATCH (:User)-[r:FRIEND]->()\n      WITH collect(r) AS friendships\n      DETACH DELETE friendships[$friendIndex]',
        graph=graph_fixture_from_create(
            """
            CREATE (u:User)
                  CREATE (u)-[:FRIEND]->()
                  CREATE (u)-[:FRIEND]->()
                  CREATE (u)-[:FRIEND]->()
                  CREATE (u)-[:FRIEND]->()
            """
        ),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason='Parameter binding is not supported',
        tags=('delete', 'params', 'xfail'),
    ),
    Scenario(
        key='delete5-3',
        feature_path='tck/features/clauses/delete/Delete5.feature',
        scenario='[3] Delete nodes from a map',
        cypher='MATCH (u:User)\n      WITH {key: u} AS nodes\n      DELETE nodes.key',
        graph=graph_fixture_from_create(
            """
            CREATE (:User), (:User)
            """
        ),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason='DELETE clause semantics are not supported',
        tags=('delete', 'xfail'),
    ),
    Scenario(
        key='delete5-4',
        feature_path='tck/features/clauses/delete/Delete5.feature',
        scenario='[4] Delete relationships from a map',
        cypher='MATCH (:User)-[r]->(:User)\n      WITH {key: r} AS rels\n      DELETE rels.key',
        graph=graph_fixture_from_create(
            """
            CREATE (a:User), (b:User)
                  CREATE (a)-[:R]->(b)
                  CREATE (b)-[:R]->(a)
            """
        ),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason='DELETE clause semantics are not supported',
        tags=('delete', 'xfail'),
    ),
    Scenario(
        key='delete5-5',
        feature_path='tck/features/clauses/delete/Delete5.feature',
        scenario='[5] Detach delete nodes from nested map/list',
        cypher='MATCH (u:User)\n      WITH {key: collect(u)} AS nodeMap\n      DETACH DELETE nodeMap.key[0]',
        graph=graph_fixture_from_create(
            """
            CREATE (a:User), (b:User)
                  CREATE (a)-[:R]->(b)
                  CREATE (b)-[:R]->(a)
            """
        ),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason='DELETE clause semantics are not supported',
        tags=('delete', 'xfail'),
    ),
    Scenario(
        key='delete5-6',
        feature_path='tck/features/clauses/delete/Delete5.feature',
        scenario='[6] Delete relationships from nested map/list',
        cypher='MATCH (:User)-[r]->(:User)\n      WITH {key: {key: collect(r)}} AS rels\n      DELETE rels.key.key[0]',
        graph=graph_fixture_from_create(
            """
            CREATE (a:User), (b:User)
                  CREATE (a)-[:R]->(b)
                  CREATE (b)-[:R]->(a)
            """
        ),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason='DELETE clause semantics are not supported',
        tags=('delete', 'xfail'),
    ),
    Scenario(
        key='delete5-7',
        feature_path='tck/features/clauses/delete/Delete5.feature',
        scenario='[7] Delete paths from nested map/list',
        cypher='MATCH p = (:User)-[r]->(:User)\n      WITH {key: collect(p)} AS pathColls\n      DELETE pathColls.key[0], pathColls.key[1]',
        graph=graph_fixture_from_create(
            """
            CREATE (a:User), (b:User)
                  CREATE (a)-[:R]->(b)
                  CREATE (b)-[:R]->(a)
            """
        ),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason='DELETE clause semantics are not supported',
        tags=('delete', 'xfail'),
    ),
    Scenario(
        key='delete5-8',
        feature_path='tck/features/clauses/delete/Delete5.feature',
        scenario='[8] Failing when using undefined variable in DELETE',
        cypher='MATCH (a)\n      DELETE x',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('delete', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='delete5-9',
        feature_path='tck/features/clauses/delete/Delete5.feature',
        scenario='[9] Failing when deleting an integer expression',
        cypher='MATCH ()\n      DELETE 1 + 1',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('delete', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='delete6-1',
        feature_path='tck/features/clauses/delete/Delete6.feature',
        scenario='[1] Limiting to zero results after deleting nodes affects the result set but not the side effects',
        cypher='MATCH (n:N)\n      DELETE n\n      RETURN 42 AS num\n      LIMIT 0',
        graph=graph_fixture_from_create(
            """
            CREATE (:N {num: 42})
            """
        ),
        expected=Expected(
            rows=[

            ],
        ),
        gfql=None,
        status="xfail",
        reason='DELETE clause semantics are not supported',
        tags=('delete', 'xfail'),
    ),
    Scenario(
        key='delete6-2',
        feature_path='tck/features/clauses/delete/Delete6.feature',
        scenario='[2] Skipping all results after deleting nodes affects the result set but not the side effects',
        cypher='MATCH (n:N)\n      DELETE n\n      RETURN 42 AS num\n      SKIP 1',
        graph=graph_fixture_from_create(
            """
            CREATE (:N {num: 42})
            """
        ),
        expected=Expected(
            rows=[

            ],
        ),
        gfql=None,
        status="xfail",
        reason='DELETE clause semantics are not supported',
        tags=('delete', 'xfail'),
    ),
    Scenario(
        key='delete6-3',
        feature_path='tck/features/clauses/delete/Delete6.feature',
        scenario='[3] Skipping and limiting to a few results after deleting nodes affects the result set but not the side effects',
        cypher='MATCH (n:N)\n      DELETE n\n      RETURN 42 AS num\n      SKIP 2 LIMIT 2',
        graph=graph_fixture_from_create(
            """
            CREATE (:N {num: 1})
                  CREATE (:N {num: 2})
                  CREATE (:N {num: 3})
                  CREATE (:N {num: 4})
                  CREATE (:N {num: 5})
            """
        ),
        expected=Expected(
            rows=[
            {'num': 42},
            {'num': 42}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='DELETE clause semantics are not supported',
        tags=('delete', 'xfail'),
    ),
    Scenario(
        key='delete6-4',
        feature_path='tck/features/clauses/delete/Delete6.feature',
        scenario='[4] Skipping zero results and limiting to all results after deleting nodes does not affect the result set nor the side effects',
        cypher='MATCH (n:N)\n      DELETE n\n      RETURN 42 AS num\n      SKIP 0 LIMIT 5',
        graph=graph_fixture_from_create(
            """
            CREATE (:N {num: 1})
                  CREATE (:N {num: 2})
                  CREATE (:N {num: 3})
                  CREATE (:N {num: 4})
                  CREATE (:N {num: 5})
            """
        ),
        expected=Expected(
            rows=[
            {'num': 42},
            {'num': 42},
            {'num': 42},
            {'num': 42},
            {'num': 42}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='DELETE clause semantics are not supported',
        tags=('delete', 'xfail'),
    ),
    Scenario(
        key='delete6-5',
        feature_path='tck/features/clauses/delete/Delete6.feature',
        scenario='[5] Filtering after deleting nodes affects the result set but not the side effects',
        cypher='MATCH (n:N)\n      WITH n, n.num AS num\n      DELETE n\n      WITH num\n      WHERE num % 2 = 0\n      RETURN num',
        graph=graph_fixture_from_create(
            """
            CREATE (:N {num: 1})
                  CREATE (:N {num: 2})
                  CREATE (:N {num: 3})
                  CREATE (:N {num: 4})
                  CREATE (:N {num: 5})
            """
        ),
        expected=Expected(
            rows=[
            {'num': 2},
            {'num': 4}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='DELETE clause semantics are not supported',
        tags=('delete', 'xfail'),
    ),
    Scenario(
        key='delete6-6',
        feature_path='tck/features/clauses/delete/Delete6.feature',
        scenario='[6] Aggregating in `RETURN` after deleting nodes affects the result set but not the side effects',
        cypher='MATCH (n:N)\n      WITH n, n.num AS num\n      DELETE n\n      RETURN sum(num) AS sum',
        graph=graph_fixture_from_create(
            """
            CREATE (:N {num: 1})
                  CREATE (:N {num: 2})
                  CREATE (:N {num: 3})
                  CREATE (:N {num: 4})
                  CREATE (:N {num: 5})
            """
        ),
        expected=Expected(
            rows=[
            {'sum': 15}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='DELETE clause semantics are not supported',
        tags=('delete', 'xfail'),
    ),
    Scenario(
        key='delete6-7',
        feature_path='tck/features/clauses/delete/Delete6.feature',
        scenario='[7] Aggregating in `WITH` after deleting nodes affects the result set but not the side effects',
        cypher='MATCH (n:N)\n      WITH n, n.num AS num\n      DELETE n\n      WITH sum(num) AS sum\n      RETURN sum',
        graph=graph_fixture_from_create(
            """
            CREATE (:N {num: 1})
                  CREATE (:N {num: 2})
                  CREATE (:N {num: 3})
                  CREATE (:N {num: 4})
                  CREATE (:N {num: 5})
            """
        ),
        expected=Expected(
            rows=[
            {'sum': 15}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='DELETE clause semantics are not supported',
        tags=('delete', 'xfail'),
    ),
    Scenario(
        key='delete6-8',
        feature_path='tck/features/clauses/delete/Delete6.feature',
        scenario='[8] Limiting to zero results after deleting relationships affects the result set but not the side effects',
        cypher='MATCH ()-[r:R]->()\n      DELETE r\n      RETURN 42 AS num\n      LIMIT 0',
        graph=graph_fixture_from_create(
            """
            CREATE ()-[r:R {num: 42}]->()
            """
        ),
        expected=Expected(
            rows=[

            ],
        ),
        gfql=None,
        status="xfail",
        reason='DELETE clause semantics are not supported',
        tags=('delete', 'xfail'),
    ),
    Scenario(
        key='delete6-9',
        feature_path='tck/features/clauses/delete/Delete6.feature',
        scenario='[9] Skipping all results after deleting relationships affects the result set but not the side effects',
        cypher='MATCH ()-[r:R]->()\n      DELETE r\n      RETURN 42 AS num\n      SKIP 1',
        graph=graph_fixture_from_create(
            """
            CREATE ()-[r:R {num: 42}]->()
            """
        ),
        expected=Expected(
            rows=[

            ],
        ),
        gfql=None,
        status="xfail",
        reason='DELETE clause semantics are not supported',
        tags=('delete', 'xfail'),
    ),
    Scenario(
        key='delete6-10',
        feature_path='tck/features/clauses/delete/Delete6.feature',
        scenario='[10] Skipping and limiting to a few results after deleting relationships affects the result set but not the side effects',
        cypher='MATCH ()-[r:R]->()\n      DELETE r\n      RETURN 42 AS num\n      SKIP 2 LIMIT 2',
        graph=graph_fixture_from_create(
            """
            CREATE ()-[:R {num: 1}]->()
                  CREATE ()-[:R {num: 2}]->()
                  CREATE ()-[:R {num: 3}]->()
                  CREATE ()-[:R {num: 4}]->()
                  CREATE ()-[:R {num: 5}]->()
            """
        ),
        expected=Expected(
            rows=[
            {'num': 42},
            {'num': 42}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='DELETE clause semantics are not supported',
        tags=('delete', 'xfail'),
    ),
    Scenario(
        key='delete6-11',
        feature_path='tck/features/clauses/delete/Delete6.feature',
        scenario='[11] Skipping zero result and limiting to all results after deleting relationships does not affect the result set nor the side effects',
        cypher='MATCH ()-[r:R]->()\n      DELETE r\n      RETURN 42 AS num\n      SKIP 0 LIMIT 5',
        graph=graph_fixture_from_create(
            """
            CREATE ()-[:R {num: 1}]->()
                  CREATE ()-[:R {num: 2}]->()
                  CREATE ()-[:R {num: 3}]->()
                  CREATE ()-[:R {num: 4}]->()
                  CREATE ()-[:R {num: 5}]->()
            """
        ),
        expected=Expected(
            rows=[
            {'num': 42},
            {'num': 42},
            {'num': 42},
            {'num': 42},
            {'num': 42}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='DELETE clause semantics are not supported',
        tags=('delete', 'xfail'),
    ),
    Scenario(
        key='delete6-12',
        feature_path='tck/features/clauses/delete/Delete6.feature',
        scenario='[12] Filtering after deleting relationships affects the result set but not the side effects',
        cypher='MATCH ()-[r:R]->()\n      WITH r, r.num AS num\n      DELETE r\n      WITH num\n      WHERE num % 2 = 0\n      RETURN num',
        graph=graph_fixture_from_create(
            """
            CREATE ()-[:R {num: 1}]->()
                  CREATE ()-[:R {num: 2}]->()
                  CREATE ()-[:R {num: 3}]->()
                  CREATE ()-[:R {num: 4}]->()
                  CREATE ()-[:R {num: 5}]->()
            """
        ),
        expected=Expected(
            rows=[
            {'num': 2},
            {'num': 4}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='DELETE clause semantics are not supported',
        tags=('delete', 'xfail'),
    ),
    Scenario(
        key='delete6-13',
        feature_path='tck/features/clauses/delete/Delete6.feature',
        scenario='[13] Aggregating in `RETURN` after deleting relationships affects the result set but not the side effects',
        cypher='MATCH ()-[r:R]->()\n      WITH r, r.num AS num\n      DELETE r\n      RETURN sum(num) AS sum',
        graph=graph_fixture_from_create(
            """
            CREATE ()-[:R {num: 1}]->()
                  CREATE ()-[:R {num: 2}]->()
                  CREATE ()-[:R {num: 3}]->()
                  CREATE ()-[:R {num: 4}]->()
                  CREATE ()-[:R {num: 5}]->()
            """
        ),
        expected=Expected(
            rows=[
            {'sum': 15}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='DELETE clause semantics are not supported',
        tags=('delete', 'xfail'),
    ),
    Scenario(
        key='delete6-14',
        feature_path='tck/features/clauses/delete/Delete6.feature',
        scenario='[14] Aggregating in `WITH` after deleting relationships affects the result set but not the side effects',
        cypher='MATCH ()-[r:R]->()\n      WITH r, r.num AS num\n      DELETE r\n      WITH sum(num) AS sum\n      RETURN sum',
        graph=graph_fixture_from_create(
            """
            CREATE ()-[:R {num: 1}]->()
                  CREATE ()-[:R {num: 2}]->()
                  CREATE ()-[:R {num: 3}]->()
                  CREATE ()-[:R {num: 4}]->()
                  CREATE ()-[:R {num: 5}]->()
            """
        ),
        expected=Expected(
            rows=[
            {'sum': 15}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='DELETE clause semantics are not supported',
        tags=('delete', 'xfail'),
    ),
    Scenario(
        key='merge1-1',
        feature_path='tck/features/clauses/merge/Merge1.feature',
        scenario='[1] Merge node when no nodes exist',
        cypher='MERGE (a)\n      RETURN count(*) AS n',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'n': 1}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='MERGE clause semantics are not supported',
        tags=('merge', 'xfail'),
    ),
    Scenario(
        key='merge1-2',
        feature_path='tck/features/clauses/merge/Merge1.feature',
        scenario='[2] Merge node with label',
        cypher='MERGE (a:TheLabel)\n      RETURN labels(a)',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'labels(a)': "['TheLabel']"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='MERGE clause semantics are not supported',
        tags=('merge', 'xfail'),
    ),
    Scenario(
        key='merge1-3',
        feature_path='tck/features/clauses/merge/Merge1.feature',
        scenario='[3] Merge node with label when it exists',
        cypher='MERGE (a:TheLabel)\n      RETURN a.id',
        graph=graph_fixture_from_create(
            """
            CREATE (:TheLabel {id: 1})
            """
        ),
        expected=Expected(
            rows=[
            {'a.id': 1}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='MERGE clause semantics are not supported',
        tags=('merge', 'xfail'),
    ),
    Scenario(
        key='merge1-4',
        feature_path='tck/features/clauses/merge/Merge1.feature',
        scenario="[4] Merge node should create when it doesn't match, properties",
        cypher='MERGE (a {num: 43})\n      RETURN a.num',
        graph=graph_fixture_from_create(
            """
            CREATE ({num: 42})
            """
        ),
        expected=Expected(
            rows=[
            {'a.num': 43}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='MERGE clause semantics are not supported',
        tags=('merge', 'xfail'),
    ),
    Scenario(
        key='merge1-5',
        feature_path='tck/features/clauses/merge/Merge1.feature',
        scenario="[5] Merge node should create when it doesn't match, properties and label",
        cypher='MERGE (a:TheLabel {num: 43})\n      RETURN a.num',
        graph=graph_fixture_from_create(
            """
            CREATE (:TheLabel {num: 42})
            """
        ),
        expected=Expected(
            rows=[
            {'a.num': 43}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='MERGE clause semantics are not supported',
        tags=('merge', 'xfail'),
    ),
    Scenario(
        key='merge1-6',
        feature_path='tck/features/clauses/merge/Merge1.feature',
        scenario='[6] Merge node with prop and label',
        cypher='MERGE (a:TheLabel {num: 42})\n      RETURN a.num',
        graph=graph_fixture_from_create(
            """
            CREATE (:TheLabel {num: 42})
            """
        ),
        expected=Expected(
            rows=[
            {'a.num': 42}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='MERGE clause semantics are not supported',
        tags=('merge', 'xfail'),
    ),
    Scenario(
        key='merge1-7',
        feature_path='tck/features/clauses/merge/Merge1.feature',
        scenario='[7] Merge should work when finding multiple elements',
        cypher='CREATE (:X)\n      CREATE (:X)\n      MERGE (:X)',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason='MERGE clause semantics are not supported',
        tags=('merge', 'xfail'),
    ),
    Scenario(
        key='merge1-8',
        feature_path='tck/features/clauses/merge/Merge1.feature',
        scenario='[8] Merge should handle argument properly',
        cypher='WITH 42 AS var\n      MERGE (c:N {var: var})',
        graph=graph_fixture_from_create(
            """
            CREATE ({var: 42}),
                    ({var: 'not42'})
            """
        ),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason='MERGE clause semantics are not supported',
        tags=('merge', 'xfail'),
    ),
    Scenario(
        key='merge1-9',
        feature_path='tck/features/clauses/merge/Merge1.feature',
        scenario='[9] Merge should support updates while merging',
        cypher='MATCH (foo)\n      WITH foo.x AS x, foo.y AS y\n      MERGE (:N {x: x, y: y + 1})\n      MERGE (:N {x: x, y: y})\n      MERGE (:N {x: x + 1, y: y})\n      RETURN x, y',
        graph=graph_fixture_from_create(
            """
            UNWIND [0, 1, 2] AS x
                  UNWIND [0, 1, 2] AS y
                  CREATE ({x: x, y: y})
            """
        ),
        expected=Expected(
            rows=[
            {'x': 0, 'y': 0},
            {'x': 0, 'y': 1},
            {'x': 0, 'y': 2},
            {'x': 1, 'y': 0},
            {'x': 1, 'y': 1},
            {'x': 1, 'y': 2},
            {'x': 2, 'y': 0},
            {'x': 2, 'y': 1},
            {'x': 2, 'y': 2}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='MERGE clause semantics are not supported',
        tags=('merge', 'xfail'),
    ),
    Scenario(
        key='merge1-10',
        feature_path='tck/features/clauses/merge/Merge1.feature',
        scenario='[10] Merge must properly handle multiple labels',
        cypher='MERGE (test:L:B {num: 42})\n      RETURN labels(test) AS labels',
        graph=graph_fixture_from_create(
            """
            CREATE (:L:A {num: 42})
            """
        ),
        expected=Expected(
            rows=[
            {'labels': "['L', 'B']"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='MERGE clause semantics are not supported',
        tags=('merge', 'xfail'),
    ),
    Scenario(
        key='merge1-11',
        feature_path='tck/features/clauses/merge/Merge1.feature',
        scenario='[11] Merge should be able to merge using property of bound node',
        cypher='MATCH (person:Person)\n      MERGE (city:City {name: person.bornIn})',
        graph=graph_fixture_from_create(
            """
            CREATE (:Person {name: 'A', bornIn: 'New York'})
                  CREATE (:Person {name: 'B', bornIn: 'Ohio'})
                  CREATE (:Person {name: 'C', bornIn: 'New Jersey'})
                  CREATE (:Person {name: 'D', bornIn: 'New York'})
                  CREATE (:Person {name: 'E', bornIn: 'Ohio'})
                  CREATE (:Person {name: 'F', bornIn: 'New Jersey'})
            """
        ),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason='MERGE clause semantics are not supported',
        tags=('merge', 'xfail'),
    ),
    Scenario(
        key='merge1-12',
        feature_path='tck/features/clauses/merge/Merge1.feature',
        scenario='[12] Merge should be able to merge using property of freshly created node',
        cypher='CREATE (a {num: 1})\n      MERGE ({v: a.num})',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason='MERGE clause semantics are not supported',
        tags=('merge', 'xfail'),
    ),
    Scenario(
        key='merge1-13',
        feature_path='tck/features/clauses/merge/Merge1.feature',
        scenario='[13] Merge should bind a path',
        cypher='MERGE p = (a {num: 1})\n      RETURN p',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'p': '<({num: 1})>'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='MERGE clause semantics are not supported',
        tags=('merge', 'xfail'),
    ),
    Scenario(
        key='merge1-14',
        feature_path='tck/features/clauses/merge/Merge1.feature',
        scenario='[14] Merges should not be able to match on deleted nodes',
        cypher='MATCH (a:A)\n      DELETE a\n      MERGE (a2:A)\n      RETURN a2.num',
        graph=graph_fixture_from_create(
            """
            CREATE (:A {num: 1}),
                    (:A {num: 2})
            """
        ),
        expected=Expected(
            rows=[
            {'a2.num': 'null'},
            {'a2.num': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='MERGE clause semantics are not supported',
        tags=('merge', 'xfail'),
    ),
    Scenario(
        key='merge1-15',
        feature_path='tck/features/clauses/merge/Merge1.feature',
        scenario='[15] Fail when merge a node that is already bound',
        cypher='MATCH (a)\n      MERGE (a)',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('merge', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='merge1-16',
        feature_path='tck/features/clauses/merge/Merge1.feature',
        scenario='[16] Fail when using parameter as node predicate in MERGE',
        cypher='MERGE (n $param)\n      RETURN n',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('merge', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='merge1-17',
        feature_path='tck/features/clauses/merge/Merge1.feature',
        scenario='[17] Fail on merging node with null property',
        cypher='MERGE ({num: null})',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Runtime error semantics are not supported',
        tags=('merge', 'runtime-error', 'xfail'),
    ),
    Scenario(
        key='merge2-1',
        feature_path='tck/features/clauses/merge/Merge2.feature',
        scenario='[1] Merge node with label add label on create',
        cypher='MERGE (a:TheLabel)\n        ON CREATE SET a:Foo\n      RETURN labels(a)',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'labels(a)': "['TheLabel', 'Foo']"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='MERGE clause semantics are not supported',
        tags=('merge', 'xfail'),
    ),
    Scenario(
        key='merge2-2',
        feature_path='tck/features/clauses/merge/Merge2.feature',
        scenario='[2] ON CREATE on created nodes',
        cypher='MERGE (b)\n        ON CREATE SET b.created = 1',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason='MERGE clause semantics are not supported',
        tags=('merge', 'xfail'),
    ),
    Scenario(
        key='merge2-3',
        feature_path='tck/features/clauses/merge/Merge2.feature',
        scenario='[3] Merge node with label add property on create',
        cypher='MERGE (a:TheLabel)\n        ON CREATE SET a.num = 42\n      RETURN a.num',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'a.num': 42}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='MERGE clause semantics are not supported',
        tags=('merge', 'xfail'),
    ),
    Scenario(
        key='merge2-4',
        feature_path='tck/features/clauses/merge/Merge2.feature',
        scenario='[4] Merge node with label add property on update when it exists',
        cypher='MERGE (a:TheLabel)\n        ON CREATE SET a.num = 42\n      RETURN a.num',
        graph=graph_fixture_from_create(
            """
            CREATE (:TheLabel)
            """
        ),
        expected=Expected(
            rows=[
            {'a.num': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='MERGE clause semantics are not supported',
        tags=('merge', 'xfail'),
    ),
    Scenario(
        key='merge2-5',
        feature_path='tck/features/clauses/merge/Merge2.feature',
        scenario='[5] Merge should be able to use properties of bound node in ON CREATE',
        cypher='MATCH (person:Person)\n      MERGE (city:City)\n        ON CREATE SET city.name = person.bornIn\n      RETURN person.bornIn',
        graph=graph_fixture_from_create(
            """
            CREATE (:Person {bornIn: 'New York'}),
                    (:Person {bornIn: 'Ohio'})
            """
        ),
        expected=Expected(
            rows=[
            {'person.bornIn': "'New York'"},
            {'person.bornIn': "'Ohio'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='MERGE clause semantics are not supported',
        tags=('merge', 'xfail'),
    ),
    Scenario(
        key='merge2-6',
        feature_path='tck/features/clauses/merge/Merge2.feature',
        scenario='[6] Fail when using undefined variable in ON CREATE',
        cypher='MERGE (n)\n        ON CREATE SET x.num = 1',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('merge', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='merge3-1',
        feature_path='tck/features/clauses/merge/Merge3.feature',
        scenario='[1] Merge should be able to set labels on match',
        cypher='MERGE (a)\n        ON MATCH SET a:L',
        graph=graph_fixture_from_create(
            """
            CREATE ()
            """
        ),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason='MERGE clause semantics are not supported',
        tags=('merge', 'xfail'),
    ),
    Scenario(
        key='merge3-2',
        feature_path='tck/features/clauses/merge/Merge3.feature',
        scenario='[2] Merge node with label add label on match when it exists',
        cypher='MERGE (a:TheLabel)\n        ON MATCH SET a:Foo\n      RETURN labels(a)',
        graph=graph_fixture_from_create(
            """
            CREATE (:TheLabel)
            """
        ),
        expected=Expected(
            rows=[
            {'labels(a)': "['TheLabel', 'Foo']"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='MERGE clause semantics are not supported',
        tags=('merge', 'xfail'),
    ),
    Scenario(
        key='merge3-3',
        feature_path='tck/features/clauses/merge/Merge3.feature',
        scenario='[3] Merge node and set property on match',
        cypher='MERGE (a:TheLabel)\n        ON MATCH SET a.num = 42\n      RETURN a.num',
        graph=graph_fixture_from_create(
            """
            CREATE (:TheLabel)
            """
        ),
        expected=Expected(
            rows=[
            {'a.num': 42}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='MERGE clause semantics are not supported',
        tags=('merge', 'xfail'),
    ),
    Scenario(
        key='merge3-4',
        feature_path='tck/features/clauses/merge/Merge3.feature',
        scenario='[4] Merge should be able to use properties of bound node in ON MATCH',
        cypher='MATCH (person:Person)\n      MERGE (city:City)\n        ON MATCH SET city.name = person.bornIn\n      RETURN person.bornIn',
        graph=graph_fixture_from_create(
            """
            CREATE (:Person {bornIn: 'New York'}),
                    (:Person {bornIn: 'Ohio'})
            """
        ),
        expected=Expected(
            rows=[
            {'person.bornIn': "'New York'"},
            {'person.bornIn': "'Ohio'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='MERGE clause semantics are not supported',
        tags=('merge', 'xfail'),
    ),
    Scenario(
        key='merge3-5',
        feature_path='tck/features/clauses/merge/Merge3.feature',
        scenario='[5] Fail when using undefined variable in ON MATCH',
        cypher='MERGE (n)\n        ON MATCH SET x.num = 1',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('merge', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='merge4-1',
        feature_path='tck/features/clauses/merge/Merge4.feature',
        scenario='[1] Merge should be able to set labels on match and on create',
        cypher='MATCH ()\n      MERGE (a:L)\n        ON MATCH SET a:M1\n        ON CREATE SET a:M2',
        graph=graph_fixture_from_create(
            """
            CREATE (), ()
            """
        ),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason='MERGE clause semantics are not supported',
        tags=('merge', 'xfail'),
    ),
    Scenario(
        key='merge4-2',
        feature_path='tck/features/clauses/merge/Merge4.feature',
        scenario='[2] Merge should be able to use properties of bound node in ON MATCH and ON CREATE',
        cypher='MATCH (person:Person)\n        MERGE (city:City)\n          ON MATCH SET city.name = person.bornIn\n          ON CREATE SET city.name = person.bornIn\n        RETURN person.bornIn',
        graph=graph_fixture_from_create(
            """
            CREATE (:Person {bornIn: 'New York'}),
                    (:Person {bornIn: 'Ohio'})
            """
        ),
        expected=Expected(
            rows=[
            {'person.bornIn': "'New York'"},
            {'person.bornIn': "'Ohio'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='MERGE clause semantics are not supported',
        tags=('merge', 'xfail'),
    ),
    Scenario(
        key='merge5-1',
        feature_path='tck/features/clauses/merge/Merge5.feature',
        scenario='[1] Creating a relationship',
        cypher='MATCH (a:A), (b:B)\n      MERGE (a)-[r:TYPE]->(b)\n      RETURN count(*)',
        graph=graph_fixture_from_create(
            """
            CREATE (:A), (:B)
            """
        ),
        expected=Expected(
            rows=[
            {'count(*)': 1}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='MERGE clause semantics are not supported',
        tags=('merge', 'xfail'),
    ),
    Scenario(
        key='merge5-2',
        feature_path='tck/features/clauses/merge/Merge5.feature',
        scenario='[2] Matching a relationship',
        cypher='MATCH (a:A), (b:B)\n      MERGE (a)-[r:TYPE]->(b)\n      RETURN count(r)',
        graph=graph_fixture_from_create(
            """
            CREATE (a:A), (b:B)
                  CREATE (a)-[:TYPE]->(b)
            """
        ),
        expected=Expected(
            rows=[
            {'count(r)': 1}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='MERGE clause semantics are not supported',
        tags=('merge', 'xfail'),
    ),
    Scenario(
        key='merge5-3',
        feature_path='tck/features/clauses/merge/Merge5.feature',
        scenario='[3] Matching two relationships',
        cypher='MATCH (a:A), (b:B)\n      MERGE (a)-[r:TYPE]->(b)\n      RETURN count(r)',
        graph=graph_fixture_from_create(
            """
            CREATE (a:A), (b:B)
                  CREATE (a)-[:TYPE]->(b)
                  CREATE (a)-[:TYPE]->(b)
            """
        ),
        expected=Expected(
            rows=[
            {'count(r)': 2}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='MERGE clause semantics are not supported',
        tags=('merge', 'xfail'),
    ),
    Scenario(
        key='merge5-4',
        feature_path='tck/features/clauses/merge/Merge5.feature',
        scenario='[4] Using bound variables from other updating clause',
        cypher='CREATE (a), (b)\n      MERGE (a)-[:X]->(b)\n      RETURN count(a)',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'count(a)': 1}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='MERGE clause semantics are not supported',
        tags=('merge', 'xfail'),
    ),
    Scenario(
        key='merge5-5',
        feature_path='tck/features/clauses/merge/Merge5.feature',
        scenario='[5] Filtering relationships',
        cypher="MATCH (a:A), (b:B)\n      MERGE (a)-[r:TYPE {name: 'r2'}]->(b)\n      RETURN count(r)",
        graph=graph_fixture_from_create(
            """
            CREATE (a:A), (b:B)
                  CREATE (a)-[:TYPE {name: 'r1'}]->(b)
                  CREATE (a)-[:TYPE {name: 'r2'}]->(b)
            """
        ),
        expected=Expected(
            rows=[
            {'count(r)': 1}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='MERGE clause semantics are not supported',
        tags=('merge', 'xfail'),
    ),
    Scenario(
        key='merge5-6',
        feature_path='tck/features/clauses/merge/Merge5.feature',
        scenario='[6] Creating relationship when all matches filtered out',
        cypher="MATCH (a:A), (b:B)\n      MERGE (a)-[r:TYPE {name: 'r2'}]->(b)\n      RETURN count(r)",
        graph=graph_fixture_from_create(
            """
            CREATE (a:A), (b:B)
                  CREATE (a)-[:TYPE {name: 'r1'}]->(b)
            """
        ),
        expected=Expected(
            rows=[
            {'count(r)': 1}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='MERGE clause semantics are not supported',
        tags=('merge', 'xfail'),
    ),
    Scenario(
        key='merge5-7',
        feature_path='tck/features/clauses/merge/Merge5.feature',
        scenario='[7] Matching incoming relationship',
        cypher='MATCH (a:A), (b:B)\n      MERGE (a)<-[r:TYPE]-(b)\n      RETURN count(r)',
        graph=graph_fixture_from_create(
            """
            CREATE (a:A), (b:B)
                  CREATE (b)-[:TYPE]->(a)
                  CREATE (a)-[:TYPE]->(b)
            """
        ),
        expected=Expected(
            rows=[
            {'count(r)': 1}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='MERGE clause semantics are not supported',
        tags=('merge', 'xfail'),
    ),
    Scenario(
        key='merge5-8',
        feature_path='tck/features/clauses/merge/Merge5.feature',
        scenario='[8] Creating relationship with property',
        cypher="MATCH (a:A), (b:B)\n      MERGE (a)-[r:TYPE {name: 'Lola'}]->(b)\n      RETURN count(r)",
        graph=graph_fixture_from_create(
            """
            CREATE (a:A), (b:B)
            """
        ),
        expected=Expected(
            rows=[
            {'count(r)': 1}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='MERGE clause semantics are not supported',
        tags=('merge', 'xfail'),
    ),
    Scenario(
        key='merge5-9',
        feature_path='tck/features/clauses/merge/Merge5.feature',
        scenario='[9] Creating relationship using merged nodes',
        cypher='MERGE (a:A)\n      MERGE (b:B)\n      MERGE (a)-[:FOO]->(b)',
        graph=graph_fixture_from_create(
            """
            CREATE (a:A), (b:B)
            """
        ),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason='MERGE clause semantics are not supported',
        tags=('merge', 'xfail'),
    ),
    Scenario(
        key='merge5-10',
        feature_path='tck/features/clauses/merge/Merge5.feature',
        scenario='[10] Merge should bind a path',
        cypher='MERGE (a {num: 1})\n      MERGE (b {num: 2})\n      MERGE p = (a)-[:R]->(b)\n      RETURN p',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'p': '<({num: 1})-[:R]->({num: 2})>'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='MERGE clause semantics are not supported',
        tags=('merge', 'xfail'),
    ),
    Scenario(
        key='merge5-11',
        feature_path='tck/features/clauses/merge/Merge5.feature',
        scenario='[11] Use outgoing direction when unspecified',
        cypher='CREATE (a {id: 2}), (b {id: 1})\n      MERGE (a)-[r:KNOWS]-(b)\n      RETURN startNode(r).id AS s, endNode(r).id AS e',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'s': 2, 'e': 1}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='MERGE clause semantics are not supported',
        tags=('merge', 'xfail'),
    ),
    Scenario(
        key='merge5-12',
        feature_path='tck/features/clauses/merge/Merge5.feature',
        scenario='[12] Match outgoing relationship when direction unspecified',
        cypher='MATCH (a {id: 2}), (b {id: 1})\n      MERGE (a)-[r:KNOWS]-(b)\n      RETURN r',
        graph=graph_fixture_from_create(
            """
            CREATE (a {id: 1}), (b {id: 2})
                  CREATE (a)-[:KNOWS]->(b)
            """
        ),
        expected=Expected(
            rows=[
            {'r': '[:KNOWS]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='MERGE clause semantics are not supported',
        tags=('merge', 'xfail'),
    ),
    Scenario(
        key='merge5-13',
        feature_path='tck/features/clauses/merge/Merge5.feature',
        scenario='[13] Match both incoming and outgoing relationships when direction unspecified',
        cypher='MATCH (a {id: 2})--(b {id: 1})\n      MERGE (a)-[r:KNOWS]-(b)\n      RETURN r',
        graph=graph_fixture_from_create(
            """
            CREATE (a {id: 2}), (b {id: 1}), (c {id: 1}), (d {id: 2})
                  CREATE (a)-[:KNOWS {name: 'ab'}]->(b)
                  CREATE (c)-[:KNOWS {name: 'cd'}]->(d)
            """
        ),
        expected=Expected(
            rows=[
            {'r': "[:KNOWS {name: 'ab'}]"},
            {'r': "[:KNOWS {name: 'cd'}]"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='MERGE clause semantics are not supported',
        tags=('merge', 'xfail'),
    ),
    Scenario(
        key='merge5-14',
        feature_path='tck/features/clauses/merge/Merge5.feature',
        scenario='[14] Using list properties via variable',
        cypher="CREATE (a:Foo), (b:Bar)\n      WITH a, b\n      UNWIND ['a,b', 'a,b'] AS str\n      WITH a, b, split(str, ',') AS roles\n      MERGE (a)-[r:FB {foobar: roles}]->(b)\n      RETURN count(*)",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'count(*)': 2}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='MERGE clause semantics are not supported',
        tags=('merge', 'xfail'),
    ),
    Scenario(
        key='merge5-15',
        feature_path='tck/features/clauses/merge/Merge5.feature',
        scenario='[15] Matching using list property',
        cypher='MATCH (a:A), (b:B)\n      MERGE (a)-[r:T {numbers: [42, 43]}]->(b)\n      RETURN count(*)',
        graph=graph_fixture_from_create(
            """
            CREATE (a:A), (b:B)
                  CREATE (a)-[:T {numbers: [42, 43]}]->(b)
            """
        ),
        expected=Expected(
            rows=[
            {'count(*)': 1}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='MERGE clause semantics are not supported',
        tags=('merge', 'xfail'),
    ),
    Scenario(
        key='merge5-16',
        feature_path='tck/features/clauses/merge/Merge5.feature',
        scenario='[16] Aliasing of existing nodes 1',
        cypher='MATCH (n)\n      MATCH (m)\n      WITH n AS a, m AS b\n      MERGE (a)-[r:T]->(b)\n      RETURN a.id AS a, b.id AS b',
        graph=graph_fixture_from_create(
            """
            CREATE ({id: 0})
            """
        ),
        expected=Expected(
            rows=[
            {'a': 0, 'b': 0}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='MERGE clause semantics are not supported',
        tags=('merge', 'xfail'),
    ),
    Scenario(
        key='merge5-17',
        feature_path='tck/features/clauses/merge/Merge5.feature',
        scenario='[17] Aliasing of existing nodes 2',
        cypher='MATCH (n)\n      WITH n AS a, n AS b\n      MERGE (a)-[r:T]->(b)\n      RETURN a.id AS a',
        graph=graph_fixture_from_create(
            """
            CREATE ({id: 0})
            """
        ),
        expected=Expected(
            rows=[
            {'a': 0}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='MERGE clause semantics are not supported',
        tags=('merge', 'xfail'),
    ),
    Scenario(
        key='merge5-18',
        feature_path='tck/features/clauses/merge/Merge5.feature',
        scenario='[18] Double aliasing of existing nodes 1',
        cypher='MATCH (n)\n      MATCH (m)\n      WITH n AS a, m AS b\n      MERGE (a)-[:T]->(b)\n      WITH a AS x, b AS y\n      MERGE (a)\n      MERGE (b)\n      MERGE (a)-[:T]->(b)\n      RETURN x.id AS x, y.id AS y',
        graph=graph_fixture_from_create(
            """
            CREATE ({id: 0})
            """
        ),
        expected=Expected(
            rows=[
            {'x': 0, 'y': 0}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='MERGE clause semantics are not supported',
        tags=('merge', 'xfail'),
    ),
    Scenario(
        key='merge5-19',
        feature_path='tck/features/clauses/merge/Merge5.feature',
        scenario='[19] Double aliasing of existing nodes 2',
        cypher='MATCH (n)\n      WITH n AS a\n      MERGE (c)\n      MERGE (a)-[:T]->(c)\n      WITH a AS x\n      MERGE (c)\n      MERGE (x)-[:T]->(c)\n      RETURN x.id AS x',
        graph=graph_fixture_from_create(
            """
            CREATE ({id: 0})
            """
        ),
        expected=Expected(
            rows=[
            {'x': 0}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='MERGE clause semantics are not supported',
        tags=('merge', 'xfail'),
    ),
    Scenario(
        key='merge5-20',
        feature_path='tck/features/clauses/merge/Merge5.feature',
        scenario='[20] Do not match on deleted entities',
        cypher='MATCH (a:A)-[ab]->(b:B)-[bc]->(c:C)\n      DELETE ab, bc, b, c\n      MERGE (newB:B {num: 1})\n      MERGE (a)-[:REL]->(newB)\n      MERGE (newC:C)\n      MERGE (newB)-[:REL]->(newC)',
        graph=graph_fixture_from_create(
            """
            CREATE (a:A)
                  CREATE (b1:B {num: 0}), (b2:B {num: 1})
                  CREATE (c1:C), (c2:C)
                  CREATE (a)-[:REL]->(b1),
                         (a)-[:REL]->(b2),
                         (b1)-[:REL]->(c1),
                         (b2)-[:REL]->(c2)
            """
        ),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason='MERGE clause semantics are not supported',
        tags=('merge', 'xfail'),
    ),
    Scenario(
        key='merge5-21',
        feature_path='tck/features/clauses/merge/Merge5.feature',
        scenario='[21] Do not match on deleted relationships',
        cypher="MATCH (a)-[t:T]->(b)\n      DELETE t\n      MERGE (a)-[t2:T {name: 'rel3'}]->(b)\n      RETURN t2.name",
        graph=graph_fixture_from_create(
            """
            CREATE (a:A), (b:B)
                  CREATE (a)-[:T {name: 'rel1'}]->(b),
                         (a)-[:T {name: 'rel2'}]->(b)
            """
        ),
        expected=Expected(
            rows=[
            {'t2.name': "'rel3'"},
            {'t2.name': "'rel3'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='MERGE clause semantics are not supported',
        tags=('merge', 'xfail'),
    ),
    Scenario(
        key='merge5-22',
        feature_path='tck/features/clauses/merge/Merge5.feature',
        scenario='[22] Fail when imposing new predicates on a variable that is already bound',
        cypher='CREATE (a:Foo)\n      MERGE (a)-[r:KNOWS]->(a:Bar)',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('merge', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='merge5-23',
        feature_path='tck/features/clauses/merge/Merge5.feature',
        scenario='[23] Fail when merging relationship without type',
        cypher='CREATE (a), (b)\n      MERGE (a)-->(b)',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('merge', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='merge5-24',
        feature_path='tck/features/clauses/merge/Merge5.feature',
        scenario='[24] Fail when merging relationship without type, no colon',
        cypher='MATCH (a), (b)\n      MERGE (a)-[NO_COLON]->(b)',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('merge', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='merge5-25',
        feature_path='tck/features/clauses/merge/Merge5.feature',
        scenario='[25] Fail when merging relationship with more than one type',
        cypher='CREATE (a), (b)\n      MERGE (a)-[:A|:B]->(b)',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('merge', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='merge5-26',
        feature_path='tck/features/clauses/merge/Merge5.feature',
        scenario='[26] Fail when merging relationship that is already bound',
        cypher='MATCH (a)-[r]->(b)\n      MERGE (a)-[r]->(b)',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('merge', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='merge5-27',
        feature_path='tck/features/clauses/merge/Merge5.feature',
        scenario='[27] Fail when using parameter as relationship predicate in MERGE',
        cypher='MERGE (a)\n      MERGE (b)\n      MERGE (a)-[r:FOO $param]->(b)\n      RETURN r',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('merge', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='merge5-28',
        feature_path='tck/features/clauses/merge/Merge5.feature',
        scenario='[28] Fail when using variable length relationship in MERGE',
        cypher='MERGE (a)\n      MERGE (b)\n      MERGE (a)-[:FOO*2]->(b)',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('merge', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='merge5-29',
        feature_path='tck/features/clauses/merge/Merge5.feature',
        scenario='[29] Fail on merging relationship with null property',
        cypher='CREATE (a), (b)\n      MERGE (a)-[r:X {num: null}]->(b)',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Runtime error semantics are not supported',
        tags=('merge', 'runtime-error', 'xfail'),
    ),
    Scenario(
        key='merge6-1',
        feature_path='tck/features/clauses/merge/Merge6.feature',
        scenario='[1] Using ON CREATE on a node',
        cypher='MATCH (a:A), (b:B)\n      MERGE (a)-[:KNOWS]->(b)\n        ON CREATE SET b.created = 1',
        graph=graph_fixture_from_create(
            """
            CREATE (:A), (:B)
            """
        ),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason='MERGE clause semantics are not supported',
        tags=('merge', 'xfail'),
    ),
    Scenario(
        key='merge6-2',
        feature_path='tck/features/clauses/merge/Merge6.feature',
        scenario='[2] Using ON CREATE on a relationship',
        cypher="MATCH (a:A), (b:B)\n      MERGE (a)-[r:TYPE]->(b)\n        ON CREATE SET r.name = 'Lola'\n      RETURN count(r)",
        graph=graph_fixture_from_create(
            """
            CREATE (:A), (:B)
            """
        ),
        expected=Expected(
            rows=[
            {'count(r)': 1}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='MERGE clause semantics are not supported',
        tags=('merge', 'xfail'),
    ),
    Scenario(
        key='merge6-3',
        feature_path='tck/features/clauses/merge/Merge6.feature',
        scenario='[3] Updating one property with ON CREATE',
        cypher="MATCH (a {name: 'A'}), (b {name: 'B'})\n      MERGE (a)-[r:TYPE]->(b)\n        ON CREATE SET r.name = 'foo'",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {name: 'A'}), (:B {name: 'B'})
            """
        ),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason='MERGE clause semantics are not supported',
        tags=('merge', 'xfail'),
    ),
    Scenario(
        key='merge6-4',
        feature_path='tck/features/clauses/merge/Merge6.feature',
        scenario='[4] Null-setting one property with ON CREATE',
        cypher="MATCH (a {name: 'A'}), (b {name: 'B'})\n      MERGE (a)-[r:TYPE]->(b)\n        ON CREATE SET r.name = null",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {name: 'A'}), (:B {name: 'B'})
            """
        ),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason='MERGE clause semantics are not supported',
        tags=('merge', 'xfail'),
    ),
    Scenario(
        key='merge6-6',
        feature_path='tck/features/clauses/merge/Merge6.feature',
        scenario='[6] Copying properties from node with ON CREATE',
        cypher="MATCH (a {name: 'A'}), (b {name: 'B'})\n      MERGE (a)-[r:TYPE]->(b)\n        ON CREATE SET r = a",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {name: 'A'}), (:B {name: 'B'})
            """
        ),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason='MERGE clause semantics are not supported',
        tags=('merge', 'xfail'),
    ),
    Scenario(
        key='merge6-7',
        feature_path='tck/features/clauses/merge/Merge6.feature',
        scenario='[7] Copying properties from literal map with ON CREATE',
        cypher="MATCH (a {name: 'A'}), (b {name: 'B'})\n      MERGE (a)-[r:TYPE]->(b)\n      ON CREATE SET r += {name: 'bar', name2: 'baz'}",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {name: 'A'}), (:B {name: 'B'})
            """
        ),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason='MERGE clause semantics are not supported',
        tags=('merge', 'xfail'),
    ),
    Scenario(
        key='merge7-1',
        feature_path='tck/features/clauses/merge/Merge7.feature',
        scenario='[1] Using ON MATCH on created node',
        cypher='MATCH (a:A), (b:B)\n      MERGE (a)-[:KNOWS]->(b)\n        ON MATCH SET b.created = 1',
        graph=graph_fixture_from_create(
            """
            CREATE (:A), (:B)
            """
        ),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason='MERGE clause semantics are not supported',
        tags=('merge', 'xfail'),
    ),
    Scenario(
        key='merge7-2',
        feature_path='tck/features/clauses/merge/Merge7.feature',
        scenario='[2] Using ON MATCH on created relationship',
        cypher='MATCH (a:A), (b:B)\n      MERGE (a)-[r:KNOWS]->(b)\n        ON MATCH SET r.created = 1',
        graph=graph_fixture_from_create(
            """
            CREATE (:A), (:B)
            """
        ),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason='MERGE clause semantics are not supported',
        tags=('merge', 'xfail'),
    ),
    Scenario(
        key='merge7-3',
        feature_path='tck/features/clauses/merge/Merge7.feature',
        scenario='[3] Using ON MATCH on a relationship',
        cypher="MATCH (a:A), (b:B)\n      MERGE (a)-[r:TYPE]->(b)\n        ON MATCH SET r.name = 'Lola'\n      RETURN count(r)",
        graph=graph_fixture_from_create(
            """
            CREATE (a:A), (b:B)
                  CREATE (a)-[:TYPE]->(b)
            """
        ),
        expected=Expected(
            rows=[
            {'count(r)': 1}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='MERGE clause semantics are not supported',
        tags=('merge', 'xfail'),
    ),
    Scenario(
        key='merge7-4',
        feature_path='tck/features/clauses/merge/Merge7.feature',
        scenario='[4] Copying properties from node with ON MATCH',
        cypher="MATCH (a {name: 'A'}), (b {name: 'B'})\n      MERGE (a)-[r:TYPE]->(b)\n        ON MATCH SET r = a",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {name: 'A'}), (:B {name: 'B'})
            MATCH (a:A), (b:B)
                  CREATE (a)-[:TYPE {name: 'bar'}]->(b)
            """
        ),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason='MERGE clause semantics are not supported',
        tags=('merge', 'xfail'),
    ),
    Scenario(
        key='merge7-5',
        feature_path='tck/features/clauses/merge/Merge7.feature',
        scenario='[5] Copying properties from literal map with ON MATCH',
        cypher="MATCH (a {name: 'A'}), (b {name: 'B'})\n      MERGE (a)-[r:TYPE]->(b)\n        ON MATCH SET r += {name: 'baz', name2: 'baz'}",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {name: 'A'}), (:B {name: 'B'})
            MATCH (a:A), (b:B)
                  CREATE (a)-[:TYPE {name: 'bar'}]->(b)
            """
        ),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason='MERGE clause semantics are not supported',
        tags=('merge', 'xfail'),
    ),
    Scenario(
        key='merge8-1',
        feature_path='tck/features/clauses/merge/Merge8.feature',
        scenario='[1] Using ON CREATE and ON MATCH',
        cypher="MATCH (a:A), (b:B)\n      MERGE (a)-[r:TYPE]->(b)\n        ON CREATE SET r.name = 'Lola'\n        ON MATCH SET r.name = 'RUN'\n      RETURN count(r)",
        graph=graph_fixture_from_create(
            """
            CREATE (a:A {id: 1}), (b:B {id: 2})
                  CREATE (a)-[:TYPE]->(b)
                  CREATE (:A {id: 3}), (:B {id: 4})
            """
        ),
        expected=Expected(
            rows=[
            {'count(r)': 4}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='MERGE clause semantics are not supported',
        tags=('merge', 'xfail'),
    ),
    Scenario(
        key='merge9-1',
        feature_path='tck/features/clauses/merge/Merge9.feature',
        scenario='[1] UNWIND with one MERGE',
        cypher='UNWIND [1, 2, 3, 4] AS int\n      MERGE (n {id: int})\n      RETURN count(*)',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'count(*)': 4}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='MERGE clause semantics are not supported',
        tags=('merge', 'xfail'),
    ),
    Scenario(
        key='merge9-2',
        feature_path='tck/features/clauses/merge/Merge9.feature',
        scenario='[2] UNWIND with multiple MERGE',
        cypher="UNWIND ['Keanu Reeves', 'Hugo Weaving', 'Carrie-Anne Moss', 'Laurence Fishburne'] AS actor\n      MERGE (m:Movie {name: 'The Matrix'})\n      MERGE (p:Person {name: actor})\n      MERGE (p)-[:ACTED_IN]->(m)",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason='MERGE clause semantics are not supported',
        tags=('merge', 'xfail'),
    ),
    Scenario(
        key='merge9-3',
        feature_path='tck/features/clauses/merge/Merge9.feature',
        scenario='[3] Mixing MERGE with CREATE',
        cypher='CREATE (a:A), (b:B)\n      MERGE (a)-[:KNOWS]->(b)\n      CREATE (b)-[:KNOWS]->(c:C)\n      RETURN count(*)',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'count(*)': 1}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='MERGE clause semantics are not supported',
        tags=('merge', 'xfail'),
    ),
    Scenario(
        key='merge9-4',
        feature_path='tck/features/clauses/merge/Merge9.feature',
        scenario='[4] MERGE after WITH with predicate and WITH with aggregation',
        cypher='UNWIND [42] AS props\n      WITH props WHERE props > 32\n      WITH DISTINCT props AS p\n      MERGE (a:A {num: p})\n      RETURN a.num AS prop',
        graph=graph_fixture_from_create(
            """
            CREATE (:A {num: 42})
            """
        ),
        expected=Expected(
            rows=[
            {'prop': 42}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='MERGE clause semantics are not supported',
        tags=('merge', 'xfail'),
    ),
    Scenario(
        key='set1-1',
        feature_path='tck/features/clauses/set/Set1.feature',
        scenario='[1] Set a property',
        cypher="MATCH (n:A)\n      WHERE n.name = 'Andres'\n      SET n.name = 'Michael'\n      RETURN n",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {name: 'Andres'})
            """
        ),
        expected=Expected(
            rows=[
            {'n': "(:A {name: 'Michael'})"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='SET clause semantics are not supported',
        tags=('set', 'xfail'),
    ),
    Scenario(
        key='set1-2',
        feature_path='tck/features/clauses/set/Set1.feature',
        scenario='[2] Set a property to an expression',
        cypher="MATCH (n:A)\n      WHERE n.name = 'Andres'\n      SET n.name = n.name + ' was here'\n      RETURN n",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {name: 'Andres'})
            """
        ),
        expected=Expected(
            rows=[
            {'n': "(:A {name: 'Andres was here'})"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='SET clause semantics are not supported',
        tags=('set', 'xfail'),
    ),
    Scenario(
        key='set1-3',
        feature_path='tck/features/clauses/set/Set1.feature',
        scenario='[3] Set a property by selecting the node using a simple expression',
        cypher="MATCH (n:A)\n      SET (n).name = 'neo4j'\n      RETURN n",
        graph=graph_fixture_from_create(
            """
            CREATE (:A)
            """
        ),
        expected=Expected(
            rows=[
            {'n': "(:A {name: 'neo4j'})"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='SET clause semantics are not supported',
        tags=('set', 'xfail'),
    ),
    Scenario(
        key='set1-4',
        feature_path='tck/features/clauses/set/Set1.feature',
        scenario='[4] Set a property by selecting the relationship using a simple expression',
        cypher="MATCH ()-[r:REL]->()\n      SET (r).name = 'neo4j'\n      RETURN r",
        graph=graph_fixture_from_create(
            """
            CREATE ()-[:REL]->()
            """
        ),
        expected=Expected(
            rows=[
            {'r': "[:REL {name: 'neo4j'}]"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='SET clause semantics are not supported',
        tags=('set', 'xfail'),
    ),
    Scenario(
        key='set1-5',
        feature_path='tck/features/clauses/set/Set1.feature',
        scenario='[5] Adding a list property',
        cypher='MATCH (n:A)\n      SET n.numbers = [1, 2, 3]\n      RETURN [i IN n.numbers | i / 2.0] AS x',
        graph=graph_fixture_from_create(
            """
            CREATE (:A)
            """
        ),
        expected=Expected(
            rows=[
            {'x': '[0.5, 1.0, 1.5]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='SET clause semantics are not supported',
        tags=('set', 'xfail'),
    ),
    Scenario(
        key='set1-6',
        feature_path='tck/features/clauses/set/Set1.feature',
        scenario='[6] Concatenate elements onto a list property',
        cypher='CREATE (a {numbers: [1, 2, 3]})\n      SET a.numbers = a.numbers + [4, 5]\n      RETURN a.numbers',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'a.numbers': '[1, 2, 3, 4, 5]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='SET clause semantics are not supported',
        tags=('set', 'xfail'),
    ),
    Scenario(
        key='set1-7',
        feature_path='tck/features/clauses/set/Set1.feature',
        scenario='[7] Concatenate elements in reverse onto a list property',
        cypher='CREATE (a {numbers: [3, 4, 5]})\n      SET a.numbers = [1, 2] + a.numbers\n      RETURN a.numbers',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'a.numbers': '[1, 2, 3, 4, 5]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='SET clause semantics are not supported',
        tags=('set', 'xfail'),
    ),
    Scenario(
        key='set1-8',
        feature_path='tck/features/clauses/set/Set1.feature',
        scenario='[8] Ignore null when setting property',
        cypher='OPTIONAL MATCH (a:DoesNotExist)\n      SET a.num = 42\n      RETURN a',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'a': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='SET clause semantics are not supported',
        tags=('set', 'xfail'),
    ),
    Scenario(
        key='set1-9',
        feature_path='tck/features/clauses/set/Set1.feature',
        scenario='[9] Failing when using undefined variable in SET',
        cypher='MATCH (a)\n      SET a.name = missing\n      RETURN a',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('set', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='set1-10',
        feature_path='tck/features/clauses/set/Set1.feature',
        scenario='[10] Failing when setting a list of maps as a property',
        cypher='CREATE (a)\n      SET a.maplist = [{num: 1}]',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Runtime error semantics are not supported',
        tags=('set', 'runtime-error', 'xfail'),
    ),
    Scenario(
        key='set1-11',
        feature_path='tck/features/clauses/set/Set1.feature',
        scenario='[11] Set multiple node properties',
        cypher="MATCH (n:X)\n      SET n.name = 'A', n.name2 = 'B', n.num = 5\n      RETURN n",
        graph=graph_fixture_from_create(
            """
            CREATE (:X)
            """
        ),
        expected=Expected(
            rows=[
            {'n': "(:X {name: 'A', name2: 'B', num: 5})"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='SET clause semantics are not supported',
        tags=('set', 'xfail'),
    ),
    Scenario(
        key='set2-1',
        feature_path='tck/features/clauses/set/Set2.feature',
        scenario='[1] Setting a node property to null removes the existing property',
        cypher='MATCH (n:A)\n      SET n.property1 = null\n      RETURN n',
        graph=graph_fixture_from_create(
            """
            CREATE (:A {property1: 23, property2: 46})
            """
        ),
        expected=Expected(
            rows=[
            {'n': '(:A {property2: 46})'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='SET clause semantics are not supported',
        tags=('set', 'xfail'),
    ),
    Scenario(
        key='set2-2',
        feature_path='tck/features/clauses/set/Set2.feature',
        scenario='[2] Setting a node property to null removes the existing property, but not before SET',
        cypher="MATCH (n)\n      WHERE n.name = 'Michael'\n      SET n.name = null\n      RETURN n",
        graph=graph_fixture_from_create(
            """
            CREATE (:A {name: 'Michael', age: 35})
            """
        ),
        expected=Expected(
            rows=[
            {'n': '(:A {age: 35})'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='SET clause semantics are not supported',
        tags=('set', 'xfail'),
    ),
    Scenario(
        key='set2-3',
        feature_path='tck/features/clauses/set/Set2.feature',
        scenario='[3] Setting a relationship property to null removes the existing property',
        cypher='MATCH ()-[r]->()\n      SET r.property1 = null\n      RETURN r',
        graph=graph_fixture_from_create(
            """
            CREATE ()-[:REL {property1: 12, property2: 24}]->()
            """
        ),
        expected=Expected(
            rows=[
            {'r': '[:REL {property2: 24}]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='SET clause semantics are not supported',
        tags=('set', 'xfail'),
    ),
    Scenario(
        key='set3-1',
        feature_path='tck/features/clauses/set/Set3.feature',
        scenario='[1] Add a single label to a node with no label',
        cypher='MATCH (n)\n      SET n:Foo\n      RETURN n',
        graph=graph_fixture_from_create(
            """
            CREATE ()
            """
        ),
        expected=Expected(
            rows=[
            {'n': '(:Foo)'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='SET clause semantics are not supported',
        tags=('set', 'xfail'),
    ),
    Scenario(
        key='set3-2',
        feature_path='tck/features/clauses/set/Set3.feature',
        scenario='[2] Adding multiple labels to a node with no label',
        cypher='MATCH (n)\n      SET n:Foo:Bar\n      RETURN n',
        graph=graph_fixture_from_create(
            """
            CREATE ()
            """
        ),
        expected=Expected(
            rows=[
            {'n': '(:Foo:Bar)'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='SET clause semantics are not supported',
        tags=('set', 'xfail'),
    ),
    Scenario(
        key='set3-3',
        feature_path='tck/features/clauses/set/Set3.feature',
        scenario='[3] Add a single label to a node with an existing label',
        cypher='MATCH (n:A)\n      SET n:Foo\n      RETURN n',
        graph=graph_fixture_from_create(
            """
            CREATE (:A)
            """
        ),
        expected=Expected(
            rows=[
            {'n': '(:A:Foo)'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='SET clause semantics are not supported',
        tags=('set', 'xfail'),
    ),
    Scenario(
        key='set3-4',
        feature_path='tck/features/clauses/set/Set3.feature',
        scenario='[4] Adding multiple labels to a node with an existing label',
        cypher='MATCH (n)\n      SET n:Foo:Bar\n      RETURN n',
        graph=graph_fixture_from_create(
            """
            CREATE (:A)
            """
        ),
        expected=Expected(
            rows=[
            {'n': '(:A:Foo:Bar)'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='SET clause semantics are not supported',
        tags=('set', 'xfail'),
    ),
    Scenario(
        key='set3-5',
        feature_path='tck/features/clauses/set/Set3.feature',
        scenario='[5] Ignore whitespace before colon 1',
        cypher='MATCH (n)\n      SET n :Foo\n      RETURN labels(n)',
        graph=graph_fixture_from_create(
            """
            CREATE ()
            """
        ),
        expected=Expected(
            rows=[
            {'labels(n)': "['Foo']"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='SET clause semantics are not supported',
        tags=('set', 'xfail'),
    ),
    Scenario(
        key='set3-6',
        feature_path='tck/features/clauses/set/Set3.feature',
        scenario='[6] Ignore whitespace before colon 2',
        cypher='MATCH (n)\n      SET n :Foo :Bar\n      RETURN labels(n)',
        graph=graph_fixture_from_create(
            """
            CREATE ()
            """
        ),
        expected=Expected(
            rows=[
            {'labels(n)': "['Foo', 'Bar']"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='SET clause semantics are not supported',
        tags=('set', 'xfail'),
    ),
    Scenario(
        key='set3-7',
        feature_path='tck/features/clauses/set/Set3.feature',
        scenario='[7] Ignore whitespace before colon 3',
        cypher='MATCH (n)\n      SET n :Foo:Bar\n      RETURN labels(n)',
        graph=graph_fixture_from_create(
            """
            CREATE ()
            """
        ),
        expected=Expected(
            rows=[
            {'labels(n)': "['Foo', 'Bar']"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='SET clause semantics are not supported',
        tags=('set', 'xfail'),
    ),
    Scenario(
        key='set3-8',
        feature_path='tck/features/clauses/set/Set3.feature',
        scenario='[8] Ignore null when setting label',
        cypher='OPTIONAL MATCH (a:DoesNotExist)\n      SET a:L\n      RETURN a',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'a': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='SET clause semantics are not supported',
        tags=('set', 'xfail'),
    ),
    Scenario(
        key='set4-1',
        feature_path='tck/features/clauses/set/Set4.feature',
        scenario='[1] Set multiple properties with a property map',
        cypher="MATCH (n:X)\n      SET n = {name: 'A', name2: 'B', num: 5}\n      RETURN n",
        graph=graph_fixture_from_create(
            """
            CREATE (:X)
            """
        ),
        expected=Expected(
            rows=[
            {'n': "(:X {name: 'A', name2: 'B', num: 5})"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='SET clause semantics are not supported',
        tags=('set', 'xfail'),
    ),
    Scenario(
        key='set4-2',
        feature_path='tck/features/clauses/set/Set4.feature',
        scenario='[2] Non-existent values in a property map are removed with SET',
        cypher="MATCH (n:X {name: 'A'})\n      SET n = {name: 'B', baz: 'C'}\n      RETURN n",
        graph=graph_fixture_from_create(
            """
            CREATE (:X {name: 'A', name2: 'B'})
            """
        ),
        expected=Expected(
            rows=[
            {'n': "(:X {name: 'B', baz: 'C'})"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='SET clause semantics are not supported',
        tags=('set', 'xfail'),
    ),
    Scenario(
        key='set4-3',
        feature_path='tck/features/clauses/set/Set4.feature',
        scenario='[3] Null values in a property map are removed with SET',
        cypher="MATCH (n:X {name: 'A'})\n      SET n = {name: 'B', name2: null, baz: 'C'}\n      RETURN n",
        graph=graph_fixture_from_create(
            """
            CREATE (:X {name: 'A', name2: 'B'})
            """
        ),
        expected=Expected(
            rows=[
            {'n': "(:X {name: 'B', baz: 'C'})"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='SET clause semantics are not supported',
        tags=('set', 'xfail'),
    ),
    Scenario(
        key='set4-4',
        feature_path='tck/features/clauses/set/Set4.feature',
        scenario='[4] All properties are removed if node is set to empty property map',
        cypher="MATCH (n:X {name: 'A'})\n      SET n = { }\n      RETURN n",
        graph=graph_fixture_from_create(
            """
            CREATE (:X {name: 'A', name2: 'B'})
            """
        ),
        expected=Expected(
            rows=[
            {'n': '(:X)'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='SET clause semantics are not supported',
        tags=('set', 'xfail'),
    ),
    Scenario(
        key='set4-5',
        feature_path='tck/features/clauses/set/Set4.feature',
        scenario='[5] Ignore null when setting properties using an overriding map',
        cypher='OPTIONAL MATCH (a:DoesNotExist)\n      SET a = {num: 42}\n      RETURN a',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'a': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='SET clause semantics are not supported',
        tags=('set', 'xfail'),
    ),
    Scenario(
        key='set5-1',
        feature_path='tck/features/clauses/set/Set5.feature',
        scenario='[1] Ignore null when setting properties using an appending map',
        cypher='OPTIONAL MATCH (a:DoesNotExist)\n      SET a += {num: 42}\n      RETURN a',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'a': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='SET clause semantics are not supported',
        tags=('set', 'xfail'),
    ),
    Scenario(
        key='set5-2',
        feature_path='tck/features/clauses/set/Set5.feature',
        scenario='[2] Overwrite values when using +=',
        cypher="MATCH (n:X {name: 'A'})\n      SET n += {name2: 'C'}\n      RETURN n",
        graph=graph_fixture_from_create(
            """
            CREATE (:X {name: 'A', name2: 'B'})
            """
        ),
        expected=Expected(
            rows=[
            {'n': "(:X {name: 'A', name2: 'C'})"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='SET clause semantics are not supported',
        tags=('set', 'xfail'),
    ),
    Scenario(
        key='set5-3',
        feature_path='tck/features/clauses/set/Set5.feature',
        scenario='[3] Retain old values when using +=',
        cypher="MATCH (n:X {name: 'A'})\n      SET n += {name2: 'B'}\n      RETURN n",
        graph=graph_fixture_from_create(
            """
            CREATE (:X {name: 'A'})
            """
        ),
        expected=Expected(
            rows=[
            {'n': "(:X {name: 'A', name2: 'B'})"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='SET clause semantics are not supported',
        tags=('set', 'xfail'),
    ),
    Scenario(
        key='set5-4',
        feature_path='tck/features/clauses/set/Set5.feature',
        scenario='[4] Explicit null values in a map remove old values',
        cypher="MATCH (n:X {name: 'A'})\n      SET n += {name: null}\n      RETURN n",
        graph=graph_fixture_from_create(
            """
            CREATE (:X {name: 'A', name2: 'B'})
            """
        ),
        expected=Expected(
            rows=[
            {'n': "(:X {name2: 'B'})"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='SET clause semantics are not supported',
        tags=('set', 'xfail'),
    ),
    Scenario(
        key='set5-5',
        feature_path='tck/features/clauses/set/Set5.feature',
        scenario='[5] Set an empty map when using += has no effect',
        cypher="MATCH (n:X {name: 'A'})\n      SET n += { }\n      RETURN n",
        graph=graph_fixture_from_create(
            """
            CREATE (:X {name: 'A', name2: 'B'})
            """
        ),
        expected=Expected(
            rows=[
            {'n': "(:X {name: 'A', name2: 'B'})"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='SET clause semantics are not supported',
        tags=('set', 'xfail'),
    ),
    Scenario(
        key='set6-1',
        feature_path='tck/features/clauses/set/Set6.feature',
        scenario='[1] Limiting to zero results after setting a property on nodes affects the result set but not the side effects',
        cypher='MATCH (n:N)\n      SET n.num = 43\n      RETURN n\n      LIMIT 0',
        graph=graph_fixture_from_create(
            """
            CREATE (:N {num: 42})
            """
        ),
        expected=Expected(
            rows=[

            ],
        ),
        gfql=None,
        status="xfail",
        reason='SET clause semantics are not supported',
        tags=('set', 'xfail'),
    ),
    Scenario(
        key='set6-2',
        feature_path='tck/features/clauses/set/Set6.feature',
        scenario='[2] Skipping all results after setting a property on nodes affects the result set but not the side effects',
        cypher='MATCH (n:N)\n      SET n.num = 43\n      RETURN n\n      SKIP 1',
        graph=graph_fixture_from_create(
            """
            CREATE (:N {num: 42})
            """
        ),
        expected=Expected(
            rows=[

            ],
        ),
        gfql=None,
        status="xfail",
        reason='SET clause semantics are not supported',
        tags=('set', 'xfail'),
    ),
    Scenario(
        key='set6-3',
        feature_path='tck/features/clauses/set/Set6.feature',
        scenario='[3] Skipping and limiting to a few results after setting a property on nodes affects the result set but not the side effects',
        cypher='MATCH (n:N)\n      SET n.num = 42\n      RETURN n.num AS num\n      SKIP 2 LIMIT 2',
        graph=graph_fixture_from_create(
            """
            CREATE (:N {num: 1})
                  CREATE (:N {num: 2})
                  CREATE (:N {num: 3})
                  CREATE (:N {num: 4})
                  CREATE (:N {num: 5})
            """
        ),
        expected=Expected(
            rows=[
            {'num': 42},
            {'num': 42}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='SET clause semantics are not supported',
        tags=('set', 'xfail'),
    ),
    Scenario(
        key='set6-4',
        feature_path='tck/features/clauses/set/Set6.feature',
        scenario='[4] Skipping zero results and limiting to all results after setting a property on nodes does not affect the result set nor the side effects',
        cypher='MATCH (n:N)\n      SET n.num = 42\n      RETURN n.num AS num\n      SKIP 0 LIMIT 5',
        graph=graph_fixture_from_create(
            """
            CREATE (:N {num: 1})
                  CREATE (:N {num: 2})
                  CREATE (:N {num: 3})
                  CREATE (:N {num: 4})
                  CREATE (:N {num: 5})
            """
        ),
        expected=Expected(
            rows=[
            {'num': 42},
            {'num': 42},
            {'num': 42},
            {'num': 42},
            {'num': 42}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='SET clause semantics are not supported',
        tags=('set', 'xfail'),
    ),
    Scenario(
        key='set6-5',
        feature_path='tck/features/clauses/set/Set6.feature',
        scenario='[5] Filtering after setting a property on nodes affects the result set but not the side effects',
        cypher='MATCH (n:N)\n      SET n.num = n.num + 1\n      WITH n\n      WHERE n.num % 2 = 0\n      RETURN n.num AS num',
        graph=graph_fixture_from_create(
            """
            CREATE (:N {num: 1})
                  CREATE (:N {num: 2})
                  CREATE (:N {num: 3})
                  CREATE (:N {num: 4})
                  CREATE (:N {num: 5})
            """
        ),
        expected=Expected(
            rows=[
            {'num': 2},
            {'num': 4},
            {'num': 6}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='SET clause semantics are not supported',
        tags=('set', 'xfail'),
    ),
    Scenario(
        key='set6-6',
        feature_path='tck/features/clauses/set/Set6.feature',
        scenario='[6] Aggregating in `RETURN` after setting a property on nodes affects the result set but not the side effects',
        cypher='MATCH (n:N)\n      SET n.num = n.num + 1\n      RETURN sum(n.num) AS sum',
        graph=graph_fixture_from_create(
            """
            CREATE (:N {num: 1})
                  CREATE (:N {num: 2})
                  CREATE (:N {num: 3})
                  CREATE (:N {num: 4})
                  CREATE (:N {num: 5})
            """
        ),
        expected=Expected(
            rows=[
            {'sum': 20}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='SET clause semantics are not supported',
        tags=('set', 'xfail'),
    ),
    Scenario(
        key='set6-7',
        feature_path='tck/features/clauses/set/Set6.feature',
        scenario='[7] Aggregating in `WITH` after setting a property on nodes affects the result set but not the side effects',
        cypher='MATCH (n:N)\n      SET n.num = n.num + 1\n      WITH sum(n.num) AS sum\n      RETURN sum',
        graph=graph_fixture_from_create(
            """
            CREATE (:N {num: 1})
                  CREATE (:N {num: 2})
                  CREATE (:N {num: 3})
                  CREATE (:N {num: 4})
                  CREATE (:N {num: 5})
            """
        ),
        expected=Expected(
            rows=[
            {'sum': 20}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='SET clause semantics are not supported',
        tags=('set', 'xfail'),
    ),
    Scenario(
        key='set6-8',
        feature_path='tck/features/clauses/set/Set6.feature',
        scenario='[8] Limiting to zero results after adding a label on nodes affects the result set but not the side effects',
        cypher='MATCH (n:N)\n      SET n:Foo\n      RETURN n\n      LIMIT 0',
        graph=graph_fixture_from_create(
            """
            CREATE (:N {num: 42})
            """
        ),
        expected=Expected(
            rows=[

            ],
        ),
        gfql=None,
        status="xfail",
        reason='SET clause semantics are not supported',
        tags=('set', 'xfail'),
    ),
    Scenario(
        key='set6-9',
        feature_path='tck/features/clauses/set/Set6.feature',
        scenario='[9] Skipping all results after adding a label on nodes affects the result set but not the side effects',
        cypher='MATCH (n:N)\n      SET n:Foo\n      RETURN n\n      SKIP 1',
        graph=graph_fixture_from_create(
            """
            CREATE (:N {num: 42})
            """
        ),
        expected=Expected(
            rows=[

            ],
        ),
        gfql=None,
        status="xfail",
        reason='SET clause semantics are not supported',
        tags=('set', 'xfail'),
    ),
    Scenario(
        key='set6-10',
        feature_path='tck/features/clauses/set/Set6.feature',
        scenario='[10] Skipping and limiting to a few results after adding a label on nodes affects the result set but not the side effects',
        cypher='MATCH (n:N)\n      SET n:Foo\n      RETURN n.num AS num\n      SKIP 2 LIMIT 2',
        graph=graph_fixture_from_create(
            """
            CREATE (:N {num: 42})
                  CREATE (:N {num: 42})
                  CREATE (:N {num: 42})
                  CREATE (:N {num: 42})
                  CREATE (:N {num: 42})
            """
        ),
        expected=Expected(
            rows=[
            {'num': 42},
            {'num': 42}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='SET clause semantics are not supported',
        tags=('set', 'xfail'),
    ),
    Scenario(
        key='set6-11',
        feature_path='tck/features/clauses/set/Set6.feature',
        scenario='[11] Skipping zero result and limiting to all results after adding a label on nodes does not affect the result set nor the side effects',
        cypher='MATCH (n:N)\n      SET n:Foo\n      RETURN n.num AS num\n      SKIP 0 LIMIT 5',
        graph=graph_fixture_from_create(
            """
            CREATE (:N {num: 42})
                  CREATE (:N {num: 42})
                  CREATE (:N {num: 42})
                  CREATE (:N {num: 42})
                  CREATE (:N {num: 42})
            """
        ),
        expected=Expected(
            rows=[
            {'num': 42},
            {'num': 42},
            {'num': 42},
            {'num': 42},
            {'num': 42}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='SET clause semantics are not supported',
        tags=('set', 'xfail'),
    ),
    Scenario(
        key='set6-12',
        feature_path='tck/features/clauses/set/Set6.feature',
        scenario='[12] Filtering after adding a label on nodes affects the result set but not the side effects',
        cypher='MATCH (n:N)\n      SET n:Foo\n      WITH n\n      WHERE n.num % 2 = 0\n      RETURN n.num AS num',
        graph=graph_fixture_from_create(
            """
            CREATE (:N {num: 1})
                  CREATE (:N {num: 2})
                  CREATE (:N {num: 3})
                  CREATE (:N {num: 4})
                  CREATE (:N {num: 5})
            """
        ),
        expected=Expected(
            rows=[
            {'num': 2},
            {'num': 4}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='SET clause semantics are not supported',
        tags=('set', 'xfail'),
    ),
    Scenario(
        key='set6-13',
        feature_path='tck/features/clauses/set/Set6.feature',
        scenario='[13] Aggregating in `RETURN` after adding a label on nodes affects the result set but not the side effects',
        cypher='MATCH (n:N)\n      SET n:Foo\n      RETURN sum(n.num) AS sum',
        graph=graph_fixture_from_create(
            """
            CREATE (:N {num: 1})
                  CREATE (:N {num: 2})
                  CREATE (:N {num: 3})
                  CREATE (:N {num: 4})
                  CREATE (:N {num: 5})
            """
        ),
        expected=Expected(
            rows=[
            {'sum': 15}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='SET clause semantics are not supported',
        tags=('set', 'xfail'),
    ),
    Scenario(
        key='set6-14',
        feature_path='tck/features/clauses/set/Set6.feature',
        scenario='[14] Aggregating in `WITH` after adding a label on nodes affects the result set but not the side effects',
        cypher='MATCH (n:N)\n      SET n:Foo\n      WITH sum(n.num) AS sum\n      RETURN sum',
        graph=graph_fixture_from_create(
            """
            CREATE (:N {num: 1})
                  CREATE (:N {num: 2})
                  CREATE (:N {num: 3})
                  CREATE (:N {num: 4})
                  CREATE (:N {num: 5})
            """
        ),
        expected=Expected(
            rows=[
            {'sum': 15}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='SET clause semantics are not supported',
        tags=('set', 'xfail'),
    ),
    Scenario(
        key='set6-15',
        feature_path='tck/features/clauses/set/Set6.feature',
        scenario='[15] Limiting to zero results after setting a property on relationships affects the result set but not the side effects',
        cypher='MATCH ()-[r:R]->()\n      SET r.num = 43\n      RETURN r\n      LIMIT 0',
        graph=graph_fixture_from_create(
            """
            CREATE ()-[r:R {num: 42}]->()
            """
        ),
        expected=Expected(
            rows=[

            ],
        ),
        gfql=None,
        status="xfail",
        reason='SET clause semantics are not supported',
        tags=('set', 'xfail'),
    ),
    Scenario(
        key='set6-16',
        feature_path='tck/features/clauses/set/Set6.feature',
        scenario='[16] Skipping all results after setting a property on relationships affects the result set but not the side effects',
        cypher='MATCH ()-[r:R]->()\n      SET r.num = 43\n      RETURN r\n      SKIP 1',
        graph=graph_fixture_from_create(
            """
            CREATE ()-[r:R {num: 42}]->()
            """
        ),
        expected=Expected(
            rows=[

            ],
        ),
        gfql=None,
        status="xfail",
        reason='SET clause semantics are not supported',
        tags=('set', 'xfail'),
    ),
    Scenario(
        key='set6-17',
        feature_path='tck/features/clauses/set/Set6.feature',
        scenario='[17] Skipping and limiting to a few results after setting a property on relationships affects the result set but not the side effects',
        cypher='MATCH ()-[r:R]->()\n      SET r.num = 42\n      RETURN r.num AS num\n      SKIP 2 LIMIT 2',
        graph=graph_fixture_from_create(
            """
            CREATE ()-[:R {num: 1}]->()
                  CREATE ()-[:R {num: 2}]->()
                  CREATE ()-[:R {num: 3}]->()
                  CREATE ()-[:R {num: 4}]->()
                  CREATE ()-[:R {num: 5}]->()
            """
        ),
        expected=Expected(
            rows=[
            {'num': 42},
            {'num': 42}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='SET clause semantics are not supported',
        tags=('set', 'xfail'),
    ),
    Scenario(
        key='set6-18',
        feature_path='tck/features/clauses/set/Set6.feature',
        scenario='[18] Skipping zero result and limiting to all results after setting a property on relationships does not affect the result set nor the side effects',
        cypher='MATCH ()-[r:R]->()\n      SET r.num = 42\n      RETURN r.num AS num\n      SKIP 0 LIMIT 5',
        graph=graph_fixture_from_create(
            """
            CREATE ()-[:R {num: 1}]->()
                  CREATE ()-[:R {num: 2}]->()
                  CREATE ()-[:R {num: 3}]->()
                  CREATE ()-[:R {num: 4}]->()
                  CREATE ()-[:R {num: 5}]->()
            """
        ),
        expected=Expected(
            rows=[
            {'num': 42},
            {'num': 42},
            {'num': 42},
            {'num': 42},
            {'num': 42}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='SET clause semantics are not supported',
        tags=('set', 'xfail'),
    ),
    Scenario(
        key='set6-19',
        feature_path='tck/features/clauses/set/Set6.feature',
        scenario='[19] Filtering after setting a property on relationships affects the result set but not the side effects',
        cypher='MATCH ()-[r:R]->()\n      SET r.num = r.num + 1\n      WITH r\n      WHERE r.num % 2 = 0\n      RETURN r.num AS num',
        graph=graph_fixture_from_create(
            """
            CREATE ()-[:R {num: 1}]->()
                  CREATE ()-[:R {num: 2}]->()
                  CREATE ()-[:R {num: 3}]->()
                  CREATE ()-[:R {num: 4}]->()
                  CREATE ()-[:R {num: 5}]->()
            """
        ),
        expected=Expected(
            rows=[
            {'num': 2},
            {'num': 4},
            {'num': 6}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='SET clause semantics are not supported',
        tags=('set', 'xfail'),
    ),
    Scenario(
        key='set6-20',
        feature_path='tck/features/clauses/set/Set6.feature',
        scenario='[20] Aggregating in `RETURN` after setting a property on relationships affects the result set but not the side effects',
        cypher='MATCH ()-[r:R]->()\n      SET r.num = r.num + 1\n      RETURN sum(r.num) AS sum',
        graph=graph_fixture_from_create(
            """
            CREATE ()-[:R {num: 1}]->()
                  CREATE ()-[:R {num: 2}]->()
                  CREATE ()-[:R {num: 3}]->()
                  CREATE ()-[:R {num: 4}]->()
                  CREATE ()-[:R {num: 5}]->()
            """
        ),
        expected=Expected(
            rows=[
            {'sum': 20}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='SET clause semantics are not supported',
        tags=('set', 'xfail'),
    ),
    Scenario(
        key='set6-21',
        feature_path='tck/features/clauses/set/Set6.feature',
        scenario='[21] Aggregating in `WITH` after setting a property on relationships affects the result set but not the side effects',
        cypher='MATCH ()-[r:R]->()\n      SET r.num = r.num + 1\n      WITH sum(r.num) AS sum\n      RETURN sum',
        graph=graph_fixture_from_create(
            """
            CREATE ()-[:R {num: 1}]->()
                  CREATE ()-[:R {num: 2}]->()
                  CREATE ()-[:R {num: 3}]->()
                  CREATE ()-[:R {num: 4}]->()
                  CREATE ()-[:R {num: 5}]->()
            """
        ),
        expected=Expected(
            rows=[
            {'sum': 20}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='SET clause semantics are not supported',
        tags=('set', 'xfail'),
    ),
    Scenario(
        key='remove1-1',
        feature_path='tck/features/clauses/remove/Remove1.feature',
        scenario='[1] Remove a single node property',
        cypher='MATCH (n)\n      REMOVE n.num\n      RETURN n.num IS NOT NULL AS still_there',
        graph=graph_fixture_from_create(
            """
            CREATE (:L {num: 42})
            """
        ),
        expected=Expected(
            rows=[
            {'still_there': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='REMOVE clause semantics are not supported',
        tags=('remove', 'xfail'),
    ),
    Scenario(
        key='remove1-2',
        feature_path='tck/features/clauses/remove/Remove1.feature',
        scenario='[2] Remove multiple node properties',
        cypher='MATCH (n)\n      REMOVE n.num, n.name\n      RETURN size(keys(n)) AS props',
        graph=graph_fixture_from_create(
            """
            CREATE (:L {num: 42, name: 'a', name2: 'B'})
            """
        ),
        expected=Expected(
            rows=[
            {'props': 1}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='REMOVE clause semantics are not supported',
        tags=('remove', 'xfail'),
    ),
    Scenario(
        key='remove1-3',
        feature_path='tck/features/clauses/remove/Remove1.feature',
        scenario='[3] Remove a single relationship property',
        cypher='MATCH ()-[r]->()\n      REMOVE r.num\n      RETURN r.num IS NOT NULL AS still_there',
        graph=graph_fixture_from_create(
            """
            CREATE (a), (b), (a)-[:X {num: 42}]->(b)
            """
        ),
        expected=Expected(
            rows=[
            {'still_there': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='REMOVE clause semantics are not supported',
        tags=('remove', 'xfail'),
    ),
    Scenario(
        key='remove1-4',
        feature_path='tck/features/clauses/remove/Remove1.feature',
        scenario='[4] Remove multiple relationship properties',
        cypher='MATCH ()-[r]->()\n      REMOVE r.num, r.a\n      RETURN size(keys(r)) AS props',
        graph=graph_fixture_from_create(
            """
            CREATE (a), (b), (a)-[:X {num: 42, a: 'a', b: 'B'}]->(b)
            """
        ),
        expected=Expected(
            rows=[
            {'props': 1}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='REMOVE clause semantics are not supported',
        tags=('remove', 'xfail'),
    ),
    Scenario(
        key='remove1-5',
        feature_path='tck/features/clauses/remove/Remove1.feature',
        scenario='[5] Ignore null when removing property from a node',
        cypher='OPTIONAL MATCH (a:DoesNotExist)\n      REMOVE a.num\n      RETURN a',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'a': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='REMOVE clause semantics are not supported',
        tags=('remove', 'xfail'),
    ),
    Scenario(
        key='remove1-6',
        feature_path='tck/features/clauses/remove/Remove1.feature',
        scenario='[6] Ignore null when removing property from a relationship',
        cypher='MATCH (n)\n      OPTIONAL MATCH (n)-[r]->()\n      REMOVE r.num\n      RETURN n',
        graph=graph_fixture_from_create(
            """
            CREATE ({num: 42})
            """
        ),
        expected=Expected(
            rows=[
            {'n': '({num: 42})'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='REMOVE clause semantics are not supported',
        tags=('remove', 'xfail'),
    ),
    Scenario(
        key='remove1-7',
        feature_path='tck/features/clauses/remove/Remove1.feature',
        scenario='[7] Remove a missing node property',
        cypher='MATCH (n)\n      REMOVE n.num\n      RETURN sum(size(keys(n))) AS totalNumberOfProps',
        graph=graph_fixture_from_create(
            """
            CREATE (), (), ()
            """
        ),
        expected=Expected(
            rows=[
            {'totalNumberOfProps': 0}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='REMOVE clause semantics are not supported',
        tags=('remove', 'xfail'),
    ),
    Scenario(
        key='remove2-1',
        feature_path='tck/features/clauses/remove/Remove2.feature',
        scenario='[1] Remove a single label from a node with a single label',
        cypher='MATCH (n)\n      REMOVE n:L\n      RETURN n.num',
        graph=graph_fixture_from_create(
            """
            CREATE (:L {num: 42})
            """
        ),
        expected=Expected(
            rows=[
            {'n.num': 42}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='REMOVE clause semantics are not supported',
        tags=('remove', 'xfail'),
    ),
    Scenario(
        key='remove2-2',
        feature_path='tck/features/clauses/remove/Remove2.feature',
        scenario='[2] Remove a single label from a node with two labels',
        cypher='MATCH (n)\n      REMOVE n:Foo\n      RETURN labels(n)',
        graph=graph_fixture_from_create(
            """
            CREATE (:Foo:Bar)
            """
        ),
        expected=Expected(
            rows=[
            {'labels(n)': "['Bar']"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='REMOVE clause semantics are not supported',
        tags=('remove', 'xfail'),
    ),
    Scenario(
        key='remove2-3',
        feature_path='tck/features/clauses/remove/Remove2.feature',
        scenario='[3] Remove two labels from a node with three labels',
        cypher='MATCH (n)\n      REMOVE n:L1:L3\n      RETURN labels(n)',
        graph=graph_fixture_from_create(
            """
            CREATE (:L1:L2:L3 {num: 42})
            """
        ),
        expected=Expected(
            rows=[
            {'labels(n)': "['L2']"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='REMOVE clause semantics are not supported',
        tags=('remove', 'xfail'),
    ),
    Scenario(
        key='remove2-4',
        feature_path='tck/features/clauses/remove/Remove2.feature',
        scenario='[4] Remove a non-existent node label',
        cypher='MATCH (n)\n      REMOVE n:Bar\n      RETURN labels(n)',
        graph=graph_fixture_from_create(
            """
            CREATE (:Foo)
            """
        ),
        expected=Expected(
            rows=[
            {'labels(n)': "['Foo']"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='REMOVE clause semantics are not supported',
        tags=('remove', 'xfail'),
    ),
    Scenario(
        key='remove2-5',
        feature_path='tck/features/clauses/remove/Remove2.feature',
        scenario='[5] Ignore null when removing a node label',
        cypher='OPTIONAL MATCH (a:DoesNotExist)\n      REMOVE a:L\n      RETURN a',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'a': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='REMOVE clause semantics are not supported',
        tags=('remove', 'xfail'),
    ),
    Scenario(
        key='remove3-1',
        feature_path='tck/features/clauses/remove/Remove3.feature',
        scenario='[1] Limiting to zero results after removing a property from nodes affects the result set but not the side effects',
        cypher='MATCH (n:N)\n      REMOVE n.num\n      RETURN n\n      LIMIT 0',
        graph=graph_fixture_from_create(
            """
            CREATE (:N {num: 42})
            """
        ),
        expected=Expected(
            rows=[

            ],
        ),
        gfql=None,
        status="xfail",
        reason='REMOVE clause semantics are not supported',
        tags=('remove', 'xfail'),
    ),
    Scenario(
        key='remove3-2',
        feature_path='tck/features/clauses/remove/Remove3.feature',
        scenario='[2] Skipping all results after removing a property from nodes affects the result set but not the side effects',
        cypher='MATCH (n:N)\n      REMOVE n.num\n      RETURN n\n      SKIP 1',
        graph=graph_fixture_from_create(
            """
            CREATE (:N {num: 42})
            """
        ),
        expected=Expected(
            rows=[

            ],
        ),
        gfql=None,
        status="xfail",
        reason='REMOVE clause semantics are not supported',
        tags=('remove', 'xfail'),
    ),
    Scenario(
        key='remove3-3',
        feature_path='tck/features/clauses/remove/Remove3.feature',
        scenario='[3] Skipping and limiting to a few results after removing a property from nodes affects the result set but not the side effects',
        cypher='MATCH (n:N)\n      REMOVE n.name\n      RETURN n.num AS num\n      SKIP 2 LIMIT 2',
        graph=graph_fixture_from_create(
            """
            CREATE (:N {name: 'a', num: 42})
                  CREATE (:N {name: 'a', num: 42})
                  CREATE (:N {name: 'a', num: 42})
                  CREATE (:N {name: 'a', num: 42})
                  CREATE (:N {name: 'a', num: 42})
            """
        ),
        expected=Expected(
            rows=[
            {'num': 42},
            {'num': 42}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='REMOVE clause semantics are not supported',
        tags=('remove', 'xfail'),
    ),
    Scenario(
        key='remove3-4',
        feature_path='tck/features/clauses/remove/Remove3.feature',
        scenario='[4] Skipping zero results and limiting to all results after removing a property from nodes does not affect the result set nor the side effects',
        cypher='MATCH (n:N)\n      REMOVE n.name\n      RETURN n.num AS num\n      SKIP 0 LIMIT 5',
        graph=graph_fixture_from_create(
            """
            CREATE (:N {name: 'a', num: 42})
                  CREATE (:N {name: 'a', num: 42})
                  CREATE (:N {name: 'a', num: 42})
                  CREATE (:N {name: 'a', num: 42})
                  CREATE (:N {name: 'a', num: 42})
            """
        ),
        expected=Expected(
            rows=[
            {'num': 42},
            {'num': 42},
            {'num': 42},
            {'num': 42},
            {'num': 42}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='REMOVE clause semantics are not supported',
        tags=('remove', 'xfail'),
    ),
    Scenario(
        key='remove3-5',
        feature_path='tck/features/clauses/remove/Remove3.feature',
        scenario='[5] Filtering after removing a property from nodes affects the result set but not the side effects',
        cypher='MATCH (n:N)\n      REMOVE n.name\n      WITH n\n      WHERE n.num % 2 = 0\n      RETURN n.num AS num',
        graph=graph_fixture_from_create(
            """
            CREATE (:N {name: 'a', num: 1})
                  CREATE (:N {name: 'a', num: 2})
                  CREATE (:N {name: 'a', num: 3})
                  CREATE (:N {name: 'a', num: 4})
                  CREATE (:N {name: 'a', num: 5})
            """
        ),
        expected=Expected(
            rows=[
            {'num': 2},
            {'num': 4}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='REMOVE clause semantics are not supported',
        tags=('remove', 'xfail'),
    ),
    Scenario(
        key='remove3-6',
        feature_path='tck/features/clauses/remove/Remove3.feature',
        scenario='[6] Aggregating in `RETURN` after removing a property from nodes affects the result set but not the side effects',
        cypher='MATCH (n:N)\n      REMOVE n.name\n      RETURN sum(n.num) AS sum',
        graph=graph_fixture_from_create(
            """
            CREATE (:N {name: 'a', num: 1})
                  CREATE (:N {name: 'a', num: 2})
                  CREATE (:N {name: 'a', num: 3})
                  CREATE (:N {name: 'a', num: 4})
                  CREATE (:N {name: 'a', num: 5})
            """
        ),
        expected=Expected(
            rows=[
            {'sum': 15}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='REMOVE clause semantics are not supported',
        tags=('remove', 'xfail'),
    ),
    Scenario(
        key='remove3-7',
        feature_path='tck/features/clauses/remove/Remove3.feature',
        scenario='[7] Aggregating in `WITH` after removing a property from nodes affects the result set but not the side effects',
        cypher='MATCH (n:N)\n      REMOVE n.name\n      WITH sum(n.num) AS sum\n      RETURN sum',
        graph=graph_fixture_from_create(
            """
            CREATE (:N {name: 'a', num: 1})
                  CREATE (:N {name: 'a', num: 2})
                  CREATE (:N {name: 'a', num: 3})
                  CREATE (:N {name: 'a', num: 4})
                  CREATE (:N {name: 'a', num: 5})
            """
        ),
        expected=Expected(
            rows=[
            {'sum': 15}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='REMOVE clause semantics are not supported',
        tags=('remove', 'xfail'),
    ),
    Scenario(
        key='remove3-8',
        feature_path='tck/features/clauses/remove/Remove3.feature',
        scenario='[8] Limiting to zero results after removing a label from nodes affects the result set but not the side effects',
        cypher='MATCH (n:N)\n      REMOVE n:N\n      RETURN n\n      LIMIT 0',
        graph=graph_fixture_from_create(
            """
            CREATE (:N {num: 42})
            """
        ),
        expected=Expected(
            rows=[

            ],
        ),
        gfql=None,
        status="xfail",
        reason='REMOVE clause semantics are not supported',
        tags=('remove', 'xfail'),
    ),
    Scenario(
        key='remove3-9',
        feature_path='tck/features/clauses/remove/Remove3.feature',
        scenario='[9] Skipping all results after removing a label from nodes affects the result set but not the side effects',
        cypher='MATCH (n:N)\n      REMOVE n:N\n      RETURN n\n      SKIP 1',
        graph=graph_fixture_from_create(
            """
            CREATE (:N {num: 42})
            """
        ),
        expected=Expected(
            rows=[

            ],
        ),
        gfql=None,
        status="xfail",
        reason='REMOVE clause semantics are not supported',
        tags=('remove', 'xfail'),
    ),
    Scenario(
        key='remove3-10',
        feature_path='tck/features/clauses/remove/Remove3.feature',
        scenario='[10] Skipping and limiting to a few results after removing a label from nodes affects the result set but not the side effects',
        cypher='MATCH (n:N)\n      REMOVE n:N\n      RETURN n.num AS num\n      SKIP 2 LIMIT 2',
        graph=graph_fixture_from_create(
            """
            CREATE (:N {num: 42})
                  CREATE (:N {num: 42})
                  CREATE (:N {num: 42})
                  CREATE (:N {num: 42})
                  CREATE (:N {num: 42})
            """
        ),
        expected=Expected(
            rows=[
            {'num': 42},
            {'num': 42}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='REMOVE clause semantics are not supported',
        tags=('remove', 'xfail'),
    ),
    Scenario(
        key='remove3-11',
        feature_path='tck/features/clauses/remove/Remove3.feature',
        scenario='[11] Skipping zero result and limiting to all results after removing a label from nodes does not affect the result set nor the side effects',
        cypher='MATCH (n:N)\n      REMOVE n:N\n      RETURN n.num AS num\n      SKIP 0 LIMIT 5',
        graph=graph_fixture_from_create(
            """
            CREATE (:N {num: 42})
                  CREATE (:N {num: 42})
                  CREATE (:N {num: 42})
                  CREATE (:N {num: 42})
                  CREATE (:N {num: 42})
            """
        ),
        expected=Expected(
            rows=[
            {'num': 42},
            {'num': 42},
            {'num': 42},
            {'num': 42},
            {'num': 42}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='REMOVE clause semantics are not supported',
        tags=('remove', 'xfail'),
    ),
    Scenario(
        key='remove3-12',
        feature_path='tck/features/clauses/remove/Remove3.feature',
        scenario='[12] Filtering after removing a label from nodes affects the result set but not the side effects',
        cypher='MATCH (n:N)\n      REMOVE n:N\n      WITH n\n      WHERE n.num % 2 = 0\n      RETURN n.num AS num',
        graph=graph_fixture_from_create(
            """
            CREATE (:N {num: 1})
                  CREATE (:N {num: 2})
                  CREATE (:N {num: 3})
                  CREATE (:N {num: 4})
                  CREATE (:N {num: 5})
            """
        ),
        expected=Expected(
            rows=[
            {'num': 2},
            {'num': 4}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='REMOVE clause semantics are not supported',
        tags=('remove', 'xfail'),
    ),
    Scenario(
        key='remove3-13',
        feature_path='tck/features/clauses/remove/Remove3.feature',
        scenario='[13] Aggregating in `RETURN` after removing a label from nodes affects the result set but not the side effects',
        cypher='MATCH (n:N)\n      REMOVE n:N\n      RETURN sum(n.num) AS sum',
        graph=graph_fixture_from_create(
            """
            CREATE (:N {num: 1})
                  CREATE (:N {num: 2})
                  CREATE (:N {num: 3})
                  CREATE (:N {num: 4})
                  CREATE (:N {num: 5})
            """
        ),
        expected=Expected(
            rows=[
            {'sum': 15}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='REMOVE clause semantics are not supported',
        tags=('remove', 'xfail'),
    ),
    Scenario(
        key='remove3-14',
        feature_path='tck/features/clauses/remove/Remove3.feature',
        scenario='[14] Aggregating in `WITH` after removing a label from nodes affects the result set but not the side effects',
        cypher='MATCH (n:N)\n      REMOVE n:N\n      WITH sum(n.num) AS sum\n      RETURN sum',
        graph=graph_fixture_from_create(
            """
            CREATE (:N {num: 1})
                  CREATE (:N {num: 2})
                  CREATE (:N {num: 3})
                  CREATE (:N {num: 4})
                  CREATE (:N {num: 5})
            """
        ),
        expected=Expected(
            rows=[
            {'sum': 15}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='REMOVE clause semantics are not supported',
        tags=('remove', 'xfail'),
    ),
    Scenario(
        key='remove3-15',
        feature_path='tck/features/clauses/remove/Remove3.feature',
        scenario='[15] Limiting to zero results after removing a property from relationships affects the result set but not the side effects',
        cypher='MATCH ()-[r:R]->()\n      REMOVE r.num\n      RETURN r\n      LIMIT 0',
        graph=graph_fixture_from_create(
            """
            CREATE ()-[r:R {num: 42}]->()
            """
        ),
        expected=Expected(
            rows=[

            ],
        ),
        gfql=None,
        status="xfail",
        reason='REMOVE clause semantics are not supported',
        tags=('remove', 'xfail'),
    ),
    Scenario(
        key='remove3-16',
        feature_path='tck/features/clauses/remove/Remove3.feature',
        scenario='[16] Skipping all results after removing a property from relationships affects the result set but not the side effects',
        cypher='MATCH ()-[r:R]->()\n      REMOVE r.num\n      RETURN r\n      SKIP 1',
        graph=graph_fixture_from_create(
            """
            CREATE ()-[r:R {num: 42}]->()
            """
        ),
        expected=Expected(
            rows=[

            ],
        ),
        gfql=None,
        status="xfail",
        reason='REMOVE clause semantics are not supported',
        tags=('remove', 'xfail'),
    ),
    Scenario(
        key='remove3-17',
        feature_path='tck/features/clauses/remove/Remove3.feature',
        scenario='[17] Skipping and limiting to a few results after removing a property from relationships affects the result set but not the side effects',
        cypher='MATCH ()-[r:R]->()\n      REMOVE r.name\n      RETURN r.num AS num\n      SKIP 2 LIMIT 2',
        graph=graph_fixture_from_create(
            """
            CREATE ()-[:R {name: 'a', num: 42}]->()
                  CREATE ()-[:R {name: 'a', num: 42}]->()
                  CREATE ()-[:R {name: 'a', num: 42}]->()
                  CREATE ()-[:R {name: 'a', num: 42}]->()
                  CREATE ()-[:R {name: 'a', num: 42}]->()
            """
        ),
        expected=Expected(
            rows=[
            {'num': 42},
            {'num': 42}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='REMOVE clause semantics are not supported',
        tags=('remove', 'xfail'),
    ),
    Scenario(
        key='remove3-18',
        feature_path='tck/features/clauses/remove/Remove3.feature',
        scenario='[18] Skipping zero result and limiting to all results after removing a property from relationships does not affect the result set nor the side effects',
        cypher='MATCH ()-[r:R]->()\n      REMOVE r.name\n      RETURN r.num AS num\n      SKIP 0 LIMIT 5',
        graph=graph_fixture_from_create(
            """
            CREATE ()-[:R {name: 'a', num: 42}]->()
                  CREATE ()-[:R {name: 'a', num: 42}]->()
                  CREATE ()-[:R {name: 'a', num: 42}]->()
                  CREATE ()-[:R {name: 'a', num: 42}]->()
                  CREATE ()-[:R {name: 'a', num: 42}]->()
            """
        ),
        expected=Expected(
            rows=[
            {'num': 42},
            {'num': 42},
            {'num': 42},
            {'num': 42},
            {'num': 42}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='REMOVE clause semantics are not supported',
        tags=('remove', 'xfail'),
    ),
    Scenario(
        key='remove3-19',
        feature_path='tck/features/clauses/remove/Remove3.feature',
        scenario='[19] Filtering after removing a property from relationships affects the result set but not the side effects',
        cypher='MATCH ()-[r:R]->()\n      REMOVE r.name\n      WITH r\n      WHERE r.num % 2 = 0\n      RETURN r.num AS num',
        graph=graph_fixture_from_create(
            """
            CREATE ()-[:R {name: 'a', num: 1}]->()
                  CREATE ()-[:R {name: 'a', num: 2}]->()
                  CREATE ()-[:R {name: 'a', num: 3}]->()
                  CREATE ()-[:R {name: 'a', num: 4}]->()
                  CREATE ()-[:R {name: 'a', num: 5}]->()
            """
        ),
        expected=Expected(
            rows=[
            {'num': 2},
            {'num': 4}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='REMOVE clause semantics are not supported',
        tags=('remove', 'xfail'),
    ),
    Scenario(
        key='remove3-20',
        feature_path='tck/features/clauses/remove/Remove3.feature',
        scenario='[20] Aggregating in `RETURN` after removing a property from relationships affects the result set but not the side effects',
        cypher='MATCH ()-[r:R]->()\n      REMOVE r.name\n      RETURN sum(r.num) AS sum',
        graph=graph_fixture_from_create(
            """
            CREATE ()-[:R {name: 'a', num: 1}]->()
                  CREATE ()-[:R {name: 'a', num: 2}]->()
                  CREATE ()-[:R {name: 'a', num: 3}]->()
                  CREATE ()-[:R {name: 'a', num: 4}]->()
                  CREATE ()-[:R {name: 'a', num: 5}]->()
            """
        ),
        expected=Expected(
            rows=[
            {'sum': 15}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='REMOVE clause semantics are not supported',
        tags=('remove', 'xfail'),
    ),
    Scenario(
        key='remove3-21',
        feature_path='tck/features/clauses/remove/Remove3.feature',
        scenario='[21] Aggregating in `WITH` after removing a property from relationships affects the result set but not the side effects',
        cypher='MATCH ()-[r:R]->()\n      REMOVE r.name\n      WITH sum(r.num) AS sum\n      RETURN sum',
        graph=graph_fixture_from_create(
            """
            CREATE ()-[:R {name: 'a', num: 1}]->()
                  CREATE ()-[:R {name: 'a', num: 2}]->()
                  CREATE ()-[:R {name: 'a', num: 3}]->()
                  CREATE ()-[:R {name: 'a', num: 4}]->()
                  CREATE ()-[:R {name: 'a', num: 5}]->()
            """
        ),
        expected=Expected(
            rows=[
            {'sum': 15}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='REMOVE clause semantics are not supported',
        tags=('remove', 'xfail'),
    ),

    Scenario(
        key='expr-aggregation1-1',
        feature_path='tck/features/expressions/aggregation/Aggregation1.feature',
        scenario='[1] Count only non-null values',
        cypher='MATCH (n)\n      RETURN n.name, count(n.num)',
        graph=graph_fixture_from_create(
            """
            CREATE ({name: 'a', num: 33})
                  CREATE ({name: 'a'})
                  CREATE ({name: 'b', num: 42})
            """
        ),
        expected=Expected(
            rows=[
            {'n.name': "'a'", 'count(n.num)': 1},
            {'n.name': "'b'", 'count(n.num)': 1}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'aggregation', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-aggregation1-2',
        feature_path='tck/features/expressions/aggregation/Aggregation1.feature',
        scenario='[2] Counting loop relationships',
        cypher='MATCH ()-[r]-()\n      RETURN count(r)',
        graph=graph_fixture_from_create(
            """
            CREATE (a), (a)-[:R]->(a)
            """
        ),
        expected=Expected(
            rows=[
            {'count(r)': 1}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'aggregation', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-aggregation2-1',
        feature_path='tck/features/expressions/aggregation/Aggregation2.feature',
        scenario='[1] `max()` over integers',
        cypher='UNWIND [1, 2, 0, null, -1] AS x\n      RETURN max(x)',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'max(x)': 2}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'aggregation', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-aggregation2-2',
        feature_path='tck/features/expressions/aggregation/Aggregation2.feature',
        scenario='[2] `min()` over integers',
        cypher='UNWIND [1, 2, 0, null, -1] AS x\n      RETURN min(x)',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'min(x)': -1}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'aggregation', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-aggregation2-3',
        feature_path='tck/features/expressions/aggregation/Aggregation2.feature',
        scenario='[3] `max()` over floats',
        cypher='UNWIND [1.0, 2.0, 0.5, null] AS x\n      RETURN max(x)',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'max(x)': 2.0}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'aggregation', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-aggregation2-4',
        feature_path='tck/features/expressions/aggregation/Aggregation2.feature',
        scenario='[4] `min()` over floats',
        cypher='UNWIND [1.0, 2.0, 0.5, null] AS x\n      RETURN min(x)',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'min(x)': 0.5}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'aggregation', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-aggregation2-5',
        feature_path='tck/features/expressions/aggregation/Aggregation2.feature',
        scenario='[5] `max()` over mixed numeric values',
        cypher='UNWIND [1, 2.0, 5, null, 3.2, 0.1] AS x\n      RETURN max(x)',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'max(x)': 5}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'aggregation', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-aggregation2-6',
        feature_path='tck/features/expressions/aggregation/Aggregation2.feature',
        scenario='[6] `min()` over mixed numeric values',
        cypher='UNWIND [1, 2.0, 5, null, 3.2, 0.1] AS x\n      RETURN min(x)',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'min(x)': 0.1}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'aggregation', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-aggregation2-7',
        feature_path='tck/features/expressions/aggregation/Aggregation2.feature',
        scenario='[7] `max()` over strings',
        cypher="UNWIND ['a', 'b', 'B', null, 'abc', 'abc1'] AS i\n      RETURN max(i)",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'max(i)': "'b'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'aggregation', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-aggregation2-8',
        feature_path='tck/features/expressions/aggregation/Aggregation2.feature',
        scenario='[8] `min()` over strings',
        cypher="UNWIND ['a', 'b', 'B', null, 'abc', 'abc1'] AS i\n      RETURN min(i)",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'min(i)': "'B'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'aggregation', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-aggregation2-9',
        feature_path='tck/features/expressions/aggregation/Aggregation2.feature',
        scenario='[9] `max()` over list values',
        cypher='UNWIND [[1], [2], [2, 1]] AS x\n      RETURN max(x)',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'max(x)': '[2, 1]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'aggregation', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-aggregation2-10',
        feature_path='tck/features/expressions/aggregation/Aggregation2.feature',
        scenario='[10] `min()` over list values',
        cypher='UNWIND [[1], [2], [2, 1]] AS x\n      RETURN min(x)',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'min(x)': '[1]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'aggregation', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-aggregation2-11',
        feature_path='tck/features/expressions/aggregation/Aggregation2.feature',
        scenario='[11] `max()` over mixed values',
        cypher="UNWIND [1, 'a', null, [1, 2], 0.2, 'b'] AS x\n      RETURN max(x)",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'max(x)': 1}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'aggregation', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-aggregation2-12',
        feature_path='tck/features/expressions/aggregation/Aggregation2.feature',
        scenario='[12] `min()` over mixed values',
        cypher="UNWIND [1, 'a', null, [1, 2], 0.2, 'b'] AS x\n      RETURN min(x)",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'min(x)': '[1, 2]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'aggregation', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-aggregation3-1',
        feature_path='tck/features/expressions/aggregation/Aggregation3.feature',
        scenario='[1] Sum only non-null values',
        cypher='MATCH (n)\n      RETURN n.name, sum(n.num)',
        graph=graph_fixture_from_create(
            """
            CREATE ({name: 'a', num: 33})
                  CREATE ({name: 'a'})
                  CREATE ({name: 'a', num: 42})
            """
        ),
        expected=Expected(
            rows=[
            {'n.name': "'a'", 'sum(n.num)': 75}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'aggregation', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-aggregation3-2',
        feature_path='tck/features/expressions/aggregation/Aggregation3.feature',
        scenario='[2] No overflow during summation',
        cypher='UNWIND range(1000000, 2000000) AS i\n      WITH i\n      LIMIT 3000\n      RETURN sum(i)',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'sum(i)': 3004498500}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'aggregation', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-aggregation5-1',
        feature_path='tck/features/expressions/aggregation/Aggregation5.feature',
        scenario='[1] `collect()` filtering nulls',
        cypher='MATCH (n)\n      OPTIONAL MATCH (n)-[:NOT_EXIST]->(x)\n      RETURN n, collect(x)',
        graph=graph_fixture_from_create(
            """
            CREATE ()
            """
        ),
        expected=Expected(
            rows=[
            {'n': '()', 'collect(x)': '[]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'aggregation', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-aggregation5-2',
        feature_path='tck/features/expressions/aggregation/Aggregation5.feature',
        scenario='[2] OPTIONAL MATCH and `collect()` on node property',
        cypher='OPTIONAL MATCH (f:DoesExist)\n      OPTIONAL MATCH (n:DoesNotExist)\n      RETURN collect(DISTINCT n.num) AS a, collect(DISTINCT f.num) AS b',
        graph=graph_fixture_from_create(
            """
            CREATE (:DoesExist {num: 42})
                  CREATE (:DoesExist {num: 43})
                  CREATE (:DoesExist {num: 44})
            """
        ),
        expected=Expected(
            rows=[
            {'a': '[]', 'b': '[42, 43, 44]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'aggregation', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-aggregation6-1-1',
        feature_path='tck/features/expressions/aggregation/Aggregation6.feature',
        scenario='[1] `percentileDisc()` (example 1)',
        cypher='MATCH (n)\n      RETURN percentileDisc(n.price, $percentile) AS p',
        graph=graph_fixture_from_create(
            """
            CREATE ({price: 10.0}),
                         ({price: 20.0}),
                         ({price: 30.0})
            """
        ),
        expected=Expected(
            rows=[
            {'p': 10.0}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Parameter binding is not supported',
        tags=('expr', 'aggregation', 'meta-xfail', 'params', 'xfail'),
    ),
    Scenario(
        key='expr-aggregation6-1-2',
        feature_path='tck/features/expressions/aggregation/Aggregation6.feature',
        scenario='[1] `percentileDisc()` (example 2)',
        cypher='MATCH (n)\n      RETURN percentileDisc(n.price, $percentile) AS p',
        graph=graph_fixture_from_create(
            """
            CREATE ({price: 10.0}),
                         ({price: 20.0}),
                         ({price: 30.0})
            """
        ),
        expected=Expected(
            rows=[
            {'p': 20.0}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Parameter binding is not supported',
        tags=('expr', 'aggregation', 'meta-xfail', 'params', 'xfail'),
    ),
    Scenario(
        key='expr-aggregation6-1-3',
        feature_path='tck/features/expressions/aggregation/Aggregation6.feature',
        scenario='[1] `percentileDisc()` (example 3)',
        cypher='MATCH (n)\n      RETURN percentileDisc(n.price, $percentile) AS p',
        graph=graph_fixture_from_create(
            """
            CREATE ({price: 10.0}),
                         ({price: 20.0}),
                         ({price: 30.0})
            """
        ),
        expected=Expected(
            rows=[
            {'p': 30.0}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Parameter binding is not supported',
        tags=('expr', 'aggregation', 'meta-xfail', 'params', 'xfail'),
    ),
    Scenario(
        key='expr-aggregation6-2-1',
        feature_path='tck/features/expressions/aggregation/Aggregation6.feature',
        scenario='[2] `percentileCont()` (example 1)',
        cypher='MATCH (n)\n      RETURN percentileCont(n.price, $percentile) AS p',
        graph=graph_fixture_from_create(
            """
            CREATE ({price: 10.0}),
                         ({price: 20.0}),
                         ({price: 30.0})
            """
        ),
        expected=Expected(
            rows=[
            {'p': 10.0}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Parameter binding is not supported',
        tags=('expr', 'aggregation', 'meta-xfail', 'params', 'xfail'),
    ),
    Scenario(
        key='expr-aggregation6-2-2',
        feature_path='tck/features/expressions/aggregation/Aggregation6.feature',
        scenario='[2] `percentileCont()` (example 2)',
        cypher='MATCH (n)\n      RETURN percentileCont(n.price, $percentile) AS p',
        graph=graph_fixture_from_create(
            """
            CREATE ({price: 10.0}),
                         ({price: 20.0}),
                         ({price: 30.0})
            """
        ),
        expected=Expected(
            rows=[
            {'p': 20.0}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Parameter binding is not supported',
        tags=('expr', 'aggregation', 'meta-xfail', 'params', 'xfail'),
    ),
    Scenario(
        key='expr-aggregation6-2-3',
        feature_path='tck/features/expressions/aggregation/Aggregation6.feature',
        scenario='[2] `percentileCont()` (example 3)',
        cypher='MATCH (n)\n      RETURN percentileCont(n.price, $percentile) AS p',
        graph=graph_fixture_from_create(
            """
            CREATE ({price: 10.0}),
                         ({price: 20.0}),
                         ({price: 30.0})
            """
        ),
        expected=Expected(
            rows=[
            {'p': 30.0}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Parameter binding is not supported',
        tags=('expr', 'aggregation', 'meta-xfail', 'params', 'xfail'),
    ),
    Scenario(
        key='expr-aggregation6-3-1',
        feature_path='tck/features/expressions/aggregation/Aggregation6.feature',
        scenario='[3] `percentileCont()` failing on bad arguments (example 1)',
        cypher='MATCH (n)\n      RETURN percentileCont(n.price, $param)',
        graph=graph_fixture_from_create(
            """
            CREATE ({price: 10.0})
            """
        ),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Parameter binding is not supported',
        tags=('expr', 'aggregation', 'meta-xfail', 'params', 'xfail'),
    ),
    Scenario(
        key='expr-aggregation6-3-2',
        feature_path='tck/features/expressions/aggregation/Aggregation6.feature',
        scenario='[3] `percentileCont()` failing on bad arguments (example 2)',
        cypher='MATCH (n)\n      RETURN percentileCont(n.price, $param)',
        graph=graph_fixture_from_create(
            """
            CREATE ({price: 10.0})
            """
        ),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Parameter binding is not supported',
        tags=('expr', 'aggregation', 'meta-xfail', 'params', 'xfail'),
    ),
    Scenario(
        key='expr-aggregation6-3-3',
        feature_path='tck/features/expressions/aggregation/Aggregation6.feature',
        scenario='[3] `percentileCont()` failing on bad arguments (example 3)',
        cypher='MATCH (n)\n      RETURN percentileCont(n.price, $param)',
        graph=graph_fixture_from_create(
            """
            CREATE ({price: 10.0})
            """
        ),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Parameter binding is not supported',
        tags=('expr', 'aggregation', 'meta-xfail', 'params', 'xfail'),
    ),
    Scenario(
        key='expr-aggregation6-4-1',
        feature_path='tck/features/expressions/aggregation/Aggregation6.feature',
        scenario='[4] `percentileDisc()` failing on bad arguments (example 1)',
        cypher='MATCH (n)\n      RETURN percentileDisc(n.price, $param)',
        graph=graph_fixture_from_create(
            """
            CREATE ({price: 10.0})
            """
        ),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Parameter binding is not supported',
        tags=('expr', 'aggregation', 'meta-xfail', 'params', 'xfail'),
    ),
    Scenario(
        key='expr-aggregation6-4-2',
        feature_path='tck/features/expressions/aggregation/Aggregation6.feature',
        scenario='[4] `percentileDisc()` failing on bad arguments (example 2)',
        cypher='MATCH (n)\n      RETURN percentileDisc(n.price, $param)',
        graph=graph_fixture_from_create(
            """
            CREATE ({price: 10.0})
            """
        ),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Parameter binding is not supported',
        tags=('expr', 'aggregation', 'meta-xfail', 'params', 'xfail'),
    ),
    Scenario(
        key='expr-aggregation6-4-3',
        feature_path='tck/features/expressions/aggregation/Aggregation6.feature',
        scenario='[4] `percentileDisc()` failing on bad arguments (example 3)',
        cypher='MATCH (n)\n      RETURN percentileDisc(n.price, $param)',
        graph=graph_fixture_from_create(
            """
            CREATE ({price: 10.0})
            """
        ),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Parameter binding is not supported',
        tags=('expr', 'aggregation', 'meta-xfail', 'params', 'xfail'),
    ),
    Scenario(
        key='expr-aggregation6-5',
        feature_path='tck/features/expressions/aggregation/Aggregation6.feature',
        scenario='[5] `percentileDisc()` failing in more involved query',
        cypher='MATCH (n:S)\n      WITH n, size([(n)-->() | 1]) AS deg\n      WHERE deg > 2\n      WITH deg\n      LIMIT 100\n      RETURN percentileDisc(0.90, deg), deg',
        graph=graph_fixture_from_create(
            """
            UNWIND range(0, 10) AS i
                  CREATE (s:S)
                  WITH s, i
                  UNWIND range(0, i) AS j
                  CREATE (s)-[:REL]->()
            """
        ),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'aggregation', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-aggregation8-1',
        feature_path='tck/features/expressions/aggregation/Aggregation8.feature',
        scenario='[1] Distinct on unbound node',
        cypher='OPTIONAL MATCH (a)\n      RETURN count(DISTINCT a)',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'count(DISTINCT a)': 0}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'aggregation', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-aggregation8-2',
        feature_path='tck/features/expressions/aggregation/Aggregation8.feature',
        scenario='[2] Distinct on null',
        cypher='MATCH (a)\n      RETURN count(DISTINCT a.name)',
        graph=graph_fixture_from_create(
            """
            CREATE ()
            """
        ),
        expected=Expected(
            rows=[
            {'count(DISTINCT a.name)': 0}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'aggregation', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-aggregation8-3',
        feature_path='tck/features/expressions/aggregation/Aggregation8.feature',
        scenario='[3] Collect distinct nulls',
        cypher='UNWIND [null, null] AS x\n      RETURN collect(DISTINCT x) AS c',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'c': '[]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'aggregation', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-aggregation8-4',
        feature_path='tck/features/expressions/aggregation/Aggregation8.feature',
        scenario='[4] Collect distinct values mixed with nulls',
        cypher='UNWIND [null, 1, null] AS x\n      RETURN collect(DISTINCT x) AS c',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'c': '[1]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'aggregation', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-boolean1-1',
        feature_path='tck/features/expressions/boolean/Boolean1.feature',
        scenario='[1] Conjunction of two truth values',
        cypher='RETURN true AND true AS tt,\n             true AND false AS tf,\n             true AND null AS tn,\n             false AND true AS ft,\n             false AND false AS ff,\n             false AND null AS fn,\n             null AND true AS nt,\n             null AND false AS nf,\n             null AND null AS nn',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'tt': 'true', 'tf': 'false', 'tn': 'null', 'ft': 'false', 'ff': 'false', 'fn': 'false', 'nt': 'null', 'nf': 'false', 'nn': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-boolean1-2',
        feature_path='tck/features/expressions/boolean/Boolean1.feature',
        scenario='[2] Conjunction of three truth values',
        cypher='RETURN true AND true AND true AS ttt,\n             true AND true AND false AS ttf,\n             true AND true AND null AS ttn,\n             true AND false AND true AS tft,\n             true AND false AND false AS tff,\n             true AND false AND null AS tfn,\n             true AND null AND true AS tnt,\n             true AND null AND false AS tnf,\n             true AND null AND null AS tnn,\n             false AND true AND true AS ftt,\n             false AND true AND false AS ftf,\n             false AND true AND null AS ftn,\n             false AND false AND true AS fft,\n             false AND false AND false AS fff,\n             false AND false AND null AS ffn,\n             false AND null AND true AS fnt,\n             false AND null AND false AS fnf,\n             false AND null AND null AS fnn,\n             null AND true AND true AS ntt,\n             null AND true AND false AS ntf,\n             null AND true AND null AS ntn,\n             null AND false AND true AS nft,\n             null AND false AND false AS nff,\n             null AND false AND null AS nfn,\n             null AND null AND true AS nnt,\n             null AND null AND false AS nnf,\n             null AND null AND null AS nnn',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'ttt': 'true', 'ttf': 'false', 'ttn': 'null', 'tft': 'false', 'tff': 'false', 'tfn': 'false', 'tnt': 'null', 'tnf': 'false', 'tnn': 'null', 'ftt': 'false', 'ftf': 'false', 'ftn': 'false', 'fft': 'false', 'fff': 'false', 'ffn': 'false', 'fnt': 'false', 'fnf': 'false', 'fnn': 'false', 'ntt': 'null', 'ntf': 'false', 'ntn': 'null', 'nft': 'false', 'nff': 'false', 'nfn': 'false', 'nnt': 'null', 'nnf': 'false', 'nnn': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-boolean1-3',
        feature_path='tck/features/expressions/boolean/Boolean1.feature',
        scenario='[3] Conjunction of many truth values',
        cypher='RETURN true AND true AND true AND true AND true AND true AND true AND true AND true AND true AND true AS t,\n             true AND true AND true AND false AND true AND true AND true AND true AND true AND true AND true AS tsf,\n             true AND true AND true AND null AND true AND true AND true AND true AND true AND true AND true AS tsn,\n             false AND false AND false AND false AND false AND false AND false AND false AND false AND false AND false AS f,\n             false AND false AND false AND false AND true AND false AND false AND false AND false AND false AND false AS fst,\n             false AND false AND false AND false AND false AND false AND null AND false AND false AND false AND false AS fsn,\n             null AND null AND null AND null AND null AND null AND null AND null AND null AND null AND null AS n,\n             null AND null AND null AND null AND true AND null AND null AND null AND null AND null AND null AS nst,\n             null AND null AND null AND null AND false AND null AND null AND null AND null AND null AND null AS nsf,\n             true AND false AND false AND false AND true AND false AND false AND true AND true AND true AND false AS m1,\n             true AND true AND false AND false AND true AND false AND false AND true AND true AND true AND false AS m2,\n             true AND true AND false AND false AND true AND null AND false AND true AND true AND null AND false AS m3',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'t': 'true', 'tsf': 'false', 'tsn': 'null', 'f': 'false', 'fst': 'false', 'fsn': 'false', 'n': 'null', 'nst': 'null', 'nsf': 'false', 'm1': 'false', 'm2': 'false', 'm3': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-boolean1-4',
        feature_path='tck/features/expressions/boolean/Boolean1.feature',
        scenario='[4] Conjunction is commutative on non-null',
        cypher='UNWIND [true, false] AS a\n      UNWIND [true, false] AS b\n      RETURN a, b, (a AND b) = (b AND a) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'a': 'true', 'b': 'true', 'result': 'true'},
            {'a': 'true', 'b': 'false', 'result': 'true'},
            {'a': 'false', 'b': 'true', 'result': 'true'},
            {'a': 'false', 'b': 'false', 'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-boolean1-5',
        feature_path='tck/features/expressions/boolean/Boolean1.feature',
        scenario='[5] Conjunction is commutative on null',
        cypher='UNWIND [true, false, null] AS a\n      UNWIND [true, false, null] AS b\n      WITH a, b WHERE a IS NULL OR b IS NULL\n      RETURN a, b, (a AND b) IS NULL = (b AND a) IS NULL AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'a': 'true', 'b': 'null', 'result': 'true'},
            {'a': 'false', 'b': 'null', 'result': 'true'},
            {'a': 'null', 'b': 'true', 'result': 'true'},
            {'a': 'null', 'b': 'false', 'result': 'true'},
            {'a': 'null', 'b': 'null', 'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-boolean1-6',
        feature_path='tck/features/expressions/boolean/Boolean1.feature',
        scenario='[6] Conjunction is associative on non-null',
        cypher='UNWIND [true, false] AS a\n      UNWIND [true, false] AS b\n      UNWIND [true, false] AS c\n      RETURN a, b, c, (a AND (b AND c)) = ((a AND b) AND c) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'a': 'true', 'b': 'true', 'c': 'true', 'result': 'true'},
            {'a': 'true', 'b': 'true', 'c': 'false', 'result': 'true'},
            {'a': 'true', 'b': 'false', 'c': 'true', 'result': 'true'},
            {'a': 'true', 'b': 'false', 'c': 'false', 'result': 'true'},
            {'a': 'false', 'b': 'true', 'c': 'true', 'result': 'true'},
            {'a': 'false', 'b': 'true', 'c': 'false', 'result': 'true'},
            {'a': 'false', 'b': 'false', 'c': 'true', 'result': 'true'},
            {'a': 'false', 'b': 'false', 'c': 'false', 'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-boolean1-7',
        feature_path='tck/features/expressions/boolean/Boolean1.feature',
        scenario='[7] Conjunction is associative on null',
        cypher='UNWIND [true, false, null] AS a\n      UNWIND [true, false, null] AS b\n      UNWIND [true, false, null] AS c\n      WITH a, b, c WHERE a IS NULL OR b IS NULL OR c IS NULL\n      RETURN a, b, c, (a AND (b AND c)) IS NULL = ((a AND b) AND c) IS NULL AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'a': 'true', 'b': 'true', 'c': 'null', 'result': 'true'},
            {'a': 'true', 'b': 'false', 'c': 'null', 'result': 'true'},
            {'a': 'true', 'b': 'null', 'c': 'true', 'result': 'true'},
            {'a': 'true', 'b': 'null', 'c': 'false', 'result': 'true'},
            {'a': 'true', 'b': 'null', 'c': 'null', 'result': 'true'},
            {'a': 'false', 'b': 'true', 'c': 'null', 'result': 'true'},
            {'a': 'false', 'b': 'false', 'c': 'null', 'result': 'true'},
            {'a': 'false', 'b': 'null', 'c': 'true', 'result': 'true'},
            {'a': 'false', 'b': 'null', 'c': 'false', 'result': 'true'},
            {'a': 'false', 'b': 'null', 'c': 'null', 'result': 'true'},
            {'a': 'null', 'b': 'true', 'c': 'true', 'result': 'true'},
            {'a': 'null', 'b': 'true', 'c': 'false', 'result': 'true'},
            {'a': 'null', 'b': 'true', 'c': 'null', 'result': 'true'},
            {'a': 'null', 'b': 'false', 'c': 'true', 'result': 'true'},
            {'a': 'null', 'b': 'false', 'c': 'false', 'result': 'true'},
            {'a': 'null', 'b': 'false', 'c': 'null', 'result': 'true'},
            {'a': 'null', 'b': 'null', 'c': 'true', 'result': 'true'},
            {'a': 'null', 'b': 'null', 'c': 'false', 'result': 'true'},
            {'a': 'null', 'b': 'null', 'c': 'null', 'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-boolean1-8-1',
        feature_path='tck/features/expressions/boolean/Boolean1.feature',
        scenario='[8] Fail on conjunction of at least one non-booleans (example 1)',
        cypher='RETURN 123 AND true',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean1-8-2',
        feature_path='tck/features/expressions/boolean/Boolean1.feature',
        scenario='[8] Fail on conjunction of at least one non-booleans (example 2)',
        cypher='RETURN 123.4 AND false',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean1-8-3',
        feature_path='tck/features/expressions/boolean/Boolean1.feature',
        scenario='[8] Fail on conjunction of at least one non-booleans (example 3)',
        cypher='RETURN 123.4 AND null',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean1-8-4',
        feature_path='tck/features/expressions/boolean/Boolean1.feature',
        scenario='[8] Fail on conjunction of at least one non-booleans (example 4)',
        cypher="RETURN 'foo' AND true",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean1-8-5',
        feature_path='tck/features/expressions/boolean/Boolean1.feature',
        scenario='[8] Fail on conjunction of at least one non-booleans (example 5)',
        cypher='RETURN [] AND false',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean1-8-6',
        feature_path='tck/features/expressions/boolean/Boolean1.feature',
        scenario='[8] Fail on conjunction of at least one non-booleans (example 6)',
        cypher='RETURN [true] AND false',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean1-8-7',
        feature_path='tck/features/expressions/boolean/Boolean1.feature',
        scenario='[8] Fail on conjunction of at least one non-booleans (example 7)',
        cypher='RETURN [null] AND null',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean1-8-8',
        feature_path='tck/features/expressions/boolean/Boolean1.feature',
        scenario='[8] Fail on conjunction of at least one non-booleans (example 8)',
        cypher='RETURN {} AND true',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean1-8-9',
        feature_path='tck/features/expressions/boolean/Boolean1.feature',
        scenario='[8] Fail on conjunction of at least one non-booleans (example 9)',
        cypher='RETURN {x: []} AND true',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean1-8-10',
        feature_path='tck/features/expressions/boolean/Boolean1.feature',
        scenario='[8] Fail on conjunction of at least one non-booleans (example 10)',
        cypher='RETURN false AND 123',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean1-8-11',
        feature_path='tck/features/expressions/boolean/Boolean1.feature',
        scenario='[8] Fail on conjunction of at least one non-booleans (example 11)',
        cypher='RETURN true AND 123.4',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean1-8-12',
        feature_path='tck/features/expressions/boolean/Boolean1.feature',
        scenario='[8] Fail on conjunction of at least one non-booleans (example 12)',
        cypher="RETURN false AND 'foo'",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean1-8-13',
        feature_path='tck/features/expressions/boolean/Boolean1.feature',
        scenario='[8] Fail on conjunction of at least one non-booleans (example 13)',
        cypher="RETURN null AND 'foo'",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean1-8-14',
        feature_path='tck/features/expressions/boolean/Boolean1.feature',
        scenario='[8] Fail on conjunction of at least one non-booleans (example 14)',
        cypher='RETURN true AND []',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean1-8-15',
        feature_path='tck/features/expressions/boolean/Boolean1.feature',
        scenario='[8] Fail on conjunction of at least one non-booleans (example 15)',
        cypher='RETURN true AND [false]',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean1-8-16',
        feature_path='tck/features/expressions/boolean/Boolean1.feature',
        scenario='[8] Fail on conjunction of at least one non-booleans (example 16)',
        cypher='RETURN null AND [null]',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean1-8-17',
        feature_path='tck/features/expressions/boolean/Boolean1.feature',
        scenario='[8] Fail on conjunction of at least one non-booleans (example 17)',
        cypher='RETURN false AND {}',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean1-8-18',
        feature_path='tck/features/expressions/boolean/Boolean1.feature',
        scenario='[8] Fail on conjunction of at least one non-booleans (example 18)',
        cypher='RETURN false AND {x: []}',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean1-8-19',
        feature_path='tck/features/expressions/boolean/Boolean1.feature',
        scenario='[8] Fail on conjunction of at least one non-booleans (example 19)',
        cypher="RETURN 123 AND 'foo'",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean1-8-20',
        feature_path='tck/features/expressions/boolean/Boolean1.feature',
        scenario='[8] Fail on conjunction of at least one non-booleans (example 20)',
        cypher='RETURN 123.4 AND 123.4',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean1-8-21',
        feature_path='tck/features/expressions/boolean/Boolean1.feature',
        scenario='[8] Fail on conjunction of at least one non-booleans (example 21)',
        cypher="RETURN 'foo' AND {x: []}",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean1-8-22',
        feature_path='tck/features/expressions/boolean/Boolean1.feature',
        scenario='[8] Fail on conjunction of at least one non-booleans (example 22)',
        cypher='RETURN [true] AND [true]',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean1-8-23',
        feature_path='tck/features/expressions/boolean/Boolean1.feature',
        scenario='[8] Fail on conjunction of at least one non-booleans (example 23)',
        cypher='RETURN {x: []} AND [123]',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean2-1',
        feature_path='tck/features/expressions/boolean/Boolean2.feature',
        scenario='[1] Disjunction of two truth values',
        cypher='RETURN true OR true AS tt,\n             true OR false AS tf,\n             true OR null AS tn,\n             false OR true AS ft,\n             false OR false AS ff,\n             false OR null AS fn,\n             null OR true AS nt,\n             null OR false AS nf,\n             null OR null AS nn',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'tt': 'true', 'tf': 'true', 'tn': 'true', 'ft': 'true', 'ff': 'false', 'fn': 'null', 'nt': 'true', 'nf': 'null', 'nn': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-boolean2-2',
        feature_path='tck/features/expressions/boolean/Boolean2.feature',
        scenario='[2] Disjunction of three truth values',
        cypher='RETURN true OR true OR true AS ttt,\n             true OR true OR false AS ttf,\n             true OR true OR null AS ttn,\n             true OR false OR true AS tft,\n             true OR false OR false AS tff,\n             true OR false OR null AS tfn,\n             true OR null OR true AS tnt,\n             true OR null OR false AS tnf,\n             true OR null OR null AS tnn,\n             false OR true OR true AS ftt,\n             false OR true OR false AS ftf,\n             false OR true OR null AS ftn,\n             false OR false OR true AS fft,\n             false OR false OR false AS fff,\n             false OR false OR null AS ffn,\n             false OR null OR true AS fnt,\n             false OR null OR false AS fnf,\n             false OR null OR null AS fnn,\n             null OR true OR true AS ntt,\n             null OR true OR false AS ntf,\n             null OR true OR null AS ntn,\n             null OR false OR true AS nft,\n             null OR false OR false AS nff,\n             null OR false OR null AS nfn,\n             null OR null OR true AS nnt,\n             null OR null OR false AS nnf,\n             null OR null OR null AS nnn',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'ttt': 'true', 'ttf': 'true', 'ttn': 'true', 'tft': 'true', 'tff': 'true', 'tfn': 'true', 'tnt': 'true', 'tnf': 'true', 'tnn': 'true', 'ftt': 'true', 'ftf': 'true', 'ftn': 'true', 'fft': 'true', 'fff': 'false', 'ffn': 'null', 'fnt': 'true', 'fnf': 'null', 'fnn': 'null', 'ntt': 'true', 'ntf': 'true', 'ntn': 'true', 'nft': 'true', 'nff': 'null', 'nfn': 'null', 'nnt': 'true', 'nnf': 'null', 'nnn': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-boolean2-3',
        feature_path='tck/features/expressions/boolean/Boolean2.feature',
        scenario='[3] Disjunction of many truth values',
        cypher='RETURN true OR true OR true OR true OR true OR true OR true OR true OR true OR true OR true AS t,\n             true OR true OR true OR false OR true OR true OR true OR true OR true OR true OR true AS tsf,\n             true OR true OR true OR null OR true OR true OR true OR true OR true OR true OR true AS tsn,\n             false OR false OR false OR false OR false OR false OR false OR false OR false OR false OR false AS f,\n             false OR false OR false OR false OR true OR false OR false OR false OR false OR false OR false AS fst,\n             false OR false OR false OR false OR false OR false OR null OR false OR false OR false OR false AS fsn,\n             null OR null OR null OR null OR null OR null OR null OR null OR null OR null OR null AS n,\n             null OR null OR null OR null OR true OR null OR null OR null OR null OR null OR null AS nst,\n             null OR null OR null OR null OR false OR null OR null OR null OR null OR null OR null AS nsf,\n             true OR false OR false OR false OR true OR false OR false OR true OR true OR true OR false AS m1,\n             true OR true OR false OR false OR true OR false OR false OR true OR true OR true OR false AS m2,\n             true OR true OR false OR false OR true OR null OR false OR true OR true OR null OR false AS m3',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'t': 'true', 'tsf': 'true', 'tsn': 'true', 'f': 'false', 'fst': 'true', 'fsn': 'null', 'n': 'null', 'nst': 'true', 'nsf': 'null', 'm1': 'true', 'm2': 'true', 'm3': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-boolean2-4',
        feature_path='tck/features/expressions/boolean/Boolean2.feature',
        scenario='[4] Disjunction is commutative on non-null',
        cypher='UNWIND [true, false] AS a\n      UNWIND [true, false] AS b\n      RETURN a, b, (a OR b) = (b OR a) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'a': 'true', 'b': 'true', 'result': 'true'},
            {'a': 'true', 'b': 'false', 'result': 'true'},
            {'a': 'false', 'b': 'true', 'result': 'true'},
            {'a': 'false', 'b': 'false', 'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-boolean2-5',
        feature_path='tck/features/expressions/boolean/Boolean2.feature',
        scenario='[5] Disjunction is commutative on null',
        cypher='UNWIND [true, false, null] AS a\n      UNWIND [true, false, null] AS b\n      WITH a, b WHERE a IS NULL OR b IS NULL\n      RETURN a, b, (a OR b) IS NULL = (b OR a) IS NULL AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'a': 'true', 'b': 'null', 'result': 'true'},
            {'a': 'false', 'b': 'null', 'result': 'true'},
            {'a': 'null', 'b': 'true', 'result': 'true'},
            {'a': 'null', 'b': 'false', 'result': 'true'},
            {'a': 'null', 'b': 'null', 'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-boolean2-6',
        feature_path='tck/features/expressions/boolean/Boolean2.feature',
        scenario='[6] Disjunction is associative on non-null',
        cypher='UNWIND [true, false] AS a\n      UNWIND [true, false] AS b\n      UNWIND [true, false] AS c\n      RETURN a, b, c, (a OR (b OR c)) = ((a OR b) OR c) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'a': 'true', 'b': 'true', 'c': 'true', 'result': 'true'},
            {'a': 'true', 'b': 'true', 'c': 'false', 'result': 'true'},
            {'a': 'true', 'b': 'false', 'c': 'true', 'result': 'true'},
            {'a': 'true', 'b': 'false', 'c': 'false', 'result': 'true'},
            {'a': 'false', 'b': 'true', 'c': 'true', 'result': 'true'},
            {'a': 'false', 'b': 'true', 'c': 'false', 'result': 'true'},
            {'a': 'false', 'b': 'false', 'c': 'true', 'result': 'true'},
            {'a': 'false', 'b': 'false', 'c': 'false', 'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-boolean2-7',
        feature_path='tck/features/expressions/boolean/Boolean2.feature',
        scenario='[7] Disjunction is associative on null',
        cypher='UNWIND [true, false, null] AS a\n      UNWIND [true, false, null] AS b\n      UNWIND [true, false, null] AS c\n      WITH a, b, c WHERE a IS NULL OR b IS NULL OR c IS NULL\n      RETURN a, b, c, (a OR (b OR c)) IS NULL = ((a OR b) OR c) IS NULL AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'a': 'true', 'b': 'true', 'c': 'null', 'result': 'true'},
            {'a': 'true', 'b': 'false', 'c': 'null', 'result': 'true'},
            {'a': 'true', 'b': 'null', 'c': 'true', 'result': 'true'},
            {'a': 'true', 'b': 'null', 'c': 'false', 'result': 'true'},
            {'a': 'true', 'b': 'null', 'c': 'null', 'result': 'true'},
            {'a': 'false', 'b': 'true', 'c': 'null', 'result': 'true'},
            {'a': 'false', 'b': 'false', 'c': 'null', 'result': 'true'},
            {'a': 'false', 'b': 'null', 'c': 'true', 'result': 'true'},
            {'a': 'false', 'b': 'null', 'c': 'false', 'result': 'true'},
            {'a': 'false', 'b': 'null', 'c': 'null', 'result': 'true'},
            {'a': 'null', 'b': 'true', 'c': 'true', 'result': 'true'},
            {'a': 'null', 'b': 'true', 'c': 'false', 'result': 'true'},
            {'a': 'null', 'b': 'true', 'c': 'null', 'result': 'true'},
            {'a': 'null', 'b': 'false', 'c': 'true', 'result': 'true'},
            {'a': 'null', 'b': 'false', 'c': 'false', 'result': 'true'},
            {'a': 'null', 'b': 'false', 'c': 'null', 'result': 'true'},
            {'a': 'null', 'b': 'null', 'c': 'true', 'result': 'true'},
            {'a': 'null', 'b': 'null', 'c': 'false', 'result': 'true'},
            {'a': 'null', 'b': 'null', 'c': 'null', 'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-boolean2-8-1',
        feature_path='tck/features/expressions/boolean/Boolean2.feature',
        scenario='[8] Fail on disjunction of at least one non-booleans (example 1)',
        cypher='RETURN 123 OR true',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean2-8-2',
        feature_path='tck/features/expressions/boolean/Boolean2.feature',
        scenario='[8] Fail on disjunction of at least one non-booleans (example 2)',
        cypher='RETURN 123.4 OR false',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean2-8-3',
        feature_path='tck/features/expressions/boolean/Boolean2.feature',
        scenario='[8] Fail on disjunction of at least one non-booleans (example 3)',
        cypher='RETURN 123.4 OR null',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean2-8-4',
        feature_path='tck/features/expressions/boolean/Boolean2.feature',
        scenario='[8] Fail on disjunction of at least one non-booleans (example 4)',
        cypher="RETURN 'foo' OR true",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean2-8-5',
        feature_path='tck/features/expressions/boolean/Boolean2.feature',
        scenario='[8] Fail on disjunction of at least one non-booleans (example 5)',
        cypher='RETURN [] OR false',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean2-8-6',
        feature_path='tck/features/expressions/boolean/Boolean2.feature',
        scenario='[8] Fail on disjunction of at least one non-booleans (example 6)',
        cypher='RETURN [true] OR false',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean2-8-7',
        feature_path='tck/features/expressions/boolean/Boolean2.feature',
        scenario='[8] Fail on disjunction of at least one non-booleans (example 7)',
        cypher='RETURN [null] OR null',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean2-8-8',
        feature_path='tck/features/expressions/boolean/Boolean2.feature',
        scenario='[8] Fail on disjunction of at least one non-booleans (example 8)',
        cypher='RETURN {} OR true',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean2-8-9',
        feature_path='tck/features/expressions/boolean/Boolean2.feature',
        scenario='[8] Fail on disjunction of at least one non-booleans (example 9)',
        cypher='RETURN {x: []} OR true',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean2-8-10',
        feature_path='tck/features/expressions/boolean/Boolean2.feature',
        scenario='[8] Fail on disjunction of at least one non-booleans (example 10)',
        cypher='RETURN false OR 123',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean2-8-11',
        feature_path='tck/features/expressions/boolean/Boolean2.feature',
        scenario='[8] Fail on disjunction of at least one non-booleans (example 11)',
        cypher='RETURN true OR 123.4',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean2-8-12',
        feature_path='tck/features/expressions/boolean/Boolean2.feature',
        scenario='[8] Fail on disjunction of at least one non-booleans (example 12)',
        cypher="RETURN false OR 'foo'",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean2-8-13',
        feature_path='tck/features/expressions/boolean/Boolean2.feature',
        scenario='[8] Fail on disjunction of at least one non-booleans (example 13)',
        cypher="RETURN null OR 'foo'",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean2-8-14',
        feature_path='tck/features/expressions/boolean/Boolean2.feature',
        scenario='[8] Fail on disjunction of at least one non-booleans (example 14)',
        cypher='RETURN true OR []',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean2-8-15',
        feature_path='tck/features/expressions/boolean/Boolean2.feature',
        scenario='[8] Fail on disjunction of at least one non-booleans (example 15)',
        cypher='RETURN true OR [false]',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean2-8-16',
        feature_path='tck/features/expressions/boolean/Boolean2.feature',
        scenario='[8] Fail on disjunction of at least one non-booleans (example 16)',
        cypher='RETURN null OR [null]',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean2-8-17',
        feature_path='tck/features/expressions/boolean/Boolean2.feature',
        scenario='[8] Fail on disjunction of at least one non-booleans (example 17)',
        cypher='RETURN false OR {}',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean2-8-18',
        feature_path='tck/features/expressions/boolean/Boolean2.feature',
        scenario='[8] Fail on disjunction of at least one non-booleans (example 18)',
        cypher='RETURN false OR {x: []}',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean2-8-19',
        feature_path='tck/features/expressions/boolean/Boolean2.feature',
        scenario='[8] Fail on disjunction of at least one non-booleans (example 19)',
        cypher="RETURN 123 OR 'foo'",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean2-8-20',
        feature_path='tck/features/expressions/boolean/Boolean2.feature',
        scenario='[8] Fail on disjunction of at least one non-booleans (example 20)',
        cypher='RETURN 123.4 OR 123.4',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean2-8-21',
        feature_path='tck/features/expressions/boolean/Boolean2.feature',
        scenario='[8] Fail on disjunction of at least one non-booleans (example 21)',
        cypher="RETURN 'foo' OR {x: []}",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean2-8-22',
        feature_path='tck/features/expressions/boolean/Boolean2.feature',
        scenario='[8] Fail on disjunction of at least one non-booleans (example 22)',
        cypher='RETURN [true] OR [true]',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean2-8-23',
        feature_path='tck/features/expressions/boolean/Boolean2.feature',
        scenario='[8] Fail on disjunction of at least one non-booleans (example 23)',
        cypher='RETURN {x: []} OR [123]',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean3-1',
        feature_path='tck/features/expressions/boolean/Boolean3.feature',
        scenario='[1] Exclusive disjunction of two truth values',
        cypher='RETURN true XOR true AS tt,\n             true XOR false AS tf,\n             true XOR null AS tn,\n             false XOR true AS ft,\n             false XOR false AS ff,\n             false XOR null AS fn,\n             null XOR true AS nt,\n             null XOR false AS nf,\n             null XOR null AS nn',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'tt': 'false', 'tf': 'true', 'tn': 'null', 'ft': 'true', 'ff': 'false', 'fn': 'null', 'nt': 'null', 'nf': 'null', 'nn': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-boolean3-2',
        feature_path='tck/features/expressions/boolean/Boolean3.feature',
        scenario='[2] Exclusive disjunction of three truth values',
        cypher='RETURN true XOR true XOR true AS ttt,\n             true XOR true XOR false AS ttf,\n             true XOR true XOR null AS ttn,\n             true XOR false XOR true AS tft,\n             true XOR false XOR false AS tff,\n             true XOR false XOR null AS tfn,\n             true XOR null XOR true AS tnt,\n             true XOR null XOR false AS tnf,\n             true XOR null XOR null AS tnn,\n             false XOR true XOR true AS ftt,\n             false XOR true XOR false AS ftf,\n             false XOR true XOR null AS ftn,\n             false XOR false XOR true AS fft,\n             false XOR false XOR false AS fff,\n             false XOR false XOR null AS ffn,\n             false XOR null XOR true AS fnt,\n             false XOR null XOR false AS fnf,\n             false XOR null XOR null AS fnn,\n             null XOR true XOR true AS ntt,\n             null XOR true XOR false AS ntf,\n             null XOR true XOR null AS ntn,\n             null XOR false XOR true AS nft,\n             null XOR false XOR false AS nff,\n             null XOR false XOR null AS nfn,\n             null XOR null XOR true AS nnt,\n             null XOR null XOR false AS nnf,\n             null XOR null XOR null AS nnn',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'ttt': 'true', 'ttf': 'false', 'ttn': 'null', 'tft': 'false', 'tff': 'true', 'tfn': 'null', 'tnt': 'null', 'tnf': 'null', 'tnn': 'null', 'ftt': 'false', 'ftf': 'true', 'ftn': 'null', 'fft': 'true', 'fff': 'false', 'ffn': 'null', 'fnt': 'null', 'fnf': 'null', 'fnn': 'null', 'ntt': 'null', 'ntf': 'null', 'ntn': 'null', 'nft': 'null', 'nff': 'null', 'nfn': 'null', 'nnt': 'null', 'nnf': 'null', 'nnn': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-boolean3-3',
        feature_path='tck/features/expressions/boolean/Boolean3.feature',
        scenario='[3] Exclusive disjunction of many truth values',
        cypher='RETURN true XOR true XOR true XOR true XOR true XOR true XOR true XOR true XOR true XOR true XOR true AS t,\n             true XOR true XOR true XOR false XOR true XOR true XOR true XOR true XOR true XOR true XOR true AS tsf,\n             true XOR true XOR true XOR null XOR true XOR true XOR true XOR true XOR true XOR true XOR true AS tsn,\n             false XOR false XOR false XOR false XOR false XOR false XOR false XOR false XOR false XOR false XOR false AS f,\n             false XOR false XOR false XOR false XOR true XOR false XOR false XOR false XOR false XOR false XOR false AS fst,\n             false XOR false XOR false XOR false XOR false XOR false XOR null XOR false XOR false XOR false XOR false AS fsn,\n             null XOR null XOR null XOR null XOR null XOR null XOR null XOR null XOR null XOR null XOR null AS n,\n             null XOR null XOR null XOR null XOR true XOR null XOR null XOR null XOR null XOR null XOR null AS nst,\n             null XOR null XOR null XOR null XOR false XOR null XOR null XOR null XOR null XOR null XOR null AS nsf,\n             true XOR false XOR false XOR false XOR true XOR false XOR false XOR true XOR true XOR true XOR false AS m1,\n             true XOR true XOR false XOR false XOR true XOR false XOR false XOR true XOR true XOR true XOR false AS m2,\n             true XOR true XOR false XOR false XOR true XOR null XOR false XOR true XOR true XOR null XOR false AS m3',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'t': 'true', 'tsf': 'false', 'tsn': 'null', 'f': 'false', 'fst': 'true', 'fsn': 'null', 'n': 'null', 'nst': 'null', 'nsf': 'null', 'm1': 'true', 'm2': 'false', 'm3': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-boolean3-4',
        feature_path='tck/features/expressions/boolean/Boolean3.feature',
        scenario='[4] Exclusive disjunction is commutative on non-null',
        cypher='UNWIND [true, false] AS a\n      UNWIND [true, false] AS b\n      RETURN a, b, (a XOR b) = (b XOR a) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'a': 'true', 'b': 'true', 'result': 'true'},
            {'a': 'true', 'b': 'false', 'result': 'true'},
            {'a': 'false', 'b': 'true', 'result': 'true'},
            {'a': 'false', 'b': 'false', 'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-boolean3-5',
        feature_path='tck/features/expressions/boolean/Boolean3.feature',
        scenario='[5] Exclusive disjunction is commutative on null',
        cypher='UNWIND [true, false, null] AS a\n      UNWIND [true, false, null] AS b\n      WITH a, b WHERE a IS NULL OR b IS NULL\n      RETURN a, b, (a XOR b) IS NULL = (b XOR a) IS NULL AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'a': 'true', 'b': 'null', 'result': 'true'},
            {'a': 'false', 'b': 'null', 'result': 'true'},
            {'a': 'null', 'b': 'true', 'result': 'true'},
            {'a': 'null', 'b': 'false', 'result': 'true'},
            {'a': 'null', 'b': 'null', 'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-boolean3-6',
        feature_path='tck/features/expressions/boolean/Boolean3.feature',
        scenario='[6] Exclusive disjunction is associative on non-null',
        cypher='UNWIND [true, false] AS a\n      UNWIND [true, false] AS b\n      UNWIND [true, false] AS c\n      RETURN a, b, c, (a XOR (b XOR c)) = ((a XOR b) XOR c) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'a': 'true', 'b': 'true', 'c': 'true', 'result': 'true'},
            {'a': 'true', 'b': 'true', 'c': 'false', 'result': 'true'},
            {'a': 'true', 'b': 'false', 'c': 'true', 'result': 'true'},
            {'a': 'true', 'b': 'false', 'c': 'false', 'result': 'true'},
            {'a': 'false', 'b': 'true', 'c': 'true', 'result': 'true'},
            {'a': 'false', 'b': 'true', 'c': 'false', 'result': 'true'},
            {'a': 'false', 'b': 'false', 'c': 'true', 'result': 'true'},
            {'a': 'false', 'b': 'false', 'c': 'false', 'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-boolean3-7',
        feature_path='tck/features/expressions/boolean/Boolean3.feature',
        scenario='[7] Exclusive disjunction is associative on null',
        cypher='UNWIND [true, false, null] AS a\n      UNWIND [true, false, null] AS b\n      UNWIND [true, false, null] AS c\n      WITH a, b, c WHERE a IS NULL OR b IS NULL OR c IS NULL\n      RETURN a, b, c, (a XOR (b XOR c)) IS NULL = ((a XOR b) XOR c) IS NULL AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'a': 'true', 'b': 'true', 'c': 'null', 'result': 'true'},
            {'a': 'true', 'b': 'false', 'c': 'null', 'result': 'true'},
            {'a': 'true', 'b': 'null', 'c': 'true', 'result': 'true'},
            {'a': 'true', 'b': 'null', 'c': 'false', 'result': 'true'},
            {'a': 'true', 'b': 'null', 'c': 'null', 'result': 'true'},
            {'a': 'false', 'b': 'true', 'c': 'null', 'result': 'true'},
            {'a': 'false', 'b': 'false', 'c': 'null', 'result': 'true'},
            {'a': 'false', 'b': 'null', 'c': 'true', 'result': 'true'},
            {'a': 'false', 'b': 'null', 'c': 'false', 'result': 'true'},
            {'a': 'false', 'b': 'null', 'c': 'null', 'result': 'true'},
            {'a': 'null', 'b': 'true', 'c': 'true', 'result': 'true'},
            {'a': 'null', 'b': 'true', 'c': 'false', 'result': 'true'},
            {'a': 'null', 'b': 'true', 'c': 'null', 'result': 'true'},
            {'a': 'null', 'b': 'false', 'c': 'true', 'result': 'true'},
            {'a': 'null', 'b': 'false', 'c': 'false', 'result': 'true'},
            {'a': 'null', 'b': 'false', 'c': 'null', 'result': 'true'},
            {'a': 'null', 'b': 'null', 'c': 'true', 'result': 'true'},
            {'a': 'null', 'b': 'null', 'c': 'false', 'result': 'true'},
            {'a': 'null', 'b': 'null', 'c': 'null', 'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-boolean3-8-1',
        feature_path='tck/features/expressions/boolean/Boolean3.feature',
        scenario='[8] Fail on exclusive disjunction of at least one non-booleans (example 1)',
        cypher='RETURN 123 XOR true',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean3-8-2',
        feature_path='tck/features/expressions/boolean/Boolean3.feature',
        scenario='[8] Fail on exclusive disjunction of at least one non-booleans (example 2)',
        cypher='RETURN 123.4 XOR false',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean3-8-3',
        feature_path='tck/features/expressions/boolean/Boolean3.feature',
        scenario='[8] Fail on exclusive disjunction of at least one non-booleans (example 3)',
        cypher='RETURN 123.4 XOR null',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean3-8-4',
        feature_path='tck/features/expressions/boolean/Boolean3.feature',
        scenario='[8] Fail on exclusive disjunction of at least one non-booleans (example 4)',
        cypher="RETURN 'foo' XOR true",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean3-8-5',
        feature_path='tck/features/expressions/boolean/Boolean3.feature',
        scenario='[8] Fail on exclusive disjunction of at least one non-booleans (example 5)',
        cypher='RETURN [] XOR false',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean3-8-6',
        feature_path='tck/features/expressions/boolean/Boolean3.feature',
        scenario='[8] Fail on exclusive disjunction of at least one non-booleans (example 6)',
        cypher='RETURN [true] XOR false',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean3-8-7',
        feature_path='tck/features/expressions/boolean/Boolean3.feature',
        scenario='[8] Fail on exclusive disjunction of at least one non-booleans (example 7)',
        cypher='RETURN [null] XOR null',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean3-8-8',
        feature_path='tck/features/expressions/boolean/Boolean3.feature',
        scenario='[8] Fail on exclusive disjunction of at least one non-booleans (example 8)',
        cypher='RETURN {} XOR true',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean3-8-9',
        feature_path='tck/features/expressions/boolean/Boolean3.feature',
        scenario='[8] Fail on exclusive disjunction of at least one non-booleans (example 9)',
        cypher='RETURN {x: []} XOR true',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean3-8-10',
        feature_path='tck/features/expressions/boolean/Boolean3.feature',
        scenario='[8] Fail on exclusive disjunction of at least one non-booleans (example 10)',
        cypher='RETURN false XOR 123',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean3-8-11',
        feature_path='tck/features/expressions/boolean/Boolean3.feature',
        scenario='[8] Fail on exclusive disjunction of at least one non-booleans (example 11)',
        cypher='RETURN true XOR 123.4',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean3-8-12',
        feature_path='tck/features/expressions/boolean/Boolean3.feature',
        scenario='[8] Fail on exclusive disjunction of at least one non-booleans (example 12)',
        cypher="RETURN false XOR 'foo'",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean3-8-13',
        feature_path='tck/features/expressions/boolean/Boolean3.feature',
        scenario='[8] Fail on exclusive disjunction of at least one non-booleans (example 13)',
        cypher="RETURN null XOR 'foo'",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean3-8-14',
        feature_path='tck/features/expressions/boolean/Boolean3.feature',
        scenario='[8] Fail on exclusive disjunction of at least one non-booleans (example 14)',
        cypher='RETURN true XOR []',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean3-8-15',
        feature_path='tck/features/expressions/boolean/Boolean3.feature',
        scenario='[8] Fail on exclusive disjunction of at least one non-booleans (example 15)',
        cypher='RETURN true XOR [false]',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean3-8-16',
        feature_path='tck/features/expressions/boolean/Boolean3.feature',
        scenario='[8] Fail on exclusive disjunction of at least one non-booleans (example 16)',
        cypher='RETURN null XOR [null]',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean3-8-17',
        feature_path='tck/features/expressions/boolean/Boolean3.feature',
        scenario='[8] Fail on exclusive disjunction of at least one non-booleans (example 17)',
        cypher='RETURN false XOR {}',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean3-8-18',
        feature_path='tck/features/expressions/boolean/Boolean3.feature',
        scenario='[8] Fail on exclusive disjunction of at least one non-booleans (example 18)',
        cypher='RETURN false XOR {x: []}',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean3-8-19',
        feature_path='tck/features/expressions/boolean/Boolean3.feature',
        scenario='[8] Fail on exclusive disjunction of at least one non-booleans (example 19)',
        cypher="RETURN 123 XOR 'foo'",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean3-8-20',
        feature_path='tck/features/expressions/boolean/Boolean3.feature',
        scenario='[8] Fail on exclusive disjunction of at least one non-booleans (example 20)',
        cypher='RETURN 123.4 XOR 123.4',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean3-8-21',
        feature_path='tck/features/expressions/boolean/Boolean3.feature',
        scenario='[8] Fail on exclusive disjunction of at least one non-booleans (example 21)',
        cypher="RETURN 'foo' XOR {x: []}",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean3-8-22',
        feature_path='tck/features/expressions/boolean/Boolean3.feature',
        scenario='[8] Fail on exclusive disjunction of at least one non-booleans (example 22)',
        cypher='RETURN [true] XOR [true]',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean3-8-23',
        feature_path='tck/features/expressions/boolean/Boolean3.feature',
        scenario='[8] Fail on exclusive disjunction of at least one non-booleans (example 23)',
        cypher='RETURN {x: []} XOR [123]',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean4-1',
        feature_path='tck/features/expressions/boolean/Boolean4.feature',
        scenario='[1] Logical negation of truth values',
        cypher='RETURN NOT true AS nt, NOT false AS nf, NOT null AS nn',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'nt': 'false', 'nf': 'true', 'nn': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-boolean4-2',
        feature_path='tck/features/expressions/boolean/Boolean4.feature',
        scenario='[2] Double logical negation of truth values',
        cypher='RETURN NOT NOT true AS nnt, NOT NOT false AS nnf, NOT NOT null AS nnn',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'nnt': 'true', 'nnf': 'false', 'nnn': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-boolean4-3',
        feature_path='tck/features/expressions/boolean/Boolean4.feature',
        scenario='[3] NOT and false',
        cypher="MATCH (n)\n      WHERE NOT(n.name = 'apa' AND false)\n      RETURN n",
        graph=graph_fixture_from_create(
            """
            CREATE ({name: 'a'})
            """
        ),
        expected=Expected(
            rows=[
            {'n': "({name: 'a'})"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-boolean4-4-1',
        feature_path='tck/features/expressions/boolean/Boolean4.feature',
        scenario='[4] Fail when using NOT on a non-boolean literal (example 1)',
        cypher='RETURN NOT 0',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean4-4-2',
        feature_path='tck/features/expressions/boolean/Boolean4.feature',
        scenario='[4] Fail when using NOT on a non-boolean literal (example 2)',
        cypher='RETURN NOT 1',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean4-4-3',
        feature_path='tck/features/expressions/boolean/Boolean4.feature',
        scenario='[4] Fail when using NOT on a non-boolean literal (example 3)',
        cypher='RETURN NOT 123',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean4-4-4',
        feature_path='tck/features/expressions/boolean/Boolean4.feature',
        scenario='[4] Fail when using NOT on a non-boolean literal (example 4)',
        cypher='RETURN NOT 123.4',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean4-4-5',
        feature_path='tck/features/expressions/boolean/Boolean4.feature',
        scenario='[4] Fail when using NOT on a non-boolean literal (example 5)',
        cypher="RETURN NOT ''",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean4-4-6',
        feature_path='tck/features/expressions/boolean/Boolean4.feature',
        scenario='[4] Fail when using NOT on a non-boolean literal (example 6)',
        cypher="RETURN NOT 'false'",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean4-4-7',
        feature_path='tck/features/expressions/boolean/Boolean4.feature',
        scenario='[4] Fail when using NOT on a non-boolean literal (example 7)',
        cypher="RETURN NOT 'true'",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean4-4-8',
        feature_path='tck/features/expressions/boolean/Boolean4.feature',
        scenario='[4] Fail when using NOT on a non-boolean literal (example 8)',
        cypher="RETURN NOT 'foo'",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean4-4-9',
        feature_path='tck/features/expressions/boolean/Boolean4.feature',
        scenario='[4] Fail when using NOT on a non-boolean literal (example 9)',
        cypher='RETURN NOT []',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean4-4-10',
        feature_path='tck/features/expressions/boolean/Boolean4.feature',
        scenario='[4] Fail when using NOT on a non-boolean literal (example 10)',
        cypher='RETURN NOT [null]',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean4-4-11',
        feature_path='tck/features/expressions/boolean/Boolean4.feature',
        scenario='[4] Fail when using NOT on a non-boolean literal (example 11)',
        cypher='RETURN NOT [true]',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean4-4-12',
        feature_path='tck/features/expressions/boolean/Boolean4.feature',
        scenario='[4] Fail when using NOT on a non-boolean literal (example 12)',
        cypher='RETURN NOT [false]',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean4-4-13',
        feature_path='tck/features/expressions/boolean/Boolean4.feature',
        scenario='[4] Fail when using NOT on a non-boolean literal (example 13)',
        cypher='RETURN NOT [true, false]',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean4-4-14',
        feature_path='tck/features/expressions/boolean/Boolean4.feature',
        scenario='[4] Fail when using NOT on a non-boolean literal (example 14)',
        cypher='RETURN NOT [false, true]',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean4-4-15',
        feature_path='tck/features/expressions/boolean/Boolean4.feature',
        scenario='[4] Fail when using NOT on a non-boolean literal (example 15)',
        cypher='RETURN NOT [0]',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean4-4-16',
        feature_path='tck/features/expressions/boolean/Boolean4.feature',
        scenario='[4] Fail when using NOT on a non-boolean literal (example 16)',
        cypher='RETURN NOT [1]',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean4-4-17',
        feature_path='tck/features/expressions/boolean/Boolean4.feature',
        scenario='[4] Fail when using NOT on a non-boolean literal (example 17)',
        cypher='RETURN NOT [1, 2, 3]',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean4-4-18',
        feature_path='tck/features/expressions/boolean/Boolean4.feature',
        scenario='[4] Fail when using NOT on a non-boolean literal (example 18)',
        cypher='RETURN NOT [0.0]',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean4-4-19',
        feature_path='tck/features/expressions/boolean/Boolean4.feature',
        scenario='[4] Fail when using NOT on a non-boolean literal (example 19)',
        cypher='RETURN NOT [1.0]',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean4-4-20',
        feature_path='tck/features/expressions/boolean/Boolean4.feature',
        scenario='[4] Fail when using NOT on a non-boolean literal (example 20)',
        cypher='RETURN NOT [1.0, 2.1]',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean4-4-21',
        feature_path='tck/features/expressions/boolean/Boolean4.feature',
        scenario='[4] Fail when using NOT on a non-boolean literal (example 21)',
        cypher="RETURN NOT ['']",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean4-4-22',
        feature_path='tck/features/expressions/boolean/Boolean4.feature',
        scenario='[4] Fail when using NOT on a non-boolean literal (example 22)',
        cypher="RETURN NOT ['', '']",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean4-4-23',
        feature_path='tck/features/expressions/boolean/Boolean4.feature',
        scenario='[4] Fail when using NOT on a non-boolean literal (example 23)',
        cypher="RETURN NOT ['true']",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean4-4-24',
        feature_path='tck/features/expressions/boolean/Boolean4.feature',
        scenario='[4] Fail when using NOT on a non-boolean literal (example 24)',
        cypher="RETURN NOT ['false']",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean4-4-25',
        feature_path='tck/features/expressions/boolean/Boolean4.feature',
        scenario='[4] Fail when using NOT on a non-boolean literal (example 25)',
        cypher="RETURN NOT ['a', 'b']",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean4-4-26',
        feature_path='tck/features/expressions/boolean/Boolean4.feature',
        scenario='[4] Fail when using NOT on a non-boolean literal (example 26)',
        cypher='RETURN NOT {}',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean4-4-27',
        feature_path='tck/features/expressions/boolean/Boolean4.feature',
        scenario='[4] Fail when using NOT on a non-boolean literal (example 27)',
        cypher='RETURN NOT {``: null}',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean4-4-28',
        feature_path='tck/features/expressions/boolean/Boolean4.feature',
        scenario='[4] Fail when using NOT on a non-boolean literal (example 28)',
        cypher='RETURN NOT {a: null}',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean4-4-29',
        feature_path='tck/features/expressions/boolean/Boolean4.feature',
        scenario='[4] Fail when using NOT on a non-boolean literal (example 29)',
        cypher='RETURN NOT {``: true}',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean4-4-30',
        feature_path='tck/features/expressions/boolean/Boolean4.feature',
        scenario='[4] Fail when using NOT on a non-boolean literal (example 30)',
        cypher='RETURN NOT {``: false}',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean4-4-31',
        feature_path='tck/features/expressions/boolean/Boolean4.feature',
        scenario='[4] Fail when using NOT on a non-boolean literal (example 31)',
        cypher='RETURN NOT {true: true}',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean4-4-32',
        feature_path='tck/features/expressions/boolean/Boolean4.feature',
        scenario='[4] Fail when using NOT on a non-boolean literal (example 32)',
        cypher='RETURN NOT {false: false}',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean4-4-33',
        feature_path='tck/features/expressions/boolean/Boolean4.feature',
        scenario='[4] Fail when using NOT on a non-boolean literal (example 33)',
        cypher='RETURN NOT {bool: true}',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean4-4-34',
        feature_path='tck/features/expressions/boolean/Boolean4.feature',
        scenario='[4] Fail when using NOT on a non-boolean literal (example 34)',
        cypher='RETURN NOT {bool: false}',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean4-4-35',
        feature_path='tck/features/expressions/boolean/Boolean4.feature',
        scenario='[4] Fail when using NOT on a non-boolean literal (example 35)',
        cypher='RETURN NOT {``: 0}',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean4-4-36',
        feature_path='tck/features/expressions/boolean/Boolean4.feature',
        scenario='[4] Fail when using NOT on a non-boolean literal (example 36)',
        cypher='RETURN NOT {``: 1}',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean4-4-37',
        feature_path='tck/features/expressions/boolean/Boolean4.feature',
        scenario='[4] Fail when using NOT on a non-boolean literal (example 37)',
        cypher='RETURN NOT {a: 0}',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean4-4-38',
        feature_path='tck/features/expressions/boolean/Boolean4.feature',
        scenario='[4] Fail when using NOT on a non-boolean literal (example 38)',
        cypher='RETURN NOT {a: 1}',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean4-4-39',
        feature_path='tck/features/expressions/boolean/Boolean4.feature',
        scenario='[4] Fail when using NOT on a non-boolean literal (example 39)',
        cypher='RETURN NOT {a: 1, b: 2}',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean4-4-40',
        feature_path='tck/features/expressions/boolean/Boolean4.feature',
        scenario='[4] Fail when using NOT on a non-boolean literal (example 40)',
        cypher='RETURN NOT {``: 0.0}',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean4-4-41',
        feature_path='tck/features/expressions/boolean/Boolean4.feature',
        scenario='[4] Fail when using NOT on a non-boolean literal (example 41)',
        cypher='RETURN NOT {``: 1.0}',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean4-4-42',
        feature_path='tck/features/expressions/boolean/Boolean4.feature',
        scenario='[4] Fail when using NOT on a non-boolean literal (example 42)',
        cypher='RETURN NOT {a: 0.0}',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean4-4-43',
        feature_path='tck/features/expressions/boolean/Boolean4.feature',
        scenario='[4] Fail when using NOT on a non-boolean literal (example 43)',
        cypher='RETURN NOT {a: 1.0}',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean4-4-44',
        feature_path='tck/features/expressions/boolean/Boolean4.feature',
        scenario='[4] Fail when using NOT on a non-boolean literal (example 44)',
        cypher='RETURN NOT {a: 1.0, b: 2.1}',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean4-4-45',
        feature_path='tck/features/expressions/boolean/Boolean4.feature',
        scenario='[4] Fail when using NOT on a non-boolean literal (example 45)',
        cypher="RETURN NOT {``: ''}",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean4-4-46',
        feature_path='tck/features/expressions/boolean/Boolean4.feature',
        scenario='[4] Fail when using NOT on a non-boolean literal (example 46)',
        cypher="RETURN NOT {a: ''}",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean4-4-47',
        feature_path='tck/features/expressions/boolean/Boolean4.feature',
        scenario='[4] Fail when using NOT on a non-boolean literal (example 47)',
        cypher="RETURN NOT {a: 'a'}",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean4-4-48',
        feature_path='tck/features/expressions/boolean/Boolean4.feature',
        scenario='[4] Fail when using NOT on a non-boolean literal (example 48)',
        cypher="RETURN NOT {a: 'a', b: 'b'}",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean4-4-49',
        feature_path='tck/features/expressions/boolean/Boolean4.feature',
        scenario='[4] Fail when using NOT on a non-boolean literal (example 49)',
        cypher='RETURN NOT {a: 12, b: true}',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-boolean5-1',
        feature_path='tck/features/expressions/boolean/Boolean5.feature',
        scenario='[1] Disjunction is distributive over conjunction on non-null',
        cypher='UNWIND [true, false] AS a\n      UNWIND [true, false] AS b\n      UNWIND [true, false] AS c\n      RETURN a, b, c, (a OR (b AND c)) = ((a OR b) AND (a OR c)) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'a': 'true', 'b': 'true', 'c': 'true', 'result': 'true'},
            {'a': 'true', 'b': 'true', 'c': 'false', 'result': 'true'},
            {'a': 'true', 'b': 'false', 'c': 'true', 'result': 'true'},
            {'a': 'true', 'b': 'false', 'c': 'false', 'result': 'true'},
            {'a': 'false', 'b': 'true', 'c': 'true', 'result': 'true'},
            {'a': 'false', 'b': 'true', 'c': 'false', 'result': 'true'},
            {'a': 'false', 'b': 'false', 'c': 'true', 'result': 'true'},
            {'a': 'false', 'b': 'false', 'c': 'false', 'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-boolean5-2',
        feature_path='tck/features/expressions/boolean/Boolean5.feature',
        scenario='[2] Disjunction is distributive over conjunction on null',
        cypher='UNWIND [true, false, null] AS a\n      UNWIND [true, false, null] AS b\n      UNWIND [true, false, null] AS c\n      WITH a, b, c WHERE a IS NULL OR b IS NULL OR c IS NULL\n      RETURN a, b, c, (a OR (b AND c)) IS NULL = ((a OR b) AND (a OR c)) IS NULL AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'a': 'true', 'b': 'true', 'c': 'null', 'result': 'true'},
            {'a': 'true', 'b': 'false', 'c': 'null', 'result': 'true'},
            {'a': 'true', 'b': 'null', 'c': 'true', 'result': 'true'},
            {'a': 'true', 'b': 'null', 'c': 'false', 'result': 'true'},
            {'a': 'true', 'b': 'null', 'c': 'null', 'result': 'true'},
            {'a': 'false', 'b': 'true', 'c': 'null', 'result': 'true'},
            {'a': 'false', 'b': 'false', 'c': 'null', 'result': 'true'},
            {'a': 'false', 'b': 'null', 'c': 'true', 'result': 'true'},
            {'a': 'false', 'b': 'null', 'c': 'false', 'result': 'true'},
            {'a': 'false', 'b': 'null', 'c': 'null', 'result': 'true'},
            {'a': 'null', 'b': 'true', 'c': 'true', 'result': 'true'},
            {'a': 'null', 'b': 'true', 'c': 'false', 'result': 'true'},
            {'a': 'null', 'b': 'true', 'c': 'null', 'result': 'true'},
            {'a': 'null', 'b': 'false', 'c': 'true', 'result': 'true'},
            {'a': 'null', 'b': 'false', 'c': 'false', 'result': 'true'},
            {'a': 'null', 'b': 'false', 'c': 'null', 'result': 'true'},
            {'a': 'null', 'b': 'null', 'c': 'true', 'result': 'true'},
            {'a': 'null', 'b': 'null', 'c': 'false', 'result': 'true'},
            {'a': 'null', 'b': 'null', 'c': 'null', 'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-boolean5-3',
        feature_path='tck/features/expressions/boolean/Boolean5.feature',
        scenario='[3] Conjunction is distributive over disjunction on non-null',
        cypher='UNWIND [true, false] AS a\n      UNWIND [true, false] AS b\n      UNWIND [true, false] AS c\n      RETURN a, b, c, (a AND (b OR c)) = ((a AND b) OR (a AND c)) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'a': 'true', 'b': 'true', 'c': 'true', 'result': 'true'},
            {'a': 'true', 'b': 'true', 'c': 'false', 'result': 'true'},
            {'a': 'true', 'b': 'false', 'c': 'true', 'result': 'true'},
            {'a': 'true', 'b': 'false', 'c': 'false', 'result': 'true'},
            {'a': 'false', 'b': 'true', 'c': 'true', 'result': 'true'},
            {'a': 'false', 'b': 'true', 'c': 'false', 'result': 'true'},
            {'a': 'false', 'b': 'false', 'c': 'true', 'result': 'true'},
            {'a': 'false', 'b': 'false', 'c': 'false', 'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-boolean5-4',
        feature_path='tck/features/expressions/boolean/Boolean5.feature',
        scenario='[4] Conjunction is distributive over disjunction on null',
        cypher='UNWIND [true, false, null] AS a\n      UNWIND [true, false, null] AS b\n      UNWIND [true, false, null] AS c\n      WITH a, b, c WHERE a IS NULL OR b IS NULL OR c IS NULL\n      RETURN a, b, c, (a AND (b OR c)) IS NULL = ((a AND b) OR (a AND c)) IS NULL AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'a': 'true', 'b': 'true', 'c': 'null', 'result': 'true'},
            {'a': 'true', 'b': 'false', 'c': 'null', 'result': 'true'},
            {'a': 'true', 'b': 'null', 'c': 'true', 'result': 'true'},
            {'a': 'true', 'b': 'null', 'c': 'false', 'result': 'true'},
            {'a': 'true', 'b': 'null', 'c': 'null', 'result': 'true'},
            {'a': 'false', 'b': 'true', 'c': 'null', 'result': 'true'},
            {'a': 'false', 'b': 'false', 'c': 'null', 'result': 'true'},
            {'a': 'false', 'b': 'null', 'c': 'true', 'result': 'true'},
            {'a': 'false', 'b': 'null', 'c': 'false', 'result': 'true'},
            {'a': 'false', 'b': 'null', 'c': 'null', 'result': 'true'},
            {'a': 'null', 'b': 'true', 'c': 'true', 'result': 'true'},
            {'a': 'null', 'b': 'true', 'c': 'false', 'result': 'true'},
            {'a': 'null', 'b': 'true', 'c': 'null', 'result': 'true'},
            {'a': 'null', 'b': 'false', 'c': 'true', 'result': 'true'},
            {'a': 'null', 'b': 'false', 'c': 'false', 'result': 'true'},
            {'a': 'null', 'b': 'false', 'c': 'null', 'result': 'true'},
            {'a': 'null', 'b': 'null', 'c': 'true', 'result': 'true'},
            {'a': 'null', 'b': 'null', 'c': 'false', 'result': 'true'},
            {'a': 'null', 'b': 'null', 'c': 'null', 'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-boolean5-5',
        feature_path='tck/features/expressions/boolean/Boolean5.feature',
        scenario='[5] Conjunction is distributive over exclusive disjunction on non-null',
        cypher='UNWIND [true, false] AS a\n      UNWIND [true, false] AS b\n      UNWIND [true, false] AS c\n      RETURN a, b, c, (a AND (b XOR c)) = ((a AND b) XOR (a AND c)) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'a': 'true', 'b': 'true', 'c': 'true', 'result': 'true'},
            {'a': 'true', 'b': 'true', 'c': 'false', 'result': 'true'},
            {'a': 'true', 'b': 'false', 'c': 'true', 'result': 'true'},
            {'a': 'true', 'b': 'false', 'c': 'false', 'result': 'true'},
            {'a': 'false', 'b': 'true', 'c': 'true', 'result': 'true'},
            {'a': 'false', 'b': 'true', 'c': 'false', 'result': 'true'},
            {'a': 'false', 'b': 'false', 'c': 'true', 'result': 'true'},
            {'a': 'false', 'b': 'false', 'c': 'false', 'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-boolean5-6',
        feature_path='tck/features/expressions/boolean/Boolean5.feature',
        scenario='[6] Conjunction is not distributive over exclusive disjunction on null',
        cypher='UNWIND [true, false, null] AS a\n      UNWIND [true, false, null] AS b\n      UNWIND [true, false, null] AS c\n      WITH a, b, c WHERE a IS NULL OR b IS NULL OR c IS NULL\n      RETURN a, b, c, (a AND (b XOR c)) IS NULL = ((a AND b) XOR (a AND c)) IS NULL AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'a': 'true', 'b': 'true', 'c': 'null', 'result': 'true'},
            {'a': 'true', 'b': 'false', 'c': 'null', 'result': 'true'},
            {'a': 'true', 'b': 'null', 'c': 'true', 'result': 'true'},
            {'a': 'true', 'b': 'null', 'c': 'false', 'result': 'true'},
            {'a': 'true', 'b': 'null', 'c': 'null', 'result': 'true'},
            {'a': 'false', 'b': 'true', 'c': 'null', 'result': 'true'},
            {'a': 'false', 'b': 'false', 'c': 'null', 'result': 'true'},
            {'a': 'false', 'b': 'null', 'c': 'true', 'result': 'true'},
            {'a': 'false', 'b': 'null', 'c': 'false', 'result': 'true'},
            {'a': 'false', 'b': 'null', 'c': 'null', 'result': 'true'},
            {'a': 'null', 'b': 'true', 'c': 'true', 'result': 'false'},
            {'a': 'null', 'b': 'true', 'c': 'false', 'result': 'true'},
            {'a': 'null', 'b': 'true', 'c': 'null', 'result': 'true'},
            {'a': 'null', 'b': 'false', 'c': 'true', 'result': 'true'},
            {'a': 'null', 'b': 'false', 'c': 'false', 'result': 'true'},
            {'a': 'null', 'b': 'false', 'c': 'null', 'result': 'true'},
            {'a': 'null', 'b': 'null', 'c': 'true', 'result': 'true'},
            {'a': 'null', 'b': 'null', 'c': 'false', 'result': 'true'},
            {'a': 'null', 'b': 'null', 'c': 'null', 'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-boolean5-7',
        feature_path='tck/features/expressions/boolean/Boolean5.feature',
        scenario="[7] De Morgan's law on non-null: the negation of a disjunction is the conjunction of the negations",
        cypher='UNWIND [true, false] AS a\n      UNWIND [true, false] AS b\n      RETURN a, b, NOT (a OR b) = (NOT (a) AND NOT (b)) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'a': 'true', 'b': 'true', 'result': 'true'},
            {'a': 'true', 'b': 'false', 'result': 'true'},
            {'a': 'false', 'b': 'true', 'result': 'true'},
            {'a': 'false', 'b': 'false', 'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-boolean5-8',
        feature_path='tck/features/expressions/boolean/Boolean5.feature',
        scenario="[8] De Morgan's law on non-null: the negation of a conjunction is the disjunction of the negations",
        cypher='UNWIND [true, false] AS a\n      UNWIND [true, false] AS b\n      RETURN a, b, NOT (a AND b) = (NOT (a) OR NOT (b)) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'a': 'true', 'b': 'true', 'result': 'true'},
            {'a': 'true', 'b': 'false', 'result': 'true'},
            {'a': 'false', 'b': 'true', 'result': 'true'},
            {'a': 'false', 'b': 'false', 'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'boolean', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-comparison1-1',
        feature_path='tck/features/expressions/comparison/Comparison1.feature',
        scenario='[1] Number-typed integer comparison',
        cypher='WITH collect([0, 0.0]) AS numbers\n      UNWIND numbers AS arr\n      WITH arr[0] AS expected\n      MATCH (n) WHERE toInteger(n.id) = expected\n      RETURN n',
        graph=graph_fixture_from_create(
            """
            CREATE ({id: 0})
            """
        ),
        expected=Expected(
            rows=[
            {'n': '({id: 0})'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'comparison', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-comparison1-2',
        feature_path='tck/features/expressions/comparison/Comparison1.feature',
        scenario='[2] Number-typed float comparison',
        cypher='WITH collect([0.5, 0]) AS numbers\n      UNWIND numbers AS arr\n      WITH arr[0] AS expected\n      MATCH (n) WHERE toInteger(n.id) = expected\n      RETURN n',
        graph=graph_fixture_from_create(
            """
            CREATE ({id: 0})
            """
        ),
        expected=Expected(
            rows=[

            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'comparison', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-comparison1-3',
        feature_path='tck/features/expressions/comparison/Comparison1.feature',
        scenario='[3] Any-typed string comparison',
        cypher="WITH collect(['0', 0]) AS things\n      UNWIND things AS arr\n      WITH arr[0] AS expected\n      MATCH (n) WHERE toInteger(n.id) = expected\n      RETURN n",
        graph=graph_fixture_from_create(
            """
            CREATE ({id: 0})
            """
        ),
        expected=Expected(
            rows=[

            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'comparison', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-comparison1-4',
        feature_path='tck/features/expressions/comparison/Comparison1.feature',
        scenario='[4] Comparing nodes to nodes',
        cypher='MATCH (a)\n      WITH a\n      MATCH (b)\n      WHERE a = b\n      RETURN count(b)',
        graph=graph_fixture_from_create(
            """
            CREATE ()
            """
        ),
        expected=Expected(
            rows=[
            {'count(b)': 1}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'comparison', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-comparison1-5',
        feature_path='tck/features/expressions/comparison/Comparison1.feature',
        scenario='[5] Comparing relationships to relationships',
        cypher='MATCH ()-[a]->()\n      WITH a\n      MATCH ()-[b]->()\n      WHERE a = b\n      RETURN count(b)',
        graph=graph_fixture_from_create(
            """
            CREATE ()-[:T]->()
            """
        ),
        expected=Expected(
            rows=[
            {'count(b)': 1}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'comparison', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-comparison1-6-1',
        feature_path='tck/features/expressions/comparison/Comparison1.feature',
        scenario='[6] Comparing lists to lists (example 1)',
        cypher='RETURN [1, 2] = [1] AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'comparison', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-comparison1-6-2',
        feature_path='tck/features/expressions/comparison/Comparison1.feature',
        scenario='[6] Comparing lists to lists (example 2)',
        cypher='RETURN [null] = [1] AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'comparison', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-comparison1-6-3',
        feature_path='tck/features/expressions/comparison/Comparison1.feature',
        scenario='[6] Comparing lists to lists (example 3)',
        cypher="RETURN ['a'] = [1] AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'comparison', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-comparison1-6-4',
        feature_path='tck/features/expressions/comparison/Comparison1.feature',
        scenario='[6] Comparing lists to lists (example 4)',
        cypher='RETURN [[1]] = [[1], [null]] AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'comparison', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-comparison1-6-5',
        feature_path='tck/features/expressions/comparison/Comparison1.feature',
        scenario='[6] Comparing lists to lists (example 5)',
        cypher='RETURN [[1], [2]] = [[1], [null]] AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'comparison', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-comparison1-6-6',
        feature_path='tck/features/expressions/comparison/Comparison1.feature',
        scenario='[6] Comparing lists to lists (example 6)',
        cypher='RETURN [[1], [2, 3]] = [[1], [null]] AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'comparison', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-comparison1-7-1',
        feature_path='tck/features/expressions/comparison/Comparison1.feature',
        scenario='[7] Comparing maps to maps (example 1)',
        cypher='RETURN {} = {} AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'comparison', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-comparison1-7-2',
        feature_path='tck/features/expressions/comparison/Comparison1.feature',
        scenario='[7] Comparing maps to maps (example 2)',
        cypher='RETURN {k: true} = {k: true} AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'comparison', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-comparison1-7-3',
        feature_path='tck/features/expressions/comparison/Comparison1.feature',
        scenario='[7] Comparing maps to maps (example 3)',
        cypher='RETURN {k: 1} = {k: 1} AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'comparison', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-comparison1-7-4',
        feature_path='tck/features/expressions/comparison/Comparison1.feature',
        scenario='[7] Comparing maps to maps (example 4)',
        cypher='RETURN {k: 1.0} = {k: 1.0} AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'comparison', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-comparison1-7-5',
        feature_path='tck/features/expressions/comparison/Comparison1.feature',
        scenario='[7] Comparing maps to maps (example 5)',
        cypher="RETURN {k: 'abc'} = {k: 'abc'} AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'comparison', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-comparison1-7-6',
        feature_path='tck/features/expressions/comparison/Comparison1.feature',
        scenario='[7] Comparing maps to maps (example 6)',
        cypher="RETURN {k: 'a', l: 2} = {k: 'a', l: 2} AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'comparison', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-comparison1-7-7',
        feature_path='tck/features/expressions/comparison/Comparison1.feature',
        scenario='[7] Comparing maps to maps (example 7)',
        cypher='RETURN {} = {k: null} AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'comparison', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-comparison1-7-8',
        feature_path='tck/features/expressions/comparison/Comparison1.feature',
        scenario='[7] Comparing maps to maps (example 8)',
        cypher='RETURN {k: null} = {} AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'comparison', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-comparison1-7-9',
        feature_path='tck/features/expressions/comparison/Comparison1.feature',
        scenario='[7] Comparing maps to maps (example 9)',
        cypher='RETURN {k: 1} = {k: 1, l: null} AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'comparison', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-comparison1-7-10',
        feature_path='tck/features/expressions/comparison/Comparison1.feature',
        scenario='[7] Comparing maps to maps (example 10)',
        cypher='RETURN {k: null, l: 1} = {l: 1} AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'comparison', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-comparison1-7-11',
        feature_path='tck/features/expressions/comparison/Comparison1.feature',
        scenario='[7] Comparing maps to maps (example 11)',
        cypher='RETURN {k: null} = {k: null, l: null} AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'comparison', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-comparison1-7-12',
        feature_path='tck/features/expressions/comparison/Comparison1.feature',
        scenario='[7] Comparing maps to maps (example 12)',
        cypher='RETURN {k: null} = {k: null} AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'comparison', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-comparison1-7-13',
        feature_path='tck/features/expressions/comparison/Comparison1.feature',
        scenario='[7] Comparing maps to maps (example 13)',
        cypher='RETURN {k: 1} = {k: null} AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'comparison', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-comparison1-7-14',
        feature_path='tck/features/expressions/comparison/Comparison1.feature',
        scenario='[7] Comparing maps to maps (example 14)',
        cypher='RETURN {k: 1, l: null} = {k: null, l: null} AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'comparison', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-comparison1-7-15',
        feature_path='tck/features/expressions/comparison/Comparison1.feature',
        scenario='[7] Comparing maps to maps (example 15)',
        cypher='RETURN {k: 1, l: null} = {k: null, l: 1} AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'comparison', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-comparison1-7-16',
        feature_path='tck/features/expressions/comparison/Comparison1.feature',
        scenario='[7] Comparing maps to maps (example 16)',
        cypher='RETURN {k: 1, l: null} = {k: 1, l: 1} AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'comparison', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-comparison1-8-1',
        feature_path='tck/features/expressions/comparison/Comparison1.feature',
        scenario='[8] Equality and inequality of NaN (example 1)',
        cypher='RETURN 0.0 / 0.0 = 1 AS isEqual, 0.0 / 0.0 <> 1 AS isNotEqual',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'isEqual': 'false', 'isNotEqual': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'comparison', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-comparison1-8-2',
        feature_path='tck/features/expressions/comparison/Comparison1.feature',
        scenario='[8] Equality and inequality of NaN (example 2)',
        cypher='RETURN 0.0 / 0.0 = 1.0 AS isEqual, 0.0 / 0.0 <> 1.0 AS isNotEqual',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'isEqual': 'false', 'isNotEqual': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'comparison', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-comparison1-8-3',
        feature_path='tck/features/expressions/comparison/Comparison1.feature',
        scenario='[8] Equality and inequality of NaN (example 3)',
        cypher='RETURN 0.0 / 0.0 = 0.0 / 0.0 AS isEqual, 0.0 / 0.0 <> 0.0 / 0.0 AS isNotEqual',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'isEqual': 'false', 'isNotEqual': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'comparison', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-comparison1-8-4',
        feature_path='tck/features/expressions/comparison/Comparison1.feature',
        scenario='[8] Equality and inequality of NaN (example 4)',
        cypher="RETURN 0.0 / 0.0 = 'a' AS isEqual, 0.0 / 0.0 <> 'a' AS isNotEqual",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'isEqual': 'false', 'isNotEqual': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'comparison', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-comparison1-9-1',
        feature_path='tck/features/expressions/comparison/Comparison1.feature',
        scenario='[9] Equality between strings and numbers (example 1)',
        cypher='RETURN 1.0 = 1.0 AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'comparison', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-comparison1-9-2',
        feature_path='tck/features/expressions/comparison/Comparison1.feature',
        scenario='[9] Equality between strings and numbers (example 2)',
        cypher='RETURN 1 = 1.0 AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'comparison', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-comparison1-9-3',
        feature_path='tck/features/expressions/comparison/Comparison1.feature',
        scenario='[9] Equality between strings and numbers (example 3)',
        cypher="RETURN '1.0' = 1.0 AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'comparison', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-comparison1-9-4',
        feature_path='tck/features/expressions/comparison/Comparison1.feature',
        scenario='[9] Equality between strings and numbers (example 4)',
        cypher="RETURN '1' = 1 AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'comparison', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-comparison1-10',
        feature_path='tck/features/expressions/comparison/Comparison1.feature',
        scenario='[10] Handling inlined equality of large integer',
        cypher='MATCH (p:TheLabel {id: 4611686018427387905})\n      RETURN p.id',
        graph=graph_fixture_from_create(
            """
            CREATE (:TheLabel {id: 4611686018427387905})
            """
        ),
        expected=Expected(
            rows=[
            {'p.id': 4611686018427387905}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'comparison', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-comparison1-11',
        feature_path='tck/features/expressions/comparison/Comparison1.feature',
        scenario='[11] Handling explicit equality of large integer',
        cypher='MATCH (p:TheLabel)\n      WHERE p.id = 4611686018427387905\n      RETURN p.id',
        graph=graph_fixture_from_create(
            """
            CREATE (:TheLabel {id: 4611686018427387905})
            """
        ),
        expected=Expected(
            rows=[
            {'p.id': 4611686018427387905}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'comparison', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-comparison1-12',
        feature_path='tck/features/expressions/comparison/Comparison1.feature',
        scenario='[12] Handling inlined equality of large integer, non-equal values',
        cypher='MATCH (p:TheLabel {id : 4611686018427387900})\n      RETURN p.id',
        graph=graph_fixture_from_create(
            """
            CREATE (:TheLabel {id: 4611686018427387905})
            """
        ),
        expected=Expected(
            rows=[

            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'comparison', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-comparison1-13',
        feature_path='tck/features/expressions/comparison/Comparison1.feature',
        scenario='[13] Handling explicit equality of large integer, non-equal values',
        cypher='MATCH (p:TheLabel)\n      WHERE p.id = 4611686018427387900\n      RETURN p.id',
        graph=graph_fixture_from_create(
            """
            CREATE (:TheLabel {id: 4611686018427387905})
            """
        ),
        expected=Expected(
            rows=[

            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'comparison', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-comparison1-14',
        feature_path='tck/features/expressions/comparison/Comparison1.feature',
        scenario='[14] Direction of traversed relationship is not significant for path equality, simple',
        cypher='MATCH p1 = (:A)-->()\n      MATCH p2 = (:A)<--()\n      RETURN p1 = p2',
        graph=graph_fixture_from_create(
            """
            CREATE (n:A)-[:LOOP]->(n)
            """
        ),
        expected=Expected(
            rows=[
            {'p1 = p2': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'comparison', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-comparison1-15',
        feature_path='tck/features/expressions/comparison/Comparison1.feature',
        scenario='[15] It is unknown - i.e. null - if a null is equal to a null',
        cypher='RETURN null = null AS value',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'value': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'comparison', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-comparison1-16',
        feature_path='tck/features/expressions/comparison/Comparison1.feature',
        scenario='[16] It is unknown - i.e. null - if a null is not equal to a null',
        cypher='RETURN null <> null AS value',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'value': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'comparison', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-comparison1-17',
        feature_path='tck/features/expressions/comparison/Comparison1.feature',
        scenario='[17] Failing when comparing to an undefined variable',
        cypher='MATCH (s)\n      WHERE s.name = undefinedVariable\n        AND s.age = 10\n      RETURN s',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'comparison', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-comparison2-1',
        feature_path='tck/features/expressions/comparison/Comparison2.feature',
        scenario="[1] Comparing strings and integers using > in an AND'd predicate",
        cypher="MATCH (:Root)-->(i:Child)\n      WHERE i.var IS NOT NULL AND i.var > 'x'\n      RETURN i.var",
        graph=graph_fixture_from_create(
            """
            CREATE (root:Root)-[:T]->(:Child {var: 0}),
                         (root)-[:T]->(:Child {var: 'xx'}),
                         (root)-[:T]->(:Child)
            """
        ),
        expected=Expected(
            rows=[
            {'i.var': "'xx'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'comparison', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-comparison2-2',
        feature_path='tck/features/expressions/comparison/Comparison2.feature',
        scenario="[2] Comparing strings and integers using > in a OR'd predicate",
        cypher="MATCH (:Root)-->(i:Child)\n      WHERE i.var IS NULL OR i.var > 'x'\n      RETURN i.var",
        graph=graph_fixture_from_create(
            """
            CREATE (root:Root)-[:T]->(:Child {var: 0}),
                         (root)-[:T]->(:Child {var: 'xx'}),
                         (root)-[:T]->(:Child)
            """
        ),
        expected=Expected(
            rows=[
            {'i.var': "'xx'"},
            {'i.var': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'comparison', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-comparison2-3-1',
        feature_path='tck/features/expressions/comparison/Comparison2.feature',
        scenario='[3] Comparing across types yields null, except numbers (example 1)',
        cypher="MATCH p = (n)-[r]->()\n      WITH [n, r, p, '', 1, 3.14, true, null, [], {}] AS types\n      UNWIND range(0, size(types) - 1) AS i\n      UNWIND range(0, size(types) - 1) AS j\n      WITH types[i] AS lhs, types[j] AS rhs\n      WHERE i <> j\n      WITH lhs, rhs, lhs < rhs AS result\n      WHERE result\n      RETURN lhs, rhs",
        graph=graph_fixture_from_create(
            """
            CREATE ()-[:T]->()
            """
        ),
        expected=Expected(
            rows=[
            {'lhs': 1, 'rhs': 3.14}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'comparison', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-comparison2-3-2',
        feature_path='tck/features/expressions/comparison/Comparison2.feature',
        scenario='[3] Comparing across types yields null, except numbers (example 2)',
        cypher="MATCH p = (n)-[r]->()\n      WITH [n, r, p, '', 1, 3.14, true, null, [], {}] AS types\n      UNWIND range(0, size(types) - 1) AS i\n      UNWIND range(0, size(types) - 1) AS j\n      WITH types[i] AS lhs, types[j] AS rhs\n      WHERE i <> j\n      WITH lhs, rhs, lhs <= rhs AS result\n      WHERE result\n      RETURN lhs, rhs",
        graph=graph_fixture_from_create(
            """
            CREATE ()-[:T]->()
            """
        ),
        expected=Expected(
            rows=[
            {'lhs': 1, 'rhs': 3.14}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'comparison', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-comparison2-3-3',
        feature_path='tck/features/expressions/comparison/Comparison2.feature',
        scenario='[3] Comparing across types yields null, except numbers (example 3)',
        cypher="MATCH p = (n)-[r]->()\n      WITH [n, r, p, '', 1, 3.14, true, null, [], {}] AS types\n      UNWIND range(0, size(types) - 1) AS i\n      UNWIND range(0, size(types) - 1) AS j\n      WITH types[i] AS lhs, types[j] AS rhs\n      WHERE i <> j\n      WITH lhs, rhs, lhs >= rhs AS result\n      WHERE result\n      RETURN lhs, rhs",
        graph=graph_fixture_from_create(
            """
            CREATE ()-[:T]->()
            """
        ),
        expected=Expected(
            rows=[
            {'lhs': 3.14, 'rhs': 1}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'comparison', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-comparison2-3-4',
        feature_path='tck/features/expressions/comparison/Comparison2.feature',
        scenario='[3] Comparing across types yields null, except numbers (example 4)',
        cypher="MATCH p = (n)-[r]->()\n      WITH [n, r, p, '', 1, 3.14, true, null, [], {}] AS types\n      UNWIND range(0, size(types) - 1) AS i\n      UNWIND range(0, size(types) - 1) AS j\n      WITH types[i] AS lhs, types[j] AS rhs\n      WHERE i <> j\n      WITH lhs, rhs, lhs > rhs AS result\n      WHERE result\n      RETURN lhs, rhs",
        graph=graph_fixture_from_create(
            """
            CREATE ()-[:T]->()
            """
        ),
        expected=Expected(
            rows=[
            {'lhs': 3.14, 'rhs': 1}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'comparison', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-comparison2-4-1',
        feature_path='tck/features/expressions/comparison/Comparison2.feature',
        scenario='[4] Comparing lists (example 1)',
        cypher='RETURN [1, 0] >= [1] AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'comparison', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-comparison2-4-2',
        feature_path='tck/features/expressions/comparison/Comparison2.feature',
        scenario='[4] Comparing lists (example 2)',
        cypher='RETURN [1, null] >= [1] AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'comparison', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-comparison2-4-3',
        feature_path='tck/features/expressions/comparison/Comparison2.feature',
        scenario='[4] Comparing lists (example 3)',
        cypher='RETURN [1, 2] >= [1, null] AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'comparison', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-comparison2-4-4',
        feature_path='tck/features/expressions/comparison/Comparison2.feature',
        scenario='[4] Comparing lists (example 4)',
        cypher="RETURN [1, 'a'] >= [1, null] AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'comparison', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-comparison2-4-5',
        feature_path='tck/features/expressions/comparison/Comparison2.feature',
        scenario='[4] Comparing lists (example 5)',
        cypher='RETURN [1, 2] >= [3, null] AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'comparison', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-comparison2-5-1',
        feature_path='tck/features/expressions/comparison/Comparison2.feature',
        scenario='[5] Comparing NaN (example 1)',
        cypher='RETURN 0.0 / 0.0 > 1 AS gt, 0.0 / 0.0 >= 1 AS gtE, 0.0 / 0.0 < <rhs> AS lt, 0.0 / 0.0 <= <rhs> AS ltE',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'gt': 'false', 'gtE': 'false', 'lt': 'false', 'ltE': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'comparison', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-comparison2-5-2',
        feature_path='tck/features/expressions/comparison/Comparison2.feature',
        scenario='[5] Comparing NaN (example 2)',
        cypher='RETURN 0.0 / 0.0 > 1.0 AS gt, 0.0 / 0.0 >= 1.0 AS gtE, 0.0 / 0.0 < <rhs> AS lt, 0.0 / 0.0 <= <rhs> AS ltE',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'gt': 'false', 'gtE': 'false', 'lt': 'false', 'ltE': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'comparison', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-comparison2-5-3',
        feature_path='tck/features/expressions/comparison/Comparison2.feature',
        scenario='[5] Comparing NaN (example 3)',
        cypher='RETURN 0.0 / 0.0 > 0.0 / 0.0 AS gt, 0.0 / 0.0 >= 0.0 / 0.0 AS gtE, 0.0 / 0.0 < <rhs> AS lt, 0.0 / 0.0 <= <rhs> AS ltE',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'gt': 'false', 'gtE': 'false', 'lt': 'false', 'ltE': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'comparison', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-comparison2-5-4',
        feature_path='tck/features/expressions/comparison/Comparison2.feature',
        scenario='[5] Comparing NaN (example 4)',
        cypher="RETURN 0.0 / 0.0 > 'a' AS gt, 0.0 / 0.0 >= 'a' AS gtE, 0.0 / 0.0 < <rhs> AS lt, 0.0 / 0.0 <= <rhs> AS ltE",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'gt': 'null', 'gtE': 'null', 'lt': 'null', 'ltE': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'comparison', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-comparison2-6-1',
        feature_path='tck/features/expressions/comparison/Comparison2.feature',
        scenario='[6] Comparability between numbers and strings (example 1)',
        cypher='RETURN 1.0 < <rhs> AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'comparison', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-comparison2-6-2',
        feature_path='tck/features/expressions/comparison/Comparison2.feature',
        scenario='[6] Comparability between numbers and strings (example 2)',
        cypher='RETURN 1 < <rhs> AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'comparison', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-comparison2-6-3',
        feature_path='tck/features/expressions/comparison/Comparison2.feature',
        scenario='[6] Comparability between numbers and strings (example 3)',
        cypher="RETURN '1.0' < <rhs> AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'comparison', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-comparison2-6-4',
        feature_path='tck/features/expressions/comparison/Comparison2.feature',
        scenario='[6] Comparability between numbers and strings (example 4)',
        cypher="RETURN '1' < <rhs> AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'comparison', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-comparison3-1',
        feature_path='tck/features/expressions/comparison/Comparison3.feature',
        scenario='[1] Handling numerical ranges 1',
        cypher='MATCH (n)\n      WHERE 1 < n.num < 3\n      RETURN n.num',
        graph=graph_fixture_from_create(
            """
            UNWIND [1, 2, 3] AS i
                  CREATE ({num: i})
            """
        ),
        expected=Expected(
            rows=[
            {'n.num': 2}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'comparison', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-comparison3-2',
        feature_path='tck/features/expressions/comparison/Comparison3.feature',
        scenario='[2] Handling numerical ranges 2',
        cypher='MATCH (n)\n      WHERE 1 < n.num <= 3\n      RETURN n.num',
        graph=graph_fixture_from_create(
            """
            UNWIND [1, 2, 3] AS i
                  CREATE ({num: i})
            """
        ),
        expected=Expected(
            rows=[
            {'n.num': 2},
            {'n.num': 3}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'comparison', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-comparison3-3',
        feature_path='tck/features/expressions/comparison/Comparison3.feature',
        scenario='[3] Handling numerical ranges 3',
        cypher='MATCH (n)\n      WHERE 1 <= n.num < 3\n      RETURN n.num',
        graph=graph_fixture_from_create(
            """
            UNWIND [1, 2, 3] AS i
                  CREATE ({num: i})
            """
        ),
        expected=Expected(
            rows=[
            {'n.num': 1},
            {'n.num': 2}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'comparison', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-comparison3-4',
        feature_path='tck/features/expressions/comparison/Comparison3.feature',
        scenario='[4] Handling numerical ranges 4',
        cypher='MATCH (n)\n      WHERE 1 <= n.num <= 3\n      RETURN n.num',
        graph=graph_fixture_from_create(
            """
            UNWIND [1, 2, 3] AS i
                  CREATE ({num: i})
            """
        ),
        expected=Expected(
            rows=[
            {'n.num': 1},
            {'n.num': 2},
            {'n.num': 3}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'comparison', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-comparison3-5',
        feature_path='tck/features/expressions/comparison/Comparison3.feature',
        scenario='[5] Handling string ranges 1',
        cypher="MATCH (n)\n      WHERE 'a' < n.name < 'c'\n      RETURN n.name",
        graph=graph_fixture_from_create(
            """
            UNWIND ['a', 'b', 'c'] AS c
                  CREATE ({name: c})
            """
        ),
        expected=Expected(
            rows=[
            {'n.name': "'b'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'comparison', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-comparison3-6',
        feature_path='tck/features/expressions/comparison/Comparison3.feature',
        scenario='[6] Handling string ranges 2',
        cypher="MATCH (n)\n      WHERE 'a' < n.name <= 'c'\n      RETURN n.name",
        graph=graph_fixture_from_create(
            """
            UNWIND ['a', 'b', 'c'] AS c
                  CREATE ({name: c})
            """
        ),
        expected=Expected(
            rows=[
            {'n.name': "'b'"},
            {'n.name': "'c'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'comparison', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-comparison3-7',
        feature_path='tck/features/expressions/comparison/Comparison3.feature',
        scenario='[7] Handling string ranges 3',
        cypher="MATCH (n)\n      WHERE 'a' <= n.name < 'c'\n      RETURN n.name",
        graph=graph_fixture_from_create(
            """
            UNWIND ['a', 'b', 'c'] AS c
                  CREATE ({name: c})
            """
        ),
        expected=Expected(
            rows=[
            {'n.name': "'a'"},
            {'n.name': "'b'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'comparison', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-comparison3-8',
        feature_path='tck/features/expressions/comparison/Comparison3.feature',
        scenario='[8] Handling string ranges 4',
        cypher="MATCH (n)\n      WHERE 'a' <= n.name <= 'c'\n      RETURN n.name",
        graph=graph_fixture_from_create(
            """
            UNWIND ['a', 'b', 'c'] AS c
                  CREATE ({name: c})
            """
        ),
        expected=Expected(
            rows=[
            {'n.name': "'a'"},
            {'n.name': "'b'"},
            {'n.name': "'c'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'comparison', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-comparison3-9',
        feature_path='tck/features/expressions/comparison/Comparison3.feature',
        scenario='[9] Handling empty range',
        cypher='MATCH (n)\n      WHERE 10 < n.num <= 3\n      RETURN n.num',
        graph=graph_fixture_from_create(
            """
            CREATE ({num: 3})
            """
        ),
        expected=Expected(
            rows=[

            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'comparison', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-comparison4-1',
        feature_path='tck/features/expressions/comparison/Comparison4.feature',
        scenario='[1] Handling long chains of operators',
        cypher='MATCH (n)-->(m)\n      WHERE n.prop1 < m.prop1 = n.prop2 <> m.prop2\n      RETURN labels(m)',
        graph=graph_fixture_from_create(
            """
            CREATE (a:A {prop1: 3, prop2: 4})
                  CREATE (b:B {prop1: 4, prop2: 5})
                  CREATE (c:C {prop1: 4, prop2: 4})
                  CREATE (a)-[:R]->(b)
                  CREATE (b)-[:R]->(c)
                  CREATE (c)-[:R]->(a)
            """
        ),
        expected=Expected(
            rows=[
            {'labels(m)': "['B']"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'comparison', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-conditional1-1',
        feature_path='tck/features/expressions/conditional/Conditional1.feature',
        scenario='[1] Run coalesce',
        cypher='MATCH (a)\n      RETURN coalesce(a.title, a.name)',
        graph=graph_fixture_from_create(
            """
            CREATE ({name: 'Emil Eifrem', title: 'CEO'}), ({name: 'Nobody'})
            """
        ),
        expected=Expected(
            rows=[
            {'coalesce(a.title, a.name)': "'CEO'"},
            {'coalesce(a.title, a.name)': "'Nobody'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'conditional', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-conditional2-1-1',
        feature_path='tck/features/expressions/conditional/Conditional2.feature',
        scenario='[1] Simple cases over integers (example 1)',
        cypher="RETURN CASE -10\n          WHEN -10 THEN 'minus ten'\n          WHEN 0 THEN 'zero'\n          WHEN 1 THEN 'one'\n          WHEN 5 THEN 'five'\n          WHEN 10 THEN 'ten'\n          WHEN 3000 THEN 'three thousand'\n          ELSE 'something else'\n        END AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'minus ten'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'conditional', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-conditional2-1-2',
        feature_path='tck/features/expressions/conditional/Conditional2.feature',
        scenario='[1] Simple cases over integers (example 2)',
        cypher="RETURN CASE 0\n          WHEN -10 THEN 'minus ten'\n          WHEN 0 THEN 'zero'\n          WHEN 1 THEN 'one'\n          WHEN 5 THEN 'five'\n          WHEN 10 THEN 'ten'\n          WHEN 3000 THEN 'three thousand'\n          ELSE 'something else'\n        END AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'zero'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'conditional', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-conditional2-1-3',
        feature_path='tck/features/expressions/conditional/Conditional2.feature',
        scenario='[1] Simple cases over integers (example 3)',
        cypher="RETURN CASE 1\n          WHEN -10 THEN 'minus ten'\n          WHEN 0 THEN 'zero'\n          WHEN 1 THEN 'one'\n          WHEN 5 THEN 'five'\n          WHEN 10 THEN 'ten'\n          WHEN 3000 THEN 'three thousand'\n          ELSE 'something else'\n        END AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'one'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'conditional', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-conditional2-1-4',
        feature_path='tck/features/expressions/conditional/Conditional2.feature',
        scenario='[1] Simple cases over integers (example 4)',
        cypher="RETURN CASE 5\n          WHEN -10 THEN 'minus ten'\n          WHEN 0 THEN 'zero'\n          WHEN 1 THEN 'one'\n          WHEN 5 THEN 'five'\n          WHEN 10 THEN 'ten'\n          WHEN 3000 THEN 'three thousand'\n          ELSE 'something else'\n        END AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'five'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'conditional', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-conditional2-1-5',
        feature_path='tck/features/expressions/conditional/Conditional2.feature',
        scenario='[1] Simple cases over integers (example 5)',
        cypher="RETURN CASE 10\n          WHEN -10 THEN 'minus ten'\n          WHEN 0 THEN 'zero'\n          WHEN 1 THEN 'one'\n          WHEN 5 THEN 'five'\n          WHEN 10 THEN 'ten'\n          WHEN 3000 THEN 'three thousand'\n          ELSE 'something else'\n        END AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'ten'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'conditional', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-conditional2-1-6',
        feature_path='tck/features/expressions/conditional/Conditional2.feature',
        scenario='[1] Simple cases over integers (example 6)',
        cypher="RETURN CASE 3000\n          WHEN -10 THEN 'minus ten'\n          WHEN 0 THEN 'zero'\n          WHEN 1 THEN 'one'\n          WHEN 5 THEN 'five'\n          WHEN 10 THEN 'ten'\n          WHEN 3000 THEN 'three thousand'\n          ELSE 'something else'\n        END AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'three thousand'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'conditional', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-conditional2-1-7',
        feature_path='tck/features/expressions/conditional/Conditional2.feature',
        scenario='[1] Simple cases over integers (example 7)',
        cypher="RETURN CASE -30\n          WHEN -10 THEN 'minus ten'\n          WHEN 0 THEN 'zero'\n          WHEN 1 THEN 'one'\n          WHEN 5 THEN 'five'\n          WHEN 10 THEN 'ten'\n          WHEN 3000 THEN 'three thousand'\n          ELSE 'something else'\n        END AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'something else'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'conditional', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-conditional2-1-8',
        feature_path='tck/features/expressions/conditional/Conditional2.feature',
        scenario='[1] Simple cases over integers (example 8)',
        cypher="RETURN CASE 3\n          WHEN -10 THEN 'minus ten'\n          WHEN 0 THEN 'zero'\n          WHEN 1 THEN 'one'\n          WHEN 5 THEN 'five'\n          WHEN 10 THEN 'ten'\n          WHEN 3000 THEN 'three thousand'\n          ELSE 'something else'\n        END AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'something else'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'conditional', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-conditional2-1-9',
        feature_path='tck/features/expressions/conditional/Conditional2.feature',
        scenario='[1] Simple cases over integers (example 9)',
        cypher="RETURN CASE 3001\n          WHEN -10 THEN 'minus ten'\n          WHEN 0 THEN 'zero'\n          WHEN 1 THEN 'one'\n          WHEN 5 THEN 'five'\n          WHEN 10 THEN 'ten'\n          WHEN 3000 THEN 'three thousand'\n          ELSE 'something else'\n        END AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'something else'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'conditional', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-conditional2-1-10',
        feature_path='tck/features/expressions/conditional/Conditional2.feature',
        scenario='[1] Simple cases over integers (example 10)',
        cypher="RETURN CASE '0'\n          WHEN -10 THEN 'minus ten'\n          WHEN 0 THEN 'zero'\n          WHEN 1 THEN 'one'\n          WHEN 5 THEN 'five'\n          WHEN 10 THEN 'ten'\n          WHEN 3000 THEN 'three thousand'\n          ELSE 'something else'\n        END AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'something else'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'conditional', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-conditional2-1-11',
        feature_path='tck/features/expressions/conditional/Conditional2.feature',
        scenario='[1] Simple cases over integers (example 11)',
        cypher="RETURN CASE true\n          WHEN -10 THEN 'minus ten'\n          WHEN 0 THEN 'zero'\n          WHEN 1 THEN 'one'\n          WHEN 5 THEN 'five'\n          WHEN 10 THEN 'ten'\n          WHEN 3000 THEN 'three thousand'\n          ELSE 'something else'\n        END AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'something else'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'conditional', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-conditional2-1-12',
        feature_path='tck/features/expressions/conditional/Conditional2.feature',
        scenario='[1] Simple cases over integers (example 12)',
        cypher="RETURN CASE 10.1\n          WHEN -10 THEN 'minus ten'\n          WHEN 0 THEN 'zero'\n          WHEN 1 THEN 'one'\n          WHEN 5 THEN 'five'\n          WHEN 10 THEN 'ten'\n          WHEN 3000 THEN 'three thousand'\n          ELSE 'something else'\n        END AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'something else'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'conditional', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-existentialsubquery1-1',
        feature_path='tck/features/expressions/existentialSubqueries/ExistentialSubquery1.feature',
        scenario='[1] Simple subquery without WHERE clause',
        cypher='MATCH (n) WHERE exists {\n        (n)-->()\n      }\n      RETURN n',
        graph=graph_fixture_from_create(
            """
            CREATE (a:A {prop: 1})-[:R]->(b:B {prop: 1}), 
                         (a)-[:R]->(:C {prop: 2}), 
                         (a)-[:R]->(:D {prop: 3})
            """
        ),
        expected=Expected(
            rows=[
            {'n': '(:A {prop:1})'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'existentialSubqueries', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-existentialsubquery1-2',
        feature_path='tck/features/expressions/existentialSubqueries/ExistentialSubquery1.feature',
        scenario='[2] Simple subquery with WHERE clause',
        cypher='MATCH (n) WHERE exists {\n        (n)-->(m) WHERE n.prop = m.prop\n      }\n      RETURN n',
        graph=graph_fixture_from_create(
            """
            CREATE (a:A {prop: 1})-[:R]->(b:B {prop: 1}), 
                         (a)-[:R]->(:C {prop: 2}), 
                         (a)-[:R]->(:D {prop: 3}), 
                         (b)-[:R]->(d)
            """
        ),
        expected=Expected(
            rows=[
            {'n': '(:A {prop:1})'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'existentialSubqueries', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-existentialsubquery1-3',
        feature_path='tck/features/expressions/existentialSubqueries/ExistentialSubquery1.feature',
        scenario='[3] Simple subquery without WHERE clause, not existing pattern',
        cypher='MATCH (n) WHERE exists {\n        (n)-[:NA]->()\n      }\n      RETURN n',
        graph=graph_fixture_from_create(
            """
            CREATE (a:A {prop: 1})-[:R]->(b:B {prop: 1}), 
                         (a)-[:R]->(:C {prop: 2}), 
                         (a)-[:R]->(:D {prop: 3})
            """
        ),
        expected=Expected(
            rows=[

            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'existentialSubqueries', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-existentialsubquery1-4',
        feature_path='tck/features/expressions/existentialSubqueries/ExistentialSubquery1.feature',
        scenario='[4] Simple subquery with WHERE clause, not existing pattern',
        cypher="MATCH (n) WHERE exists {\n        (n)-[r]->() WHERE type(r) = 'NA'\n      }\n      RETURN n",
        graph=graph_fixture_from_create(
            """
            CREATE (a:A {prop: 1})-[:R]->(b:B {prop: 1}), 
                         (a)-[:R]->(:C {prop: 2}), 
                         (a)-[:R]->(:D {prop: 3})
            """
        ),
        expected=Expected(
            rows=[

            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'existentialSubqueries', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-existentialsubquery2-1',
        feature_path='tck/features/expressions/existentialSubqueries/ExistentialSubquery2.feature',
        scenario='[1] Full existential subquery',
        cypher='MATCH (n) WHERE exists {\n        MATCH (n)-->()\n        RETURN true\n      }\n      RETURN n',
        graph=graph_fixture_from_create(
            """
            CREATE (a:A {prop: 1})-[:R]->(b:B {prop: 1}), 
                         (a)-[:R]->(:C {prop: 2}), 
                         (a)-[:R]->(:D {prop: 3})
            """
        ),
        expected=Expected(
            rows=[
            {'n': '(:A {prop:1})'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'existentialSubqueries', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-existentialsubquery2-2',
        feature_path='tck/features/expressions/existentialSubqueries/ExistentialSubquery2.feature',
        scenario='[2] Full existential subquery with aggregation',
        cypher='MATCH (n) WHERE exists {\n        MATCH (n)-->(m)\n        WITH n, count(*) AS numConnections\n        WHERE numConnections = 3\n        RETURN true\n      }\n      RETURN n',
        graph=graph_fixture_from_create(
            """
            CREATE (a:A {prop: 1})-[:R]->(b:B {prop: 1}), 
                         (a)-[:R]->(:C {prop: 2}), 
                         (a)-[:R]->(d:D {prop: 3}), 
                         (b)-[:R]->(d)
            """
        ),
        expected=Expected(
            rows=[
            {'n': '(:A {prop:1})'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'existentialSubqueries', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-existentialsubquery2-3',
        feature_path='tck/features/expressions/existentialSubqueries/ExistentialSubquery2.feature',
        scenario='[3] Full existential subquery with update clause should fail',
        cypher="MATCH (n) WHERE exists {\n        MATCH (n)-->(m)\n        SET m.prop='fail'\n      }\n      RETURN n",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'existentialSubqueries', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-existentialsubquery3-1',
        feature_path='tck/features/expressions/existentialSubqueries/ExistentialSubquery3.feature',
        scenario='[1] Nested simple existential subquery',
        cypher='MATCH (n) WHERE exists {\n        MATCH (m) WHERE exists {\n          (n)-[]->(m) WHERE n.prop = m.prop\n        }\n        RETURN true\n      }\n      RETURN n',
        graph=graph_fixture_from_create(
            """
            CREATE (a:A {prop: 1})-[:R]->(b:B {prop: 1}), 
                         (a)-[:R]->(:C {prop: 2}), 
                         (a)-[:R]->(:D {prop: 3})
            """
        ),
        expected=Expected(
            rows=[
            {'n': '(:A {prop:1})'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'existentialSubqueries', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-existentialsubquery3-2',
        feature_path='tck/features/expressions/existentialSubqueries/ExistentialSubquery3.feature',
        scenario='[2] Nested full existential subquery',
        cypher='MATCH (n) WHERE exists {\n        MATCH (m) WHERE exists {\n          MATCH (l)<-[:R]-(n)-[:R]->(m) RETURN true\n        }\n        RETURN true\n      }\n      RETURN n',
        graph=graph_fixture_from_create(
            """
            CREATE (a:A {prop: 1})-[:R]->(b:B {prop: 1}), 
                         (a)-[:R]->(:C {prop: 2}), 
                         (a)-[:R]->(:D {prop: 3})
            """
        ),
        expected=Expected(
            rows=[
            {'n': '(:A {prop:1})'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'existentialSubqueries', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-existentialsubquery3-3',
        feature_path='tck/features/expressions/existentialSubqueries/ExistentialSubquery3.feature',
        scenario='[3] Nested full existential subquery with pattern predicate',
        cypher='MATCH (n) WHERE exists {\n        MATCH (m) WHERE exists {\n          MATCH (l) WHERE (l)<-[:R]-(n)-[:R]->(m) RETURN true\n        }\n        RETURN true\n      }\n      RETURN n',
        graph=graph_fixture_from_create(
            """
            CREATE (a:A {prop: 1})-[:R]->(b:B {prop: 1}), 
                         (a)-[:R]->(:C {prop: 2}), 
                         (a)-[:R]->(:D {prop: 3})
            """
        ),
        expected=Expected(
            rows=[
            {'n': '(:A {prop:1})'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'existentialSubqueries', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-graph3-1',
        feature_path='tck/features/expressions/graph/Graph3.feature',
        scenario='[1] Creating node without label',
        cypher='CREATE (node)\n      RETURN labels(node)',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'labels(node)': '[]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'graph', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-graph3-2',
        feature_path='tck/features/expressions/graph/Graph3.feature',
        scenario='[2] Creating node with two labels',
        cypher="CREATE (node:Foo:Bar {name: 'Mattias'})\n      RETURN labels(node)",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'labels(node)': "['Foo', 'Bar']"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'graph', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-graph3-3',
        feature_path='tck/features/expressions/graph/Graph3.feature',
        scenario='[3] Ignore space when creating node with labels',
        cypher='CREATE (node :Foo:Bar)\n      RETURN labels(node)',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'labels(node)': "['Foo', 'Bar']"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'graph', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-graph3-4',
        feature_path='tck/features/expressions/graph/Graph3.feature',
        scenario='[4] Create node with label in pattern',
        cypher='CREATE (n:Person)-[:OWNS]->(:Dog)\n      RETURN labels(n)',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'labels(n)': "['Person']"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'graph', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-graph3-5',
        feature_path='tck/features/expressions/graph/Graph3.feature',
        scenario='[5] Using `labels()` in return clauses',
        cypher='MATCH (n)\n      RETURN labels(n)',
        graph=graph_fixture_from_create(
            """
            CREATE ()
            """
        ),
        expected=Expected(
            rows=[
            {'labels(n)': '[]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'graph', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-graph3-6',
        feature_path='tck/features/expressions/graph/Graph3.feature',
        scenario='[6] `labels()` should accept type Any',
        cypher='MATCH (a)\n      WITH [a, 1] AS list\n      RETURN labels(list[0]) AS l',
        graph=graph_fixture_from_create(
            """
            CREATE (:Foo), (:Foo:Bar)
            """
        ),
        expected=Expected(
            rows=[
            {'l': "['Foo']"},
            {'l': "['Foo', 'Bar']"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'graph', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-graph3-7',
        feature_path='tck/features/expressions/graph/Graph3.feature',
        scenario='[7] `labels()` on null node',
        cypher='OPTIONAL MATCH (n:DoesNotExist)\n      RETURN labels(n), labels(null)',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'labels(n)': 'null', 'labels(null)': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'graph', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-graph3-8',
        feature_path='tck/features/expressions/graph/Graph3.feature',
        scenario='[8] `labels()` failing on a path',
        cypher='MATCH p = (a)\n      RETURN labels(p) AS l',
        graph=graph_fixture_from_create(
            """
            CREATE (:Foo), (:Foo:Bar)
            """
        ),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'graph', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-graph3-9',
        feature_path='tck/features/expressions/graph/Graph3.feature',
        scenario='[9] `labels()` failing on invalid arguments',
        cypher='MATCH (a)\n      WITH [a, 1] AS list\n      RETURN labels(list[1]) AS l',
        graph=graph_fixture_from_create(
            """
            CREATE (:Foo), (:Foo:Bar)
            """
        ),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Runtime error semantics are not supported',
        tags=('expr', 'graph', 'meta-xfail', 'runtime-error', 'xfail'),
    ),
    Scenario(
        key='expr-graph4-1',
        feature_path='tck/features/expressions/graph/Graph4.feature',
        scenario='[1] `type()`',
        cypher='MATCH ()-[r]->()\n      RETURN type(r)',
        graph=graph_fixture_from_create(
            """
            CREATE ()-[:T]->()
            """
        ),
        expected=Expected(
            rows=[
            {'type(r)': "'T'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'graph', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-graph4-2',
        feature_path='tck/features/expressions/graph/Graph4.feature',
        scenario='[2] `type()` on two relationships',
        cypher='MATCH ()-[r1]->()-[r2]->()\n      RETURN type(r1), type(r2)',
        graph=graph_fixture_from_create(
            """
            CREATE ()-[:T1]->()-[:T2]->()
            """
        ),
        expected=Expected(
            rows=[
            {'type(r1)': "'T1'", 'type(r2)': "'T2'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'graph', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-graph4-3',
        feature_path='tck/features/expressions/graph/Graph4.feature',
        scenario='[3] `type()` on null relationship',
        cypher='MATCH (a)\n      OPTIONAL MATCH (a)-[r:NOT_THERE]->()\n      RETURN type(r), type(null)',
        graph=graph_fixture_from_create(
            """
            CREATE ()
            """
        ),
        expected=Expected(
            rows=[
            {'type(r)': 'null', 'type(null)': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'graph', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-graph4-4',
        feature_path='tck/features/expressions/graph/Graph4.feature',
        scenario='[4] `type()` on mixed null and non-null relationships',
        cypher='MATCH (a)\n      OPTIONAL MATCH (a)-[r:T]->()\n      RETURN type(r)',
        graph=graph_fixture_from_create(
            """
            CREATE ()-[:T]->()
            """
        ),
        expected=Expected(
            rows=[
            {'type(r)': "'T'"},
            {'type(r)': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'graph', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-graph4-5',
        feature_path='tck/features/expressions/graph/Graph4.feature',
        scenario='[5] `type()` handling Any type',
        cypher='MATCH (a)-[r]->()\n      WITH [r, 1] AS list\n      RETURN type(list[0])',
        graph=graph_fixture_from_create(
            """
            CREATE ()-[:T]->()
            """
        ),
        expected=Expected(
            rows=[
            {'type(list[0])': "'T'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'graph', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-graph4-6-1',
        feature_path='tck/features/expressions/graph/Graph4.feature',
        scenario='[6] `type()` failing on invalid arguments (example 1)',
        cypher='MATCH p = (n)-[r:T]->()\n      RETURN [x IN [r, 0] | type(x) ] AS list',
        graph=graph_fixture_from_create(
            """
            CREATE ()-[:T]->()
            """
        ),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Runtime error semantics are not supported',
        tags=('expr', 'graph', 'meta-xfail', 'runtime-error', 'xfail'),
    ),
    Scenario(
        key='expr-graph4-6-2',
        feature_path='tck/features/expressions/graph/Graph4.feature',
        scenario='[6] `type()` failing on invalid arguments (example 2)',
        cypher='MATCH p = (n)-[r:T]->()\n      RETURN [x IN [r, 1.0] | type(x) ] AS list',
        graph=graph_fixture_from_create(
            """
            CREATE ()-[:T]->()
            """
        ),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Runtime error semantics are not supported',
        tags=('expr', 'graph', 'meta-xfail', 'runtime-error', 'xfail'),
    ),
    Scenario(
        key='expr-graph4-6-3',
        feature_path='tck/features/expressions/graph/Graph4.feature',
        scenario='[6] `type()` failing on invalid arguments (example 3)',
        cypher='MATCH p = (n)-[r:T]->()\n      RETURN [x IN [r, true] | type(x) ] AS list',
        graph=graph_fixture_from_create(
            """
            CREATE ()-[:T]->()
            """
        ),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Runtime error semantics are not supported',
        tags=('expr', 'graph', 'meta-xfail', 'runtime-error', 'xfail'),
    ),
    Scenario(
        key='expr-graph4-6-4',
        feature_path='tck/features/expressions/graph/Graph4.feature',
        scenario='[6] `type()` failing on invalid arguments (example 4)',
        cypher="MATCH p = (n)-[r:T]->()\n      RETURN [x IN [r, ''] | type(x) ] AS list",
        graph=graph_fixture_from_create(
            """
            CREATE ()-[:T]->()
            """
        ),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Runtime error semantics are not supported',
        tags=('expr', 'graph', 'meta-xfail', 'runtime-error', 'xfail'),
    ),
    Scenario(
        key='expr-graph4-6-5',
        feature_path='tck/features/expressions/graph/Graph4.feature',
        scenario='[6] `type()` failing on invalid arguments (example 5)',
        cypher='MATCH p = (n)-[r:T]->()\n      RETURN [x IN [r, []] | type(x) ] AS list',
        graph=graph_fixture_from_create(
            """
            CREATE ()-[:T]->()
            """
        ),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Runtime error semantics are not supported',
        tags=('expr', 'graph', 'meta-xfail', 'runtime-error', 'xfail'),
    ),
    Scenario(
        key='expr-graph4-7',
        feature_path='tck/features/expressions/graph/Graph4.feature',
        scenario='[7] Failing when using `type()` on a node',
        cypher='MATCH (r)\n      RETURN type(r)',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'graph', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-graph5-1',
        feature_path='tck/features/expressions/graph/Graph5.feature',
        scenario='[1] Single-labels expression on nodes',
        cypher='MATCH (a)\n      RETURN a, a:B AS result',
        graph=graph_fixture_from_create(
            """
            CREATE (:A:B:C), (:A:B), (:A:C), (:B:C),
                         (:A), (:B), (:C), ()
            """
        ),
        expected=Expected(
            rows=[
            {'a': '(:A:B:C)', 'result': 'true'},
            {'a': '(:A:B)', 'result': 'true'},
            {'a': '(:A:C)', 'result': 'false'},
            {'a': '(:B:C)', 'result': 'true'},
            {'a': '(:A)', 'result': 'false'},
            {'a': '(:B)', 'result': 'true'},
            {'a': '(:C)', 'result': 'false'},
            {'a': '()', 'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'graph', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-graph5-2',
        feature_path='tck/features/expressions/graph/Graph5.feature',
        scenario='[2] Single-labels expression on relationships',
        cypher='MATCH ()-[r]->()\n      RETURN r, r:T2 AS result',
        graph=graph_fixture_from_create(
            """
            CREATE ()-[:T1]->(),
                         ()-[:T2]->(),
                         ()-[:t2]->(),
                         (:T2)-[:T3]->(),
                         ()-[:T4]->(:T2)
            """
        ),
        expected=Expected(
            rows=[
            {'r': '[:T1]', 'result': 'false'},
            {'r': '[:T2]', 'result': 'true'},
            {'r': '[:t2]', 'result': 'false'},
            {'r': '[:T3]', 'result': 'false'},
            {'r': '[:T4]', 'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'graph', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-graph5-3',
        feature_path='tck/features/expressions/graph/Graph5.feature',
        scenario='[3] Conjunctive labels expression on nodes',
        cypher='MATCH (a)\n      RETURN a, a:A:B AS result',
        graph=graph_fixture_from_create(
            """
            CREATE (:A:B:C), (:A:B), (:A:C), (:B:C),
                         (:A), (:B), (:C), ()
            """
        ),
        expected=Expected(
            rows=[
            {'a': '(:A:B:C)', 'result': 'true'},
            {'a': '(:A:B)', 'result': 'true'},
            {'a': '(:A:C)', 'result': 'false'},
            {'a': '(:B:C)', 'result': 'false'},
            {'a': '(:A)', 'result': 'false'},
            {'a': '(:B)', 'result': 'false'},
            {'a': '(:C)', 'result': 'false'},
            {'a': '()', 'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'graph', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-graph5-4-1',
        feature_path='tck/features/expressions/graph/Graph5.feature',
        scenario='[4] Conjunctive labels expression on nodes with varying order and repeating labels (example 1)',
        cypher='MATCH (a)\n      WHERE a:A:C\n      RETURN a',
        graph=graph_fixture_from_create(
            """
            CREATE (:A:B), (:A:C), (:B:C),
                         (:A), (:B), (:C), ()
            """
        ),
        expected=Expected(
            rows=[
            {'a': '(:A:C)'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'graph', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-graph5-4-2',
        feature_path='tck/features/expressions/graph/Graph5.feature',
        scenario='[4] Conjunctive labels expression on nodes with varying order and repeating labels (example 2)',
        cypher='MATCH (a)\n      WHERE a:C:A\n      RETURN a',
        graph=graph_fixture_from_create(
            """
            CREATE (:A:B), (:A:C), (:B:C),
                         (:A), (:B), (:C), ()
            """
        ),
        expected=Expected(
            rows=[
            {'a': '(:A:C)'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'graph', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-graph5-4-3',
        feature_path='tck/features/expressions/graph/Graph5.feature',
        scenario='[4] Conjunctive labels expression on nodes with varying order and repeating labels (example 3)',
        cypher='MATCH (a)\n      WHERE a:A:C:A\n      RETURN a',
        graph=graph_fixture_from_create(
            """
            CREATE (:A:B), (:A:C), (:B:C),
                         (:A), (:B), (:C), ()
            """
        ),
        expected=Expected(
            rows=[
            {'a': '(:A:C)'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'graph', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-graph5-4-4',
        feature_path='tck/features/expressions/graph/Graph5.feature',
        scenario='[4] Conjunctive labels expression on nodes with varying order and repeating labels (example 4)',
        cypher='MATCH (a)\n      WHERE a:C:C:A\n      RETURN a',
        graph=graph_fixture_from_create(
            """
            CREATE (:A:B), (:A:C), (:B:C),
                         (:A), (:B), (:C), ()
            """
        ),
        expected=Expected(
            rows=[
            {'a': '(:A:C)'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'graph', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-graph5-4-5',
        feature_path='tck/features/expressions/graph/Graph5.feature',
        scenario='[4] Conjunctive labels expression on nodes with varying order and repeating labels (example 5)',
        cypher='MATCH (a)\n      WHERE a:C:A:A:C\n      RETURN a',
        graph=graph_fixture_from_create(
            """
            CREATE (:A:B), (:A:C), (:B:C),
                         (:A), (:B), (:C), ()
            """
        ),
        expected=Expected(
            rows=[
            {'a': '(:A:C)'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'graph', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-graph5-5',
        feature_path='tck/features/expressions/graph/Graph5.feature',
        scenario='[5] Label expression on null',
        cypher='MATCH (n:Single)\n      OPTIONAL MATCH (n)-[r:TYPE]-(m)\n      RETURN m:TYPE',
        graph=graph_fixture_from_create(
            """
            CREATE (s:Single)
            """
        ),
        expected=Expected(
            rows=[
            {'m:TYPE': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'graph', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-graph6-1',
        feature_path='tck/features/expressions/graph/Graph6.feature',
        scenario='[1] Statically access a property of a non-null node',
        cypher='MATCH (n)\n      RETURN n.missing, n.missingToo, n.existing',
        graph=graph_fixture_from_create(
            """
            CREATE ({existing: 42, missing: null})
            """
        ),
        expected=Expected(
            rows=[
            {'n.missing': 'null', 'n.missingToo': 'null', 'n.existing': 42}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'graph', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-graph6-2',
        feature_path='tck/features/expressions/graph/Graph6.feature',
        scenario='[2] Statically access a property of a optional non-null node',
        cypher='OPTIONAL MATCH (n)\n      RETURN n.missing, n.missingToo, n.existing',
        graph=graph_fixture_from_create(
            """
            CREATE ({existing: 42, missing: null})
            """
        ),
        expected=Expected(
            rows=[
            {'n.missing': 'null', 'n.missingToo': 'null', 'n.existing': 42}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'graph', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-graph6-3',
        feature_path='tck/features/expressions/graph/Graph6.feature',
        scenario='[3] Statically access a property of a null node',
        cypher='OPTIONAL MATCH (n)\n      RETURN n.missing',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'n.missing': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'graph', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-graph6-4',
        feature_path='tck/features/expressions/graph/Graph6.feature',
        scenario='[4] Statically access a property of a node resulting from an expression',
        cypher='MATCH (n)\n      WITH [123, n] AS list\n      RETURN (list[1]).missing, (list[1]).missingToo, (list[1]).existing',
        graph=graph_fixture_from_create(
            """
            CREATE ({existing: 42, missing: null})
            """
        ),
        expected=Expected(
            rows=[
            {'(list[1]).missing': 'null', '(list[1]).missingToo': 'null', '(list[1]).existing': 42}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'graph', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-graph6-5',
        feature_path='tck/features/expressions/graph/Graph6.feature',
        scenario='[5] Statically access a property of a non-null relationship',
        cypher='MATCH ()-[r]->()\n      RETURN r.missing, r.missingToo, r.existing',
        graph=graph_fixture_from_create(
            """
            CREATE ()-[:REL {existing: 42, missing: null}]->()
            """
        ),
        expected=Expected(
            rows=[
            {'r.missing': 'null', 'r.missingToo': 'null', 'r.existing': 42}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'graph', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-graph6-6',
        feature_path='tck/features/expressions/graph/Graph6.feature',
        scenario='[6] Statically access a property of a optional non-null relationship',
        cypher='OPTIONAL MATCH ()-[r]->()\n      RETURN r.missing, r.missingToo, r.existing',
        graph=graph_fixture_from_create(
            """
            CREATE ()-[:REL {existing: 42, missing: null}]->()
            """
        ),
        expected=Expected(
            rows=[
            {'r.missing': 'null', 'r.missingToo': 'null', 'r.existing': 42}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'graph', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-graph6-7',
        feature_path='tck/features/expressions/graph/Graph6.feature',
        scenario='[7] Statically access a property of a null relationship',
        cypher='OPTIONAL MATCH ()-[r]->()\n      RETURN r.missing',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'r.missing': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'graph', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-graph6-8',
        feature_path='tck/features/expressions/graph/Graph6.feature',
        scenario='[8] Statically access a property of a relationship resulting from an expression',
        cypher='MATCH ()-[r]->()\n      WITH [123, r] AS list\n      RETURN (list[1]).missing, (list[1]).missingToo, (list[1]).existing',
        graph=graph_fixture_from_create(
            """
            CREATE ()-[:REL {existing: 42, missing: null}]->()
            """
        ),
        expected=Expected(
            rows=[
            {'(list[1]).missing': 'null', '(list[1]).missingToo': 'null', '(list[1]).existing': 42}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'graph', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-graph6-9-1',
        feature_path='tck/features/expressions/graph/Graph6.feature',
        scenario='[9] Fail when performing property access on a non-graph element (example 1)',
        cypher='WITH 123 AS nonGraphElement\n      RETURN nonGraphElement.num',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Runtime error semantics are not supported',
        tags=('expr', 'graph', 'meta-xfail', 'runtime-error', 'xfail'),
    ),
    Scenario(
        key='expr-graph6-9-2',
        feature_path='tck/features/expressions/graph/Graph6.feature',
        scenario='[9] Fail when performing property access on a non-graph element (example 2)',
        cypher='WITH 42.45 AS nonGraphElement\n      RETURN nonGraphElement.num',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Runtime error semantics are not supported',
        tags=('expr', 'graph', 'meta-xfail', 'runtime-error', 'xfail'),
    ),
    Scenario(
        key='expr-graph6-9-3',
        feature_path='tck/features/expressions/graph/Graph6.feature',
        scenario='[9] Fail when performing property access on a non-graph element (example 3)',
        cypher='WITH true AS nonGraphElement\n      RETURN nonGraphElement.num',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Runtime error semantics are not supported',
        tags=('expr', 'graph', 'meta-xfail', 'runtime-error', 'xfail'),
    ),
    Scenario(
        key='expr-graph6-9-4',
        feature_path='tck/features/expressions/graph/Graph6.feature',
        scenario='[9] Fail when performing property access on a non-graph element (example 4)',
        cypher='WITH false AS nonGraphElement\n      RETURN nonGraphElement.num',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Runtime error semantics are not supported',
        tags=('expr', 'graph', 'meta-xfail', 'runtime-error', 'xfail'),
    ),
    Scenario(
        key='expr-graph6-9-5',
        feature_path='tck/features/expressions/graph/Graph6.feature',
        scenario='[9] Fail when performing property access on a non-graph element (example 5)',
        cypher="WITH 'string' AS nonGraphElement\n      RETURN nonGraphElement.num",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Runtime error semantics are not supported',
        tags=('expr', 'graph', 'meta-xfail', 'runtime-error', 'xfail'),
    ),
    Scenario(
        key='expr-graph6-9-6',
        feature_path='tck/features/expressions/graph/Graph6.feature',
        scenario='[9] Fail when performing property access on a non-graph element (example 6)',
        cypher='WITH [123, true] AS nonGraphElement\n      RETURN nonGraphElement.num',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Runtime error semantics are not supported',
        tags=('expr', 'graph', 'meta-xfail', 'runtime-error', 'xfail'),
    ),
    Scenario(
        key='expr-graph7-1',
        feature_path='tck/features/expressions/graph/Graph7.feature',
        scenario="[1] Execute n['name'] in read queries",
        cypher="MATCH (n {name: 'Apa'})\n      RETURN n['nam' + 'e'] AS value",
        graph=graph_fixture_from_create(
            """
            CREATE ({name: 'Apa'})
            """
        ),
        expected=Expected(
            rows=[
            {'value': "'Apa'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'graph', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-graph7-2',
        feature_path='tck/features/expressions/graph/Graph7.feature',
        scenario="[2] Execute n['name'] in update queries",
        cypher="CREATE (n {name: 'Apa'})\n      RETURN n['nam' + 'e'] AS value",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'value': "'Apa'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'graph', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-graph7-3',
        feature_path='tck/features/expressions/graph/Graph7.feature',
        scenario='[3] Use dynamic property lookup based on parameters when there is lhs type information',
        cypher="CREATE (n {name: 'Apa'})\n      RETURN n[$idx] AS value",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'value': "'Apa'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Parameter binding is not supported',
        tags=('expr', 'graph', 'meta-xfail', 'params', 'xfail'),
    ),
    Scenario(
        key='expr-graph8-1',
        feature_path='tck/features/expressions/graph/Graph8.feature',
        scenario='[1] Using `keys()` on a single node, non-empty result',
        cypher='MATCH (n)\n      UNWIND keys(n) AS x\n      RETURN DISTINCT x AS theProps',
        graph=graph_fixture_from_create(
            """
            CREATE ({name: 'Andres', surname: 'Lopez'})
            """
        ),
        expected=Expected(
            rows=[
            {'theProps': "'name'"},
            {'theProps': "'surname'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'graph', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-graph8-2',
        feature_path='tck/features/expressions/graph/Graph8.feature',
        scenario='[2] Using `keys()` on multiple nodes, non-empty result',
        cypher='MATCH (n)\n      UNWIND keys(n) AS x\n      RETURN DISTINCT x AS theProps',
        graph=graph_fixture_from_create(
            """
            CREATE ({name: 'Andres', surname: 'Lopez'}),
                         ({otherName: 'Andres', otherSurname: 'Lopez'})
            """
        ),
        expected=Expected(
            rows=[
            {'theProps': "'name'"},
            {'theProps': "'surname'"},
            {'theProps': "'otherName'"},
            {'theProps': "'otherSurname'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'graph', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-graph8-3',
        feature_path='tck/features/expressions/graph/Graph8.feature',
        scenario='[3] Using `keys()` on a single node, empty result',
        cypher='MATCH (n)\n      UNWIND keys(n) AS x\n      RETURN DISTINCT x AS theProps',
        graph=graph_fixture_from_create(
            """
            CREATE ()
            """
        ),
        expected=Expected(
            rows=[

            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'graph', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-graph8-4',
        feature_path='tck/features/expressions/graph/Graph8.feature',
        scenario='[4] Using `keys()` on an optionally matched node',
        cypher='OPTIONAL MATCH (n)\n      UNWIND keys(n) AS x\n      RETURN DISTINCT x AS theProps',
        graph=graph_fixture_from_create(
            """
            CREATE ()
            """
        ),
        expected=Expected(
            rows=[

            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'graph', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-graph8-5',
        feature_path='tck/features/expressions/graph/Graph8.feature',
        scenario='[5] Using `keys()` on a relationship, non-empty result',
        cypher='MATCH ()-[r:KNOWS]-()\n      UNWIND keys(r) AS x\n      RETURN DISTINCT x AS theProps',
        graph=graph_fixture_from_create(
            """
            CREATE ()-[:KNOWS {status: 'bad', year: '2015'}]->()
            """
        ),
        expected=Expected(
            rows=[
            {'theProps': "'status'"},
            {'theProps': "'year'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'graph', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-graph8-6',
        feature_path='tck/features/expressions/graph/Graph8.feature',
        scenario='[6] Using `keys()` on a relationship, empty result',
        cypher='MATCH ()-[r:KNOWS]-()\n      UNWIND keys(r) AS x\n      RETURN DISTINCT x AS theProps',
        graph=graph_fixture_from_create(
            """
            CREATE ()-[:KNOWS]->()
            """
        ),
        expected=Expected(
            rows=[

            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'graph', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-graph8-7',
        feature_path='tck/features/expressions/graph/Graph8.feature',
        scenario='[7] Using `keys()` on an optionally matched relationship',
        cypher='OPTIONAL MATCH ()-[r:KNOWS]-()\n      UNWIND keys(r) AS x\n      RETURN DISTINCT x AS theProps',
        graph=graph_fixture_from_create(
            """
            CREATE ()-[:KNOWS]->()
            """
        ),
        expected=Expected(
            rows=[

            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'graph', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-graph8-8',
        feature_path='tck/features/expressions/graph/Graph8.feature',
        scenario='[8] Using `keys()` and `IN` to check property existence',
        cypher="MATCH (n)\n      RETURN 'exists' IN keys(n) AS a,\n             'missing' IN keys(n) AS b,\n             'missingToo' IN keys(n) AS c",
        graph=graph_fixture_from_create(
            """
            CREATE ({exists: 42, missing: null})
            """
        ),
        expected=Expected(
            rows=[
            {'a': 'true', 'b': 'false', 'c': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'graph', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-graph9-1',
        feature_path='tck/features/expressions/graph/Graph9.feature',
        scenario='[1] `properties()` on a node',
        cypher='MATCH (p:Person)\n      RETURN properties(p) AS m',
        graph=graph_fixture_from_create(
            """
            CREATE (n:Person {name: 'Popeye', level: 9001})
            """
        ),
        expected=Expected(
            rows=[
            {'m': "{name: 'Popeye', level: 9001}"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'graph', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-graph9-2',
        feature_path='tck/features/expressions/graph/Graph9.feature',
        scenario='[2] `properties()` on a relationship',
        cypher='MATCH ()-[r:R]->()\n      RETURN properties(r) AS m',
        graph=graph_fixture_from_create(
            """
            CREATE (n)-[:R {name: 'Popeye', level: 9001}]->(n)
            """
        ),
        expected=Expected(
            rows=[
            {'m': "{name: 'Popeye', level: 9001}"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'graph', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-graph9-3',
        feature_path='tck/features/expressions/graph/Graph9.feature',
        scenario='[3] `properties()` on null',
        cypher='OPTIONAL MATCH (n:DoesNotExist)\n      OPTIONAL MATCH (n)-[r:NOT_THERE]->()\n      RETURN properties(n), properties(r), properties(null)',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'properties(n)': 'null', 'properties(r)': 'null', 'properties(null)': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'graph', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-graph9-4',
        feature_path='tck/features/expressions/graph/Graph9.feature',
        scenario='[4] `properties()` on a map',
        cypher="RETURN properties({name: 'Popeye', level: 9001}) AS m",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'m': "{name: 'Popeye', level: 9001}"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'graph', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-graph9-5',
        feature_path='tck/features/expressions/graph/Graph9.feature',
        scenario='[5] `properties()` failing on an integer literal',
        cypher='RETURN properties(1)',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'graph', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-graph9-6',
        feature_path='tck/features/expressions/graph/Graph9.feature',
        scenario='[6] `properties()` failing on a string literal',
        cypher="RETURN properties('Cypher')",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'graph', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-graph9-7',
        feature_path='tck/features/expressions/graph/Graph9.feature',
        scenario='[7] `properties()` failing on a list of booleans',
        cypher='RETURN properties([true, false])',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'graph', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-list1-1',
        feature_path='tck/features/expressions/list/List1.feature',
        scenario='[1] Indexing into literal list',
        cypher='RETURN [1, 2, 3][0] AS value',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'value': 1}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list1-2',
        feature_path='tck/features/expressions/list/List1.feature',
        scenario='[2] Indexing into nested literal lists',
        cypher='RETURN [[1]][0][0]',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'[[1]][0][0]': 1}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list1-3',
        feature_path='tck/features/expressions/list/List1.feature',
        scenario='[3] Use list lookup based on parameters when there is no type information',
        cypher='WITH $expr AS expr, $idx AS idx\n      RETURN expr[idx] AS value',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'value': "'Apa'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Parameter binding is not supported',
        tags=('expr', 'list', 'meta-xfail', 'params', 'xfail'),
    ),
    Scenario(
        key='expr-list1-4',
        feature_path='tck/features/expressions/list/List1.feature',
        scenario='[4] Use list lookup based on parameters when there is lhs type information',
        cypher="WITH ['Apa'] AS expr\n      RETURN expr[$idx] AS value",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'value': "'Apa'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Parameter binding is not supported',
        tags=('expr', 'list', 'meta-xfail', 'params', 'xfail'),
    ),
    Scenario(
        key='expr-list1-5',
        feature_path='tck/features/expressions/list/List1.feature',
        scenario='[5] Use list lookup based on parameters when there is rhs type information',
        cypher='WITH $expr AS expr, $idx AS idx\n      RETURN expr[toInteger(idx)] AS value',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'value': "'Apa'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Parameter binding is not supported',
        tags=('expr', 'list', 'meta-xfail', 'params', 'xfail'),
    ),
    Scenario(
        key='expr-list1-6-1',
        feature_path='tck/features/expressions/list/List1.feature',
        scenario='[6] Fail when indexing a non-list #Example: <exampleName> (example 1)',
        cypher='WITH true AS list, 0 AS idx\n      RETURN list[idx]',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Runtime error semantics are not supported',
        tags=('expr', 'list', 'meta-xfail', 'runtime-error', 'xfail'),
    ),
    Scenario(
        key='expr-list1-6-2',
        feature_path='tck/features/expressions/list/List1.feature',
        scenario='[6] Fail when indexing a non-list #Example: <exampleName> (example 2)',
        cypher='WITH 123 AS list, 0 AS idx\n      RETURN list[idx]',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Runtime error semantics are not supported',
        tags=('expr', 'list', 'meta-xfail', 'runtime-error', 'xfail'),
    ),
    Scenario(
        key='expr-list1-6-3',
        feature_path='tck/features/expressions/list/List1.feature',
        scenario='[6] Fail when indexing a non-list #Example: <exampleName> (example 3)',
        cypher='WITH 4.7 AS list, 0 AS idx\n      RETURN list[idx]',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Runtime error semantics are not supported',
        tags=('expr', 'list', 'meta-xfail', 'runtime-error', 'xfail'),
    ),
    Scenario(
        key='expr-list1-6-4',
        feature_path='tck/features/expressions/list/List1.feature',
        scenario='[6] Fail when indexing a non-list #Example: <exampleName> (example 4)',
        cypher="WITH '1' AS list, 0 AS idx\n      RETURN list[idx]",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Runtime error semantics are not supported',
        tags=('expr', 'list', 'meta-xfail', 'runtime-error', 'xfail'),
    ),
    Scenario(
        key='expr-list1-7-1',
        feature_path='tck/features/expressions/list/List1.feature',
        scenario='[7] Fail when indexing a non-list given by a parameter #Example: <exampleName> (example 1)',
        cypher='WITH $expr AS list, $idx AS idx\n      RETURN list[idx]',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Runtime error semantics are not supported',
        tags=('expr', 'list', 'meta-xfail', 'params', 'runtime-error', 'xfail'),
    ),
    Scenario(
        key='expr-list1-7-2',
        feature_path='tck/features/expressions/list/List1.feature',
        scenario='[7] Fail when indexing a non-list given by a parameter #Example: <exampleName> (example 2)',
        cypher='WITH $expr AS list, $idx AS idx\n      RETURN list[idx]',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Runtime error semantics are not supported',
        tags=('expr', 'list', 'meta-xfail', 'params', 'runtime-error', 'xfail'),
    ),
    Scenario(
        key='expr-list1-7-3',
        feature_path='tck/features/expressions/list/List1.feature',
        scenario='[7] Fail when indexing a non-list given by a parameter #Example: <exampleName> (example 3)',
        cypher='WITH $expr AS list, $idx AS idx\n      RETURN list[idx]',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Runtime error semantics are not supported',
        tags=('expr', 'list', 'meta-xfail', 'params', 'runtime-error', 'xfail'),
    ),
    Scenario(
        key='expr-list1-7-4',
        feature_path='tck/features/expressions/list/List1.feature',
        scenario='[7] Fail when indexing a non-list given by a parameter #Example: <exampleName> (example 4)',
        cypher='WITH $expr AS list, $idx AS idx\n      RETURN list[idx]',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Runtime error semantics are not supported',
        tags=('expr', 'list', 'meta-xfail', 'params', 'runtime-error', 'xfail'),
    ),
    Scenario(
        key='expr-list1-8-1',
        feature_path='tck/features/expressions/list/List1.feature',
        scenario='[8] Fail when indexing with a non-integer #Example: <exampleName> (example 1)',
        cypher='WITH [1, 2, 3, 4, 5] AS list, true AS idx\n      RETURN list[idx]',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Runtime error semantics are not supported',
        tags=('expr', 'list', 'meta-xfail', 'runtime-error', 'xfail'),
    ),
    Scenario(
        key='expr-list1-8-2',
        feature_path='tck/features/expressions/list/List1.feature',
        scenario='[8] Fail when indexing with a non-integer #Example: <exampleName> (example 2)',
        cypher='WITH [1, 2, 3, 4, 5] AS list, 4.7 AS idx\n      RETURN list[idx]',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Runtime error semantics are not supported',
        tags=('expr', 'list', 'meta-xfail', 'runtime-error', 'xfail'),
    ),
    Scenario(
        key='expr-list1-8-3',
        feature_path='tck/features/expressions/list/List1.feature',
        scenario='[8] Fail when indexing with a non-integer #Example: <exampleName> (example 3)',
        cypher="WITH [1, 2, 3, 4, 5] AS list, '1' AS idx\n      RETURN list[idx]",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Runtime error semantics are not supported',
        tags=('expr', 'list', 'meta-xfail', 'runtime-error', 'xfail'),
    ),
    Scenario(
        key='expr-list1-8-4',
        feature_path='tck/features/expressions/list/List1.feature',
        scenario='[8] Fail when indexing with a non-integer #Example: <exampleName> (example 4)',
        cypher='WITH [1, 2, 3, 4, 5] AS list, [1] AS idx\n      RETURN list[idx]',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Runtime error semantics are not supported',
        tags=('expr', 'list', 'meta-xfail', 'runtime-error', 'xfail'),
    ),
    Scenario(
        key='expr-list1-8-5',
        feature_path='tck/features/expressions/list/List1.feature',
        scenario='[8] Fail when indexing with a non-integer #Example: <exampleName> (example 5)',
        cypher='WITH [1, 2, 3, 4, 5] AS list, {x: 3} AS idx\n      RETURN list[idx]',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Runtime error semantics are not supported',
        tags=('expr', 'list', 'meta-xfail', 'runtime-error', 'xfail'),
    ),
    Scenario(
        key='expr-list1-9-1',
        feature_path='tck/features/expressions/list/List1.feature',
        scenario='[9] Fail when indexing with a non-integer given by a parameter #Example: <exampleName> (example 1)',
        cypher='WITH $expr AS list, $idx AS idx\n      RETURN list[idx]',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Runtime error semantics are not supported',
        tags=('expr', 'list', 'meta-xfail', 'params', 'runtime-error', 'xfail'),
    ),
    Scenario(
        key='expr-list1-9-2',
        feature_path='tck/features/expressions/list/List1.feature',
        scenario='[9] Fail when indexing with a non-integer given by a parameter #Example: <exampleName> (example 2)',
        cypher='WITH $expr AS list, $idx AS idx\n      RETURN list[idx]',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Runtime error semantics are not supported',
        tags=('expr', 'list', 'meta-xfail', 'params', 'runtime-error', 'xfail'),
    ),
    Scenario(
        key='expr-list1-9-3',
        feature_path='tck/features/expressions/list/List1.feature',
        scenario='[9] Fail when indexing with a non-integer given by a parameter #Example: <exampleName> (example 3)',
        cypher='WITH $expr AS list, $idx AS idx\n      RETURN list[idx]',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Runtime error semantics are not supported',
        tags=('expr', 'list', 'meta-xfail', 'params', 'runtime-error', 'xfail'),
    ),
    Scenario(
        key='expr-list1-9-4',
        feature_path='tck/features/expressions/list/List1.feature',
        scenario='[9] Fail when indexing with a non-integer given by a parameter #Example: <exampleName> (example 4)',
        cypher='WITH $expr AS list, $idx AS idx\n      RETURN list[idx]',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Runtime error semantics are not supported',
        tags=('expr', 'list', 'meta-xfail', 'params', 'runtime-error', 'xfail'),
    ),
    Scenario(
        key='expr-list1-9-5',
        feature_path='tck/features/expressions/list/List1.feature',
        scenario='[9] Fail when indexing with a non-integer given by a parameter #Example: <exampleName> (example 5)',
        cypher='WITH $expr AS list, $idx AS idx\n      RETURN list[idx]',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Runtime error semantics are not supported',
        tags=('expr', 'list', 'meta-xfail', 'params', 'runtime-error', 'xfail'),
    ),
    Scenario(
        key='expr-list11-1-1',
        feature_path='tck/features/expressions/list/List11.feature',
        scenario='[1] Create list from `range()` with default step (example 1)',
        cypher='RETURN range(-1236, -1234) AS list',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'list': '[-1236, -1235, -1234]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list11-1-2',
        feature_path='tck/features/expressions/list/List11.feature',
        scenario='[1] Create list from `range()` with default step (example 2)',
        cypher='RETURN range(-1234, -1234) AS list',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'list': '[-1234]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list11-1-3',
        feature_path='tck/features/expressions/list/List11.feature',
        scenario='[1] Create list from `range()` with default step (example 3)',
        cypher='RETURN range(-10, -3) AS list',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'list': '[-10, -9, -8, -7, -6, -5, -4, -3]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list11-1-4',
        feature_path='tck/features/expressions/list/List11.feature',
        scenario='[1] Create list from `range()` with default step (example 4)',
        cypher='RETURN range(-10, 0) AS list',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'list': '[-10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list11-1-5',
        feature_path='tck/features/expressions/list/List11.feature',
        scenario='[1] Create list from `range()` with default step (example 5)',
        cypher='RETURN range(-1, 0) AS list',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'list': '[-1, 0]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list11-1-6',
        feature_path='tck/features/expressions/list/List11.feature',
        scenario='[1] Create list from `range()` with default step (example 6)',
        cypher='RETURN range(0, -123) AS list',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'list': '[]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list11-1-7',
        feature_path='tck/features/expressions/list/List11.feature',
        scenario='[1] Create list from `range()` with default step (example 7)',
        cypher='RETURN range(0, -1) AS list',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'list': '[]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list11-1-8',
        feature_path='tck/features/expressions/list/List11.feature',
        scenario='[1] Create list from `range()` with default step (example 8)',
        cypher='RETURN range(-1, 1) AS list',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'list': '[-1, 0, 1]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list11-1-9',
        feature_path='tck/features/expressions/list/List11.feature',
        scenario='[1] Create list from `range()` with default step (example 9)',
        cypher='RETURN range(0, 0) AS list',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'list': '[0]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list11-1-10',
        feature_path='tck/features/expressions/list/List11.feature',
        scenario='[1] Create list from `range()` with default step (example 10)',
        cypher='RETURN range(0, 1) AS list',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'list': '[0, 1]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list11-1-11',
        feature_path='tck/features/expressions/list/List11.feature',
        scenario='[1] Create list from `range()` with default step (example 11)',
        cypher='RETURN range(0, 10) AS list',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'list': '[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list11-1-12',
        feature_path='tck/features/expressions/list/List11.feature',
        scenario='[1] Create list from `range()` with default step (example 12)',
        cypher='RETURN range(6, 10) AS list',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'list': '[6, 7, 8, 9, 10]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list11-1-13',
        feature_path='tck/features/expressions/list/List11.feature',
        scenario='[1] Create list from `range()` with default step (example 13)',
        cypher='RETURN range(1234, 1234) AS list',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'list': '[1234]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list11-1-14',
        feature_path='tck/features/expressions/list/List11.feature',
        scenario='[1] Create list from `range()` with default step (example 14)',
        cypher='RETURN range(1234, 1236) AS list',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'list': '[1234, 1235, 1236]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list11-2-1',
        feature_path='tck/features/expressions/list/List11.feature',
        scenario='[2] Create list from `range()` with explicitly given step (example 1)',
        cypher='RETURN range(1381, -3412, -1298) AS list',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'list': '[1381, 83, -1215, -2513]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list11-2-2',
        feature_path='tck/features/expressions/list/List11.feature',
        scenario='[2] Create list from `range()` with explicitly given step (example 2)',
        cypher='RETURN range(0, -2000, -1298) AS list',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'list': '[0, -1298]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list11-2-3',
        feature_path='tck/features/expressions/list/List11.feature',
        scenario='[2] Create list from `range()` with explicitly given step (example 3)',
        cypher='RETURN range(10, -10, -3) AS list',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'list': '[10, 7, 4, 1, -2, -5, -8]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list11-2-4',
        feature_path='tck/features/expressions/list/List11.feature',
        scenario='[2] Create list from `range()` with explicitly given step (example 4)',
        cypher='RETURN range(0, -10, -3) AS list',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'list': '[0, -3, -6, -9]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list11-2-5',
        feature_path='tck/features/expressions/list/List11.feature',
        scenario='[2] Create list from `range()` with explicitly given step (example 5)',
        cypher='RETURN range(0, -20, -2) AS list',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'list': '[0, -2, -4, -6, -8, -10, -12, -14, -16, -18, -20]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list11-2-6',
        feature_path='tck/features/expressions/list/List11.feature',
        scenario='[2] Create list from `range()` with explicitly given step (example 6)',
        cypher='RETURN range(0, -10, -1) AS list',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'list': '[0, -1, -2, -3, -4, -5, -6, -7, -8, -9, -10]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list11-2-7',
        feature_path='tck/features/expressions/list/List11.feature',
        scenario='[2] Create list from `range()` with explicitly given step (example 7)',
        cypher='RETURN range(0, -1, -1) AS list',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'list': '[0, -1]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list11-2-8',
        feature_path='tck/features/expressions/list/List11.feature',
        scenario='[2] Create list from `range()` with explicitly given step (example 8)',
        cypher='RETURN range(-1236, -1234, 1) AS list',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'list': '[-1236, -1235, -1234]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list11-2-9',
        feature_path='tck/features/expressions/list/List11.feature',
        scenario='[2] Create list from `range()` with explicitly given step (example 9)',
        cypher='RETURN range(-10, 0, 1) AS list',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'list': '[-10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list11-2-10',
        feature_path='tck/features/expressions/list/List11.feature',
        scenario='[2] Create list from `range()` with explicitly given step (example 10)',
        cypher='RETURN range(-1, 0, 1) AS list',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'list': '[-1, 0]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list11-2-11',
        feature_path='tck/features/expressions/list/List11.feature',
        scenario='[2] Create list from `range()` with explicitly given step (example 11)',
        cypher='RETURN range(0, 1, -123) AS list',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'list': '[]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list11-2-12',
        feature_path='tck/features/expressions/list/List11.feature',
        scenario='[2] Create list from `range()` with explicitly given step (example 12)',
        cypher='RETURN range(0, 1, -1) AS list',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'list': '[]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list11-2-13',
        feature_path='tck/features/expressions/list/List11.feature',
        scenario='[2] Create list from `range()` with explicitly given step (example 13)',
        cypher='RETURN range(0, -123, 1) AS list',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'list': '[]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list11-2-14',
        feature_path='tck/features/expressions/list/List11.feature',
        scenario='[2] Create list from `range()` with explicitly given step (example 14)',
        cypher='RETURN range(0, -1, 1) AS list',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'list': '[]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list11-2-15',
        feature_path='tck/features/expressions/list/List11.feature',
        scenario='[2] Create list from `range()` with explicitly given step (example 15)',
        cypher='RETURN range(0, 0, -1) AS list',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'list': '[0]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list11-2-16',
        feature_path='tck/features/expressions/list/List11.feature',
        scenario='[2] Create list from `range()` with explicitly given step (example 16)',
        cypher='RETURN range(0, 0, 1) AS list',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'list': '[0]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list11-2-17',
        feature_path='tck/features/expressions/list/List11.feature',
        scenario='[2] Create list from `range()` with explicitly given step (example 17)',
        cypher='RETURN range(0, 1, 2) AS list',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'list': '[0]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list11-2-18',
        feature_path='tck/features/expressions/list/List11.feature',
        scenario='[2] Create list from `range()` with explicitly given step (example 18)',
        cypher='RETURN range(0, 1, 1) AS list',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'list': '[0, 1]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list11-2-19',
        feature_path='tck/features/expressions/list/List11.feature',
        scenario='[2] Create list from `range()` with explicitly given step (example 19)',
        cypher='RETURN range(0, 10, 1) AS list',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'list': '[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list11-2-20',
        feature_path='tck/features/expressions/list/List11.feature',
        scenario='[2] Create list from `range()` with explicitly given step (example 20)',
        cypher='RETURN range(6, 10, 1) AS list',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'list': '[6, 7, 8, 9, 10]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list11-2-21',
        feature_path='tck/features/expressions/list/List11.feature',
        scenario='[2] Create list from `range()` with explicitly given step (example 21)',
        cypher='RETURN range(1234, 1234, 1) AS list',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'list': '[1234]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list11-2-22',
        feature_path='tck/features/expressions/list/List11.feature',
        scenario='[2] Create list from `range()` with explicitly given step (example 22)',
        cypher='RETURN range(1234, 1236, 1) AS list',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'list': '[1234, 1235, 1236]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list11-2-23',
        feature_path='tck/features/expressions/list/List11.feature',
        scenario='[2] Create list from `range()` with explicitly given step (example 23)',
        cypher='RETURN range(-10, 0, 3) AS list',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'list': '[-10, -7, -4, -1]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list11-2-24',
        feature_path='tck/features/expressions/list/List11.feature',
        scenario='[2] Create list from `range()` with explicitly given step (example 24)',
        cypher='RETURN range(-10, 10, 3) AS list',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'list': '[-10, -7, -4, -1, 2, 5, 8]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list11-2-25',
        feature_path='tck/features/expressions/list/List11.feature',
        scenario='[2] Create list from `range()` with explicitly given step (example 25)',
        cypher='RETURN range(-2000, 0, 1298) AS list',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'list': '[-2000, -702]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list11-2-26',
        feature_path='tck/features/expressions/list/List11.feature',
        scenario='[2] Create list from `range()` with explicitly given step (example 26)',
        cypher='RETURN range(-3412, 1381, 1298) AS list',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'list': '[-3412, -2114, -816, 482]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list11-3',
        feature_path='tck/features/expressions/list/List11.feature',
        scenario='[3] Create an empty list if range direction and step direction are inconsistent',
        cypher='WITH 0 AS start, [1, 2, 500, 1000, 1500] AS stopList, [-1000, -3, -2, -1, 1, 2, 3, 1000] AS stepList\n      UNWIND stopList AS stop\n      UNWIND stepList AS step\n      WITH start, stop, step, range(start, stop, step) AS list\n      WITH start, stop, step, list, sign(stop-start) <> sign(step) AS empty\n      RETURN ALL(ok IN collect((size(list) = 0) = empty) WHERE ok) AS okay',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'okay': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list11-4-1',
        feature_path='tck/features/expressions/list/List11.feature',
        scenario='[4] Fail on invalid arguments for `range()` (example 1)',
        cypher='RETURN range(2, 8, 0)',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list11-4-2',
        feature_path='tck/features/expressions/list/List11.feature',
        scenario='[4] Fail on invalid arguments for `range()` (example 2)',
        cypher='RETURN range(2, 8, 0)',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list11-4-3',
        feature_path='tck/features/expressions/list/List11.feature',
        scenario='[4] Fail on invalid arguments for `range()` (example 3)',
        cypher='RETURN range(2, 8, 0)',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list11-4-4',
        feature_path='tck/features/expressions/list/List11.feature',
        scenario='[4] Fail on invalid arguments for `range()` (example 4)',
        cypher='RETURN range(2, 8, 0)',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list11-5-1',
        feature_path='tck/features/expressions/list/List11.feature',
        scenario='[5] Fail on invalid argument types for `range()` (example 1)',
        cypher='RETURN range(true, 1, 1)',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list11-5-2',
        feature_path='tck/features/expressions/list/List11.feature',
        scenario='[5] Fail on invalid argument types for `range()` (example 2)',
        cypher='RETURN range(0, true, 1)',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list11-5-3',
        feature_path='tck/features/expressions/list/List11.feature',
        scenario='[5] Fail on invalid argument types for `range()` (example 3)',
        cypher='RETURN range(0, 1, true)',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list11-5-4',
        feature_path='tck/features/expressions/list/List11.feature',
        scenario='[5] Fail on invalid argument types for `range()` (example 4)',
        cypher='RETURN range(-1.1, 1, 1)',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list11-5-5',
        feature_path='tck/features/expressions/list/List11.feature',
        scenario='[5] Fail on invalid argument types for `range()` (example 5)',
        cypher='RETURN range(-0.0, 1, 1)',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list11-5-6',
        feature_path='tck/features/expressions/list/List11.feature',
        scenario='[5] Fail on invalid argument types for `range()` (example 6)',
        cypher='RETURN range(0.0, 1, 1)',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list11-5-7',
        feature_path='tck/features/expressions/list/List11.feature',
        scenario='[5] Fail on invalid argument types for `range()` (example 7)',
        cypher='RETURN range(1.1, 1, 1)',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list11-5-8',
        feature_path='tck/features/expressions/list/List11.feature',
        scenario='[5] Fail on invalid argument types for `range()` (example 8)',
        cypher='RETURN range(0, -1.1, 1)',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list11-5-9',
        feature_path='tck/features/expressions/list/List11.feature',
        scenario='[5] Fail on invalid argument types for `range()` (example 9)',
        cypher='RETURN range(0, -0.0, 1)',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list11-5-10',
        feature_path='tck/features/expressions/list/List11.feature',
        scenario='[5] Fail on invalid argument types for `range()` (example 10)',
        cypher='RETURN range(0, 0.0, 1)',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list11-5-11',
        feature_path='tck/features/expressions/list/List11.feature',
        scenario='[5] Fail on invalid argument types for `range()` (example 11)',
        cypher='RETURN range(0, 1.1, 1)',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list11-5-12',
        feature_path='tck/features/expressions/list/List11.feature',
        scenario='[5] Fail on invalid argument types for `range()` (example 12)',
        cypher='RETURN range(0, 1, -1.1)',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list11-5-13',
        feature_path='tck/features/expressions/list/List11.feature',
        scenario='[5] Fail on invalid argument types for `range()` (example 13)',
        cypher='RETURN range(0, 1, 1.1)',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list11-5-14',
        feature_path='tck/features/expressions/list/List11.feature',
        scenario='[5] Fail on invalid argument types for `range()` (example 14)',
        cypher="RETURN range('xyz', 1, 1)",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list11-5-15',
        feature_path='tck/features/expressions/list/List11.feature',
        scenario='[5] Fail on invalid argument types for `range()` (example 15)',
        cypher="RETURN range(0, 'xyz', 1)",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list11-5-16',
        feature_path='tck/features/expressions/list/List11.feature',
        scenario='[5] Fail on invalid argument types for `range()` (example 16)',
        cypher="RETURN range(0, 1, 'xyz')",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list11-5-17',
        feature_path='tck/features/expressions/list/List11.feature',
        scenario='[5] Fail on invalid argument types for `range()` (example 17)',
        cypher='RETURN range([0], 1, 1)',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list11-5-18',
        feature_path='tck/features/expressions/list/List11.feature',
        scenario='[5] Fail on invalid argument types for `range()` (example 18)',
        cypher='RETURN range(0, [1], 1)',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list11-5-19',
        feature_path='tck/features/expressions/list/List11.feature',
        scenario='[5] Fail on invalid argument types for `range()` (example 19)',
        cypher='RETURN range(0, 1, [1])',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list11-5-20',
        feature_path='tck/features/expressions/list/List11.feature',
        scenario='[5] Fail on invalid argument types for `range()` (example 20)',
        cypher='RETURN range({start: 0}, 1, 1)',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list11-5-21',
        feature_path='tck/features/expressions/list/List11.feature',
        scenario='[5] Fail on invalid argument types for `range()` (example 21)',
        cypher='RETURN range(0, {end: 1}, 1)',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list11-5-22',
        feature_path='tck/features/expressions/list/List11.feature',
        scenario='[5] Fail on invalid argument types for `range()` (example 22)',
        cypher='RETURN range(0, 1, {step: 1})',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list12-1',
        feature_path='tck/features/expressions/list/List12.feature',
        scenario='[1] Collect and extract using a list comprehension',
        cypher="MATCH (a:Label1)\n      WITH collect(a) AS nodes\n      WITH nodes, [x IN nodes | x.name] AS oldNames\n      UNWIND nodes AS n\n      SET n.name = 'newName'\n      RETURN n.name, oldNames",
        graph=graph_fixture_from_create(
            """
            CREATE (:Label1 {name: 'original'})
            """
        ),
        expected=Expected(
            rows=[
            {'n.name': "'newName'", 'oldNames': "['original']"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list12-2',
        feature_path='tck/features/expressions/list/List12.feature',
        scenario='[2] Collect and filter using a list comprehension',
        cypher="MATCH (a:Label1)\n      WITH collect(a) AS nodes\n      WITH nodes, [x IN nodes WHERE x.name = 'original'] AS noopFiltered\n      UNWIND nodes AS n\n      SET n.name = 'newName'\n      RETURN n.name, size(noopFiltered)",
        graph=graph_fixture_from_create(
            """
            CREATE (:Label1 {name: 'original'})
            """
        ),
        expected=Expected(
            rows=[
            {'n.name': "'newName'", 'size(noopFiltered)': 1}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list12-3',
        feature_path='tck/features/expressions/list/List12.feature',
        scenario='[3] Size of list comprehension',
        cypher='MATCH (n)\n      OPTIONAL MATCH (n)-[r]->(m)\n      RETURN size([x IN collect(r) WHERE x <> null]) AS cn',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'cn': 0}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list12-4',
        feature_path='tck/features/expressions/list/List12.feature',
        scenario='[4] Returning a list comprehension',
        cypher='MATCH p = (n)-->()\n      RETURN [x IN collect(p) | head(nodes(x))] AS p',
        graph=graph_fixture_from_create(
            """
            CREATE (a:A)
                  CREATE (a)-[:T]->(:B),
                         (a)-[:T]->(:C)
            """
        ),
        expected=Expected(
            rows=[
            {'p': '[(:A), (:A)]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list12-5',
        feature_path='tck/features/expressions/list/List12.feature',
        scenario='[5] Using a list comprehension in a WITH',
        cypher='MATCH p = (n:A)-->()\n      WITH [x IN collect(p) | head(nodes(x))] AS p, count(n) AS c\n      RETURN p, c',
        graph=graph_fixture_from_create(
            """
            CREATE (a:A)
                  CREATE (a)-[:T]->(:B),
                         (a)-[:T]->(:C)
            """
        ),
        expected=Expected(
            rows=[
            {'p': '[(:A), (:A)]', 'c': 2}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list12-6',
        feature_path='tck/features/expressions/list/List12.feature',
        scenario='[6] Using a list comprehension in a WHERE',
        cypher='MATCH (n)-->(b)\n      WHERE n.name IN [x IN labels(b) | toLower(x)]\n      RETURN b',
        graph=graph_fixture_from_create(
            """
            CREATE (a:A {name: 'c'})
                  CREATE (a)-[:T]->(:B),
                         (a)-[:T]->(:C)
            """
        ),
        expected=Expected(
            rows=[
            {'b': '(:C)'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list12-7',
        feature_path='tck/features/expressions/list/List12.feature',
        scenario='[7] Fail when using aggregation in list comprehension',
        cypher='MATCH (n)\n      RETURN [x IN [1, 2, 3, 4, 5] | count(*)]',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-list2-1',
        feature_path='tck/features/expressions/list/List2.feature',
        scenario='[1] List slice',
        cypher='WITH [1, 2, 3, 4, 5] AS list\n      RETURN list[1..3] AS r',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'r': '[2, 3]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list2-2',
        feature_path='tck/features/expressions/list/List2.feature',
        scenario='[2] List slice with implicit end',
        cypher='WITH [1, 2, 3] AS list\n      RETURN list[1..] AS r',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'r': '[2, 3]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list2-3',
        feature_path='tck/features/expressions/list/List2.feature',
        scenario='[3] List slice with implicit start',
        cypher='WITH [1, 2, 3] AS list\n      RETURN list[..2] AS r',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'r': '[1, 2]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list2-4',
        feature_path='tck/features/expressions/list/List2.feature',
        scenario='[4] List slice with singleton range',
        cypher='WITH [1, 2, 3] AS list\n      RETURN list[0..1] AS r',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'r': '[1]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list2-5',
        feature_path='tck/features/expressions/list/List2.feature',
        scenario='[5] List slice with empty range',
        cypher='WITH [1, 2, 3] AS list\n      RETURN list[0..0] AS r',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'r': '[]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list2-6',
        feature_path='tck/features/expressions/list/List2.feature',
        scenario='[6] List slice with negative range',
        cypher='WITH [1, 2, 3] AS list\n      RETURN list[-3..-1] AS r',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'r': '[1, 2]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list2-7',
        feature_path='tck/features/expressions/list/List2.feature',
        scenario='[7] List slice with invalid range',
        cypher='WITH [1, 2, 3] AS list\n      RETURN list[3..1] AS r',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'r': '[]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list2-8',
        feature_path='tck/features/expressions/list/List2.feature',
        scenario='[8] List slice with exceeding range',
        cypher='WITH [1, 2, 3] AS list\n      RETURN list[-5..5] AS r',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'r': '[1, 2, 3]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list2-9-1',
        feature_path='tck/features/expressions/list/List2.feature',
        scenario='[9] List slice with null range (example 1)',
        cypher='WITH [1, 2, 3] AS list\n      RETURN list[null..null] AS r',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'r': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list2-9-2',
        feature_path='tck/features/expressions/list/List2.feature',
        scenario='[9] List slice with null range (example 2)',
        cypher='WITH [1, 2, 3] AS list\n      RETURN list[1..null] AS r',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'r': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list2-9-3',
        feature_path='tck/features/expressions/list/List2.feature',
        scenario='[9] List slice with null range (example 3)',
        cypher='WITH [1, 2, 3] AS list\n      RETURN list[null..3] AS r',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'r': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list2-9-4',
        feature_path='tck/features/expressions/list/List2.feature',
        scenario='[9] List slice with null range (example 4)',
        cypher='WITH [1, 2, 3] AS list\n      RETURN list[..null] AS r',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'r': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list2-9-5',
        feature_path='tck/features/expressions/list/List2.feature',
        scenario='[9] List slice with null range (example 5)',
        cypher='WITH [1, 2, 3] AS list\n      RETURN list[null..] AS r',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'r': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list2-10',
        feature_path='tck/features/expressions/list/List2.feature',
        scenario='[10] List slice with parameterised range',
        cypher='WITH [1, 2, 3] AS list\n      RETURN list[$from..$to] AS r',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'r': '[2, 3]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Parameter binding is not supported',
        tags=('expr', 'list', 'meta-xfail', 'params', 'xfail'),
    ),
    Scenario(
        key='expr-list2-11',
        feature_path='tck/features/expressions/list/List2.feature',
        scenario='[11] List slice with parameterised invalid range',
        cypher='WITH [1, 2, 3] AS list\n      RETURN list[$from..$to] AS r',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'r': '[]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Parameter binding is not supported',
        tags=('expr', 'list', 'meta-xfail', 'params', 'xfail'),
    ),
    Scenario(
        key='expr-list3-1',
        feature_path='tck/features/expressions/list/List3.feature',
        scenario='[1] Equality between list and literal should return false',
        cypher="RETURN [1, 2] = 'foo' AS res",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'res': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list3-2',
        feature_path='tck/features/expressions/list/List3.feature',
        scenario='[2] Equality of lists of different length should return false despite nulls',
        cypher='RETURN [1] = [1, null] AS res',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'res': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list3-3',
        feature_path='tck/features/expressions/list/List3.feature',
        scenario='[3] Equality between different lists with null should return false',
        cypher="RETURN [1, 2] = [null, 'foo'] AS res",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'res': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list3-4',
        feature_path='tck/features/expressions/list/List3.feature',
        scenario='[4] Equality between almost equal lists with null should return null',
        cypher='RETURN [1, 2] = [null, 2] AS res',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'res': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list3-5',
        feature_path='tck/features/expressions/list/List3.feature',
        scenario='[5] Equality of nested lists of different length should return false despite nulls',
        cypher='RETURN [[1]] = [[1], [null]] AS res',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'res': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list3-6',
        feature_path='tck/features/expressions/list/List3.feature',
        scenario='[6] Equality between different nested lists with null should return false',
        cypher="RETURN [[1, 2], [1, 3]] = [[1, 2], [null, 'foo']] AS res",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'res': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list3-7',
        feature_path='tck/features/expressions/list/List3.feature',
        scenario='[7] Equality between almost equal nested lists with null should return null',
        cypher="RETURN [[1, 2], ['foo', 'bar']] = [[1, 2], [null, 'bar']] AS res",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'res': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list4-1',
        feature_path='tck/features/expressions/list/List4.feature',
        scenario='[1] Concatenating lists of same type',
        cypher='RETURN [1, 10, 100] + [4, 5] AS foo',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'foo': '[1, 10, 100, 4, 5]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list4-2',
        feature_path='tck/features/expressions/list/List4.feature',
        scenario='[2] Concatenating a list with a scalar of same type',
        cypher='RETURN [false, true] + false AS foo',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'foo': '[false, true, false]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list5-1',
        feature_path='tck/features/expressions/list/List5.feature',
        scenario='[1] IN should work with nested list subscripting',
        cypher='WITH [[1, 2, 3]] AS list\n      RETURN 3 IN list[0] AS r',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'r': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list5-2',
        feature_path='tck/features/expressions/list/List5.feature',
        scenario='[2] IN should work with nested literal list subscripting',
        cypher='RETURN 3 IN [[1, 2, 3]][0] AS r',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'r': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list5-3',
        feature_path='tck/features/expressions/list/List5.feature',
        scenario='[3] IN should work with list slices',
        cypher='WITH [1, 2, 3] AS list\n      RETURN 3 IN list[0..1] AS r',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'r': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list5-4',
        feature_path='tck/features/expressions/list/List5.feature',
        scenario='[4] IN should work with literal list slices',
        cypher='RETURN 3 IN [1, 2, 3][0..1] AS r',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'r': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list5-5',
        feature_path='tck/features/expressions/list/List5.feature',
        scenario='[5] IN should return false when matching a number with a string',
        cypher="RETURN 1 IN ['1', 2] AS res",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'res': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list5-6',
        feature_path='tck/features/expressions/list/List5.feature',
        scenario='[6] IN should return false when matching a number with a string - list version',
        cypher="RETURN [1, 2] IN [1, [1, '2']] AS res",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'res': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list5-7',
        feature_path='tck/features/expressions/list/List5.feature',
        scenario="[7] IN should return false when types of LHS and RHS don't match - singleton list",
        cypher='RETURN [1] IN [1, 2] AS res',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'res': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list5-8',
        feature_path='tck/features/expressions/list/List5.feature',
        scenario="[8] IN should return false when types of LHS and RHS don't match - list",
        cypher='RETURN [1, 2] IN [1, 2] AS res',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'res': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list5-9',
        feature_path='tck/features/expressions/list/List5.feature',
        scenario='[9] IN should return true when types of LHS and RHS match - singleton list',
        cypher='RETURN [1] IN [1, 2, [1]] AS res',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'res': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list5-10',
        feature_path='tck/features/expressions/list/List5.feature',
        scenario='[10] IN should return true when types of LHS and RHS match - list',
        cypher='RETURN [1, 2] IN [1, [1, 2]] AS res',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'res': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list5-11',
        feature_path='tck/features/expressions/list/List5.feature',
        scenario="[11] IN should return false when order of elements in LHS list and RHS list don't match",
        cypher='RETURN [1, 2] IN [1, [2, 1]] AS res',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'res': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list5-12',
        feature_path='tck/features/expressions/list/List5.feature',
        scenario='[12] IN with different length lists should return false',
        cypher='RETURN [1, 2] IN [1, [1, 2, 3]] AS res',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'res': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list5-13',
        feature_path='tck/features/expressions/list/List5.feature',
        scenario='[13] IN should return false when matching a list with a nested list with same elements',
        cypher='RETURN [1, 2] IN [1, [[1, 2]]] AS res',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'res': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list5-14',
        feature_path='tck/features/expressions/list/List5.feature',
        scenario='[14] IN should return true when both LHS and RHS contain nested lists',
        cypher='RETURN [[1, 2], [3, 4]] IN [5, [[1, 2], [3, 4]]] AS res',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'res': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list5-15',
        feature_path='tck/features/expressions/list/List5.feature',
        scenario='[15] IN should return true when both LHS and RHS contain a nested list alongside a scalar element',
        cypher='RETURN [[1, 2], 3] IN [1, [[1, 2], 3]] AS res',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'res': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list5-16',
        feature_path='tck/features/expressions/list/List5.feature',
        scenario='[16] IN should return true when LHS and RHS contain a nested list - singleton version',
        cypher='RETURN [[1]] IN [2, [[1]]] AS res',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'res': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list5-17',
        feature_path='tck/features/expressions/list/List5.feature',
        scenario='[17] IN should return true when LHS and RHS contain a nested list',
        cypher='RETURN [[1, 3]] IN [2, [[1, 3]]] AS res',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'res': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list5-18',
        feature_path='tck/features/expressions/list/List5.feature',
        scenario='[18] IN should return false when LHS contains a nested list and type mismatch on RHS - singleton version',
        cypher='RETURN [[1]] IN [2, [1]] AS res',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'res': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list5-19',
        feature_path='tck/features/expressions/list/List5.feature',
        scenario='[19] IN should return false when LHS contains a nested list and type mismatch on RHS',
        cypher='RETURN [[1, 3]] IN [2, [1, 3]] AS res',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'res': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list5-20',
        feature_path='tck/features/expressions/list/List5.feature',
        scenario='[20] IN should return null if LHS and RHS are null',
        cypher='RETURN null IN [null] AS res',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'res': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list5-21',
        feature_path='tck/features/expressions/list/List5.feature',
        scenario='[21] IN should return null if LHS and RHS are null - list version',
        cypher='RETURN [null] IN [[null]] AS res',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'res': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list5-22',
        feature_path='tck/features/expressions/list/List5.feature',
        scenario='[22] IN should return null when LHS and RHS both ultimately contain null, even if LHS and RHS are of different types (nested list and flat list)',
        cypher='RETURN [null] IN [null] AS res',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'res': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list5-23',
        feature_path='tck/features/expressions/list/List5.feature',
        scenario='[23] IN with different length lists should return false despite nulls',
        cypher='RETURN [1] IN [[1, null]] AS res',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'res': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list5-24',
        feature_path='tck/features/expressions/list/List5.feature',
        scenario='[24] IN should return true if match despite nulls',
        cypher='RETURN 3 IN [1, null, 3] AS res',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'res': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list5-25',
        feature_path='tck/features/expressions/list/List5.feature',
        scenario='[25] IN should return null if comparison with null is required',
        cypher='RETURN 4 IN [1, null, 3] AS res',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'res': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list5-26',
        feature_path='tck/features/expressions/list/List5.feature',
        scenario='[26] IN should return true if correct list found despite other lists having nulls',
        cypher="RETURN [1, 2] IN [[null, 'foo'], [1, 2]] AS res",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'res': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list5-27',
        feature_path='tck/features/expressions/list/List5.feature',
        scenario='[27] IN should return true if correct list found despite null being another element within containing list',
        cypher='RETURN [1, 2] IN [1, [1, 2], null] AS res',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'res': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list5-28',
        feature_path='tck/features/expressions/list/List5.feature',
        scenario='[28] IN should return false if no match can be found, despite nulls',
        cypher="RETURN [1, 2] IN [[null, 'foo']] AS res",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'res': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list5-29',
        feature_path='tck/features/expressions/list/List5.feature',
        scenario='[29] IN should return null if comparison with null is required, list version',
        cypher='RETURN [1, 2] IN [[null, 2]] AS res',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'res': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list5-30',
        feature_path='tck/features/expressions/list/List5.feature',
        scenario='[30] IN should return false if different length lists compared, even if the extra element is null',
        cypher='RETURN [1, 2] IN [1, [1, 2, null]] AS res',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'res': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list5-31',
        feature_path='tck/features/expressions/list/List5.feature',
        scenario='[31] IN should return null when comparing two so-called identical lists where one element is null',
        cypher='RETURN [1, 2, null] IN [1, [1, 2, null]] AS res',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'res': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list5-32',
        feature_path='tck/features/expressions/list/List5.feature',
        scenario='[32] IN should return true with previous null match, list version',
        cypher='RETURN [1, 2] IN [[null, 2], [1, 2]] AS res',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'res': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list5-33',
        feature_path='tck/features/expressions/list/List5.feature',
        scenario='[33] IN should return false if different length lists with nested elements compared, even if the extra element is null',
        cypher='RETURN [[1, 2], [3, 4]] IN [5, [[1, 2], [3, 4], null]] AS res',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'res': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list5-34',
        feature_path='tck/features/expressions/list/List5.feature',
        scenario='[34] IN should return null if comparison with null is required, list version 2',
        cypher='RETURN [1, 2] IN [[null, 2], [1, 3]] AS res',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'res': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list5-35',
        feature_path='tck/features/expressions/list/List5.feature',
        scenario='[35] IN should work with an empty list',
        cypher='RETURN [] IN [[]] AS res',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'res': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list5-36',
        feature_path='tck/features/expressions/list/List5.feature',
        scenario='[36] IN should return false for the empty list if the LHS and RHS types differ',
        cypher='RETURN [] IN [] AS res',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'res': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list5-37',
        feature_path='tck/features/expressions/list/List5.feature',
        scenario='[37] IN should work with an empty list in the presence of other list elements: matching',
        cypher='RETURN [] IN [1, []] AS res',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'res': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list5-38',
        feature_path='tck/features/expressions/list/List5.feature',
        scenario='[38] IN should work with an empty list in the presence of other list elements: not matching',
        cypher='RETURN [] IN [1, 2] AS res',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'res': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list5-39',
        feature_path='tck/features/expressions/list/List5.feature',
        scenario='[39] IN should work with an empty list when comparing nested lists',
        cypher='RETURN [[]] IN [1, [[]]] AS res',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'res': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list5-40',
        feature_path='tck/features/expressions/list/List5.feature',
        scenario='[40] IN should return null if comparison with null is required for empty list',
        cypher='RETURN [] IN [1, 2, null] AS res',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'res': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list5-41',
        feature_path='tck/features/expressions/list/List5.feature',
        scenario='[41] IN should return true when LHS and RHS contain nested list with multiple empty lists',
        cypher='RETURN [[], []] IN [1, [[], []]] AS res',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'res': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list5-42-1',
        feature_path='tck/features/expressions/list/List5.feature',
        scenario='[42] Failing when using IN on a non-list literal (example 1)',
        cypher='RETURN 1 IN true',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-list5-42-2',
        feature_path='tck/features/expressions/list/List5.feature',
        scenario='[42] Failing when using IN on a non-list literal (example 2)',
        cypher='RETURN 1 IN 123',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-list5-42-3',
        feature_path='tck/features/expressions/list/List5.feature',
        scenario='[42] Failing when using IN on a non-list literal (example 3)',
        cypher='RETURN 1 IN 123.4',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-list5-42-4',
        feature_path='tck/features/expressions/list/List5.feature',
        scenario='[42] Failing when using IN on a non-list literal (example 4)',
        cypher="RETURN 1 IN 'foo'",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-list5-42-5',
        feature_path='tck/features/expressions/list/List5.feature',
        scenario='[42] Failing when using IN on a non-list literal (example 5)',
        cypher='RETURN 1 IN {x: []}',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-list6-1',
        feature_path='tck/features/expressions/list/List6.feature',
        scenario='[1] Return list size',
        cypher='RETURN size([1, 2, 3]) AS n',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'n': 3}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list6-2',
        feature_path='tck/features/expressions/list/List6.feature',
        scenario='[2] Setting and returning the size of a list property',
        cypher='MATCH (n:TheLabel)\n      SET n.numbers = [1, 2, 3]\n      RETURN size(n.numbers)',
        graph=graph_fixture_from_create(
            """
            CREATE (:TheLabel)
            """
        ),
        expected=Expected(
            rows=[
            {'size(n.numbers)': 3}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list6-3',
        feature_path='tck/features/expressions/list/List6.feature',
        scenario='[3] Concatenating and returning the size of literal lists',
        cypher='RETURN size([[], []] + [[]]) AS l',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'l': 3}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list6-4',
        feature_path='tck/features/expressions/list/List6.feature',
        scenario='[4] `size()` on null list',
        cypher='WITH null AS l\n      RETURN size(l), size(null)',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'size(l)': 'null', 'size(null)': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list6-5',
        feature_path='tck/features/expressions/list/List6.feature',
        scenario='[5] Fail for `size()` on paths',
        cypher='MATCH p = (a)-[*]->(b)\n      RETURN size(p)',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-list6-6-1',
        feature_path='tck/features/expressions/list/List6.feature',
        scenario='[6] Fail for `size()` on pattern predicates (example 1)',
        cypher='MATCH (a), (b), (c)\n      RETURN size(()--())',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-list6-6-2',
        feature_path='tck/features/expressions/list/List6.feature',
        scenario='[6] Fail for `size()` on pattern predicates (example 2)',
        cypher='MATCH (a), (b), (c)\n      RETURN size(()--(a))',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-list6-6-3',
        feature_path='tck/features/expressions/list/List6.feature',
        scenario='[6] Fail for `size()` on pattern predicates (example 3)',
        cypher='MATCH (a), (b), (c)\n      RETURN size((a)-->())',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-list6-6-4',
        feature_path='tck/features/expressions/list/List6.feature',
        scenario='[6] Fail for `size()` on pattern predicates (example 4)',
        cypher='MATCH (a), (b), (c)\n      RETURN size((a)<--(a {}))',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-list6-6-5',
        feature_path='tck/features/expressions/list/List6.feature',
        scenario='[6] Fail for `size()` on pattern predicates (example 5)',
        cypher='MATCH (a), (b), (c)\n      RETURN size((a)-[:REL]->(b))',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-list6-6-6',
        feature_path='tck/features/expressions/list/List6.feature',
        scenario='[6] Fail for `size()` on pattern predicates (example 6)',
        cypher='MATCH (a), (b), (c)\n      RETURN size((a)-[:REL]->(b))',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-list6-6-7',
        feature_path='tck/features/expressions/list/List6.feature',
        scenario='[6] Fail for `size()` on pattern predicates (example 7)',
        cypher='MATCH (a), (b), (c)\n      RETURN size((a)-[:REL]->(:C)<-[:REL]-(a {num: 5}))',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-list6-6-8',
        feature_path='tck/features/expressions/list/List6.feature',
        scenario='[6] Fail for `size()` on pattern predicates (example 8)',
        cypher='MATCH (a), (b), (c)\n      RETURN size(()-[:REL*0..2]->()<-[:REL]-(:A {num: 5}))',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-list6-7',
        feature_path='tck/features/expressions/list/List6.feature',
        scenario='[7] Using size of pattern comprehension to test existence',
        cypher='MATCH (n:X)\n      RETURN n, size([(n)--() | 1]) > 0 AS b',
        graph=graph_fixture_from_create(
            """
            CREATE (a:X {num: 42}), (:X {num: 43})
                  CREATE (a)-[:T]->()
            """
        ),
        expected=Expected(
            rows=[
            {'n': '(:X {num: 42})', 'b': 'true'},
            {'n': '(:X {num: 43})', 'b': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list6-8',
        feature_path='tck/features/expressions/list/List6.feature',
        scenario='[8] Get node degree via size of pattern comprehension',
        cypher='MATCH (a:X)\n      RETURN size([(a)-->() | 1]) AS length',
        graph=graph_fixture_from_create(
            """
            CREATE (x:X),
                    (x)-[:T]->(),
                    (x)-[:T]->(),
                    (x)-[:T]->()
            """
        ),
        expected=Expected(
            rows=[
            {'length': 3}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list6-9',
        feature_path='tck/features/expressions/list/List6.feature',
        scenario='[9] Get node degree via size of pattern comprehension that specifies a relationship type',
        cypher='MATCH (a:X)\n      RETURN size([(a)-[:T]->() | 1]) AS length',
        graph=graph_fixture_from_create(
            """
            CREATE (x:X),
                    (x)-[:T]->(),
                    (x)-[:T]->(),
                    (x)-[:T]->(),
                    (x)-[:OTHER]->()
            """
        ),
        expected=Expected(
            rows=[
            {'length': 3}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list6-10',
        feature_path='tck/features/expressions/list/List6.feature',
        scenario='[10] Get node degree via size of pattern comprehension that specifies multiple relationship types',
        cypher='MATCH (a:X)\n      RETURN size([(a)-[:T|OTHER]->() | 1]) AS length',
        graph=graph_fixture_from_create(
            """
            CREATE (x:X),
                    (x)-[:T]->(),
                    (x)-[:T]->(),
                    (x)-[:T]->(),
                    (x)-[:OTHER]->()
            """
        ),
        expected=Expected(
            rows=[
            {'length': 4}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-list9-1',
        feature_path='tck/features/expressions/list/List9.feature',
        scenario='[1] Returning nested expressions based on list property',
        cypher='MATCH (n:TheLabel)\n      SET n.array = [1, 2, 3, 4, 5]\n      RETURN tail(tail(n.array))',
        graph=graph_fixture_from_create(
            """
            CREATE (:TheLabel)
            """
        ),
        expected=Expected(
            rows=[
            {'tail(tail(n.array))': '[3, 4, 5]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'list', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals1-1',
        feature_path='tck/features/expressions/literals/Literals1.feature',
        scenario='[1] Return a boolean true lower case',
        cypher='RETURN true AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals1-2',
        feature_path='tck/features/expressions/literals/Literals1.feature',
        scenario='[2] Return a boolean true upper case',
        cypher='RETURN TRUE AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals1-3',
        feature_path='tck/features/expressions/literals/Literals1.feature',
        scenario='[3] Return a boolean false lower case',
        cypher='RETURN false AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals1-4',
        feature_path='tck/features/expressions/literals/Literals1.feature',
        scenario='[4] Return a boolean false upper case',
        cypher='RETURN FALSE AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals1-5',
        feature_path='tck/features/expressions/literals/Literals1.feature',
        scenario='[5] Return null lower case',
        cypher='RETURN null AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals1-6',
        feature_path='tck/features/expressions/literals/Literals1.feature',
        scenario='[6] Return null upper case',
        cypher='RETURN NULL AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals2-1',
        feature_path='tck/features/expressions/literals/Literals2.feature',
        scenario='[1] Return a short positive integer',
        cypher='RETURN 1 AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': 1}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals2-2',
        feature_path='tck/features/expressions/literals/Literals2.feature',
        scenario='[2] Return a long positive integer',
        cypher='RETURN 372036854 AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': 372036854}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals2-3',
        feature_path='tck/features/expressions/literals/Literals2.feature',
        scenario='[3] Return the largest integer',
        cypher='RETURN 9223372036854775807 AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': 9223372036854775807}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals2-4',
        feature_path='tck/features/expressions/literals/Literals2.feature',
        scenario='[4] Return a positive zero',
        cypher='RETURN 0 AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': 0}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals2-5',
        feature_path='tck/features/expressions/literals/Literals2.feature',
        scenario='[5] Return a negative zero',
        cypher='RETURN -0 AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': 0}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals2-6',
        feature_path='tck/features/expressions/literals/Literals2.feature',
        scenario='[6] Return a short negative integer',
        cypher='RETURN -1 AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': -1}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals2-7',
        feature_path='tck/features/expressions/literals/Literals2.feature',
        scenario='[7] Return a long negative integer',
        cypher='RETURN -372036854 AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': -372036854}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals2-8',
        feature_path='tck/features/expressions/literals/Literals2.feature',
        scenario='[8] Return the smallest integer',
        cypher='RETURN -9223372036854775808 AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': -9223372036854775808}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals2-9',
        feature_path='tck/features/expressions/literals/Literals2.feature',
        scenario='[9] Fail on a too large integer',
        cypher='RETURN 9223372036854775808 AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-literals2-10',
        feature_path='tck/features/expressions/literals/Literals2.feature',
        scenario='[10] Fail on a too small integer',
        cypher='RETURN -9223372036854775809 AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-literals2-11',
        feature_path='tck/features/expressions/literals/Literals2.feature',
        scenario='[11] Fail on an integer containing a alphabetic character',
        cypher='RETURN 9223372h54775808 AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-literals2-12',
        feature_path='tck/features/expressions/literals/Literals2.feature',
        scenario='[12] Fail on an integer containing a invalid symbol character',
        cypher='RETURN 9223372#54775808 AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-literals3-1',
        feature_path='tck/features/expressions/literals/Literals3.feature',
        scenario='[1] Return a short positive hexadecimal integer',
        cypher='RETURN 0x1 AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': 1}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals3-2',
        feature_path='tck/features/expressions/literals/Literals3.feature',
        scenario='[2] Return a long positive hexadecimal integer',
        cypher='RETURN 0x162CD4F6 AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': 372036854}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals3-3',
        feature_path='tck/features/expressions/literals/Literals3.feature',
        scenario='[3] Return the largest hexadecimal integer',
        cypher='RETURN 0x7FFFFFFFFFFFFFFF AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': 9223372036854775807}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals3-4',
        feature_path='tck/features/expressions/literals/Literals3.feature',
        scenario='[4] Return a positive hexadecimal zero',
        cypher='RETURN 0x0 AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': 0}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals3-5',
        feature_path='tck/features/expressions/literals/Literals3.feature',
        scenario='[5] Return a negative hexadecimal zero',
        cypher='RETURN -0x0 AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': 0}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals3-6',
        feature_path='tck/features/expressions/literals/Literals3.feature',
        scenario='[6] Return a short negative hexadecimal integer',
        cypher='RETURN -0x1 AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': -1}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals3-7',
        feature_path='tck/features/expressions/literals/Literals3.feature',
        scenario='[7] Return a long negative hexadecimal integer',
        cypher='RETURN -0x162CD4F6 AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': -372036854}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals3-8',
        feature_path='tck/features/expressions/literals/Literals3.feature',
        scenario='[8] Return the smallest hexadecimal integer',
        cypher='RETURN -0x8000000000000000 AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': -9223372036854775808}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals3-9',
        feature_path='tck/features/expressions/literals/Literals3.feature',
        scenario='[9] Return a lower case hexadecimal integer',
        cypher='RETURN 0x1a2b3c4d5e6f7 AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': 460367961908983}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals3-10',
        feature_path='tck/features/expressions/literals/Literals3.feature',
        scenario='[10] Return a upper case hexadecimal integer',
        cypher='RETURN 0x1A2B3C4D5E6F7 AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': 460367961908983}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals3-11',
        feature_path='tck/features/expressions/literals/Literals3.feature',
        scenario='[11] Return a mixed case hexadecimal integer',
        cypher='RETURN 0x1A2b3c4D5E6f7 AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': 460367961908983}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals3-12',
        feature_path='tck/features/expressions/literals/Literals3.feature',
        scenario='[12] Fail on an incomplete hexadecimal integer',
        cypher='RETURN 0x AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-literals3-13',
        feature_path='tck/features/expressions/literals/Literals3.feature',
        scenario='[13] Fail on an hexadecimal literal containing a lower case invalid alphanumeric character',
        cypher='RETURN 0x1A2b3j4D5E6f7 AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-literals3-14',
        feature_path='tck/features/expressions/literals/Literals3.feature',
        scenario='[14] Fail on an hexadecimal literal containing a upper case invalid alphanumeric character',
        cypher='RETURN 0x1A2b3c4Z5E6f7 AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-literals3-16',
        feature_path='tck/features/expressions/literals/Literals3.feature',
        scenario='[16] Fail on a too large hexadecimal integer',
        cypher='RETURN 0x8000000000000000 AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-literals3-17',
        feature_path='tck/features/expressions/literals/Literals3.feature',
        scenario='[17] Fail on a too small hexadecimal integer',
        cypher='RETURN -0x8000000000000001 AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-literals4-1',
        feature_path='tck/features/expressions/literals/Literals4.feature',
        scenario='[1] Return a short positive octal integer',
        cypher='RETURN 0o1 AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': 1}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals4-2',
        feature_path='tck/features/expressions/literals/Literals4.feature',
        scenario='[2] Return a long positive octal integer',
        cypher='RETURN 0o2613152366 AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': 372036854}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals4-3',
        feature_path='tck/features/expressions/literals/Literals4.feature',
        scenario='[3] Return the largest octal integer',
        cypher='RETURN 0o777777777777777777777 AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': 9223372036854775807}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals4-4',
        feature_path='tck/features/expressions/literals/Literals4.feature',
        scenario='[4] Return a positive octal zero',
        cypher='RETURN 0o0 AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': 0}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals4-5',
        feature_path='tck/features/expressions/literals/Literals4.feature',
        scenario='[5] Return a negative octal zero',
        cypher='RETURN -0o0 AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': 0}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals4-6',
        feature_path='tck/features/expressions/literals/Literals4.feature',
        scenario='[6] Return a short negative octal integer',
        cypher='RETURN -0o1 AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': -1}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals4-7',
        feature_path='tck/features/expressions/literals/Literals4.feature',
        scenario='[7] Return a long negative octal integer',
        cypher='RETURN -0o2613152366 AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': -372036854}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals4-8',
        feature_path='tck/features/expressions/literals/Literals4.feature',
        scenario='[8] Return the smallest octal integer',
        cypher='RETURN -0o1000000000000000000000 AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': -9223372036854775808}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals4-9',
        feature_path='tck/features/expressions/literals/Literals4.feature',
        scenario='[9] Fail on a too large octal integer',
        cypher='RETURN 0o1000000000000000000000 AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-literals4-10',
        feature_path='tck/features/expressions/literals/Literals4.feature',
        scenario='[10] Fail on a too small octal integer',
        cypher='RETURN -0o1000000000000000000001 AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-literals5-1',
        feature_path='tck/features/expressions/literals/Literals5.feature',
        scenario='[1] Return a short positive float',
        cypher='RETURN 1.0 AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': 1.0}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals5-2',
        feature_path='tck/features/expressions/literals/Literals5.feature',
        scenario='[2] Return a short positive float without integer digits',
        cypher='RETURN .1 AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': 0.1}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals5-3',
        feature_path='tck/features/expressions/literals/Literals5.feature',
        scenario='[3] Return a long positive float',
        cypher='RETURN 3985764.3405892687 AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': 3985764.3405892686}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals5-4',
        feature_path='tck/features/expressions/literals/Literals5.feature',
        scenario='[4] Return a long positive float without integer digits',
        cypher='RETURN .3405892687 AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': 0.3405892687}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals5-5',
        feature_path='tck/features/expressions/literals/Literals5.feature',
        scenario='[5] Return a very long positive float',
        cypher='RETURN 126354186523812635418263552340512384016094862983471987543918591348961093487896783409268730945879405123840160948812635418265234051238401609486298347198754391859134896109348789678340926873094587962983471812635265234051238401609486298348126354182652340512384016094862983471987543918591348961093487896783409218.0 AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': '1.2635418652381264e305'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals5-6',
        feature_path='tck/features/expressions/literals/Literals5.feature',
        scenario='[6] Return a very long positive float without integer digits',
        cypher='RETURN .00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001 AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': '1e-305'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals5-7',
        feature_path='tck/features/expressions/literals/Literals5.feature',
        scenario='[7] Return a positive zero float',
        cypher='RETURN 0.0 AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': 0.0}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals5-8',
        feature_path='tck/features/expressions/literals/Literals5.feature',
        scenario='[8] Return a positive zero float without integer digits',
        cypher='RETURN .0 AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': 0.0}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals5-9',
        feature_path='tck/features/expressions/literals/Literals5.feature',
        scenario='[9] Return a negative zero float',
        cypher='RETURN -0.0 AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': 0.0}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals5-10',
        feature_path='tck/features/expressions/literals/Literals5.feature',
        scenario='[10] Return a negative zero float without integer digits',
        cypher='RETURN -.0 AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': 0.0}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals5-11',
        feature_path='tck/features/expressions/literals/Literals5.feature',
        scenario='[11] Return a very long negative float',
        cypher='RETURN -126354186523812635418263552340512384016094862983471987543918591348961093487896783409268730945879405123840160948812635418265234051238401609486298347198754391859134896109348789678340926873094587962983471812635265234051238401609486298348126354182652340512384016094862983471987543918591348961093487896783409218.0 AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': '-1.2635418652381264e305'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals5-12',
        feature_path='tck/features/expressions/literals/Literals5.feature',
        scenario='[12] Return a very long negative float without integer digits',
        cypher='RETURN -.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001 AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': '-1e-305'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals5-13',
        feature_path='tck/features/expressions/literals/Literals5.feature',
        scenario='[13] Return a positive float with positive lower case exponent',
        cypher='RETURN 1e9 AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': 1000000000.0}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals5-14',
        feature_path='tck/features/expressions/literals/Literals5.feature',
        scenario='[14] Return a positive float with positive upper case exponent',
        cypher='RETURN 1E9 AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': 1000000000.0}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals5-15',
        feature_path='tck/features/expressions/literals/Literals5.feature',
        scenario='[15] Return a positive float with positive lower case exponent without integer digits',
        cypher='RETURN .1e9 AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': 100000000.0}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals5-16',
        feature_path='tck/features/expressions/literals/Literals5.feature',
        scenario='[16] Return a positive float with negative lower case exponent',
        cypher='RETURN 1e-5 AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': 1e-05}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals5-17',
        feature_path='tck/features/expressions/literals/Literals5.feature',
        scenario='[17] Return a positive float with negative lower case exponent without integer digits',
        cypher='RETURN .1e-5 AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': 1e-06}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals5-18',
        feature_path='tck/features/expressions/literals/Literals5.feature',
        scenario='[18] Return a positive float with negative upper case exponent without integer digits',
        cypher='RETURN .1E-5 AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': 1e-06}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals5-19',
        feature_path='tck/features/expressions/literals/Literals5.feature',
        scenario='[19] Return a negative float in with positive lower case exponent',
        cypher='RETURN -1e9 AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': -1000000000.0}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals5-20',
        feature_path='tck/features/expressions/literals/Literals5.feature',
        scenario='[20] Return a negative float in with positive upper case exponent',
        cypher='RETURN -1E9 AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': -1000000000.0}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals5-21',
        feature_path='tck/features/expressions/literals/Literals5.feature',
        scenario='[21] Return a negative float with positive lower case exponent without integer digits',
        cypher='RETURN -.1e9 AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': -100000000.0}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals5-22',
        feature_path='tck/features/expressions/literals/Literals5.feature',
        scenario='[22] Return a negative float with negative lower case exponent',
        cypher='RETURN -1e-5 AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': -1e-05}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals5-23',
        feature_path='tck/features/expressions/literals/Literals5.feature',
        scenario='[23] Return a negative float with negative lower case exponent without integer digits',
        cypher='RETURN -.1e-5 AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': -1e-06}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals5-24',
        feature_path='tck/features/expressions/literals/Literals5.feature',
        scenario='[24] Return a negative float with negative upper case exponent without integer digits',
        cypher='RETURN -.1E-5 AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': -1e-06}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals5-25',
        feature_path='tck/features/expressions/literals/Literals5.feature',
        scenario='[25] Return a positive float with one integer digit and maximum positive exponent',
        cypher='RETURN 1e308 AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': '1e308'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals5-26',
        feature_path='tck/features/expressions/literals/Literals5.feature',
        scenario='[26] Return a positive float with nine integer digit and maximum positive exponent',
        cypher='RETURN 123456789e300 AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': '1.23456789e308'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals5-27',
        feature_path='tck/features/expressions/literals/Literals5.feature',
        scenario='[27] Fail when float value is too large',
        cypher='RETURN 1.34E999',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-literals6-1',
        feature_path='tck/features/expressions/literals/Literals6.feature',
        scenario='[1] Return a single-quoted empty string',
        cypher="RETURN '' AS literal",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': "''"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals6-2',
        feature_path='tck/features/expressions/literals/Literals6.feature',
        scenario='[2] Return a single-quoted string with one character',
        cypher="RETURN 'a' AS literal",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': "'a'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals6-3',
        feature_path='tck/features/expressions/literals/Literals6.feature',
        scenario='[3] Return a single-quoted string with uft-8 characters',
        cypher="RETURN '🧐🍌❖⋙⚐' AS literal",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': "'🧐🍌❖⋙⚐'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals6-4',
        feature_path='tck/features/expressions/literals/Literals6.feature',
        scenario='[4] Return a single-quoted string with escaped single-quoted',
        cypher="RETURN '\\'' AS literal",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': "'\\''"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals6-5',
        feature_path='tck/features/expressions/literals/Literals6.feature',
        scenario='[5] Return a single-quoted string with escaped characters',
        cypher='RETURN \'a\\\\bcn5t\\\'"\\\\//\\\\"\\\'\' AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': '\'a\\\\\\\\bcn5t\\\'"\\\\\\\\//\\\\\\\\"\\\'\''}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals6-6',
        feature_path='tck/features/expressions/literals/Literals6.feature',
        scenario='[6] Return a single-quoted string with 100 characters',
        cypher="RETURN 'zvhg02LrjXbeIWUue4CzFT1baQ5ZA uP0ur4suuufFWZu3MGLlMUDYdhya1WcV8GcpEa4Pi03YjPieg2hJY3rt4OAQIeBKhpasUd' AS literal",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': "'zvhg02LrjXbeIWUue4CzFT1baQ5ZA uP0ur4suuufFWZu3MGLlMUDYdhya1WcV8GcpEa4Pi03YjPieg2hJY3rt4OAQIeBKhpasUd'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals6-7',
        feature_path='tck/features/expressions/literals/Literals6.feature',
        scenario='[7] Return a single-quoted string with 1000 characters',
        cypher="RETURN '92WeD0wBWj GWB1Y pUd6ZiCalZR5VJzIxXt6C74 4bfhdEAkXIHccJ4Avce2aWXTBj v22FvYQ4F0R GfPsbTyQYaL6DEHMbKR HlnP3BrpNBSO427Tsayra 950dNriiiRPbfLhV5oNHZl1Lbs44oAl40hU4LTkZkzIzNhwDtnOunSXwHH4FWpoqSP7B8VHz88z7X8BoSCECUIVs T4z5UFT9oPUCIsdTjzOocn8nT0dD7PVwRzsO2a4R5sNyYe6R4TdBqIWELcIiKhTpaMQsfuEPuzFnwCV1L g zZhhR7yNIo14oupUUD0V0oIHIRvtM0MITOkSiTTmO68ROtezWPfdJQq9pQ6gdcPsy YAU0wMs dVFBTyTzPml55k VOgY4dEuHUC5BkDGwCm8BTvls07JdY4cwm1zsLq1xGuQfVYmr62WF7VeVVIKFX3FuAIOyFqIshJxA8rTnEtzL1eSxrVcabZ0j24i1Zv2D6SDvsbs45pPHNollnZJmKUkLfrldZzlNEuy4JkJa2ahzizZW72f5m2xiwDKgM3 g7nrbYLgIKUtXOdoJeKgUl2cN7j4Xd30dajZpcIDBqsZ LwmRYQlvRXFafWBMD3yQfU4GEzbWQlxV6iBidK83UVdyyvMKaqPvdqovPVQzhIK Xfs yVwnSHDXpjUonwsOFeykee9TcixuxkbYp3Md EBk4LcBDn4zFR3JSmz3FGfP1llIGL ZYWHrzjugMbxPXU02OrqExStd X1ALxTJq2W6mO4kQig4ZQFKHIs66EVWf6HG3SKAxzPAmmf4DZmlZGawG agiO2PrNnWyifOau4em ozqdkAbxu6mCbMEjMri7dkzpjtYFwkxUGpgSjfDm481Eby3SKvwNybwvqfj5CXHWSjGpk8YtJV0T3jzNd731Wb3SWQrVyIy2Wz1UntzYJ33O W9cFnumIVZK1Sj0pQwWoxktNdyknjXiL5COyZiZDBJOcNtIXoklXdBDy' AS literal",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': "'92WeD0wBWj GWB1Y pUd6ZiCalZR5VJzIxXt6C74 4bfhdEAkXIHccJ4Avce2aWXTBj v22FvYQ4F0R GfPsbTyQYaL6DEHMbKR HlnP3BrpNBSO427Tsayra 950dNriiiRPbfLhV5oNHZl1Lbs44oAl40hU4LTkZkzIzNhwDtnOunSXwHH4FWpoqSP7B8VHz88z7X8BoSCECUIVs T4z5UFT9oPUCIsdTjzOocn8nT0dD7PVwRzsO2a4R5sNyYe6R4TdBqIWELcIiKhTpaMQsfuEPuzFnwCV1L g zZhhR7yNIo14oupUUD0V0oIHIRvtM0MITOkSiTTmO68ROtezWPfdJQq9pQ6gdcPsy YAU0wMs dVFBTyTzPml55k VOgY4dEuHUC5BkDGwCm8BTvls07JdY4cwm1zsLq1xGuQfVYmr62WF7VeVVIKFX3FuAIOyFqIshJxA8rTnEtzL1eSxrVcabZ0j24i1Zv2D6SDvsbs45pPHNollnZJmKUkLfrldZzlNEuy4JkJa2ahzizZW72f5m2xiwDKgM3 g7nrbYLgIKUtXOdoJeKgUl2cN7j4Xd30dajZpcIDBqsZ LwmRYQlvRXFafWBMD3yQfU4GEzbWQlxV6iBidK83UVdyyvMKaqPvdqovPVQzhIK Xfs yVwnSHDXpjUonwsOFeykee9TcixuxkbYp3Md EBk4LcBDn4zFR3JSmz3FGfP1llIGL ZYWHrzjugMbxPXU02OrqExStd X1ALxTJq2W6mO4kQig4ZQFKHIs66EVWf6HG3SKAxzPAmmf4DZmlZGawG agiO2PrNnWyifOau4em ozqdkAbxu6mCbMEjMri7dkzpjtYFwkxUGpgSjfDm481Eby3SKvwNybwvqfj5CXHWSjGpk8YtJV0T3jzNd731Wb3SWQrVyIy2Wz1UntzYJ33O W9cFnumIVZK1Sj0pQwWoxktNdyknjXiL5COyZiZDBJOcNtIXoklXdBDy'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals6-8',
        feature_path='tck/features/expressions/literals/Literals6.feature',
        scenario='[8] Return a single-quoted string with 10000 characters',
        cypher="RETURN 'Qu7cFy732T2KJBCJzyY2xP7fWr4bhg7mdQALjUcVNa2nW2vIfAYMDxd4 ZGSe8g52kVWAiYI5K9SnVH2lMc7Uvh4M9hrvBUs5CPrAIjq9OwgxbVtZcfSrQgRe7hbkx162n0SNvY3KvqBBT5gyhTe4cG2BwJjFx8y11zpf0zyLpnYeQtd6V5maSx9tBigoLnjWdu9pjZ3aycAY8ZpzzOoBniPWThl1ydWyA8E4blXlzkeXnR9GY2UCpHpdmsg5u0GkF4phyqPt61 QRUiJBFXIHDx0zljppa vNLVbIaz8AqM7CGXU5796XKbiCX6uM9WRJXtUooJBJv0uHowr1tey4GQEL4t7j0tE4MznU9X7gRx7BMQGREyCBl5yR6qstIuMKug95TsVxUK3uE1oE5VsS68GlnL6IBAeNhsNMTA4kEflKNI2XKYGf4aDBLABvRa5Qbm12JpccslBbaILFQgQkPBy5nPRfh9Brjpyif1fPPkFB1rJIn 2z4G4irjFafOMuB 4JFTJnvj3 65yEbX7bNtgEF4oB7b7On8DVUAfFQfSz6T1SAFnOatwsNTts6dcH5JewU3jkS4TihfDUvAvw sjo0qoNxowKCoOtOUybt31Xg2mpeV5y5lyxZCSBkqjADNwLglwVcFa08Go3gU qP xs Hrw7ZmQ6vcy6oS6UH R3cJBUKWslkZKEYhXct3duSSWsnn8QFzKm6B4U6dmYXttjjVED0tqPXQ2vwp9eN8jJPebjZfT453810lZM9cQlfOhLdgsSaNaszT8t9pbPC5SrPPPIaXKF2IwRY3uMqAtTJD03bW o8dA3ZqT9igCrKRRfVo5j82HfUzjm2kBh4VT3UXfLGyTnnWqBqQ5WUbmdQQNfiMqGpBIcktEhov1XlJ6DyAzrn 1s yDyQS4Pjqg6y7NHl09nnJ3aMOxdDE7BHv4HVethC3Db32LHv6ZW9zotdOZ8tSH2AGKwhND6cfum67hSXu5OsAGeLZxrrMIn9ml9VWZj8Qxar 3lw3OM2jeUB62REWg7lxTJp3zVuaCQgejCGh40wOPR4vYtyzLdFxsxZ2qwn3XvnO2Xw25KckV8dstFfv4w9NFe03VTBWhoYkuSl0j3eCB1absxURBvss7ReatCgqonoVtkwD5RgknklJg12R56ikPOa9akQwEY ri5X8xDrKyqo2FXrj Np8AmXc4nx0yxydL4yF6WVk J9HmgHjGP0M3dMFOl0n15BUPyTAQNQhAHhDcGjt3jvTqKDW A4GG6gK2xn7hfdgAuoDj4h1lMZsSyYIGTnV6Zig8Nlmtwtss9kjCx 234UQbVuBD96JXbrjmY5jHd7c10KRvUFFzlGcdTscUUi38q6f0czcpoeT8MFBgEbrAw2b50fzz5tLhBGJGeKE0ndK64LOWP0olrS0voljEXYRiLMEArn1bkNUcaOgtQHzoV1Pqp6CR4suZxza66QcNOPH CoSuReOfjYOs1f0hWQ2RU2BUg1vJ5OyRPxAZ81195eJg82WgMFxIo 3EwNLUH6j3D41mu9G2L4ckbETdQRy8PEeM1KSIIjEBLD7xJdXFneolAbsv81mKzrWYRXw0pA8hTI4aIFFQSE8aaUkPUmCE0hzUENcHeNNHMK2UqsClOAdxRiz58hrzdUROac 7UM97kncRVWBSuW4GtISDrgBoEAJQqR2IFIh93W9wKCrESYtjf5uGLzEsGn3l0b2B0jXBoTkbd05jweOTk9LUOgpeNGBNWlpinKda9ny3OfjjCIZx3NnVqsxYiFeV0r4EgE4Vd5QypPNSoQN7rNx2aGufdT52tf1tGeK2d9uVgjDKIjJjZsDJhmnaOUbT5KPYb7fDJ4FJUcl22SMtXAkmQZTbXxGAkyve2SD6pyNB6ShBJ9LkeJPKDWQybSdRD tlQnHVqboE9iYdYOQSblltZwiQHMZcy4eiUHqW7uJ3Mve7bwRZLXYgJEoHeR7E8MXc0SpbVLpbEKEItiqFoi0XEhPGrRvE1PUhphlwiTJBXoLdGO02G97kpy2E8AZtFwboyuW0TXMyEg3bgAP TvGBrbtHyuYfbX6TC1meqTQOGTEMUBjz2VzRB ouL nUpSH7DojvQdxGi8F13xP12K 3IDVZX3UkPAsDgdChHvG5mFiSAaOWBZzUGbGTBkW52NtUQCMkzwYoCNwooNh5Ewk9rNafQQCsrmwaZQGrV pl4u9dBgedBtOeVF7SbxDdOewY uOb1TxLPn9CLwY7KY7igUGZ1prFMUqQ6IsmDLebpOIlG uKI7Xkar6hoRj1Xm8yWPf9o5qkGk agGuD4HrZOA2CtNVsWKiWnV09NLSBd5LdVkhjDbCFGRevIHO1aPCHTPpkml0EStzJdDHVtmGt6EYkbTXUZz7UZs8gKxNs950gEG 4Vtj98io9N0xNbO8FjLL lIqo4LunkmUs0otjT3gmshVAVTwQ0SjCRhqBs10NqVHAT9jCv J3s4mRSoirWeWw7UtzqRc bYtZrpvzmKvP 9lVvuOlEvWhcufv2VUQniDZFYE2EDtNCWrAqiodSAeX5eHEbfbQ5CwJjDjpBHJwoa7lPcZpt43nsXDLvZoIJZPzRPWOzDbt5u3loDI8aYrF2HOmpZ1Lrei XVV3DGYok8M5cWFgfaDILw8sa3kmDDJ2erUPblmMJZZB9eEOLnvEl5O9ALYbBBpnVTnLJvedw9uPVr1HXDmNWgAVpUFYXxKeQVReEFkHT29vENZGi3g7Bv2VUgEx5BxTlHGa13Kmge9QliYARWNfhBPjWQoP2ZRoKCDalsOCeohq2pNOKvkgZOy3AwfpFykBoUjtsvI7NAg6zVhCtCSo6PHcryDgAYYRF737e82qLpjkbCpMozebQRoGrZ7deTFTy TZCiOP2nGOKWiMnGq1daw3uAOx3ntthuZR1viQ8qmyXiIaBwJF5REqFJbZdPvRTpXns8vsG9PsXu DkPiWh3LieaiMGM3zyBsdFheatoBnj0ccBSsiKSDH SmVyBPw8K5vAeVA5WQy8LXX27mzhA7rlrXdWH8kMmtK15lR2AHE7XmSrzGaUbqWGRzmfrTDM vJPKZ8y73x8jhCvVK34nqFZbvlIRdYaUfWjQIGhdJ60V0JMJsh3bvYMDOlDnviPgT5MoAP6LszNwTp4O4yzdxgmq7CY48bQigcLRYEmg8ZWBU6ekc0Gk8Uuj3qC2Oy4DviJoC5Sy68xnl762KjXseDWuO0US6k5NCcztEWuB41AhFLjT Xlfv7dJNvDvyrTwYbnapgnqRTq2fD0NlkKq 0Wmjgv8HRMAUOU4Sfh2PNem 4BK4fBQKbzZWjK8Mjh4quPQr23P4K3qfVfyqGU9Y7HWPRiaz 86zjtl0Gu6DGo92GqPEGNBs RVMTebDPNWQWZju4bqF01z9jnsyzLbG1PD5bqdZccxHK9E bD9AM0KjsT3bSvhG4wCqIUOH9VBFKARnrscsgtF7sbmiBwtt3RfX9cddLMWn8lxh6swaE1pFyN8sg4qRhjVBHv0viacoxg7glAHAowSaqJXKRUWO0wBLz7esMhv9H44d6ztNLrgfays65REWjKWuMe4RsSP7VLGrQRvG6QKZ2GyI5K3WdQRRsPl2QrSxzCEHR1feQLSkngRpWAi4Gwt0ZUHzTGLMZeDQpG9fYWjSRfuPBWm4rHYyI0ny6WmqZa3yi3zeaHXKsNMMxV5RhI3wcY3UdgRBNTG1 yogATPH JYM5tSqE3M6tPgUumwH3qba 7a9XZcAJF7MYjb214yDndl8CYcQiJ9xUnyta9DToaXdLDFMOxIWdv4Oc Ae 092ASura8P5qig9RUZAwUpWiJTnCz6fSEkb1XHzAgW4HwrczuFFGsRNAUY5cReitkmwpFhf4Jz8KHHbUj8fbDROSfdsmjInlHnwLsB1sjfvZG6vk3LffL78GSIZ5fPfDnFm3rc2A0AWP0Abu539HMhSFd967byWCgpKqWCyMBjW1b6ool1XPus5gM0hx10WdSbMsEpYRR2SwicTxN18oIR4pJaQkE6or9TX6rz9vV6ZEyb4 ud wHyp1I227JdmFLT79kilRqj9K9xWnDR7SlCYSrIVavAnAa1vp4OF4fIQv5ER0Yj61PgmVQQWorwnGK4B9ArBshfyu CTzvR2isHgEpXVRg q2c4c4u7S19M 2PlDrcryc1M0HR1oBmdAsy mIV0E8BR 5E4xi5ZmrKMCXnpH7jURkiDLcu6bsOBufpLbEhKCaFJoC5r3nKY59nohuSWOigeOkEIcdCJt3VaQdwL1doyWzdpG0lUsCP9ZzzIB5oOp5RGgkoGiAh 5WSB5gHlpeK7lDPm2JEulXLeh97fRmSxe4nOVgyGscjoFfi9PgFqDuntZZwsNLiiMfsX8W 97fDeOT0TWvHw7JuioLjxDtOOOBrnZlKkUZQ7CRy7ch38tA1DzJOcCb178efuhtH91QrhoHJn6csVBRrg0DL98BGshITV Rojhsgq7j4NSLircpRgENiVRh49HigUtgwH5AK7xIAjMpD1ky gLFMqpfp4l9vlNrBhTpPDCI1R9UQMeCpiSXnJ9UjtL4uoXfmraI9xY4yVxVZFBXyhhk BaCRXp92qhUege4cIsMfK47FVJLIXzqn3Nu1TPmVyxQmmqXw7NLvVVu12x3DRrsi8ouiedz1KwDXmDhR4cLlnnHSei62MXC0elxELoUAooeyWnLPj6irfATHZ2BvdHUHNXLMq0xqqwzWDsQPklXiI5UPrCi6LfKDvwa38SAyF460vkacS92lPRdrh9S7xjhUOVN7mvjRYdnCU5I5sNiBsQqiuo8aA3GjQkXO0zBnddviQinlSjDEqB97aqZlviAgLTYtM8nbN1tWUH8gayIEPcpC4GyC37WCRiRg0hgyeXbs9sA1nHm5pIZ6sWY33A849nLfYF28C1TB27YPGTlrbCGIZEB4j62BvYUUAxmVo8VXS3hqegl2NPEKX8viEqv qwJZn1YBNjXRlJ1CHd6kqi48 udquQQT4XJTCMpfzbS9HOpXq4SRZmJDrqgXSsY4HPGc xk8p2ZRBodSSpKH3z6YOJ6tdOJ8BRqrymXoIsE1YK63BLSSyD437qwJedJzpHUMiLRZWJ 5FTcYrdWUIh4d I98rGjwjmlAdzEKMtXl0aimE 3hQ2T14pGWF2BlIKQPiX Q2FlSssswVhXtfdUdaBSlBXSk1e2JXVh4a2X5F ENUoTSbAgRHm 0jeYe9Mgw7BAOv1IXWzqfEpBgca0DnbIaDhYGojuvYb3ZKygKzsEXWF9ybgSNdMXARHYfNru2MoI9EKQHEcAHwwBWWKevcr92SnF83UyNyoyATmfb76bqggDHg0e4OD7FYyQ16VhLFowFGew7OhN16urh5 SU9JxECvjmbpe3mY83MOtZR65FRq3FaxYSsEDgI41Ce3wsNgkUXaxmiUw8M6FUFwihz8ZEihfxMb41EAnafjOUo66tfs1bzzWFvGuuEXfLeHOs07YF7YSmwhs6smrP3SkWXJCQfEjr9kn8sGB2VBpmO7aTiIdGHBa2u hyjkJrTu64n54dknHBPMl2Yc nyEoHucwalDRjPBhPNTAenytix29MsVEFvnaEqgxkB1DbdbifGvkWAt9t86BWvbgE2hIPAGA6zcm43Wzg8ENZCLqVoGSAFe ZjpptB4c84l a1XxUUxo7fmmDdkFNaTZP6UFmkzFnhDt3NB Dzom5Px h5CEHIvdgRSbdBr9tlLkm9gBTbS3fTYjPTPBnnGyUZnOhLMS8CExBvaAdxh6lmprWxyfaLOfi4uqmDQ5VGmjexWZin2Q7QQBSDZaLoSImoZ0TytdMvwpdIHQysLtvdLUJ9Jmklz4C cwZM538cCfD97iMjkZ sGB95sShsGhgNCUwR35cmjMJfVuFtppu4iU3AZkXs0OyKFUxBMhLEHQYBM0U9H rV0rHJDW0LirrncRqtLBOvcj bC4jKiSN3slzd v2XbmKBd4tWKKLcgMZmtF99WcteKyYMCWkF62nBVTyZZsyxUWETHOB9O2B7dukuQuGFz28pQhR Qsf7xKo8cwjc66YYWj61OFt4qFO9miVOojp8MR2qhCXdl1tVVHoUPh8WnrEnPWT C9u5co4NUhSAUHwyPuMKbr jhx9u34vJNaAScYvGDKy3wmxB3ogzfWE7n yqN1RvxJl9 mc0vk3ObjaGUYidas4nK2fQaVeNvwebbr dHeLJF0f qHWUoJmBKg6d7owotrQ7beZcYO7J7vZRZv0P26JuM3he8Q hl2Lak9ViLes59a4zfOn rzS9swYagFbPhwll44Q7lfRQzbjs7OO6viaC3aCYPv5BAPB8F9k W6sKpfuY52rpez5W4LoBBmjYMz8j 9Sc5WPXj32Zic fCaM65d eFACBAwnQeJKohksmmx9GPBKEZScTHe0gVqOfKklUv7OITLOVFIXD311e8KoWg2L7RZgiWz1JHNPI1BL9jkY3aQW52b6OGDX LR HQf7WoT3lQF85ICLNVKbjzWUDEL2AOIWK0jxvTnFiDBH7y2b4MpfmAfWBXtUsJJfgUGG2VW3pTFOqQS6rWir6jfvQs43ohSyt68RiZ1CfbR0Y9xY04fWPVsLKRlo9KM4JllXAwwKuSbvRpT4amOtbdkdKEKDPvmA6FQ61cSWayEADwjN8lbpUELdl150T9MjcDDdWZxv7nZ XAj493l8tUZlVGNXZ7OxOyoTf3PyIDCdtN9ut7TDBzpIFlDQhSBAHDY5cs5ct9nLzA6s1DGqdBj4NJPeRiKsPYGHnyqK5CE8S9IAJ 0XIfiJR so8fY9iySAKKECppnRk4hcdoVQhevjFBqAbSG02X1zkaKRXpvGxdWryFYL6TA9fVvRNpwi3JVSnhLslULMTcsnZeIkwN7QHWLDWh29DPXX31g7lLYdYnkiA53ZCCN0EKuwEpToy84vh3Gu8sO6Kv k6tHynKAVz0SentHsh 0LV387w8PQHYdYn7PzsQJ1sNmqIOyTn4Te7z1ElCSgqU0I0ImflD ilxsSUrsqaqhofXMyDkb5ZAaYGtFrhn Ea6 qw5ZCkbws8N8aY4gW90e90k9Rhhg0vE5nD74Rg5awiOA7vtmjn9LOKdLF67j1nVrpIZU4ADStXLwHWX0yCRFdw sfEKYuIrnFOc1sSjOKx fvHOSVGlYqaBv1yKqRBheU hsYupfxA3zzrlsYD71qZ4TmlqayGtK8p5SELT1mD0YG0v9VYPQrSqkrk V4kcPKckonY7zPZKkYbf6b5e22XVE0AWokBiYQwNuyIqEifpkhlc9PrUp13cwWncTlnMWyRDQrlW2i6oRJbMZJoE2Bcy72YMzbqvbcrmXnemI9tUDiHRZi0V1gbtxxvEjw 0 Z5UjDGk0jua35FOBRL4DdYRIawvkbzo7Lr 4PymJ0DrUu3k5IvBhQthdDJG7Dpf8Q4AiyUsZKkied3d7CFLKcpAmZ7up8J0pOcGEN3q0HsIUJ m1oW3acBCBXiYJ2 n JKAteFJPTgCqQzDhNOootC6BJXq4Ju4VUSdfD8poERjuadKYrInUCTKqRgU6H7N8B2lILyF GKnUT4mrxGxDduPrMIKE1wIdCOwAlD7H5V BYKZDF3GGwxsRU9Ktctq3tgatYQyB40VkWSftduesDqH118 2MhhZqYFwq8stqRqhFpYsjHwqY1owy yPnApsBOt7F7P9Y2NPCBziPywkY7nZiRhf2UtSLpWGPWlegIlkMCYtOB fNnPpxotXpOyUiNWcF TpwXxXrUG2PTnHouO2vtQOSS5OkbpDYPMgCNZI Pvc6WAV8H61FnNOaGJHYY8zmKGMNaqZg4XRpbDZKCd34aFJDmu6rXwzOf4LqagfuR6S3shK82phsJvJXpho6pkugIfCiai0Xw9qkUW2NT4DMiomcJmWEwUCnTEsZCUSN0Lxlz6Cm49 Jc8OBtlCYqGwOtQkK2Uqz0CYGxX9zUcu BYH2I00luXU6seC2vcn2ouX3oBmOkfg5GW4whSQJd0ahBvsRAvHMj2YAixGkZM9XE FgJqJYl98YoIUQtH7aOXkZfcgWsojqGo0v8DdZNjYuXJzUEgDzIbD xWwxjf2S1LeLieYDcqgnu6I6WpMlwaCAtReo tY7mLd5r2oxLABi7epYW6oZZrYxwhjZZNw1FgOo1OEWfwKn ApeXjiXDrQZb5rhwEjKGOE5uzI6Qohv3LIQgbBUL8rFU3g9FmkmmfdVtMGPpolkueiFzm4maKb8X4LLGiZ PeQfMGFQBW7UzH9PJFsVHecq96W6MVn6xbIiRItnuce61JXf7YWslpM1ktrFVzEF2hyEJSoMAec1Z3z2rEm33CBtOF9snfBky2ePmnioOm1yE8FpkyK7DVXGQEER2Zpz4nBGUalgPCNTQcOf34D4IY2Ucbn5 qMJzF5ibH0ogr6QmeSyRMQ3gWRp92RVpxD5sWQwKoCIagfhxevuLhz5k59zJqW5p82zcGiC3hcf3mMuJJ0IVibzNgepksfKRz19wGpOnnCKJW10jI7eW8EpF1pWdhTdcxZ7IGhMCFwj7ZHCmqNZLArfBI2gZYcKqR6hBDZYyzFj6SZ6J2X74JtFtIdWVasiyZ8gKviEAajZXIO2dn7cwwk17BWuFsP5NZ8l v07haNR0dcYwa9V4Nt3t8o7ZJSlXwELzODYA3WPsq4pUaof2dz8bsB1Fv2Hbe0VarRC9uqkthty1MImPBG5tDNbXZlTU4dh9Ph WIPtudfX3BRmptNHhJ5vPn2NJN41UIj70c0tgwNALFOgzk8NynQ5cGdz7CD8sQufqZPtlaDBV4ndTAgRpIg79DSA8SxN8eDQP4YrT6wDxJMxA9Aaerojes3EiQFc PVjqyqJ0oUDQvNK9rJ1ANrgJrcF jyk8BZtH Dipxg6HXKlDdLB5Tb8NObOnOBesJYHMY2iPQWKHhJc7g1hxJy9aUfdo5J4d9AyNDo83kPbNgqhsJO5tu7ZBaZVsJsV19H26SkHY8Z1vZOlQac7uKnqBZpp5OFwyHMOqIfw2Nf B6pmiF2lE1AlkMdICL2Nqh N8I54R918QZNNXDNtHnZWeLaGRqmS9DZBIwGkMm2COY3naU1IoF6yQY1MccPmebAdTNAmey1ArqvZCek5EXCJOoasrRE3qBIUSZXlU87odvxNCKJ78pZeP7U8Ed7RrnN3SbiDyEiY c7eDjdF4AAzcEr2 UlGGznQxBDriVuWBRWugpdIufzu5rk9KUe13Sa 5fPTAoHNXyjRIDObArGnjBHjPHPFM4nxyhk6mm2JCCYfNhKUmL5CBEf9jImdwRpu3KxQ1mv7bH9vKUWPcLMpVoX5P5gXvN1eOI0ZYyPoMDLd7UvcOrnjXL  2t4E0GG8TBRqLfbCLqyuBaePrnA0lIPHGQLMDoPe3IBidztyAhR KwoCWrwt2QbmvYs3KRaidfYuvMQ2 IlxUazVSZgJnc4PIpg cZkIWaTuQakpDyvJozz3yL2F4RIv14GovVvTq9QTpYkOvqHZxolngw0qpGbMeALhwFlWGpot5jgqeQjA VYA72jb2fxoWBl45AnqdW1czHYXG46kdRnUzrCenkF0mAkDuV0gRPY222BC7uWHAn6PTEWgDB3HyoBqPvanbc6s2ccdzSHJ4YJQWfAX td7UqFApODVkTbW6G7mjzuCeSpMoULyouH q1s0LjyECDXokV1Kri KhWGJUugEuxquue vh9AVw09QW fhya0F8ZmKVqD78G9EFbpMQjvOvgPlmCcvUmnxi3PXFDNkJG8WRPzocUVe3PTw0E3eEHghOKiEB4u0Xvt2Hb2esODlsJ5Uajn7B46Bq0w3W55MDUw0U5i8CP6QDrizWsQOYQOCF3vpLGOCVIyeleOWkVPz51u30XZCD7jKlRYvYOw2Rxocfq2YdbPZcvhPN7iRT ToHlNUY' AS literal",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': "'Qu7cFy732T2KJBCJzyY2xP7fWr4bhg7mdQALjUcVNa2nW2vIfAYMDxd4 ZGSe8g52kVWAiYI5K9SnVH2lMc7Uvh4M9hrvBUs5CPrAIjq9OwgxbVtZcfSrQgRe7hbkx162n0SNvY3KvqBBT5gyhTe4cG2BwJjFx8y11zpf0zyLpnYeQtd6V5maSx9tBigoLnjWdu9pjZ3aycAY8ZpzzOoBniPWThl1ydWyA8E4blXlzkeXnR9GY2UCpHpdmsg5u0GkF4phyqPt61 QRUiJBFXIHDx0zljppa vNLVbIaz8AqM7CGXU5796XKbiCX6uM9WRJXtUooJBJv0uHowr1tey4GQEL4t7j0tE4MznU9X7gRx7BMQGREyCBl5yR6qstIuMKug95TsVxUK3uE1oE5VsS68GlnL6IBAeNhsNMTA4kEflKNI2XKYGf4aDBLABvRa5Qbm12JpccslBbaILFQgQkPBy5nPRfh9Brjpyif1fPPkFB1rJIn 2z4G4irjFafOMuB 4JFTJnvj3 65yEbX7bNtgEF4oB7b7On8DVUAfFQfSz6T1SAFnOatwsNTts6dcH5JewU3jkS4TihfDUvAvw sjo0qoNxowKCoOtOUybt31Xg2mpeV5y5lyxZCSBkqjADNwLglwVcFa08Go3gU qP xs Hrw7ZmQ6vcy6oS6UH R3cJBUKWslkZKEYhXct3duSSWsnn8QFzKm6B4U6dmYXttjjVED0tqPXQ2vwp9eN8jJPebjZfT453810lZM9cQlfOhLdgsSaNaszT8t9pbPC5SrPPPIaXKF2IwRY3uMqAtTJD03bW o8dA3ZqT9igCrKRRfVo5j82HfUzjm2kBh4VT3UXfLGyTnnWqBqQ5WUbmdQQNfiMqGpBIcktEhov1XlJ6DyAzrn 1s yDyQS4Pjqg6y7NHl09nnJ3aMOxdDE7BHv4HVethC3Db32LHv6ZW9zotdOZ8tSH2AGKwhND6cfum67hSXu5OsAGeLZxrrMIn9ml9VWZj8Qxar 3lw3OM2jeUB62REWg7lxTJp3zVuaCQgejCGh40wOPR4vYtyzLdFxsxZ2qwn3XvnO2Xw25KckV8dstFfv4w9NFe03VTBWhoYkuSl0j3eCB1absxURBvss7ReatCgqonoVtkwD5RgknklJg12R56ikPOa9akQwEY ri5X8xDrKyqo2FXrj Np8AmXc4nx0yxydL4yF6WVk J9HmgHjGP0M3dMFOl0n15BUPyTAQNQhAHhDcGjt3jvTqKDW A4GG6gK2xn7hfdgAuoDj4h1lMZsSyYIGTnV6Zig8Nlmtwtss9kjCx 234UQbVuBD96JXbrjmY5jHd7c10KRvUFFzlGcdTscUUi38q6f0czcpoeT8MFBgEbrAw2b50fzz5tLhBGJGeKE0ndK64LOWP0olrS0voljEXYRiLMEArn1bkNUcaOgtQHzoV1Pqp6CR4suZxza66QcNOPH CoSuReOfjYOs1f0hWQ2RU2BUg1vJ5OyRPxAZ81195eJg82WgMFxIo 3EwNLUH6j3D41mu9G2L4ckbETdQRy8PEeM1KSIIjEBLD7xJdXFneolAbsv81mKzrWYRXw0pA8hTI4aIFFQSE8aaUkPUmCE0hzUENcHeNNHMK2UqsClOAdxRiz58hrzdUROac 7UM97kncRVWBSuW4GtISDrgBoEAJQqR2IFIh93W9wKCrESYtjf5uGLzEsGn3l0b2B0jXBoTkbd05jweOTk9LUOgpeNGBNWlpinKda9ny3OfjjCIZx3NnVqsxYiFeV0r4EgE4Vd5QypPNSoQN7rNx2aGufdT52tf1tGeK2d9uVgjDKIjJjZsDJhmnaOUbT5KPYb7fDJ4FJUcl22SMtXAkmQZTbXxGAkyve2SD6pyNB6ShBJ9LkeJPKDWQybSdRD tlQnHVqboE9iYdYOQSblltZwiQHMZcy4eiUHqW7uJ3Mve7bwRZLXYgJEoHeR7E8MXc0SpbVLpbEKEItiqFoi0XEhPGrRvE1PUhphlwiTJBXoLdGO02G97kpy2E8AZtFwboyuW0TXMyEg3bgAP TvGBrbtHyuYfbX6TC1meqTQOGTEMUBjz2VzRB ouL nUpSH7DojvQdxGi8F13xP12K 3IDVZX3UkPAsDgdChHvG5mFiSAaOWBZzUGbGTBkW52NtUQCMkzwYoCNwooNh5Ewk9rNafQQCsrmwaZQGrV pl4u9dBgedBtOeVF7SbxDdOewY uOb1TxLPn9CLwY7KY7igUGZ1prFMUqQ6IsmDLebpOIlG uKI7Xkar6hoRj1Xm8yWPf9o5qkGk agGuD4HrZOA2CtNVsWKiWnV09NLSBd5LdVkhjDbCFGRevIHO1aPCHTPpkml0EStzJdDHVtmGt6EYkbTXUZz7UZs8gKxNs950gEG 4Vtj98io9N0xNbO8FjLL lIqo4LunkmUs0otjT3gmshVAVTwQ0SjCRhqBs10NqVHAT9jCv J3s4mRSoirWeWw7UtzqRc bYtZrpvzmKvP 9lVvuOlEvWhcufv2VUQniDZFYE2EDtNCWrAqiodSAeX5eHEbfbQ5CwJjDjpBHJwoa7lPcZpt43nsXDLvZoIJZPzRPWOzDbt5u3loDI8aYrF2HOmpZ1Lrei XVV3DGYok8M5cWFgfaDILw8sa3kmDDJ2erUPblmMJZZB9eEOLnvEl5O9ALYbBBpnVTnLJvedw9uPVr1HXDmNWgAVpUFYXxKeQVReEFkHT29vENZGi3g7Bv2VUgEx5BxTlHGa13Kmge9QliYARWNfhBPjWQoP2ZRoKCDalsOCeohq2pNOKvkgZOy3AwfpFykBoUjtsvI7NAg6zVhCtCSo6PHcryDgAYYRF737e82qLpjkbCpMozebQRoGrZ7deTFTy TZCiOP2nGOKWiMnGq1daw3uAOx3ntthuZR1viQ8qmyXiIaBwJF5REqFJbZdPvRTpXns8vsG9PsXu DkPiWh3LieaiMGM3zyBsdFheatoBnj0ccBSsiKSDH SmVyBPw8K5vAeVA5WQy8LXX27mzhA7rlrXdWH8kMmtK15lR2AHE7XmSrzGaUbqWGRzmfrTDM vJPKZ8y73x8jhCvVK34nqFZbvlIRdYaUfWjQIGhdJ60V0JMJsh3bvYMDOlDnviPgT5MoAP6LszNwTp4O4yzdxgmq7CY48bQigcLRYEmg8ZWBU6ekc0Gk8Uuj3qC2Oy4DviJoC5Sy68xnl762KjXseDWuO0US6k5NCcztEWuB41AhFLjT Xlfv7dJNvDvyrTwYbnapgnqRTq2fD0NlkKq 0Wmjgv8HRMAUOU4Sfh2PNem 4BK4fBQKbzZWjK8Mjh4quPQr23P4K3qfVfyqGU9Y7HWPRiaz 86zjtl0Gu6DGo92GqPEGNBs RVMTebDPNWQWZju4bqF01z9jnsyzLbG1PD5bqdZccxHK9E bD9AM0KjsT3bSvhG4wCqIUOH9VBFKARnrscsgtF7sbmiBwtt3RfX9cddLMWn8lxh6swaE1pFyN8sg4qRhjVBHv0viacoxg7glAHAowSaqJXKRUWO0wBLz7esMhv9H44d6ztNLrgfays65REWjKWuMe4RsSP7VLGrQRvG6QKZ2GyI5K3WdQRRsPl2QrSxzCEHR1feQLSkngRpWAi4Gwt0ZUHzTGLMZeDQpG9fYWjSRfuPBWm4rHYyI0ny6WmqZa3yi3zeaHXKsNMMxV5RhI3wcY3UdgRBNTG1 yogATPH JYM5tSqE3M6tPgUumwH3qba 7a9XZcAJF7MYjb214yDndl8CYcQiJ9xUnyta9DToaXdLDFMOxIWdv4Oc Ae 092ASura8P5qig9RUZAwUpWiJTnCz6fSEkb1XHzAgW4HwrczuFFGsRNAUY5cReitkmwpFhf4Jz8KHHbUj8fbDROSfdsmjInlHnwLsB1sjfvZG6vk3LffL78GSIZ5fPfDnFm3rc2A0AWP0Abu539HMhSFd967byWCgpKqWCyMBjW1b6ool1XPus5gM0hx10WdSbMsEpYRR2SwicTxN18oIR4pJaQkE6or9TX6rz9vV6ZEyb4 ud wHyp1I227JdmFLT79kilRqj9K9xWnDR7SlCYSrIVavAnAa1vp4OF4fIQv5ER0Yj61PgmVQQWorwnGK4B9ArBshfyu CTzvR2isHgEpXVRg q2c4c4u7S19M 2PlDrcryc1M0HR1oBmdAsy mIV0E8BR 5E4xi5ZmrKMCXnpH7jURkiDLcu6bsOBufpLbEhKCaFJoC5r3nKY59nohuSWOigeOkEIcdCJt3VaQdwL1doyWzdpG0lUsCP9ZzzIB5oOp5RGgkoGiAh 5WSB5gHlpeK7lDPm2JEulXLeh97fRmSxe4nOVgyGscjoFfi9PgFqDuntZZwsNLiiMfsX8W 97fDeOT0TWvHw7JuioLjxDtOOOBrnZlKkUZQ7CRy7ch38tA1DzJOcCb178efuhtH91QrhoHJn6csVBRrg0DL98BGshITV Rojhsgq7j4NSLircpRgENiVRh49HigUtgwH5AK7xIAjMpD1ky gLFMqpfp4l9vlNrBhTpPDCI1R9UQMeCpiSXnJ9UjtL4uoXfmraI9xY4yVxVZFBXyhhk BaCRXp92qhUege4cIsMfK47FVJLIXzqn3Nu1TPmVyxQmmqXw7NLvVVu12x3DRrsi8ouiedz1KwDXmDhR4cLlnnHSei62MXC0elxELoUAooeyWnLPj6irfATHZ2BvdHUHNXLMq0xqqwzWDsQPklXiI5UPrCi6LfKDvwa38SAyF460vkacS92lPRdrh9S7xjhUOVN7mvjRYdnCU5I5sNiBsQqiuo8aA3GjQkXO0zBnddviQinlSjDEqB97aqZlviAgLTYtM8nbN1tWUH8gayIEPcpC4GyC37WCRiRg0hgyeXbs9sA1nHm5pIZ6sWY33A849nLfYF28C1TB27YPGTlrbCGIZEB4j62BvYUUAxmVo8VXS3hqegl2NPEKX8viEqv qwJZn1YBNjXRlJ1CHd6kqi48 udquQQT4XJTCMpfzbS9HOpXq4SRZmJDrqgXSsY4HPGc xk8p2ZRBodSSpKH3z6YOJ6tdOJ8BRqrymXoIsE1YK63BLSSyD437qwJedJzpHUMiLRZWJ 5FTcYrdWUIh4d I98rGjwjmlAdzEKMtXl0aimE 3hQ2T14pGWF2BlIKQPiX Q2FlSssswVhXtfdUdaBSlBXSk1e2JXVh4a2X5F ENUoTSbAgRHm 0jeYe9Mgw7BAOv1IXWzqfEpBgca0DnbIaDhYGojuvYb3ZKygKzsEXWF9ybgSNdMXARHYfNru2MoI9EKQHEcAHwwBWWKevcr92SnF83UyNyoyATmfb76bqggDHg0e4OD7FYyQ16VhLFowFGew7OhN16urh5 SU9JxECvjmbpe3mY83MOtZR65FRq3FaxYSsEDgI41Ce3wsNgkUXaxmiUw8M6FUFwihz8ZEihfxMb41EAnafjOUo66tfs1bzzWFvGuuEXfLeHOs07YF7YSmwhs6smrP3SkWXJCQfEjr9kn8sGB2VBpmO7aTiIdGHBa2u hyjkJrTu64n54dknHBPMl2Yc nyEoHucwalDRjPBhPNTAenytix29MsVEFvnaEqgxkB1DbdbifGvkWAt9t86BWvbgE2hIPAGA6zcm43Wzg8ENZCLqVoGSAFe ZjpptB4c84l a1XxUUxo7fmmDdkFNaTZP6UFmkzFnhDt3NB Dzom5Px h5CEHIvdgRSbdBr9tlLkm9gBTbS3fTYjPTPBnnGyUZnOhLMS8CExBvaAdxh6lmprWxyfaLOfi4uqmDQ5VGmjexWZin2Q7QQBSDZaLoSImoZ0TytdMvwpdIHQysLtvdLUJ9Jmklz4C cwZM538cCfD97iMjkZ sGB95sShsGhgNCUwR35cmjMJfVuFtppu4iU3AZkXs0OyKFUxBMhLEHQYBM0U9H rV0rHJDW0LirrncRqtLBOvcj bC4jKiSN3slzd v2XbmKBd4tWKKLcgMZmtF99WcteKyYMCWkF62nBVTyZZsyxUWETHOB9O2B7dukuQuGFz28pQhR Qsf7xKo8cwjc66YYWj61OFt4qFO9miVOojp8MR2qhCXdl1tVVHoUPh8WnrEnPWT C9u5co4NUhSAUHwyPuMKbr jhx9u34vJNaAScYvGDKy3wmxB3ogzfWE7n yqN1RvxJl9 mc0vk3ObjaGUYidas4nK2fQaVeNvwebbr dHeLJF0f qHWUoJmBKg6d7owotrQ7beZcYO7J7vZRZv0P26JuM3he8Q hl2Lak9ViLes59a4zfOn rzS9swYagFbPhwll44Q7lfRQzbjs7OO6viaC3aCYPv5BAPB8F9k W6sKpfuY52rpez5W4LoBBmjYMz8j 9Sc5WPXj32Zic fCaM65d eFACBAwnQeJKohksmmx9GPBKEZScTHe0gVqOfKklUv7OITLOVFIXD311e8KoWg2L7RZgiWz1JHNPI1BL9jkY3aQW52b6OGDX LR HQf7WoT3lQF85ICLNVKbjzWUDEL2AOIWK0jxvTnFiDBH7y2b4MpfmAfWBXtUsJJfgUGG2VW3pTFOqQS6rWir6jfvQs43ohSyt68RiZ1CfbR0Y9xY04fWPVsLKRlo9KM4JllXAwwKuSbvRpT4amOtbdkdKEKDPvmA6FQ61cSWayEADwjN8lbpUELdl150T9MjcDDdWZxv7nZ XAj493l8tUZlVGNXZ7OxOyoTf3PyIDCdtN9ut7TDBzpIFlDQhSBAHDY5cs5ct9nLzA6s1DGqdBj4NJPeRiKsPYGHnyqK5CE8S9IAJ 0XIfiJR so8fY9iySAKKECppnRk4hcdoVQhevjFBqAbSG02X1zkaKRXpvGxdWryFYL6TA9fVvRNpwi3JVSnhLslULMTcsnZeIkwN7QHWLDWh29DPXX31g7lLYdYnkiA53ZCCN0EKuwEpToy84vh3Gu8sO6Kv k6tHynKAVz0SentHsh 0LV387w8PQHYdYn7PzsQJ1sNmqIOyTn4Te7z1ElCSgqU0I0ImflD ilxsSUrsqaqhofXMyDkb5ZAaYGtFrhn Ea6 qw5ZCkbws8N8aY4gW90e90k9Rhhg0vE5nD74Rg5awiOA7vtmjn9LOKdLF67j1nVrpIZU4ADStXLwHWX0yCRFdw sfEKYuIrnFOc1sSjOKx fvHOSVGlYqaBv1yKqRBheU hsYupfxA3zzrlsYD71qZ4TmlqayGtK8p5SELT1mD0YG0v9VYPQrSqkrk V4kcPKckonY7zPZKkYbf6b5e22XVE0AWokBiYQwNuyIqEifpkhlc9PrUp13cwWncTlnMWyRDQrlW2i6oRJbMZJoE2Bcy72YMzbqvbcrmXnemI9tUDiHRZi0V1gbtxxvEjw 0 Z5UjDGk0jua35FOBRL4DdYRIawvkbzo7Lr 4PymJ0DrUu3k5IvBhQthdDJG7Dpf8Q4AiyUsZKkied3d7CFLKcpAmZ7up8J0pOcGEN3q0HsIUJ m1oW3acBCBXiYJ2 n JKAteFJPTgCqQzDhNOootC6BJXq4Ju4VUSdfD8poERjuadKYrInUCTKqRgU6H7N8B2lILyF GKnUT4mrxGxDduPrMIKE1wIdCOwAlD7H5V BYKZDF3GGwxsRU9Ktctq3tgatYQyB40VkWSftduesDqH118 2MhhZqYFwq8stqRqhFpYsjHwqY1owy yPnApsBOt7F7P9Y2NPCBziPywkY7nZiRhf2UtSLpWGPWlegIlkMCYtOB fNnPpxotXpOyUiNWcF TpwXxXrUG2PTnHouO2vtQOSS5OkbpDYPMgCNZI Pvc6WAV8H61FnNOaGJHYY8zmKGMNaqZg4XRpbDZKCd34aFJDmu6rXwzOf4LqagfuR6S3shK82phsJvJXpho6pkugIfCiai0Xw9qkUW2NT4DMiomcJmWEwUCnTEsZCUSN0Lxlz6Cm49 Jc8OBtlCYqGwOtQkK2Uqz0CYGxX9zUcu BYH2I00luXU6seC2vcn2ouX3oBmOkfg5GW4whSQJd0ahBvsRAvHMj2YAixGkZM9XE FgJqJYl98YoIUQtH7aOXkZfcgWsojqGo0v8DdZNjYuXJzUEgDzIbD xWwxjf2S1LeLieYDcqgnu6I6WpMlwaCAtReo tY7mLd5r2oxLABi7epYW6oZZrYxwhjZZNw1FgOo1OEWfwKn ApeXjiXDrQZb5rhwEjKGOE5uzI6Qohv3LIQgbBUL8rFU3g9FmkmmfdVtMGPpolkueiFzm4maKb8X4LLGiZ PeQfMGFQBW7UzH9PJFsVHecq96W6MVn6xbIiRItnuce61JXf7YWslpM1ktrFVzEF2hyEJSoMAec1Z3z2rEm33CBtOF9snfBky2ePmnioOm1yE8FpkyK7DVXGQEER2Zpz4nBGUalgPCNTQcOf34D4IY2Ucbn5 qMJzF5ibH0ogr6QmeSyRMQ3gWRp92RVpxD5sWQwKoCIagfhxevuLhz5k59zJqW5p82zcGiC3hcf3mMuJJ0IVibzNgepksfKRz19wGpOnnCKJW10jI7eW8EpF1pWdhTdcxZ7IGhMCFwj7ZHCmqNZLArfBI2gZYcKqR6hBDZYyzFj6SZ6J2X74JtFtIdWVasiyZ8gKviEAajZXIO2dn7cwwk17BWuFsP5NZ8l v07haNR0dcYwa9V4Nt3t8o7ZJSlXwELzODYA3WPsq4pUaof2dz8bsB1Fv2Hbe0VarRC9uqkthty1MImPBG5tDNbXZlTU4dh9Ph WIPtudfX3BRmptNHhJ5vPn2NJN41UIj70c0tgwNALFOgzk8NynQ5cGdz7CD8sQufqZPtlaDBV4ndTAgRpIg79DSA8SxN8eDQP4YrT6wDxJMxA9Aaerojes3EiQFc PVjqyqJ0oUDQvNK9rJ1ANrgJrcF jyk8BZtH Dipxg6HXKlDdLB5Tb8NObOnOBesJYHMY2iPQWKHhJc7g1hxJy9aUfdo5J4d9AyNDo83kPbNgqhsJO5tu7ZBaZVsJsV19H26SkHY8Z1vZOlQac7uKnqBZpp5OFwyHMOqIfw2Nf B6pmiF2lE1AlkMdICL2Nqh N8I54R918QZNNXDNtHnZWeLaGRqmS9DZBIwGkMm2COY3naU1IoF6yQY1MccPmebAdTNAmey1ArqvZCek5EXCJOoasrRE3qBIUSZXlU87odvxNCKJ78pZeP7U8Ed7RrnN3SbiDyEiY c7eDjdF4AAzcEr2 UlGGznQxBDriVuWBRWugpdIufzu5rk9KUe13Sa 5fPTAoHNXyjRIDObArGnjBHjPHPFM4nxyhk6mm2JCCYfNhKUmL5CBEf9jImdwRpu3KxQ1mv7bH9vKUWPcLMpVoX5P5gXvN1eOI0ZYyPoMDLd7UvcOrnjXL  2t4E0GG8TBRqLfbCLqyuBaePrnA0lIPHGQLMDoPe3IBidztyAhR KwoCWrwt2QbmvYs3KRaidfYuvMQ2 IlxUazVSZgJnc4PIpg cZkIWaTuQakpDyvJozz3yL2F4RIv14GovVvTq9QTpYkOvqHZxolngw0qpGbMeALhwFlWGpot5jgqeQjA VYA72jb2fxoWBl45AnqdW1czHYXG46kdRnUzrCenkF0mAkDuV0gRPY222BC7uWHAn6PTEWgDB3HyoBqPvanbc6s2ccdzSHJ4YJQWfAX td7UqFApODVkTbW6G7mjzuCeSpMoULyouH q1s0LjyECDXokV1Kri KhWGJUugEuxquue vh9AVw09QW fhya0F8ZmKVqD78G9EFbpMQjvOvgPlmCcvUmnxi3PXFDNkJG8WRPzocUVe3PTw0E3eEHghOKiEB4u0Xvt2Hb2esODlsJ5Uajn7B46Bq0w3W55MDUw0U5i8CP6QDrizWsQOYQOCF3vpLGOCVIyeleOWkVPz51u30XZCD7jKlRYvYOw2Rxocfq2YdbPZcvhPN7iRT ToHlNUY'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals6-9',
        feature_path='tck/features/expressions/literals/Literals6.feature',
        scenario='[9] Return a double-quoted empty string',
        cypher='RETURN "" AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': "''"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals6-10',
        feature_path='tck/features/expressions/literals/Literals6.feature',
        scenario='[10] Accept valid Unicode literal',
        cypher="RETURN '\\u01FF' AS a",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'a': "'ǿ'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals6-11',
        feature_path='tck/features/expressions/literals/Literals6.feature',
        scenario='[11] Return a double-quoted string with one character',
        cypher='RETURN "a" AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': "'a'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals6-12',
        feature_path='tck/features/expressions/literals/Literals6.feature',
        scenario='[12] Return a double-quoted string with uft-8 characters',
        cypher='RETURN "🧐🍌❖⋙⚐" AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': "'🧐🍌❖⋙⚐'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals6-13',
        feature_path='tck/features/expressions/literals/Literals6.feature',
        scenario='[13] Failing on incorrect unicode literal',
        cypher="RETURN '\\uH'",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-literals7-1',
        feature_path='tck/features/expressions/literals/Literals7.feature',
        scenario='[1] Return an empty list',
        cypher='RETURN [] AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': '[]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals7-2',
        feature_path='tck/features/expressions/literals/Literals7.feature',
        scenario='[2] Return a list containing a boolean',
        cypher='RETURN [false] AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': '[false]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals7-3',
        feature_path='tck/features/expressions/literals/Literals7.feature',
        scenario='[3] Return a list containing a null',
        cypher='RETURN [null] AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': '[null]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals7-4',
        feature_path='tck/features/expressions/literals/Literals7.feature',
        scenario='[4] Return a list containing a integer',
        cypher='RETURN [1] AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': '[1]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals7-5',
        feature_path='tck/features/expressions/literals/Literals7.feature',
        scenario='[5] Return a list containing a hexadecimal integer',
        cypher='RETURN [-0x162CD4F6] AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': '[-372036854]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals7-6',
        feature_path='tck/features/expressions/literals/Literals7.feature',
        scenario='[6] Return a list containing a octal integer',
        cypher='RETURN [0o2613152366] AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': '[372036854]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals7-7',
        feature_path='tck/features/expressions/literals/Literals7.feature',
        scenario='[7] Return a list containing a float',
        cypher='RETURN [-.1e-5] AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': '[-0.000001]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals7-8',
        feature_path='tck/features/expressions/literals/Literals7.feature',
        scenario='[8] Return a list containing a string',
        cypher="RETURN ['abc, as#?lßdj '] AS literal",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': "['abc, as#?lßdj ']"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals7-9',
        feature_path='tck/features/expressions/literals/Literals7.feature',
        scenario='[9] Return a list containing an empty lists',
        cypher='RETURN [[]] AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': '[[]]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals7-10',
        feature_path='tck/features/expressions/literals/Literals7.feature',
        scenario='[10] Return seven-deep nested empty lists',
        cypher='RETURN [[[[[[[]]]]]]] AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': '[[[[[[[]]]]]]]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals7-11',
        feature_path='tck/features/expressions/literals/Literals7.feature',
        scenario='[11] Return 20-deep nested empty lists',
        cypher='RETURN [[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]] AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': '[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals7-12',
        feature_path='tck/features/expressions/literals/Literals7.feature',
        scenario='[12] Return 40-deep nested empty lists',
        cypher='RETURN [[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]] AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': '[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals7-13',
        feature_path='tck/features/expressions/literals/Literals7.feature',
        scenario='[13] Return a list containing an empty map',
        cypher='RETURN [{}] AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': '[{}]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals7-14',
        feature_path='tck/features/expressions/literals/Literals7.feature',
        scenario='[14] Return a list containing multiple integer',
        cypher='RETURN [1, -2, 0o77, 0xA4C, 71034856] AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': '[1, -2, 63, 2636, 71034856]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals7-16',
        feature_path='tck/features/expressions/literals/Literals7.feature',
        scenario='[16] Return a list containing multiple mixed values',
        cypher="RETURN [2E-01, ', as#?lßdj ', null, 71034856, false] AS literal",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': "[0.2, ', as#?lßdj ', null, 71034856, false]"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals7-17',
        feature_path='tck/features/expressions/literals/Literals7.feature',
        scenario='[17] Return a list containing real and fake nested lists',
        cypher="RETURN [null, [ ' a ', ' ' ], ' [ a ', ' [ ], ] ', ' [ ', [ ' ' ], ' ] ' ] AS literal",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': "[null, [' a ', ' '], ' [ a ', ' [ ], ] ', ' [ ', [' '], ' ] ']"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals7-18',
        feature_path='tck/features/expressions/literals/Literals7.feature',
        scenario='[18] Return a complex list containing multiple mixed and nested values',
        cypher="RETURN [ {\n                  id: '0001',\n                  type: 'donut',\n                  name: 'Cake',\n                  ppu: 0.55,\n                  batters:\n                      {\n                          batter:\n                              [\n                                  { id: '1001', type: 'Regular' },\n                                  { id: '1002', type: 'Chocolate' },\n                                  { id: '1003', type: 'Blueberry' },\n                                  { id: '1004', type: 'Devils Food' }\n                              ]\n                      },\n                  topping:\n                      [\n                          { id: '5001', type: 'None' },\n                          { id: '5002', type: 'Glazed' },\n                          { id: '5005', type: 'Sugar' },\n                          { id: '5007', type: 'Powdered Sugar' },\n                          { id: '5006', type: 'Chocolate Sprinkles' },\n                          { id: '5003', type: 'Chocolate' },\n                          { id: '5004', type: 'Maple' }\n                      ]\n              },\n              {\n                  id: '0002',\n                  type: 'donut',\n                  name: 'Raised',\n                  ppu: 0.55,\n                  batters:\n                      {\n                          batter:\n                              [\n                                  { id: '1001', type: 'Regular' }\n                              ]\n                      },\n                  topping:\n                      [\n                          { id: '5001', type: 'None' },\n                          { id: '5002', type: 'Glazed' },\n                          { id: '5005', type: 'Sugar' },\n                          { id: '5003', type: 'Chocolate' },\n                          { id: '5004', type: 'Maple' }\n                      ]\n              },\n              {\n                  id: '0003',\n                  type: 'donut',\n                  name: 'Old Fashioned',\n                  ppu: 0.55,\n                  batters:\n                      {\n                          batter:\n                              [\n                                  { id: '1001', type: 'Regular' },\n                                  { id: '1002', type: 'Chocolate' }\n                              ]\n                      },\n                  topping:\n                      [\n                          { id: '5001', type: 'None' },\n                          { id: '5002', type: 'Glazed' },\n                          { id: '5003', type: 'Chocolate' },\n                          { id: '5004', type: 'Maple' }\n                      ]\n              } ] AS literal",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': "[{id: '0001', type: 'donut', name: 'Cake', ppu: 0.55, batters: {batter: [{id: '1001', type: 'Regular'}, {id: '1002', type: 'Chocolate'}, {id: '1003', type: 'Blueberry'}, {id: '1004', type: 'Devils Food'}]}, topping: [{id: '5001', type: 'None'}, {id: '5002', type: 'Glazed'}, {id: '5005', type: 'Sugar'}, {id: '5007', type: 'Powdered Sugar'}, {id: '5006', type: 'Chocolate Sprinkles'}, {id: '5003', type: 'Chocolate'}, {id: '5004', type: 'Maple'}]}, {id: '0002', type: 'donut', name: 'Raised', ppu: 0.55, batters: {batter: [{id: '1001', type: 'Regular'}]}, topping: [{id: '5001', type: 'None'}, {id: '5002', type: 'Glazed'}, {id: '5005', type: 'Sugar'}, {id: '5003', type: 'Chocolate'}, {id: '5004', type: 'Maple'}]}, {id: '0003', type: 'donut', name: 'Old Fashioned', ppu: 0.55, batters: {batter: [{id: '1001', type: 'Regular'}, {id: '1002', type: 'Chocolate'}]}, topping: [{id: '5001', type: 'None'}, {id: '5002', type: 'Glazed'}, {id: '5003', type: 'Chocolate'}, {id: '5004', type: 'Maple'}]}]"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals7-19',
        feature_path='tck/features/expressions/literals/Literals7.feature',
        scenario='[19] Fail on a list containing only a comma',
        cypher='RETURN [, ] AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-literals7-20',
        feature_path='tck/features/expressions/literals/Literals7.feature',
        scenario='[20] Fail on a nested list with non-matching brackets',
        cypher='RETURN [[[]] AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-literals7-21',
        feature_path='tck/features/expressions/literals/Literals7.feature',
        scenario='[21] Fail on a nested list with missing commas',
        cypher="RETURN [[','[]',']] AS literal",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-literals8-1',
        feature_path='tck/features/expressions/literals/Literals8.feature',
        scenario='[1] Return an empty map',
        cypher='RETURN {} AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': '{}'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals8-2',
        feature_path='tck/features/expressions/literals/Literals8.feature',
        scenario='[2] Return a map containing one value with alphabetic lower case key',
        cypher='RETURN {abc: 1} AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': '{abc: 1}'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals8-3',
        feature_path='tck/features/expressions/literals/Literals8.feature',
        scenario='[3] Return a map containing one value with alphabetic upper case key',
        cypher='RETURN {ABC: 1} AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': '{ABC: 1}'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals8-4',
        feature_path='tck/features/expressions/literals/Literals8.feature',
        scenario='[4] Return a map containing one value with alphabetic mixed case key',
        cypher='RETURN {aBCdeF: 1} AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': '{aBCdeF: 1}'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals8-5',
        feature_path='tck/features/expressions/literals/Literals8.feature',
        scenario='[5] Return a map containing one value with alphanumeric mixed case key',
        cypher='RETURN {a1B2c3e67: 1} AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': '{a1B2c3e67: 1}'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals8-6',
        feature_path='tck/features/expressions/literals/Literals8.feature',
        scenario='[6] Return a map containing a boolean',
        cypher='RETURN {k: false} AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': '{k: false}'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals8-7',
        feature_path='tck/features/expressions/literals/Literals8.feature',
        scenario='[7] Return a map containing a null',
        cypher='RETURN {k: null} AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': '{k: null}'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals8-8',
        feature_path='tck/features/expressions/literals/Literals8.feature',
        scenario='[8] Return a map containing a integer',
        cypher='RETURN {k: 1} AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': '{k: 1}'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals8-9',
        feature_path='tck/features/expressions/literals/Literals8.feature',
        scenario='[9] Return a map containing a hexadecimal integer',
        cypher='RETURN {F: -0x162CD4F6} AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': '{F: -372036854}'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals8-10',
        feature_path='tck/features/expressions/literals/Literals8.feature',
        scenario='[10] Return a map containing a octal integer',
        cypher='RETURN {k: 0o2613152366} AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': '{k: 372036854}'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals8-11',
        feature_path='tck/features/expressions/literals/Literals8.feature',
        scenario='[11] Return a map containing a float',
        cypher='RETURN {k: -.1e-5} AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': '{k: -0.000001}'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals8-12',
        feature_path='tck/features/expressions/literals/Literals8.feature',
        scenario='[12] Return a map containing a string',
        cypher="RETURN {k: 'ab: c, as#?lßdj '} AS literal",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': "{k: 'ab: c, as#?lßdj '}"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals8-13',
        feature_path='tck/features/expressions/literals/Literals8.feature',
        scenario='[13] Return a map containing an empty map',
        cypher='RETURN {a: {}} AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': '{a: {}}'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals8-14',
        feature_path='tck/features/expressions/literals/Literals8.feature',
        scenario='[14] Return seven-deep nested maps',
        cypher='RETURN {a1: {a2: {a3: {a4: {a5: {a6: {}}}}}}} AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': '{a1: {a2: {a3: {a4: {a5: {a6: {}}}}}}}'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals8-15',
        feature_path='tck/features/expressions/literals/Literals8.feature',
        scenario='[15] Return 20-deep nested maps',
        cypher='RETURN {a1: {a2: {a3: {a4: {a5: {a6: {a7: {a8: {a9: {a10: {a11: {a12: {a13: {a14: {a15: {a16: {a17: {a18: {a19: {}}}}}}}}}}}}}}}}}}}} AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': '{a1: {a2: {a3: {a4: {a5: {a6: {a7: {a8: {a9: {a10: {a11: {a12: {a13: {a14: {a15: {a16: {a17: {a18: {a19: {}}}}}}}}}}}}}}}}}}}}'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals8-16',
        feature_path='tck/features/expressions/literals/Literals8.feature',
        scenario='[16] Return 40-deep nested maps',
        cypher='RETURN {a1: {a2: {a3: {a4: {a5: {a6: {a7: {a8: {a9: {a10: {a11: {a12: {a13: {a14: {a15: {a16: {a17: {a18: {a19: {a20: {a21: {a22: {a23: {a24: {a25: {a26: {a27: {a28: {a29: {a30: {a31: {a32: {a33: {a34: {a35: {a36: {a37: {a38: {a39: {}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}} AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': '{a1: {a2: {a3: {a4: {a5: {a6: {a7: {a8: {a9: {a10: {a11: {a12: {a13: {a14: {a15: {a16: {a17: {a18: {a19: {a20: {a21: {a22: {a23: {a24: {a25: {a26: {a27: {a28: {a29: {a30: {a31: {a32: {a33: {a34: {a35: {a36: {a37: {a38: {a39: {}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals8-17',
        feature_path='tck/features/expressions/literals/Literals8.feature',
        scenario='[17] Return a map containing real and fake nested maps',
        cypher="RETURN { a : ' { b : ' , c : { d : ' ' } , d : ' } ' } AS literal",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': "{a: ' { b : ', c: {d: ' '}, d: ' } '}"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals8-18',
        feature_path='tck/features/expressions/literals/Literals8.feature',
        scenario='[18] Return a complex map containing multiple mixed and nested values',
        cypher="RETURN  { data: [ {\n                  id: '0001',\n                  type: 'donut',\n                  name: 'Cake',\n                  ppu: 0.55,\n                  batters:\n                      {\n                          batter:\n                              [\n                                  { id: '1001', type: 'Regular' },\n                                  { id: '1002', type: 'Chocolate' },\n                                  { id: '1003', type: 'Blueberry' },\n                                  { id: '1004', type: 'Devils Food' }\n                              ]\n                      },\n                  topping:\n                      [\n                          { id: '5001', type: 'None' },\n                          { id: '5002', type: 'Glazed' },\n                          { id: '5005', type: 'Sugar' },\n                          { id: '5007', type: 'Powdered Sugar' },\n                          { id: '5006', type: 'Chocolate Sprinkles' },\n                          { id: '5003', type: 'Chocolate' },\n                          { id: '5004', type: 'Maple' }\n                      ]\n              },\n              {\n                  id: '0002',\n                  type: 'donut',\n                  name: 'Raised',\n                  ppu: 0.55,\n                  batters:\n                      {\n                          batter:\n                              [\n                                  { id: '1001', type: 'Regular' }\n                              ]\n                      },\n                  topping:\n                      [\n                          { id: '5001', type: 'None' },\n                          { id: '5002', type: 'Glazed' },\n                          { id: '5005', type: 'Sugar' },\n                          { id: '5003', type: 'Chocolate' },\n                          { id: '5004', type: 'Maple' }\n                      ]\n              },\n              {\n                  id: '0003',\n                  type: 'donut',\n                  name: 'Old Fashioned',\n                  ppu: 0.55,\n                  batters:\n                      {\n                          batter:\n                              [\n                                  { id: '1001', type: 'Regular' },\n                                  { id: '1002', type: 'Chocolate' }\n                              ]\n                      },\n                  topping:\n                      [\n                          { id: '5001', type: 'None' },\n                          { id: '5002', type: 'Glazed' },\n                          { id: '5003', type: 'Chocolate' },\n                          { id: '5004', type: 'Maple' }\n                      ]\n              } ] } AS literal",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'literal': "{data: [{id: '0001', type: 'donut', name: 'Cake', ppu: 0.55, batters: {batter: [{id: '1001', type: 'Regular'}, {id: '1002', type: 'Chocolate'}, {id: '1003', type: 'Blueberry'}, {id: '1004', type: 'Devils Food'}]}, topping: [{id: '5001', type: 'None'}, {id: '5002', type: 'Glazed'}, {id: '5005', type: 'Sugar'}, {id: '5007', type: 'Powdered Sugar'}, {id: '5006', type: 'Chocolate Sprinkles'}, {id: '5003', type: 'Chocolate'}, {id: '5004', type: 'Maple'}]}, {id: '0002', type: 'donut', name: 'Raised', ppu: 0.55, batters: {batter: [{id: '1001', type: 'Regular'}]}, topping: [{id: '5001', type: 'None'}, {id: '5002', type: 'Glazed'}, {id: '5005', type: 'Sugar'}, {id: '5003', type: 'Chocolate'}, {id: '5004', type: 'Maple'}]}, {id: '0003', type: 'donut', name: 'Old Fashioned', ppu: 0.55, batters: {batter: [{id: '1001', type: 'Regular'}, {id: '1002', type: 'Chocolate'}]}, topping: [{id: '5001', type: 'None'}, {id: '5002', type: 'Glazed'}, {id: '5003', type: 'Chocolate'}, {id: '5004', type: 'Maple'}]}]}"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-literals8-19',
        feature_path='tck/features/expressions/literals/Literals8.feature',
        scenario='[19] Fail on a map containing key starting with a number',
        cypher='RETURN {1B2c3e67:1} AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-literals8-20',
        feature_path='tck/features/expressions/literals/Literals8.feature',
        scenario='[20] Fail on a map containing key with symbol',
        cypher='RETURN {k1#k: 1} AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-literals8-21',
        feature_path='tck/features/expressions/literals/Literals8.feature',
        scenario='[21] Fail on a map containing key with dot',
        cypher='RETURN {k1.k: 1} AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-literals8-22',
        feature_path='tck/features/expressions/literals/Literals8.feature',
        scenario='[22] Fail on a map containing unquoted string',
        cypher='RETURN {k1: k2} AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-literals8-23',
        feature_path='tck/features/expressions/literals/Literals8.feature',
        scenario='[23] Fail on a map containing only a comma',
        cypher='RETURN {, } AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-literals8-24',
        feature_path='tck/features/expressions/literals/Literals8.feature',
        scenario='[24] Fail on a map containing a value without key',
        cypher='RETURN {1} AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-literals8-25',
        feature_path='tck/features/expressions/literals/Literals8.feature',
        scenario='[25] Fail on a map containing a list without key',
        cypher='RETURN {[]} AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-literals8-26',
        feature_path='tck/features/expressions/literals/Literals8.feature',
        scenario='[26] Fail on a map containing a map without key',
        cypher='RETURN {{}} AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-literals8-27',
        feature_path='tck/features/expressions/literals/Literals8.feature',
        scenario='[27] Fail on a nested map with non-matching braces',
        cypher='RETURN {k: {k: {}} AS literal',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'literals', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-map1-1',
        feature_path='tck/features/expressions/map/Map1.feature',
        scenario='[1] Statically access a field of a non-null map',
        cypher='WITH {existing: 42, notMissing: null} AS m\n      RETURN m.missing, m.notMissing, m.existing',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'m.missing': 'null', 'm.notMissing': 'null', 'm.existing': 42}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'map', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-map1-2',
        feature_path='tck/features/expressions/map/Map1.feature',
        scenario='[2] Statically access a field of a null map',
        cypher='WITH null AS m\n      RETURN m.missing',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'m.missing': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'map', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-map1-3',
        feature_path='tck/features/expressions/map/Map1.feature',
        scenario='[3] Statically access a field of a map resulting from an expression',
        cypher='WITH [123, {existing: 42, notMissing: null}] AS list\n      RETURN (list[1]).missing, (list[1]).notMissing, (list[1]).existing',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'(list[1]).missing': 'null', '(list[1]).notMissing': 'null', '(list[1]).existing': 42}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'map', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-map1-4-1',
        feature_path='tck/features/expressions/map/Map1.feature',
        scenario='[4] Statically access a field is case-sensitive (example 1)',
        cypher="WITH {name: 'Mats', nome: 'Pontus'} AS map\n      RETURN map.name AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'Mats'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'map', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-map1-4-2',
        feature_path='tck/features/expressions/map/Map1.feature',
        scenario='[4] Statically access a field is case-sensitive (example 2)',
        cypher="WITH {name: 'Mats', Name: 'Pontus'} AS map\n      RETURN map.name AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'Mats'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'map', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-map1-4-3',
        feature_path='tck/features/expressions/map/Map1.feature',
        scenario='[4] Statically access a field is case-sensitive (example 3)',
        cypher="WITH {name: 'Mats', Name: 'Pontus'} AS map\n      RETURN map.Name AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'Pontus'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'map', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-map1-4-4',
        feature_path='tck/features/expressions/map/Map1.feature',
        scenario='[4] Statically access a field is case-sensitive (example 4)',
        cypher="WITH {name: 'Mats', Name: 'Pontus'} AS map\n      RETURN map.nAMe AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'map', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-map1-5-1',
        feature_path='tck/features/expressions/map/Map1.feature',
        scenario='[5] Statically access a field with a delimited identifier (example 1)',
        cypher="WITH {name: 'Mats', nome: 'Pontus'} AS map\n      RETURN map.`name` AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'Mats'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'map', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-map1-5-2',
        feature_path='tck/features/expressions/map/Map1.feature',
        scenario='[5] Statically access a field with a delimited identifier (example 2)',
        cypher="WITH {name: 'Mats', nome: 'Pontus'} AS map\n      RETURN map.`nome` AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'Pontus'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'map', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-map1-5-3',
        feature_path='tck/features/expressions/map/Map1.feature',
        scenario='[5] Statically access a field with a delimited identifier (example 3)',
        cypher="WITH {name: 'Mats', nome: 'Pontus'} AS map\n      RETURN map.`Mats` AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'map', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-map1-5-4',
        feature_path='tck/features/expressions/map/Map1.feature',
        scenario='[5] Statically access a field with a delimited identifier (example 4)',
        cypher="WITH {name: 'Mats', nome: 'Pontus'} AS map\n      RETURN map.`null` AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'map', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-map1-5-5',
        feature_path='tck/features/expressions/map/Map1.feature',
        scenario='[5] Statically access a field with a delimited identifier (example 5)',
        cypher="WITH {null: 'Mats', NULL: 'Pontus'} AS map\n      RETURN map.`null` AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'Mats'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'map', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-map1-5-6',
        feature_path='tck/features/expressions/map/Map1.feature',
        scenario='[5] Statically access a field with a delimited identifier (example 6)',
        cypher="WITH {null: 'Mats', NULL: 'Pontus'} AS map\n      RETURN map.`NULL` AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'Pontus'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'map', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-map1-6-1',
        feature_path='tck/features/expressions/map/Map1.feature',
        scenario='[6] Fail when performing property access on a non-map (example 1)',
        cypher='WITH 123 AS nonMap\n      RETURN nonMap.num',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Runtime error semantics are not supported',
        tags=('expr', 'map', 'meta-xfail', 'runtime-error', 'xfail'),
    ),
    Scenario(
        key='expr-map1-6-2',
        feature_path='tck/features/expressions/map/Map1.feature',
        scenario='[6] Fail when performing property access on a non-map (example 2)',
        cypher='WITH 42.45 AS nonMap\n      RETURN nonMap.num',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Runtime error semantics are not supported',
        tags=('expr', 'map', 'meta-xfail', 'runtime-error', 'xfail'),
    ),
    Scenario(
        key='expr-map1-6-3',
        feature_path='tck/features/expressions/map/Map1.feature',
        scenario='[6] Fail when performing property access on a non-map (example 3)',
        cypher='WITH true AS nonMap\n      RETURN nonMap.num',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Runtime error semantics are not supported',
        tags=('expr', 'map', 'meta-xfail', 'runtime-error', 'xfail'),
    ),
    Scenario(
        key='expr-map1-6-4',
        feature_path='tck/features/expressions/map/Map1.feature',
        scenario='[6] Fail when performing property access on a non-map (example 4)',
        cypher='WITH false AS nonMap\n      RETURN nonMap.num',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Runtime error semantics are not supported',
        tags=('expr', 'map', 'meta-xfail', 'runtime-error', 'xfail'),
    ),
    Scenario(
        key='expr-map1-6-5',
        feature_path='tck/features/expressions/map/Map1.feature',
        scenario='[6] Fail when performing property access on a non-map (example 5)',
        cypher="WITH 'string' AS nonMap\n      RETURN nonMap.num",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Runtime error semantics are not supported',
        tags=('expr', 'map', 'meta-xfail', 'runtime-error', 'xfail'),
    ),
    Scenario(
        key='expr-map1-6-6',
        feature_path='tck/features/expressions/map/Map1.feature',
        scenario='[6] Fail when performing property access on a non-map (example 6)',
        cypher='WITH [123, true] AS nonMap\n      RETURN nonMap.num',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Runtime error semantics are not supported',
        tags=('expr', 'map', 'meta-xfail', 'runtime-error', 'xfail'),
    ),
    Scenario(
        key='expr-map2-1',
        feature_path='tck/features/expressions/map/Map2.feature',
        scenario='[1] Dynamically access a field based on parameters when there is no type information',
        cypher='WITH $expr AS expr, $idx AS idx\n      RETURN expr[idx] AS value',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'value': "'Apa'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Parameter binding is not supported',
        tags=('expr', 'map', 'meta-xfail', 'params', 'xfail'),
    ),
    Scenario(
        key='expr-map2-2',
        feature_path='tck/features/expressions/map/Map2.feature',
        scenario='[2] Dynamically access a field based on parameters when there is rhs type information',
        cypher='WITH $expr AS expr, $idx AS idx\n      RETURN expr[toString(idx)] AS value',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'value': "'Apa'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Parameter binding is not supported',
        tags=('expr', 'map', 'meta-xfail', 'params', 'xfail'),
    ),
    Scenario(
        key='expr-map2-3',
        feature_path='tck/features/expressions/map/Map2.feature',
        scenario='[3] Dynamically access a field on null results in null',
        cypher="WITH null AS expr, 'x' AS idx\n      RETURN expr[idx] AS value",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'value': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'map', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-map2-4',
        feature_path='tck/features/expressions/map/Map2.feature',
        scenario='[4] Dynamically access a field with null results in null',
        cypher="WITH {name: 'Mats'} AS expr, null AS idx\n      RETURN expr[idx] AS value",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'value': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'map', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-map2-5-1',
        feature_path='tck/features/expressions/map/Map2.feature',
        scenario='[5] Dynamically access a field is case-sensitive (example 1)',
        cypher="WITH {name: 'Mats', nome: 'Pontus'} AS map\n      RETURN map['name'] AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'Mats'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'map', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-map2-5-2',
        feature_path='tck/features/expressions/map/Map2.feature',
        scenario='[5] Dynamically access a field is case-sensitive (example 2)',
        cypher="WITH {name: 'Mats', Name: 'Pontus'} AS map\n      RETURN map['name'] AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'Mats'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'map', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-map2-5-3',
        feature_path='tck/features/expressions/map/Map2.feature',
        scenario='[5] Dynamically access a field is case-sensitive (example 3)',
        cypher="WITH {name: 'Mats', Name: 'Pontus'} AS map\n      RETURN map['Name'] AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'Pontus'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'map', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-map2-5-4',
        feature_path='tck/features/expressions/map/Map2.feature',
        scenario='[5] Dynamically access a field is case-sensitive (example 4)',
        cypher="WITH {name: 'Mats', Name: 'Pontus'} AS map\n      RETURN map['nAMe'] AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'map', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-map2-5-5',
        feature_path='tck/features/expressions/map/Map2.feature',
        scenario='[5] Dynamically access a field is case-sensitive (example 5)',
        cypher="WITH {name: 'Mats', nome: 'Pontus'} AS map\n      RETURN map['null'] AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'map', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-map2-5-6',
        feature_path='tck/features/expressions/map/Map2.feature',
        scenario='[5] Dynamically access a field is case-sensitive (example 6)',
        cypher="WITH {null: 'Mats', NULL: 'Pontus'} AS map\n      RETURN map['null'] AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'Mats'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'map', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-map2-5-7',
        feature_path='tck/features/expressions/map/Map2.feature',
        scenario='[5] Dynamically access a field is case-sensitive (example 7)',
        cypher="WITH {null: 'Mats', NULL: 'Pontus'} AS map\n      RETURN map['NULL'] AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'Pontus'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'map', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-map2-6',
        feature_path='tck/features/expressions/map/Map2.feature',
        scenario='[6] Fail at runtime when attempting to index with an Int into a Map',
        cypher='WITH $expr AS expr, $idx AS idx\n      RETURN expr[idx]',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Runtime error semantics are not supported',
        tags=('expr', 'map', 'meta-xfail', 'params', 'runtime-error', 'xfail'),
    ),
    Scenario(
        key='expr-map2-7',
        feature_path='tck/features/expressions/map/Map2.feature',
        scenario='[7] Fail at runtime when trying to index into a map with a non-string',
        cypher='WITH $expr AS expr, $idx AS idx\n      RETURN expr[idx]',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Runtime error semantics are not supported',
        tags=('expr', 'map', 'meta-xfail', 'params', 'runtime-error', 'xfail'),
    ),
    Scenario(
        key='expr-map2-8',
        feature_path='tck/features/expressions/map/Map2.feature',
        scenario='[8] Fail at runtime when trying to index something which is not a map',
        cypher='WITH $expr AS expr, $idx AS idx\n      RETURN expr[idx]',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Runtime error semantics are not supported',
        tags=('expr', 'map', 'meta-xfail', 'params', 'runtime-error', 'xfail'),
    ),
    Scenario(
        key='expr-map3-1',
        feature_path='tck/features/expressions/map/Map3.feature',
        scenario='[1] Using `keys()` on a literal map',
        cypher="RETURN keys({name: 'Alice', age: 38, address: {city: 'London', residential: true}}) AS k",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'k': "['name', 'age', 'address']"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'map', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-map3-2',
        feature_path='tck/features/expressions/map/Map3.feature',
        scenario='[2] Using `keys()` on a parameter map',
        cypher='RETURN keys($param) AS k',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'k': "['address', 'name', 'age']"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Parameter binding is not supported',
        tags=('expr', 'map', 'meta-xfail', 'params', 'xfail'),
    ),
    Scenario(
        key='expr-map3-3',
        feature_path='tck/features/expressions/map/Map3.feature',
        scenario='[3] Using `keys()` on null map',
        cypher='WITH null AS m\n      RETURN keys(m), keys(null)',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'keys(m)': 'null', 'keys(null)': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'map', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-map3-4-1',
        feature_path='tck/features/expressions/map/Map3.feature',
        scenario='[4] Using `keys()` on map with null values (example 1)',
        cypher='RETURN keys({}) AS keys',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'keys': '[]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'map', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-map3-4-2',
        feature_path='tck/features/expressions/map/Map3.feature',
        scenario='[4] Using `keys()` on map with null values (example 2)',
        cypher='RETURN keys({k: 1}) AS keys',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'keys': "['k']"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'map', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-map3-4-3',
        feature_path='tck/features/expressions/map/Map3.feature',
        scenario='[4] Using `keys()` on map with null values (example 3)',
        cypher='RETURN keys({k: null}) AS keys',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'keys': "['k']"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'map', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-map3-4-4',
        feature_path='tck/features/expressions/map/Map3.feature',
        scenario='[4] Using `keys()` on map with null values (example 4)',
        cypher='RETURN keys({k: null, l: 1}) AS keys',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'keys': "['k', 'l']"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'map', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-map3-4-5',
        feature_path='tck/features/expressions/map/Map3.feature',
        scenario='[4] Using `keys()` on map with null values (example 5)',
        cypher='RETURN keys({k: 1, l: null}) AS keys',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'keys': "['k', 'l']"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'map', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-map3-4-6',
        feature_path='tck/features/expressions/map/Map3.feature',
        scenario='[4] Using `keys()` on map with null values (example 6)',
        cypher='RETURN keys({k: null, l: null}) AS keys',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'keys': "['k', 'l']"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'map', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-map3-4-7',
        feature_path='tck/features/expressions/map/Map3.feature',
        scenario='[4] Using `keys()` on map with null values (example 7)',
        cypher='RETURN keys({k: 1, l: null, m: 1}) AS keys',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'keys': "['k', 'l', 'm']"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'map', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-map3-5',
        feature_path='tck/features/expressions/map/Map3.feature',
        scenario='[5] Using `keys()` and `IN` to check field existence',
        cypher="WITH {exists: 42, notMissing: null} AS map\n      RETURN 'exists' IN keys(map) AS a,\n             'notMissing' IN keys(map) AS b,\n             'missing' IN keys(map) AS c",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'a': 'true', 'b': 'true', 'c': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'map', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-mathematical11-1',
        feature_path='tck/features/expressions/mathematical/Mathematical11.feature',
        scenario='[1] Absolute function',
        cypher='RETURN abs(-1)',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'abs(-1)': 1}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'mathematical', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-mathematical13-1',
        feature_path='tck/features/expressions/mathematical/Mathematical13.feature',
        scenario='[1] `sqrt()` returning float values',
        cypher='RETURN sqrt(12.96)',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'sqrt(12.96)': 3.6}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'mathematical', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-mathematical2-1',
        feature_path='tck/features/expressions/mathematical/Mathematical2.feature',
        scenario='[1] Allow addition',
        cypher='MATCH (a)\n      WHERE a.id = 1337\n      RETURN a.version + 5',
        graph=graph_fixture_from_create(
            """
            CREATE ({id: 1337, version: 99})
            """
        ),
        expected=Expected(
            rows=[
            {'a.version + 5': 104}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'mathematical', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-mathematical3-1',
        feature_path='tck/features/expressions/mathematical/Mathematical3.feature',
        scenario='[1] Fail for invalid Unicode hyphen in subtraction',
        cypher='RETURN 42 — 41',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'mathematical', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-mathematical8-1',
        feature_path='tck/features/expressions/mathematical/Mathematical8.feature',
        scenario='[1] Arithmetic precedence test',
        cypher='RETURN 12 / 4 * 3 - 2 * 4',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'12 / 4 * 3 - 2 * 4': 1}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'mathematical', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-mathematical8-2',
        feature_path='tck/features/expressions/mathematical/Mathematical8.feature',
        scenario='[2] Arithmetic precedence with parenthesis test',
        cypher='RETURN 12 / 4 * (3 - 2 * 4)',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'12 / 4 * (3 - 2 * 4)': -15}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'mathematical', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-null1-1',
        feature_path='tck/features/expressions/null/Null1.feature',
        scenario='[1] Property null check on non-null node',
        cypher='MATCH (n)\n      RETURN n.missing IS NULL,\n             n.exists IS NULL',
        graph=graph_fixture_from_create(
            """
            CREATE ({exists: 42})
            """
        ),
        expected=Expected(
            rows=[
            {'n.missing IS NULL': 'true', 'n.exists IS NULL': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'null', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-null1-2',
        feature_path='tck/features/expressions/null/Null1.feature',
        scenario='[2] Property null check on optional non-null node',
        cypher='OPTIONAL MATCH (n)\n      RETURN n.missing IS NULL,\n             n.exists IS NULL',
        graph=graph_fixture_from_create(
            """
            CREATE ({exists: 42})
            """
        ),
        expected=Expected(
            rows=[
            {'n.missing IS NULL': 'true', 'n.exists IS NULL': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'null', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-null1-3',
        feature_path='tck/features/expressions/null/Null1.feature',
        scenario='[3] Property null check on null node',
        cypher='OPTIONAL MATCH (n)\n      RETURN n.missing IS NULL',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'n.missing IS NULL': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'null', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-null1-4',
        feature_path='tck/features/expressions/null/Null1.feature',
        scenario='[4] A literal null IS null',
        cypher='RETURN null IS NULL AS value',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'value': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'null', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-null1-5-1',
        feature_path='tck/features/expressions/null/Null1.feature',
        scenario='[5] IS NULL on a map (example 1)',
        cypher="WITH {name: 'Mats', name2: 'Pontus'} AS map\n      RETURN map.name IS NULL AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'null', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-null1-5-2',
        feature_path='tck/features/expressions/null/Null1.feature',
        scenario='[5] IS NULL on a map (example 2)',
        cypher="WITH {name: 'Mats', name2: 'Pontus'} AS map\n      RETURN map.name2 IS NULL AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'null', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-null1-5-3',
        feature_path='tck/features/expressions/null/Null1.feature',
        scenario='[5] IS NULL on a map (example 3)',
        cypher="WITH {name: 'Mats', name2: null} AS map\n      RETURN map.name IS NULL AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'null', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-null1-5-4',
        feature_path='tck/features/expressions/null/Null1.feature',
        scenario='[5] IS NULL on a map (example 4)',
        cypher="WITH {name: 'Mats', name2: null} AS map\n      RETURN map.name2 IS NULL AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'null', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-null1-5-5',
        feature_path='tck/features/expressions/null/Null1.feature',
        scenario='[5] IS NULL on a map (example 5)',
        cypher='WITH {name: null} AS map\n      RETURN map.name IS NULL AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'null', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-null1-5-6',
        feature_path='tck/features/expressions/null/Null1.feature',
        scenario='[5] IS NULL on a map (example 6)',
        cypher='WITH {name: null, name2: null} AS map\n      RETURN map.name IS NULL AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'null', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-null1-5-7',
        feature_path='tck/features/expressions/null/Null1.feature',
        scenario='[5] IS NULL on a map (example 7)',
        cypher='WITH {name: null, name2: null} AS map\n      RETURN map.name2 IS NULL AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'null', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-null1-5-8',
        feature_path='tck/features/expressions/null/Null1.feature',
        scenario='[5] IS NULL on a map (example 8)',
        cypher='WITH {notName: null, notName2: null} AS map\n      RETURN map.name IS NULL AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'null', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-null1-5-9',
        feature_path='tck/features/expressions/null/Null1.feature',
        scenario='[5] IS NULL on a map (example 9)',
        cypher='WITH {notName: 0, notName2: null} AS map\n      RETURN map.name IS NULL AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'null', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-null1-5-10',
        feature_path='tck/features/expressions/null/Null1.feature',
        scenario='[5] IS NULL on a map (example 10)',
        cypher='WITH {notName: 0} AS map\n      RETURN map.name IS NULL AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'null', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-null1-5-11',
        feature_path='tck/features/expressions/null/Null1.feature',
        scenario='[5] IS NULL on a map (example 11)',
        cypher='WITH {} AS map\n      RETURN map.name IS NULL AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'null', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-null1-5-12',
        feature_path='tck/features/expressions/null/Null1.feature',
        scenario='[5] IS NULL on a map (example 12)',
        cypher='WITH null AS map\n      RETURN map.name IS NULL AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'null', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-null1-6',
        feature_path='tck/features/expressions/null/Null1.feature',
        scenario='[6] IS NULL is case insensitive',
        cypher='MATCH (n:X)\n      RETURN n, n.prop iS NuLl AS b',
        graph=graph_fixture_from_create(
            """
            CREATE (a:X {prop: 42}), (:X)
            """
        ),
        expected=Expected(
            rows=[
            {'n': '(:X {prop: 42})', 'b': 'false'},
            {'n': '(:X)', 'b': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'null', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-null2-1',
        feature_path='tck/features/expressions/null/Null2.feature',
        scenario='[1] Property not null check on non-null node',
        cypher='MATCH (n)\n      RETURN n.missing IS NOT NULL,\n             n.exists IS NOT NULL',
        graph=graph_fixture_from_create(
            """
            CREATE ({exists: 42})
            """
        ),
        expected=Expected(
            rows=[
            {'n.missing IS NOT NULL': 'false', 'n.exists IS NOT NULL': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'null', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-null2-2',
        feature_path='tck/features/expressions/null/Null2.feature',
        scenario='[2] Property not null check on optional non-null node',
        cypher='OPTIONAL MATCH (n)\n      RETURN n.missing IS NOT NULL,\n             n.exists IS NOT NULL',
        graph=graph_fixture_from_create(
            """
            CREATE ({exists: 42})
            """
        ),
        expected=Expected(
            rows=[
            {'n.missing IS NOT NULL': 'false', 'n.exists IS NOT NULL': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'null', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-null2-3',
        feature_path='tck/features/expressions/null/Null2.feature',
        scenario='[3] Property not null check on null node',
        cypher='OPTIONAL MATCH (n)\n      RETURN n.missing IS NOT NULL',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'n.missing IS NOT NULL': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'null', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-null2-4',
        feature_path='tck/features/expressions/null/Null2.feature',
        scenario='[4] A literal null is not IS NOT null',
        cypher='RETURN null IS NOT NULL AS value',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'value': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'null', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-null2-5-1',
        feature_path='tck/features/expressions/null/Null2.feature',
        scenario='[5] IS NOT NULL on a map (example 1)',
        cypher="WITH {name: 'Mats', name2: 'Pontus'} AS map\n      RETURN map.name IS NOT NULL AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'null', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-null2-5-2',
        feature_path='tck/features/expressions/null/Null2.feature',
        scenario='[5] IS NOT NULL on a map (example 2)',
        cypher="WITH {name: 'Mats', name2: 'Pontus'} AS map\n      RETURN map.name2 IS NOT NULL AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'null', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-null2-5-3',
        feature_path='tck/features/expressions/null/Null2.feature',
        scenario='[5] IS NOT NULL on a map (example 3)',
        cypher="WITH {name: 'Mats', name2: null} AS map\n      RETURN map.name IS NOT NULL AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'null', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-null2-5-4',
        feature_path='tck/features/expressions/null/Null2.feature',
        scenario='[5] IS NOT NULL on a map (example 4)',
        cypher="WITH {name: 'Mats', name2: null} AS map\n      RETURN map.name2 IS NOT NULL AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'null', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-null2-5-5',
        feature_path='tck/features/expressions/null/Null2.feature',
        scenario='[5] IS NOT NULL on a map (example 5)',
        cypher='WITH {name: null} AS map\n      RETURN map.name IS NOT NULL AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'null', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-null2-5-6',
        feature_path='tck/features/expressions/null/Null2.feature',
        scenario='[5] IS NOT NULL on a map (example 6)',
        cypher='WITH {name: null, name2: null} AS map\n      RETURN map.name IS NOT NULL AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'null', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-null2-5-7',
        feature_path='tck/features/expressions/null/Null2.feature',
        scenario='[5] IS NOT NULL on a map (example 7)',
        cypher='WITH {name: null, name2: null} AS map\n      RETURN map.name2 IS NOT NULL AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'null', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-null2-5-8',
        feature_path='tck/features/expressions/null/Null2.feature',
        scenario='[5] IS NOT NULL on a map (example 8)',
        cypher='WITH {notName: null, notName2: null} AS map\n      RETURN map.name IS NOT NULL AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'null', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-null2-5-9',
        feature_path='tck/features/expressions/null/Null2.feature',
        scenario='[5] IS NOT NULL on a map (example 9)',
        cypher='WITH {notName: 0, notName2: null} AS map\n      RETURN map.name IS NOT NULL AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'null', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-null2-5-10',
        feature_path='tck/features/expressions/null/Null2.feature',
        scenario='[5] IS NOT NULL on a map (example 10)',
        cypher='WITH {notName: 0} AS map\n      RETURN map.name IS NOT NULL AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'null', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-null2-5-11',
        feature_path='tck/features/expressions/null/Null2.feature',
        scenario='[5] IS NOT NULL on a map (example 11)',
        cypher='WITH {} AS map\n      RETURN map.name IS NOT NULL AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'null', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-null2-5-12',
        feature_path='tck/features/expressions/null/Null2.feature',
        scenario='[5] IS NOT NULL on a map (example 12)',
        cypher='WITH null AS map\n      RETURN map.name IS NOT NULL AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'null', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-null2-6',
        feature_path='tck/features/expressions/null/Null2.feature',
        scenario='[6] IS NOT NULL is case insensitive',
        cypher='MATCH (n:X)\n      RETURN n, n.prop Is noT nULl AS b',
        graph=graph_fixture_from_create(
            """
            CREATE (a:X {prop: 42}), (:X)
            """
        ),
        expected=Expected(
            rows=[
            {'n': '(:X {prop: 42})', 'b': 'true'},
            {'n': '(:X)', 'b': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'null', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-null3-1',
        feature_path='tck/features/expressions/null/Null3.feature',
        scenario='[1] The inverse of a null is a null',
        cypher='RETURN NOT null AS value',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'value': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'null', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-null3-2',
        feature_path='tck/features/expressions/null/Null3.feature',
        scenario='[2] It is unknown - i.e. null - if a null is equal to a null',
        cypher='RETURN null = null AS value',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'value': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'null', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-null3-3',
        feature_path='tck/features/expressions/null/Null3.feature',
        scenario='[3] It is unknown - i.e. null - if a null is not equal to a null',
        cypher='RETURN null <> null AS value',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'value': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'null', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-null3-4-1',
        feature_path='tck/features/expressions/null/Null3.feature',
        scenario='[4] Using null in IN (example 1)',
        cypher='RETURN $elt IN $coll AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Parameter binding is not supported',
        tags=('expr', 'null', 'meta-xfail', 'params', 'xfail'),
    ),
    Scenario(
        key='expr-null3-4-2',
        feature_path='tck/features/expressions/null/Null3.feature',
        scenario='[4] Using null in IN (example 2)',
        cypher='RETURN $elt IN $coll AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Parameter binding is not supported',
        tags=('expr', 'null', 'meta-xfail', 'params', 'xfail'),
    ),
    Scenario(
        key='expr-null3-4-3',
        feature_path='tck/features/expressions/null/Null3.feature',
        scenario='[4] Using null in IN (example 3)',
        cypher='RETURN $elt IN $coll AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Parameter binding is not supported',
        tags=('expr', 'null', 'meta-xfail', 'params', 'xfail'),
    ),
    Scenario(
        key='expr-null3-4-4',
        feature_path='tck/features/expressions/null/Null3.feature',
        scenario='[4] Using null in IN (example 4)',
        cypher='RETURN $elt IN $coll AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Parameter binding is not supported',
        tags=('expr', 'null', 'meta-xfail', 'params', 'xfail'),
    ),
    Scenario(
        key='expr-null3-4-5',
        feature_path='tck/features/expressions/null/Null3.feature',
        scenario='[4] Using null in IN (example 5)',
        cypher='RETURN $elt IN $coll AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Parameter binding is not supported',
        tags=('expr', 'null', 'meta-xfail', 'params', 'xfail'),
    ),
    Scenario(
        key='expr-null3-4-6',
        feature_path='tck/features/expressions/null/Null3.feature',
        scenario='[4] Using null in IN (example 6)',
        cypher='RETURN $elt IN $coll AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Parameter binding is not supported',
        tags=('expr', 'null', 'meta-xfail', 'params', 'xfail'),
    ),
    Scenario(
        key='expr-null3-4-7',
        feature_path='tck/features/expressions/null/Null3.feature',
        scenario='[4] Using null in IN (example 7)',
        cypher='RETURN $elt IN $coll AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Parameter binding is not supported',
        tags=('expr', 'null', 'meta-xfail', 'params', 'xfail'),
    ),
    Scenario(
        key='expr-path1-1',
        feature_path='tck/features/expressions/path/Path1.feature',
        scenario='[1] `nodes()` on null path',
        cypher='WITH null AS a\n      OPTIONAL MATCH p = (a)-[r]->()\n      RETURN nodes(p), nodes(null)',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'nodes(p)': 'null', 'nodes(null)': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'path', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-path2-1',
        feature_path='tck/features/expressions/path/Path2.feature',
        scenario='[1] Return relationships by fetching them from the path',
        cypher='MATCH p = (a:Start)-[:REL*2..2]->(b)\n      RETURN relationships(p)',
        graph=graph_fixture_from_create(
            """
            CREATE (s:Start)-[:REL {num: 1}]->(b:B)-[:REL {num: 2}]->(c:C)
            """
        ),
        expected=Expected(
            rows=[
            {'relationships(p)': '[[:REL {num: 1}], [:REL {num: 2}]]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'path', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-path2-2',
        feature_path='tck/features/expressions/path/Path2.feature',
        scenario='[2] Return relationships by fetching them from the path - starting from the end',
        cypher='MATCH p = (a)-[:REL*2..2]->(b:End)\n      RETURN relationships(p)',
        graph=graph_fixture_from_create(
            """
            CREATE (a:A)-[:REL {num: 1}]->(b:B)-[:REL {num: 2}]->(e:End)
            """
        ),
        expected=Expected(
            rows=[
            {'relationships(p)': '[[:REL {num: 1}], [:REL {num: 2}]]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'path', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-path2-3',
        feature_path='tck/features/expressions/path/Path2.feature',
        scenario='[3] `relationships()` on null path',
        cypher='WITH null AS a\n      OPTIONAL MATCH p = (a)-[r]->()\n      RETURN relationships(p), relationships(null)',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'relationships(p)': 'null', 'relationships(null)': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'path', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-path3-1',
        feature_path='tck/features/expressions/path/Path3.feature',
        scenario='[1] Return a var length path of length zero',
        cypher='MATCH p = (a)-[*0..1]->(b)\n      RETURN a, b, length(p) AS l',
        graph=graph_fixture_from_create(
            """
            CREATE (a:A)-[:REL]->(b:B)
            """
        ),
        expected=Expected(
            rows=[
            {'a': '(:A)', 'b': '(:A)', 'l': 0},
            {'a': '(:B)', 'b': '(:B)', 'l': 0},
            {'a': '(:A)', 'b': '(:B)', 'l': 1}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'path', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-path3-2',
        feature_path='tck/features/expressions/path/Path3.feature',
        scenario='[2] Failing when using `length()` on a node',
        cypher='MATCH (n)\n      RETURN length(n)',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'path', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-path3-3',
        feature_path='tck/features/expressions/path/Path3.feature',
        scenario='[3] Failing when using `length()` on a relationship',
        cypher='MATCH ()-[r]->()\n      RETURN length(r)',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'path', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-pattern1-1',
        feature_path='tck/features/expressions/pattern/Pattern1.feature',
        scenario='[1] Matching on any single outgoing directed connection',
        cypher='MATCH (n) WHERE (n)-[]->() RETURN n',
        graph=graph_fixture_from_create(
            """
            CREATE (a:A)-[:REL1]->(b:B), (b)-[:REL2]->(a), (a)-[:REL3]->(:C), (a)-[:REL1]->(:D)
            """
        ),
        expected=Expected(
            rows=[
            {'n': '(:A)'},
            {'n': '(:B)'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'pattern', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-pattern1-2',
        feature_path='tck/features/expressions/pattern/Pattern1.feature',
        scenario='[2] Matching on a single undirected connection',
        cypher='MATCH (n) WHERE (n)-[]-() RETURN n',
        graph=graph_fixture_from_create(
            """
            CREATE (a:A)-[:REL1]->(b:B), (b)-[:REL2]->(a), (a)-[:REL3]->(:C), (a)-[:REL1]->(:D)
            """
        ),
        expected=Expected(
            rows=[
            {'n': '(:A)'},
            {'n': '(:B)'},
            {'n': '(:C)'},
            {'n': '(:D)'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'pattern', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-pattern1-3',
        feature_path='tck/features/expressions/pattern/Pattern1.feature',
        scenario='[3] Matching on any single incoming directed connection',
        cypher='MATCH (n) WHERE (n)<-[]-() RETURN n',
        graph=graph_fixture_from_create(
            """
            CREATE (a:A)-[:REL1]->(b:B), (b)-[:REL2]->(a), (a)-[:REL3]->(:C), (a)-[:REL1]->(:D)
            """
        ),
        expected=Expected(
            rows=[
            {'n': '(:A)'},
            {'n': '(:B)'},
            {'n': '(:C)'},
            {'n': '(:D)'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'pattern', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-pattern1-4',
        feature_path='tck/features/expressions/pattern/Pattern1.feature',
        scenario='[4] Matching on a specific type of single outgoing directed connection',
        cypher='MATCH (n) WHERE (n)-[:REL1]->() RETURN n',
        graph=graph_fixture_from_create(
            """
            CREATE (a:A)-[:REL1]->(b:B), (b)-[:REL2]->(a), (a)-[:REL3]->(:C), (a)-[:REL1]->(:D)
            """
        ),
        expected=Expected(
            rows=[
            {'n': '(:A)'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'pattern', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-pattern1-5',
        feature_path='tck/features/expressions/pattern/Pattern1.feature',
        scenario='[5] Matching on a specific type of single undirected connection',
        cypher='MATCH (n) WHERE (n)-[:REL1]-() RETURN n',
        graph=graph_fixture_from_create(
            """
            CREATE (a:A)-[:REL1]->(b:B), (b)-[:REL2]->(a), (a)-[:REL3]->(:C), (a)-[:REL1]->(:D)
            """
        ),
        expected=Expected(
            rows=[
            {'n': '(:A)'},
            {'n': '(:B)'},
            {'n': '(:D)'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'pattern', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-pattern1-6',
        feature_path='tck/features/expressions/pattern/Pattern1.feature',
        scenario='[6] Matching on a specific type of single incoming directed connection',
        cypher='MATCH (n) WHERE (n)<-[:REL1]-() RETURN n',
        graph=graph_fixture_from_create(
            """
            CREATE (a:A)-[:REL1]->(b:B), (b)-[:REL2]->(a), (a)-[:REL3]->(:C), (a)-[:REL1]->(:D)
            """
        ),
        expected=Expected(
            rows=[
            {'n': '(:B)'},
            {'n': '(:D)'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'pattern', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-pattern1-7',
        feature_path='tck/features/expressions/pattern/Pattern1.feature',
        scenario='[7] Matching on a specific type of a variable length outgoing directed connection',
        cypher='MATCH (n) WHERE (n)-[:REL1*]->() RETURN n',
        graph=graph_fixture_from_create(
            """
            CREATE (a:A)-[:REL1]->(b:B), (b)-[:REL2]->(a), (a)-[:REL3]->(:C), (a)-[:REL1]->(:D)
            """
        ),
        expected=Expected(
            rows=[
            {'n': '(:A)'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'pattern', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-pattern1-8',
        feature_path='tck/features/expressions/pattern/Pattern1.feature',
        scenario='[8] Matching on a specific type of variable length undirected connection',
        cypher='MATCH (n) WHERE (n)-[:REL1*]-() RETURN n',
        graph=graph_fixture_from_create(
            """
            CREATE (a:A)-[:REL1]->(b:B), (b)-[:REL2]->(a), (a)-[:REL3]->(:C), (a)-[:REL1]->(:D)
            """
        ),
        expected=Expected(
            rows=[
            {'n': '(:A)'},
            {'n': '(:B)'},
            {'n': '(:D)'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'pattern', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-pattern1-9',
        feature_path='tck/features/expressions/pattern/Pattern1.feature',
        scenario='[9] Matching on a specific type of variable length incoming directed connection',
        cypher='MATCH (n) WHERE (n)<-[:REL1*]-() RETURN n',
        graph=graph_fixture_from_create(
            """
            CREATE (a:A)-[:REL1]->(b:B), (b)-[:REL2]->(a), (a)-[:REL3]->(:C), (a)-[:REL1]->(:D)
            """
        ),
        expected=Expected(
            rows=[
            {'n': '(:B)'},
            {'n': '(:D)'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'pattern', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-pattern1-10',
        feature_path='tck/features/expressions/pattern/Pattern1.feature',
        scenario='[10] Matching on a specific type of undirected connection with length 2',
        cypher='MATCH (n) WHERE (n)-[:REL1*2]-() RETURN n',
        graph=graph_fixture_from_create(
            """
            CREATE (a:A)-[:REL1]->(b:B), (b)-[:REL2]->(a), (a)-[:REL3]->(:C), (a)-[:REL1]->(:D)
            """
        ),
        expected=Expected(
            rows=[
            {'n': '(:B)'},
            {'n': '(:D)'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'pattern', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-pattern1-10-1',
        feature_path='tck/features/expressions/pattern/Pattern1.feature',
        scenario='[10] Fail on introducing unbounded variables in pattern (example 1)',
        cypher='MATCH (n) WHERE (a) RETURN n',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'pattern', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-pattern1-10-2',
        feature_path='tck/features/expressions/pattern/Pattern1.feature',
        scenario='[10] Fail on introducing unbounded variables in pattern (example 2)',
        cypher='MATCH (n) WHERE (n)-[r]->(a) RETURN n',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'pattern', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-pattern1-10-3',
        feature_path='tck/features/expressions/pattern/Pattern1.feature',
        scenario='[10] Fail on introducing unbounded variables in pattern (example 3)',
        cypher='MATCH (n) WHERE (a)-[r]->(n) RETURN n',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'pattern', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-pattern1-10-4',
        feature_path='tck/features/expressions/pattern/Pattern1.feature',
        scenario='[10] Fail on introducing unbounded variables in pattern (example 4)',
        cypher='MATCH (n) WHERE (n)<-[r {}]-(a) RETURN n',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'pattern', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-pattern1-10-5',
        feature_path='tck/features/expressions/pattern/Pattern1.feature',
        scenario='[10] Fail on introducing unbounded variables in pattern (example 5)',
        cypher='MATCH (n) WHERE (n)-[r {}]-(a) RETURN n',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'pattern', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-pattern1-10-6',
        feature_path='tck/features/expressions/pattern/Pattern1.feature',
        scenario='[10] Fail on introducing unbounded variables in pattern (example 6)',
        cypher='MATCH (n) WHERE (n)-[r]->() RETURN n',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'pattern', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-pattern1-10-7',
        feature_path='tck/features/expressions/pattern/Pattern1.feature',
        scenario='[10] Fail on introducing unbounded variables in pattern (example 7)',
        cypher='MATCH (n) WHERE ()-[r]->(n) RETURN n',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'pattern', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-pattern1-10-8',
        feature_path='tck/features/expressions/pattern/Pattern1.feature',
        scenario='[10] Fail on introducing unbounded variables in pattern (example 8)',
        cypher='MATCH (n) WHERE (n)<-[r]-() RETURN n',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'pattern', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-pattern1-10-9',
        feature_path='tck/features/expressions/pattern/Pattern1.feature',
        scenario='[10] Fail on introducing unbounded variables in pattern (example 9)',
        cypher='MATCH (n) WHERE (n)-[r]-() RETURN n',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'pattern', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-pattern1-10-10',
        feature_path='tck/features/expressions/pattern/Pattern1.feature',
        scenario='[10] Fail on introducing unbounded variables in pattern (example 10)',
        cypher='MATCH (n) WHERE ()-[r]->() RETURN n',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'pattern', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-pattern1-10-11',
        feature_path='tck/features/expressions/pattern/Pattern1.feature',
        scenario='[10] Fail on introducing unbounded variables in pattern (example 11)',
        cypher='MATCH (n) WHERE ()<-[r]-() RETURN n',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'pattern', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-pattern1-10-12',
        feature_path='tck/features/expressions/pattern/Pattern1.feature',
        scenario='[10] Fail on introducing unbounded variables in pattern (example 12)',
        cypher='MATCH (n) WHERE ()-[r]-() RETURN n',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'pattern', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-pattern1-10-13',
        feature_path='tck/features/expressions/pattern/Pattern1.feature',
        scenario='[10] Fail on introducing unbounded variables in pattern (example 13)',
        cypher='MATCH (n) WHERE (n)-[r:REL]->(a {num: 5}) RETURN n',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'pattern', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-pattern1-10-14',
        feature_path='tck/features/expressions/pattern/Pattern1.feature',
        scenario='[10] Fail on introducing unbounded variables in pattern (example 14)',
        cypher='MATCH (n) WHERE (n)-[r:REL*0..2]->(a {num: 5}) RETURN n',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'pattern', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-pattern1-10-15',
        feature_path='tck/features/expressions/pattern/Pattern1.feature',
        scenario='[10] Fail on introducing unbounded variables in pattern (example 15)',
        cypher='MATCH (n) WHERE (n)-[r:REL]->(:C)<-[s:REL]-(a {num: 5}) RETURN n',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'pattern', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-pattern1-11',
        feature_path='tck/features/expressions/pattern/Pattern1.feature',
        scenario='[11] Fail on checking self pattern',
        cypher='MATCH (n) WHERE (n) RETURN n',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'pattern', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-pattern1-12',
        feature_path='tck/features/expressions/pattern/Pattern1.feature',
        scenario='[12] Matching two nodes on a single directed connection between them',
        cypher='MATCH (n), (m) WHERE (n)-[]->(m) RETURN n, m',
        graph=graph_fixture_from_create(
            """
            CREATE (a:A)-[:REL1]->(b:B), (b)-[:REL2]->(a), (a)-[:REL3]->(:C), (a)-[:REL1]->(:D)
            """
        ),
        expected=Expected(
            rows=[
            {'n': '(:A)', 'm': '(:B)'},
            {'n': '(:B)', 'm': '(:A)'},
            {'n': '(:A)', 'm': '(:C)'},
            {'n': '(:A)', 'm': '(:D)'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'pattern', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-pattern1-13',
        feature_path='tck/features/expressions/pattern/Pattern1.feature',
        scenario='[13] Fail on matching two nodes on a single undirected connection between them',
        cypher='MATCH (n), (m) WHERE (n)-[:REL1|REL2|REL3|REL4]-(m) RETURN n, m',
        graph=graph_fixture_from_create(
            """
            CREATE (a:A)-[:REL1]->(b:B), (b)-[:REL2]->(a), (a)-[:REL3]->(:C), (a)-[:REL1]->(:D)
            """
        ),
        expected=Expected(
            rows=[
            {'n': '(:A)', 'm': '(:B)'},
            {'n': '(:B)', 'm': '(:A)'},
            {'n': '(:A)', 'm': '(:C)'},
            {'n': '(:A)', 'm': '(:D)'},
            {'n': '(:C)', 'm': '(:A)'},
            {'n': '(:D)', 'm': '(:A)'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'pattern', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-pattern1-14',
        feature_path='tck/features/expressions/pattern/Pattern1.feature',
        scenario='[14] Matching two nodes on a specific type of single outgoing directed connection',
        cypher='MATCH (n), (m) WHERE (n)-[:REL1]->(m) RETURN n, m',
        graph=graph_fixture_from_create(
            """
            CREATE (a:A)-[:REL1]->(b:B), (b)-[:REL2]->(a), (a)-[:REL3]->(:C), (a)-[:REL1]->(:D)
            """
        ),
        expected=Expected(
            rows=[
            {'n': '(:A)', 'm': '(:B)'},
            {'n': '(:A)', 'm': '(:D)'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'pattern', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-pattern1-15',
        feature_path='tck/features/expressions/pattern/Pattern1.feature',
        scenario='[15] Matching two nodes on a specific type of single undirected connection',
        cypher='MATCH (n), (m) WHERE (n)-[:REL1]-(m) RETURN n, m',
        graph=graph_fixture_from_create(
            """
            CREATE (a:A)-[:REL1]->(b:B), (b)-[:REL2]->(a), (a)-[:REL3]->(:C), (a)-[:REL1]->(:D)
            """
        ),
        expected=Expected(
            rows=[
            {'n': '(:A)', 'm': '(:B)'},
            {'n': '(:B)', 'm': '(:A)'},
            {'n': '(:A)', 'm': '(:D)'},
            {'n': '(:D)', 'm': '(:A)'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'pattern', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-pattern1-16',
        feature_path='tck/features/expressions/pattern/Pattern1.feature',
        scenario='[16] Matching two nodes on a specific type of a variable length outgoing directed connection',
        cypher='MATCH (n), (m) WHERE (n)-[:REL1*]->(m) RETURN n, m',
        graph=graph_fixture_from_create(
            """
            CREATE (a:A)-[:REL1]->(b:B), (b)-[:REL2]->(a), (a)-[:REL3]->(:C), (a)-[:REL1]->(:D)
            """
        ),
        expected=Expected(
            rows=[
            {'n': '(:A)', 'm': '(:B)'},
            {'n': '(:A)', 'm': '(:D)'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'pattern', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-pattern1-17',
        feature_path='tck/features/expressions/pattern/Pattern1.feature',
        scenario='[17] Matching two nodes on a specific type of variable length undirected connection',
        cypher='MATCH (n), (m) WHERE (n)-[:REL1*]-(m) RETURN n, m',
        graph=graph_fixture_from_create(
            """
            CREATE (a:A)-[:REL1]->(b:B), (b)-[:REL2]->(a), (a)-[:REL3]->(:C), (a)-[:REL1]->(:D)
            """
        ),
        expected=Expected(
            rows=[
            {'n': '(:A)', 'm': '(:B)'},
            {'n': '(:A)', 'm': '(:D)'},
            {'n': '(:B)', 'm': '(:A)'},
            {'n': '(:B)', 'm': '(:D)'},
            {'n': '(:D)', 'm': '(:A)'},
            {'n': '(:D)', 'm': '(:B)'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'pattern', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-pattern1-18',
        feature_path='tck/features/expressions/pattern/Pattern1.feature',
        scenario='[18] Matching two nodes on a specific type of undirected connection with length 2',
        cypher='MATCH (n), (m) WHERE (n)-[:REL1*2]-(m) RETURN n, m',
        graph=graph_fixture_from_create(
            """
            CREATE (a:A)-[:REL1]->(b:B), (b)-[:REL2]->(a), (a)-[:REL3]->(:C), (a)-[:REL1]->(:D)
            """
        ),
        expected=Expected(
            rows=[
            {'n': '(:D)', 'm': '(:B)'},
            {'n': '(:B)', 'm': '(:D)'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'pattern', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-pattern1-19',
        feature_path='tck/features/expressions/pattern/Pattern1.feature',
        scenario='[19] Using a negated existential pattern predicate',
        cypher='MATCH (n) WHERE NOT (n)-[:REL2]-() RETURN n',
        graph=graph_fixture_from_create(
            """
            CREATE (a:A)-[:REL1]->(b:B), (b)-[:REL2]->(a), (a)-[:REL3]->(:C), (a)-[:REL1]->(:D)
            """
        ),
        expected=Expected(
            rows=[
            {'n': '(:C)'},
            {'n': '(:D)'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'pattern', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-pattern1-20',
        feature_path='tck/features/expressions/pattern/Pattern1.feature',
        scenario='[20] Using two existential pattern predicates in a conjunction',
        cypher='MATCH (n) WHERE (n)-[:REL1]-() AND (n)-[:REL3]-() RETURN n',
        graph=graph_fixture_from_create(
            """
            CREATE (a:A)-[:REL1]->(b:B), (b)-[:REL2]->(a), (a)-[:REL3]->(:C), (a)-[:REL1]->(:D)
            """
        ),
        expected=Expected(
            rows=[
            {'n': '(:A)'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'pattern', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-pattern1-21',
        feature_path='tck/features/expressions/pattern/Pattern1.feature',
        scenario='[21] Using two existential pattern predicates in a disjunction',
        cypher='MATCH (n) WHERE (n)-[:REL1]-() OR (n)-[:REL2]-() RETURN n',
        graph=graph_fixture_from_create(
            """
            CREATE (a:A)-[:REL1]->(b:B), (b)-[:REL2]->(a), (a)-[:REL3]->(:C), (a)-[:REL1]->(:D)
            """
        ),
        expected=Expected(
            rows=[
            {'n': '(:A)'},
            {'n': '(:B)'},
            {'n': '(:D)'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'pattern', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-pattern1-22',
        feature_path='tck/features/expressions/pattern/Pattern1.feature',
        scenario='[22] Fail on using pattern in RETURN projection',
        cypher='MATCH (n) RETURN (n)-[]->()',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'pattern', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-pattern1-23',
        feature_path='tck/features/expressions/pattern/Pattern1.feature',
        scenario='[23] Fail on using pattern in WITH projection',
        cypher='MATCH (n) WITH (n)-[]->() AS x RETURN x',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'pattern', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-pattern1-24',
        feature_path='tck/features/expressions/pattern/Pattern1.feature',
        scenario='[24] Fail on using pattern in right-hand side of SET',
        cypher='MATCH (n) SET n.prop = head(nodes(head((n)-[:REL]->()))).foo',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'pattern', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-pattern2-1',
        feature_path='tck/features/expressions/pattern/Pattern2.feature',
        scenario='[1] Return a pattern comprehension',
        cypher='MATCH (n)\n      RETURN [p = (n)-->() | p] AS list',
        graph=graph_fixture_from_create(
            """
            CREATE (a:A), (b:B)
                  CREATE (a)-[:T]->(b),
                         (b)-[:T]->(:C)
            """
        ),
        expected=Expected(
            rows=[
            {'list': '[<(:A)-[:T]->(:B)>]'},
            {'list': '[<(:B)-[:T]->(:C)>]'},
            {'list': '[]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'pattern', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-pattern2-2',
        feature_path='tck/features/expressions/pattern/Pattern2.feature',
        scenario='[2] Return a pattern comprehension with label predicate',
        cypher='MATCH (n:A)\n      RETURN [p = (n)-->(:B) | p] AS list',
        graph=graph_fixture_from_create(
            """
            CREATE (a:A), (b:B), (c:C), (d:D)
                  CREATE (a)-[:T]->(b),
                         (a)-[:T]->(c),
                         (a)-[:T]->(d)
            """
        ),
        expected=Expected(
            rows=[
            {'list': '[<(:A)-[:T]->(:B)>]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'pattern', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-pattern2-3',
        feature_path='tck/features/expressions/pattern/Pattern2.feature',
        scenario='[3] Return a pattern comprehension with bound nodes',
        cypher='MATCH (a:A), (b:B)\n      RETURN [p = (a)-->(b) | p] AS list',
        graph=graph_fixture_from_create(
            """
            CREATE (a:A), (b:B)
                  CREATE (a)-[:T]->(b)
            """
        ),
        expected=Expected(
            rows=[
            {'list': '[<(:A)-[:T]->(:B)>]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'pattern', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-pattern2-4',
        feature_path='tck/features/expressions/pattern/Pattern2.feature',
        scenario='[4] Introduce a new node variable in pattern comprehension',
        cypher='MATCH (n)\n      RETURN [(n)-[:T]->(b) | b.name] AS list',
        graph=graph_fixture_from_create(
            """
            CREATE (a), (b {name: 'val'}), (c)
                  CREATE (a)-[:T]->(b),
                         (b)-[:T]->(c)
            """
        ),
        expected=Expected(
            rows=[
            {'list': "['val']"},
            {'list': '[null]'},
            {'list': '[]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'pattern', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-pattern2-5',
        feature_path='tck/features/expressions/pattern/Pattern2.feature',
        scenario='[5] Introduce a new relationship variable in pattern comprehension',
        cypher='MATCH (n)\n      RETURN [(n)-[r:T]->() | r.name] AS list',
        graph=graph_fixture_from_create(
            """
            CREATE (a), (b), (c)
                  CREATE (a)-[:T {name: 'val'}]->(b),
                         (b)-[:T]->(c)
            """
        ),
        expected=Expected(
            rows=[
            {'list': "['val']"},
            {'list': '[null]'},
            {'list': '[]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'pattern', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-pattern2-6',
        feature_path='tck/features/expressions/pattern/Pattern2.feature',
        scenario='[6] Aggregate on a pattern comprehension',
        cypher='MATCH (n:A)\n      RETURN count([p = (n)-[:HAS]->() | p]) AS c',
        graph=graph_fixture_from_create(
            """
            CREATE (a:A), (:A), (:A)
                  CREATE (a)-[:HAS]->()
            """
        ),
        expected=Expected(
            rows=[
            {'c': 3}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'pattern', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-pattern2-7',
        feature_path='tck/features/expressions/pattern/Pattern2.feature',
        scenario='[7] Use a pattern comprehension inside a list comprehension',
        cypher='MATCH p = (n:X)-->()\n      RETURN n, [x IN nodes(p) | size([(x)-->(:Y) | 1])] AS list',
        graph=graph_fixture_from_create(
            """
            CREATE (n1:X {n: 1}), (m1:Y), (i1:Y), (i2:Y)
                  CREATE (n1)-[:T]->(m1),
                         (m1)-[:T]->(i1),
                         (m1)-[:T]->(i2)
                  CREATE (n2:X {n: 2}), (m2), (i3:L), (i4:Y)
                  CREATE (n2)-[:T]->(m2),
                         (m2)-[:T]->(i3),
                         (m2)-[:T]->(i4)
            """
        ),
        expected=Expected(
            rows=[
            {'n': '(:X {n: 1})', 'list': '[1, 2]'},
            {'n': '(:X {n: 2})', 'list': '[0, 1]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'pattern', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-pattern2-8',
        feature_path='tck/features/expressions/pattern/Pattern2.feature',
        scenario='[8] Use a pattern comprehension in WITH',
        cypher='MATCH (n)-->(b)\n      WITH [p = (n)-->() | p] AS ps, count(b) AS c\n      RETURN ps, c',
        graph=graph_fixture_from_create(
            """
            CREATE (a:A), (b:B)
                  CREATE (a)-[:T]->(b),
                         (b)-[:T]->(:C)
            """
        ),
        expected=Expected(
            rows=[
            {'ps': '[<(:A)-[:T]->(:B)>]', 'c': 1},
            {'ps': '[<(:B)-[:T]->(:C)>]', 'c': 1}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'pattern', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-pattern2-9',
        feature_path='tck/features/expressions/pattern/Pattern2.feature',
        scenario='[9] Use a variable-length pattern comprehension in WITH',
        cypher='MATCH (a:A), (b:B)\n      WITH [p = (a)-[*]->(b) | p] AS paths, count(a) AS c\n      RETURN paths, c',
        graph=graph_fixture_from_create(
            """
            CREATE (:A)-[:T]->(:B)
            """
        ),
        expected=Expected(
            rows=[
            {'paths': '[<(:A)-[:T]->(:B)>]', 'c': 1}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'pattern', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-pattern2-10',
        feature_path='tck/features/expressions/pattern/Pattern2.feature',
        scenario='[10] Use a pattern comprehension in RETURN',
        cypher='MATCH (n:A)\n      RETURN [p = (n)-[:HAS]->() | p] AS ps',
        graph=graph_fixture_from_create(
            """
            CREATE (a:A), (:A), (:A)
                  CREATE (a)-[:HAS]->()
            """
        ),
        expected=Expected(
            rows=[
            {'ps': '[<(:A)-[:HAS]->()>]'},
            {'ps': '[]'},
            {'ps': '[]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'pattern', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-pattern2-11',
        feature_path='tck/features/expressions/pattern/Pattern2.feature',
        scenario='[11] Use a pattern comprehension and ORDER BY',
        cypher='MATCH (liker)\n      RETURN [p = (liker)--() | p] AS isNew\n        ORDER BY liker.time',
        graph=graph_fixture_from_create(
            """
            CREATE (a {time: 10}), (b {time: 20})
                  CREATE (a)-[:T]->(b)
            """
        ),
        expected=Expected(
            rows=[
            {'isNew': '[<({time: 10})-[:T]->({time: 20})>]'},
            {'isNew': '[<({time: 20})<-[:T]-({time: 10})>]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'pattern', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence1-1',
        feature_path='tck/features/expressions/precedence/Precedence1.feature',
        scenario='[1] Exclusive disjunction takes precedence over inclusive disjunction',
        cypher='RETURN true OR true XOR true AS a,\n             true OR (true XOR true) AS b,\n             (true OR true) XOR true AS c',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'a': 'true', 'b': 'true', 'c': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence1-2',
        feature_path='tck/features/expressions/precedence/Precedence1.feature',
        scenario='[2] Conjunction disjunction takes precedence over exclusive disjunction',
        cypher='RETURN true XOR false AND false AS a,\n             true XOR (false AND false) AS b,\n             (true XOR false) AND false AS c',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'a': 'true', 'b': 'true', 'c': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence1-3',
        feature_path='tck/features/expressions/precedence/Precedence1.feature',
        scenario='[3] Conjunction disjunction takes precedence over inclusive disjunction',
        cypher='RETURN true OR false AND false AS a,\n             true OR (false AND false) AS b,\n             (true OR false) AND false AS c',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'a': 'true', 'b': 'true', 'c': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence1-4',
        feature_path='tck/features/expressions/precedence/Precedence1.feature',
        scenario='[4] Negation takes precedence over conjunction',
        cypher='RETURN NOT true AND false AS a,\n             (NOT true) AND false AS b,\n             NOT (true AND false) AS c',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'a': 'false', 'b': 'false', 'c': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence1-5',
        feature_path='tck/features/expressions/precedence/Precedence1.feature',
        scenario='[5] Negation takes precedence over inclusive disjunction',
        cypher='RETURN NOT false OR true AS a,\n             (NOT false) OR true AS b,\n             NOT (false OR true) AS c',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'a': 'true', 'b': 'true', 'c': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence1-6',
        feature_path='tck/features/expressions/precedence/Precedence1.feature',
        scenario='[6] Comparison operator takes precedence over boolean negation',
        cypher='RETURN NOT false >= false AS a,\n             NOT (false >= false) AS b,\n             (NOT false) >= false AS c',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'a': 'false', 'b': 'false', 'c': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence1-7',
        feature_path='tck/features/expressions/precedence/Precedence1.feature',
        scenario='[7] Comparison operator takes precedence over binary boolean operator',
        cypher='RETURN true OR false = false AS a,\n             true OR (false = false) AS b,\n             (true OR false) = false AS c',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'a': 'true', 'b': 'true', 'c': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence1-8',
        feature_path='tck/features/expressions/precedence/Precedence1.feature',
        scenario='[8] Null predicate takes precedence over comparison operator',
        cypher='RETURN false = true IS NULL AS a,\n             false = (true IS NULL) AS b,\n             (false = true) IS NULL AS c',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'a': 'true', 'b': 'true', 'c': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence1-9',
        feature_path='tck/features/expressions/precedence/Precedence1.feature',
        scenario='[9] Null predicate takes precedence over negation',
        cypher='RETURN NOT false IS NULL AS a,\n             NOT (false IS NULL) AS b,\n             (NOT false) IS NULL AS c',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'a': 'true', 'b': 'true', 'c': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence1-10',
        feature_path='tck/features/expressions/precedence/Precedence1.feature',
        scenario='[10] Null predicate takes precedence over boolean operator',
        cypher='RETURN true OR false IS NULL AS a,\n             true OR (false IS NULL) AS b,\n             (true OR false) IS NULL AS c',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'a': 'true', 'b': 'true', 'c': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence1-11',
        feature_path='tck/features/expressions/precedence/Precedence1.feature',
        scenario='[11] List predicate takes precedence over comparison operator',
        cypher='RETURN false = true IN [true, false] AS a,\n             false = (true IN [true, false]) AS b,\n             (false = true) IN [true, false] AS c',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'a': 'false', 'b': 'false', 'c': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence1-12',
        feature_path='tck/features/expressions/precedence/Precedence1.feature',
        scenario='[12] List predicate takes precedence over negation',
        cypher='RETURN NOT true IN [true, false] AS a,\n             NOT (true IN [true, false]) AS b,\n             (NOT true) IN [true, false] AS c',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'a': 'false', 'b': 'false', 'c': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence1-13',
        feature_path='tck/features/expressions/precedence/Precedence1.feature',
        scenario='[13] List predicate takes precedence over boolean operator',
        cypher='RETURN false AND true IN [true, false] AS a,\n             false AND (true IN [true, false]) AS b,\n             (false AND true) IN [true, false] AS c',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'a': 'false', 'b': 'false', 'c': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence1-14',
        feature_path='tck/features/expressions/precedence/Precedence1.feature',
        scenario='[14] Exclusive disjunction takes precedence over inclusive disjunction in every combination of truth values',
        cypher='UNWIND [true, false, null] AS a\n      UNWIND [true, false, null] AS b\n      UNWIND [true, false, null] AS c\n      WITH collect((a OR b XOR c) = (a OR (b XOR c))) AS eq,\n           collect((a OR b XOR c) <> ((a OR b) XOR c)) AS neq\n      RETURN all(x IN eq WHERE x) AND any(x IN neq WHERE x) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence1-15',
        feature_path='tck/features/expressions/precedence/Precedence1.feature',
        scenario='[15] Conjunction takes precedence over exclusive disjunction in every combination of truth values',
        cypher='UNWIND [true, false, null] AS a\n      UNWIND [true, false, null] AS b\n      UNWIND [true, false, null] AS c\n      WITH collect((a XOR b AND c) = (a XOR (b AND c))) AS eq,\n           collect((a XOR b AND c) <> ((a XOR b) AND c)) AS neq\n      RETURN all(x IN eq WHERE x) AND any(x IN neq WHERE x) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence1-16',
        feature_path='tck/features/expressions/precedence/Precedence1.feature',
        scenario='[16] Conjunction takes precedence over inclusive disjunction in every combination of truth values',
        cypher='UNWIND [true, false, null] AS a\n      UNWIND [true, false, null] AS b\n      UNWIND [true, false, null] AS c\n      WITH collect((a OR b AND c) = (a OR (b AND c))) AS eq,\n           collect((a OR b AND c) <> ((a OR b) AND c)) AS neq\n      RETURN all(x IN eq WHERE x) AND any(x IN neq WHERE x) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence1-17',
        feature_path='tck/features/expressions/precedence/Precedence1.feature',
        scenario='[17] Negation takes precedence over conjunction in every combination of truth values',
        cypher='UNWIND [true, false, null] AS a\n      UNWIND [true, false, null] AS b\n      WITH collect((NOT a AND b) = ((NOT a) AND b)) AS eq,\n           collect((NOT a AND b) <> (NOT (a AND b))) AS neq\n      RETURN all(x IN eq WHERE x) AND any(x IN neq WHERE x) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence1-18',
        feature_path='tck/features/expressions/precedence/Precedence1.feature',
        scenario='[18] Negation takes precedence over inclusive disjunction in every combination of truth values',
        cypher='UNWIND [true, false, null] AS a\n      UNWIND [true, false, null] AS b\n      WITH collect((NOT a OR b) = ((NOT a) OR b)) AS eq,\n           collect((NOT a OR b) <> (NOT (a OR b))) AS neq\n      RETURN all(x IN eq WHERE x) AND any(x IN neq WHERE x) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence1-20-1',
        feature_path='tck/features/expressions/precedence/Precedence1.feature',
        scenario='[20] Pairs of comparison operators and boolean negation that are associative in every combination of truth values (example 1)',
        cypher='UNWIND [true, false, null] AS a\n      UNWIND [true, false, null] AS b\n      WITH collect((NOT (a = b)) = ((NOT a) = b)) AS eq\n      RETURN all(x IN eq WHERE x) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence1-20-2',
        feature_path='tck/features/expressions/precedence/Precedence1.feature',
        scenario='[20] Pairs of comparison operators and boolean negation that are associative in every combination of truth values (example 2)',
        cypher='UNWIND [true, false, null] AS a\n      UNWIND [true, false, null] AS b\n      WITH collect((NOT (a <> b)) = ((NOT a) <> b)) AS eq\n      RETURN all(x IN eq WHERE x) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence1-21-1',
        feature_path='tck/features/expressions/precedence/Precedence1.feature',
        scenario='[21] Comparison operators take precedence over binary boolean operators in every combination of truth values (example 1)',
        cypher='UNWIND [true, false, null] AS a\n      UNWIND [true, false, null] AS b\n      UNWIND [true, false, null] AS c\n      WITH collect((a OR b = c) = (a OR (b = c))) AS eq,\n           collect((a OR b = c) <> ((a OR b) = c)) AS neq\n      RETURN all(x IN eq WHERE x) AND any(x IN neq WHERE x) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence1-22-1',
        feature_path='tck/features/expressions/precedence/Precedence1.feature',
        scenario='[22] Pairs of comparison operators and binary boolean operators that are associative in every combination of truth values (example 1)',
        cypher='UNWIND [true, false, null] AS a\n      UNWIND [true, false, null] AS b\n      UNWIND [true, false, null] AS c\n      WITH collect((a XOR (b = c)) = ((a XOR b) = c)) AS eq\n      RETURN all(x IN eq WHERE x) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence1-22-2',
        feature_path='tck/features/expressions/precedence/Precedence1.feature',
        scenario='[22] Pairs of comparison operators and binary boolean operators that are associative in every combination of truth values (example 2)',
        cypher='UNWIND [true, false, null] AS a\n      UNWIND [true, false, null] AS b\n      UNWIND [true, false, null] AS c\n      WITH collect((a OR (b >= c)) = ((a OR b) >= c)) AS eq\n      RETURN all(x IN eq WHERE x) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence1-22-3',
        feature_path='tck/features/expressions/precedence/Precedence1.feature',
        scenario='[22] Pairs of comparison operators and binary boolean operators that are associative in every combination of truth values (example 3)',
        cypher='UNWIND [true, false, null] AS a\n      UNWIND [true, false, null] AS b\n      UNWIND [true, false, null] AS c\n      WITH collect((a AND (b > c)) = ((a AND b) > c)) AS eq\n      RETURN all(x IN eq WHERE x) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence1-22-4',
        feature_path='tck/features/expressions/precedence/Precedence1.feature',
        scenario='[22] Pairs of comparison operators and binary boolean operators that are associative in every combination of truth values (example 4)',
        cypher='UNWIND [true, false, null] AS a\n      UNWIND [true, false, null] AS b\n      UNWIND [true, false, null] AS c\n      WITH collect((a XOR (b <> c)) = ((a XOR b) <> c)) AS eq\n      RETURN all(x IN eq WHERE x) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence1-23-1',
        feature_path='tck/features/expressions/precedence/Precedence1.feature',
        scenario='[23] Null predicates take precedence over comparison operators in every combination of truth values (example 1)',
        cypher='UNWIND [true, false, null] AS a\n      UNWIND [true, false, null] AS b\n      WITH collect((a = b IS NULL) = (a = (b IS NULL))) AS eq,\n           collect((a = b IS NULL) <> ((a = b) IS NULL)) AS neq\n      RETURN all(x IN eq WHERE x) AND any(x IN neq WHERE x) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence1-23-2',
        feature_path='tck/features/expressions/precedence/Precedence1.feature',
        scenario='[23] Null predicates take precedence over comparison operators in every combination of truth values (example 2)',
        cypher='UNWIND [true, false, null] AS a\n      UNWIND [true, false, null] AS b\n      WITH collect((a = b IS NOT NULL) = (a = (b IS NOT NULL))) AS eq,\n           collect((a = b IS NOT NULL) <> ((a = b) IS NOT NULL)) AS neq\n      RETURN all(x IN eq WHERE x) AND any(x IN neq WHERE x) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence1-23-3',
        feature_path='tck/features/expressions/precedence/Precedence1.feature',
        scenario='[23] Null predicates take precedence over comparison operators in every combination of truth values (example 3)',
        cypher='UNWIND [true, false, null] AS a\n      UNWIND [true, false, null] AS b\n      WITH collect((a <= b IS NULL) = (a <= (b IS NULL))) AS eq,\n           collect((a <= b IS NULL) <> ((a <= b) IS NULL)) AS neq\n      RETURN all(x IN eq WHERE x) AND any(x IN neq WHERE x) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence1-23-4',
        feature_path='tck/features/expressions/precedence/Precedence1.feature',
        scenario='[23] Null predicates take precedence over comparison operators in every combination of truth values (example 4)',
        cypher='UNWIND [true, false, null] AS a\n      UNWIND [true, false, null] AS b\n      WITH collect((a <= b IS NOT NULL) = (a <= (b IS NOT NULL))) AS eq,\n           collect((a <= b IS NOT NULL) <> ((a <= b) IS NOT NULL)) AS neq\n      RETURN all(x IN eq WHERE x) AND any(x IN neq WHERE x) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence1-23-5',
        feature_path='tck/features/expressions/precedence/Precedence1.feature',
        scenario='[23] Null predicates take precedence over comparison operators in every combination of truth values (example 5)',
        cypher='UNWIND [true, false, null] AS a\n      UNWIND [true, false, null] AS b\n      WITH collect((a >= b IS NULL) = (a >= (b IS NULL))) AS eq,\n           collect((a >= b IS NULL) <> ((a >= b) IS NULL)) AS neq\n      RETURN all(x IN eq WHERE x) AND any(x IN neq WHERE x) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence1-23-6',
        feature_path='tck/features/expressions/precedence/Precedence1.feature',
        scenario='[23] Null predicates take precedence over comparison operators in every combination of truth values (example 6)',
        cypher='UNWIND [true, false, null] AS a\n      UNWIND [true, false, null] AS b\n      WITH collect((a >= b IS NOT NULL) = (a >= (b IS NOT NULL))) AS eq,\n           collect((a >= b IS NOT NULL) <> ((a >= b) IS NOT NULL)) AS neq\n      RETURN all(x IN eq WHERE x) AND any(x IN neq WHERE x) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence1-23-7',
        feature_path='tck/features/expressions/precedence/Precedence1.feature',
        scenario='[23] Null predicates take precedence over comparison operators in every combination of truth values (example 7)',
        cypher='UNWIND [true, false, null] AS a\n      UNWIND [true, false, null] AS b\n      WITH collect((a < b IS NULL) = (a < (b IS NULL))) AS eq,\n           collect((a < b IS NULL) <> ((a < b) IS NULL)) AS neq\n      RETURN all(x IN eq WHERE x) AND any(x IN neq WHERE x) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence1-23-8',
        feature_path='tck/features/expressions/precedence/Precedence1.feature',
        scenario='[23] Null predicates take precedence over comparison operators in every combination of truth values (example 8)',
        cypher='UNWIND [true, false, null] AS a\n      UNWIND [true, false, null] AS b\n      WITH collect((a < b IS NOT NULL) = (a < (b IS NOT NULL))) AS eq,\n           collect((a < b IS NOT NULL) <> ((a < b) IS NOT NULL)) AS neq\n      RETURN all(x IN eq WHERE x) AND any(x IN neq WHERE x) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence1-23-9',
        feature_path='tck/features/expressions/precedence/Precedence1.feature',
        scenario='[23] Null predicates take precedence over comparison operators in every combination of truth values (example 9)',
        cypher='UNWIND [true, false, null] AS a\n      UNWIND [true, false, null] AS b\n      WITH collect((a > b IS NULL) = (a > (b IS NULL))) AS eq,\n           collect((a > b IS NULL) <> ((a > b) IS NULL)) AS neq\n      RETURN all(x IN eq WHERE x) AND any(x IN neq WHERE x) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence1-23-10',
        feature_path='tck/features/expressions/precedence/Precedence1.feature',
        scenario='[23] Null predicates take precedence over comparison operators in every combination of truth values (example 10)',
        cypher='UNWIND [true, false, null] AS a\n      UNWIND [true, false, null] AS b\n      WITH collect((a > b IS NOT NULL) = (a > (b IS NOT NULL))) AS eq,\n           collect((a > b IS NOT NULL) <> ((a > b) IS NOT NULL)) AS neq\n      RETURN all(x IN eq WHERE x) AND any(x IN neq WHERE x) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence1-23-11',
        feature_path='tck/features/expressions/precedence/Precedence1.feature',
        scenario='[23] Null predicates take precedence over comparison operators in every combination of truth values (example 11)',
        cypher='UNWIND [true, false, null] AS a\n      UNWIND [true, false, null] AS b\n      WITH collect((a <> b IS NULL) = (a <> (b IS NULL))) AS eq,\n           collect((a <> b IS NULL) <> ((a <> b) IS NULL)) AS neq\n      RETURN all(x IN eq WHERE x) AND any(x IN neq WHERE x) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence1-23-12',
        feature_path='tck/features/expressions/precedence/Precedence1.feature',
        scenario='[23] Null predicates take precedence over comparison operators in every combination of truth values (example 12)',
        cypher='UNWIND [true, false, null] AS a\n      UNWIND [true, false, null] AS b\n      WITH collect((a <> b IS NOT NULL) = (a <> (b IS NOT NULL))) AS eq,\n           collect((a <> b IS NOT NULL) <> ((a <> b) IS NOT NULL)) AS neq\n      RETURN all(x IN eq WHERE x) AND any(x IN neq WHERE x) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence1-24-1',
        feature_path='tck/features/expressions/precedence/Precedence1.feature',
        scenario='[24] Null predicates take precedence over boolean negation on every truth values (example 1)',
        cypher='UNWIND [true, false, null] AS a\n      UNWIND [true, false, null] AS b\n      WITH collect((NOT a IS NULL) = (NOT (a IS NULL))) AS eq,\n           collect((NOT a IS NULL) <> ((NOT a) IS NULL)) AS neq\n      RETURN all(x IN eq WHERE x) AND any(x IN neq WHERE x) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence1-24-2',
        feature_path='tck/features/expressions/precedence/Precedence1.feature',
        scenario='[24] Null predicates take precedence over boolean negation on every truth values (example 2)',
        cypher='UNWIND [true, false, null] AS a\n      UNWIND [true, false, null] AS b\n      WITH collect((NOT a IS NOT NULL) = (NOT (a IS NOT NULL))) AS eq,\n           collect((NOT a IS NOT NULL) <> ((NOT a) IS NOT NULL)) AS neq\n      RETURN all(x IN eq WHERE x) AND any(x IN neq WHERE x) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence1-25-1',
        feature_path='tck/features/expressions/precedence/Precedence1.feature',
        scenario='[25] Null predicates take precedence over binary boolean operators in every combination of truth values (example 1)',
        cypher='UNWIND [true, false, null] AS a\n      UNWIND [true, false, null] AS b\n      WITH collect((a OR b IS NULL) = (a OR (b IS NULL))) AS eq,\n           collect((a OR b IS NULL) <> ((a OR b) IS NULL)) AS neq\n      RETURN all(x IN eq WHERE x) AND any(x IN neq WHERE x) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence1-25-2',
        feature_path='tck/features/expressions/precedence/Precedence1.feature',
        scenario='[25] Null predicates take precedence over binary boolean operators in every combination of truth values (example 2)',
        cypher='UNWIND [true, false, null] AS a\n      UNWIND [true, false, null] AS b\n      WITH collect((a OR b IS NOT NULL) = (a OR (b IS NOT NULL))) AS eq,\n           collect((a OR b IS NOT NULL) <> ((a OR b) IS NOT NULL)) AS neq\n      RETURN all(x IN eq WHERE x) AND any(x IN neq WHERE x) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence1-25-3',
        feature_path='tck/features/expressions/precedence/Precedence1.feature',
        scenario='[25] Null predicates take precedence over binary boolean operators in every combination of truth values (example 3)',
        cypher='UNWIND [true, false, null] AS a\n      UNWIND [true, false, null] AS b\n      WITH collect((a XOR b IS NULL) = (a XOR (b IS NULL))) AS eq,\n           collect((a XOR b IS NULL) <> ((a XOR b) IS NULL)) AS neq\n      RETURN all(x IN eq WHERE x) AND any(x IN neq WHERE x) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence1-25-4',
        feature_path='tck/features/expressions/precedence/Precedence1.feature',
        scenario='[25] Null predicates take precedence over binary boolean operators in every combination of truth values (example 4)',
        cypher='UNWIND [true, false, null] AS a\n      UNWIND [true, false, null] AS b\n      WITH collect((a XOR b IS NOT NULL) = (a XOR (b IS NOT NULL))) AS eq,\n           collect((a XOR b IS NOT NULL) <> ((a XOR b) IS NOT NULL)) AS neq\n      RETURN all(x IN eq WHERE x) AND any(x IN neq WHERE x) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence1-25-5',
        feature_path='tck/features/expressions/precedence/Precedence1.feature',
        scenario='[25] Null predicates take precedence over binary boolean operators in every combination of truth values (example 5)',
        cypher='UNWIND [true, false, null] AS a\n      UNWIND [true, false, null] AS b\n      WITH collect((a AND b IS NULL) = (a AND (b IS NULL))) AS eq,\n           collect((a AND b IS NULL) <> ((a AND b) IS NULL)) AS neq\n      RETURN all(x IN eq WHERE x) AND any(x IN neq WHERE x) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence1-25-6',
        feature_path='tck/features/expressions/precedence/Precedence1.feature',
        scenario='[25] Null predicates take precedence over binary boolean operators in every combination of truth values (example 6)',
        cypher='UNWIND [true, false, null] AS a\n      UNWIND [true, false, null] AS b\n      WITH collect((a AND b IS NOT NULL) = (a AND (b IS NOT NULL))) AS eq,\n           collect((a AND b IS NOT NULL) <> ((a AND b) IS NOT NULL)) AS neq\n      RETURN all(x IN eq WHERE x) AND any(x IN neq WHERE x) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence1-26-1',
        feature_path='tck/features/expressions/precedence/Precedence1.feature',
        scenario='[26] List predicate takes precedence over comparison operators in every combination of truth values (example 1)',
        cypher='UNWIND [true, false, null] AS a\n      UNWIND [true, false, null] AS b\n      UNWIND [[], [true], [false], [null], [true, false], [true, false, null]] AS c\n      WITH collect((a = b IN c) = (a = (b IN c))) AS eq,\n           collect((a = b IN c) <> ((a = b) IN c)) AS neq\n      RETURN all(x IN eq WHERE x) AND any(x IN neq WHERE x) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence1-26-2',
        feature_path='tck/features/expressions/precedence/Precedence1.feature',
        scenario='[26] List predicate takes precedence over comparison operators in every combination of truth values (example 2)',
        cypher='UNWIND [true, false, null] AS a\n      UNWIND [true, false, null] AS b\n      UNWIND [[], [true], [false], [null], [true, false], [true, false, null]] AS c\n      WITH collect((a <= b IN c) = (a <= (b IN c))) AS eq,\n           collect((a <= b IN c) <> ((a <= b) IN c)) AS neq\n      RETURN all(x IN eq WHERE x) AND any(x IN neq WHERE x) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence1-26-3',
        feature_path='tck/features/expressions/precedence/Precedence1.feature',
        scenario='[26] List predicate takes precedence over comparison operators in every combination of truth values (example 3)',
        cypher='UNWIND [true, false, null] AS a\n      UNWIND [true, false, null] AS b\n      UNWIND [[], [true], [false], [null], [true, false], [true, false, null]] AS c\n      WITH collect((a >= b IN c) = (a >= (b IN c))) AS eq,\n           collect((a >= b IN c) <> ((a >= b) IN c)) AS neq\n      RETURN all(x IN eq WHERE x) AND any(x IN neq WHERE x) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence1-26-4',
        feature_path='tck/features/expressions/precedence/Precedence1.feature',
        scenario='[26] List predicate takes precedence over comparison operators in every combination of truth values (example 4)',
        cypher='UNWIND [true, false, null] AS a\n      UNWIND [true, false, null] AS b\n      UNWIND [[], [true], [false], [null], [true, false], [true, false, null]] AS c\n      WITH collect((a < b IN c) = (a < (b IN c))) AS eq,\n           collect((a < b IN c) <> ((a < b) IN c)) AS neq\n      RETURN all(x IN eq WHERE x) AND any(x IN neq WHERE x) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence1-26-5',
        feature_path='tck/features/expressions/precedence/Precedence1.feature',
        scenario='[26] List predicate takes precedence over comparison operators in every combination of truth values (example 5)',
        cypher='UNWIND [true, false, null] AS a\n      UNWIND [true, false, null] AS b\n      UNWIND [[], [true], [false], [null], [true, false], [true, false, null]] AS c\n      WITH collect((a > b IN c) = (a > (b IN c))) AS eq,\n           collect((a > b IN c) <> ((a > b) IN c)) AS neq\n      RETURN all(x IN eq WHERE x) AND any(x IN neq WHERE x) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence1-26-6',
        feature_path='tck/features/expressions/precedence/Precedence1.feature',
        scenario='[26] List predicate takes precedence over comparison operators in every combination of truth values (example 6)',
        cypher='UNWIND [true, false, null] AS a\n      UNWIND [true, false, null] AS b\n      UNWIND [[], [true], [false], [null], [true, false], [true, false, null]] AS c\n      WITH collect((a <> b IN c) = (a <> (b IN c))) AS eq,\n           collect((a <> b IN c) <> ((a <> b) IN c)) AS neq\n      RETURN all(x IN eq WHERE x) AND any(x IN neq WHERE x) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence1-27',
        feature_path='tck/features/expressions/precedence/Precedence1.feature',
        scenario='[27] List predicate takes precedence over negation in every combination of truth values',
        cypher='UNWIND [true, false, null] AS a\n      UNWIND [[], [true], [false], [null], [true, false], [true, false, null]] AS b\n      WITH collect((NOT a IN b) = (NOT (a IN b))) AS eq,\n           collect((NOT a IN b) <> ((NOT a) IN b)) AS neq\n      RETURN all(x IN eq WHERE x) AND any(x IN neq WHERE x) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence1-28-1',
        feature_path='tck/features/expressions/precedence/Precedence1.feature',
        scenario='[28] List predicate takes precedence over binary boolean operators in every combination of truth values (example 1)',
        cypher='UNWIND [true, false, null] AS a\n      UNWIND [true, false, null] AS b\n      UNWIND [[], [true], [false], [null], [true, false], [true, false, null]] AS c\n      WITH collect((a OR b IN c) = (a OR (b IN c))) AS eq,\n           collect((a OR b IN c) <> ((a OR b) IN c)) AS neq\n      RETURN all(x IN eq WHERE x) AND any(x IN neq WHERE x) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence1-28-2',
        feature_path='tck/features/expressions/precedence/Precedence1.feature',
        scenario='[28] List predicate takes precedence over binary boolean operators in every combination of truth values (example 2)',
        cypher='UNWIND [true, false, null] AS a\n      UNWIND [true, false, null] AS b\n      UNWIND [[], [true], [false], [null], [true, false], [true, false, null]] AS c\n      WITH collect((a XOR b IN c) = (a XOR (b IN c))) AS eq,\n           collect((a XOR b IN c) <> ((a XOR b) IN c)) AS neq\n      RETURN all(x IN eq WHERE x) AND any(x IN neq WHERE x) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence1-28-3',
        feature_path='tck/features/expressions/precedence/Precedence1.feature',
        scenario='[28] List predicate takes precedence over binary boolean operators in every combination of truth values (example 3)',
        cypher='UNWIND [true, false, null] AS a\n      UNWIND [true, false, null] AS b\n      UNWIND [[], [true], [false], [null], [true, false], [true, false, null]] AS c\n      WITH collect((a AND b IN c) = (a AND (b IN c))) AS eq,\n           collect((a AND b IN c) <> ((a AND b) IN c)) AS neq\n      RETURN all(x IN eq WHERE x) AND any(x IN neq WHERE x) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence2-1-1',
        feature_path='tck/features/expressions/precedence/Precedence2.feature',
        scenario='[1] Numeric multiplicative operations takes precedence over numeric additive operations (example 1)',
        cypher='RETURN 4 * 2 + 3 * 2 AS a,\n             4 * 2 + (3 * 2) AS b,\n             4 * (2 + 3) * 2 AS c',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'a': 14, 'b': 14, 'c': 40}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence2-1-2',
        feature_path='tck/features/expressions/precedence/Precedence2.feature',
        scenario='[1] Numeric multiplicative operations takes precedence over numeric additive operations (example 2)',
        cypher='RETURN 4 * 2 + 3 / 2 AS a,\n             4 * 2 + (3 / 2) AS b,\n             4 * (2 + 3) / 2 AS c',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'a': 9, 'b': 9, 'c': 10}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence2-1-3',
        feature_path='tck/features/expressions/precedence/Precedence2.feature',
        scenario='[1] Numeric multiplicative operations takes precedence over numeric additive operations (example 3)',
        cypher='RETURN 4 * 2 + 3 % 2 AS a,\n             4 * 2 + (3 % 2) AS b,\n             4 * (2 + 3) % 2 AS c',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'a': 9, 'b': 9, 'c': 0}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence2-1-4',
        feature_path='tck/features/expressions/precedence/Precedence2.feature',
        scenario='[1] Numeric multiplicative operations takes precedence over numeric additive operations (example 4)',
        cypher='RETURN 4 * 2 - 3 * 2 AS a,\n             4 * 2 - (3 * 2) AS b,\n             4 * (2 - 3) * 2 AS c',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'a': 2, 'b': 2, 'c': -8}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence2-1-5',
        feature_path='tck/features/expressions/precedence/Precedence2.feature',
        scenario='[1] Numeric multiplicative operations takes precedence over numeric additive operations (example 5)',
        cypher='RETURN 4 * 2 - 3 / 2 AS a,\n             4 * 2 - (3 / 2) AS b,\n             4 * (2 - 3) / 2 AS c',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'a': 7, 'b': 7, 'c': -2}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence2-1-6',
        feature_path='tck/features/expressions/precedence/Precedence2.feature',
        scenario='[1] Numeric multiplicative operations takes precedence over numeric additive operations (example 6)',
        cypher='RETURN 4 * 2 - 3 % 2 AS a,\n             4 * 2 - (3 % 2) AS b,\n             4 * (2 - 3) % 2 AS c',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'a': 7, 'b': 7, 'c': 0}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence2-1-7',
        feature_path='tck/features/expressions/precedence/Precedence2.feature',
        scenario='[1] Numeric multiplicative operations takes precedence over numeric additive operations (example 7)',
        cypher='RETURN 4 / 2 + 3 * 2 AS a,\n             4 / 2 + (3 * 2) AS b,\n             4 / (2 + 3) * 2 AS c',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'a': 8, 'b': 8, 'c': 0}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence2-1-8',
        feature_path='tck/features/expressions/precedence/Precedence2.feature',
        scenario='[1] Numeric multiplicative operations takes precedence over numeric additive operations (example 8)',
        cypher='RETURN 4 / 2 + 3 / 2 AS a,\n             4 / 2 + (3 / 2) AS b,\n             4 / (2 + 3) / 2 AS c',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'a': 3, 'b': 3, 'c': 0}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence2-1-9',
        feature_path='tck/features/expressions/precedence/Precedence2.feature',
        scenario='[1] Numeric multiplicative operations takes precedence over numeric additive operations (example 9)',
        cypher='RETURN 4 / 2 + 3 % 2 AS a,\n             4 / 2 + (3 % 2) AS b,\n             4 / (2 + 3) % 2 AS c',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'a': 3, 'b': 3, 'c': 0}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence2-1-10',
        feature_path='tck/features/expressions/precedence/Precedence2.feature',
        scenario='[1] Numeric multiplicative operations takes precedence over numeric additive operations (example 10)',
        cypher='RETURN 4 / 2 - 3 * 2 AS a,\n             4 / 2 - (3 * 2) AS b,\n             4 / (2 - 3) * 2 AS c',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'a': -4, 'b': -4, 'c': -8}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence2-1-11',
        feature_path='tck/features/expressions/precedence/Precedence2.feature',
        scenario='[1] Numeric multiplicative operations takes precedence over numeric additive operations (example 11)',
        cypher='RETURN 4 / 2 - 3 / 2 AS a,\n             4 / 2 - (3 / 2) AS b,\n             4 / (2 - 3) / 2 AS c',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'a': 1, 'b': 1, 'c': -2}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence2-1-12',
        feature_path='tck/features/expressions/precedence/Precedence2.feature',
        scenario='[1] Numeric multiplicative operations takes precedence over numeric additive operations (example 12)',
        cypher='RETURN 4 / 2 - 3 % 2 AS a,\n             4 / 2 - (3 % 2) AS b,\n             4 / (2 - 3) % 2 AS c',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'a': 1, 'b': 1, 'c': 0}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence2-1-13',
        feature_path='tck/features/expressions/precedence/Precedence2.feature',
        scenario='[1] Numeric multiplicative operations takes precedence over numeric additive operations (example 13)',
        cypher='RETURN 4 % 2 + 3 * 2 AS a,\n             4 % 2 + (3 * 2) AS b,\n             4 % (2 + 3) * 2 AS c',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'a': 6, 'b': 6, 'c': 8}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence2-1-14',
        feature_path='tck/features/expressions/precedence/Precedence2.feature',
        scenario='[1] Numeric multiplicative operations takes precedence over numeric additive operations (example 14)',
        cypher='RETURN 4 % 2 + 3 / 2 AS a,\n             4 % 2 + (3 / 2) AS b,\n             4 % (2 + 3) / 2 AS c',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'a': 1, 'b': 1, 'c': 2}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence2-1-15',
        feature_path='tck/features/expressions/precedence/Precedence2.feature',
        scenario='[1] Numeric multiplicative operations takes precedence over numeric additive operations (example 15)',
        cypher='RETURN 4 % 2 + 3 % 2 AS a,\n             4 % 2 + (3 % 2) AS b,\n             4 % (2 + 3) % 2 AS c',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'a': 1, 'b': 1, 'c': 0}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence2-1-16',
        feature_path='tck/features/expressions/precedence/Precedence2.feature',
        scenario='[1] Numeric multiplicative operations takes precedence over numeric additive operations (example 16)',
        cypher='RETURN 4 % 2 - 3 * 2 AS a,\n             4 % 2 - (3 * 2) AS b,\n             4 % (2 - 3) * 2 AS c',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'a': -6, 'b': -6, 'c': 0}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence2-1-17',
        feature_path='tck/features/expressions/precedence/Precedence2.feature',
        scenario='[1] Numeric multiplicative operations takes precedence over numeric additive operations (example 17)',
        cypher='RETURN 4 % 2 - 3 / 2 AS a,\n             4 % 2 - (3 / 2) AS b,\n             4 % (2 - 3) / 2 AS c',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'a': -1, 'b': -1, 'c': 0}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence2-1-18',
        feature_path='tck/features/expressions/precedence/Precedence2.feature',
        scenario='[1] Numeric multiplicative operations takes precedence over numeric additive operations (example 18)',
        cypher='RETURN 4 % 2 - 3 % 2 AS a,\n             4 % 2 - (3 % 2) AS b,\n             4 % (2 - 3) % 2 AS c',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'a': -1, 'b': -1, 'c': 0}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence2-2-1',
        feature_path='tck/features/expressions/precedence/Precedence2.feature',
        scenario='[2] Exponentiation takes precedence over numeric multiplicative operations (example 1)',
        cypher='RETURN 4 ^ 3 * 2 ^ 3 AS a,\n             (4 ^ 3) * (2 ^ 3) AS b,\n             4 ^ (3 * 2) ^ 3 AS c',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'a': 512.0, 'b': 512.0, 'c': 68719476736.0}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence2-2-2',
        feature_path='tck/features/expressions/precedence/Precedence2.feature',
        scenario='[2] Exponentiation takes precedence over numeric multiplicative operations (example 2)',
        cypher='RETURN 4 ^ 3 / 2 ^ 3 AS a,\n             (4 ^ 3) / (2 ^ 3) AS b,\n             4 ^ (3 / 2) ^ 3 AS c',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'a': 8.0, 'b': 8.0, 'c': 64.0}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence2-2-3',
        feature_path='tck/features/expressions/precedence/Precedence2.feature',
        scenario='[2] Exponentiation takes precedence over numeric multiplicative operations (example 3)',
        cypher='RETURN 4 ^ 3 % 2 ^ 3 AS a,\n             (4 ^ 3) % (2 ^ 3) AS b,\n             4 ^ (3 % 2) ^ 3 AS c',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'a': 0.0, 'b': 0.0, 'c': 64.0}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence2-3-1',
        feature_path='tck/features/expressions/precedence/Precedence2.feature',
        scenario='[3] Exponentiation takes precedence over numeric additive operations (example 1)',
        cypher='RETURN 4 ^ 3 + 2 ^ 3 AS a,\n             (4 ^ 3) + (2 ^ 3) AS b,\n             4 ^ (3 + 2) ^ 3 AS c',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'a': 72.0, 'b': 72.0, 'c': 1073741824.0}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence2-3-2',
        feature_path='tck/features/expressions/precedence/Precedence2.feature',
        scenario='[3] Exponentiation takes precedence over numeric additive operations (example 2)',
        cypher='RETURN 4 ^ 3 - 2 ^ 3 AS a,\n             (4 ^ 3) - (2 ^ 3) AS b,\n             4 ^ (3 - 2) ^ 3 AS c',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'a': 56.0, 'b': 56.0, 'c': 64.0}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence2-4',
        feature_path='tck/features/expressions/precedence/Precedence2.feature',
        scenario='[4] Numeric unary negative takes precedence over exponentiation',
        cypher='RETURN -3 ^ 2 AS a,\n             (-3) ^ 2 AS b,\n             -(3 ^ 2) AS c',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'a': 9.0, 'b': 9.0, 'c': -9.0}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence2-5-1',
        feature_path='tck/features/expressions/precedence/Precedence2.feature',
        scenario='[5] Numeric unary negative takes precedence over numeric additive operations (example 1)',
        cypher='RETURN -3 + 2 AS a,\n             (-3) + 2 AS b,\n             -(3 + 2) AS c',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'a': -1, 'b': -1, 'c': -5}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence2-5-2',
        feature_path='tck/features/expressions/precedence/Precedence2.feature',
        scenario='[5] Numeric unary negative takes precedence over numeric additive operations (example 2)',
        cypher='RETURN -3 - 2 AS a,\n             (-3) - 2 AS b,\n             -(3 - 2) AS c',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'a': -5, 'b': -5, 'c': -1}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence3-1',
        feature_path='tck/features/expressions/precedence/Precedence3.feature',
        scenario='[1] List element access takes precedence over list appending',
        cypher='RETURN [[1], [2, 3], [4, 5]] + [5, [6, 7], [8, 9], 10][3] AS a,\n             [[1], [2, 3], [4, 5]] + ([5, [6, 7], [8, 9], 10][3]) AS b,\n             ([[1], [2, 3], [4, 5]] + [5, [6, 7], [8, 9], 10])[3] AS c',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'a': '[[1], [2, 3], [4, 5], 10]', 'b': '[[1], [2, 3], [4, 5], 10]', 'c': 5}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence3-2',
        feature_path='tck/features/expressions/precedence/Precedence3.feature',
        scenario='[2] List element access takes precedence over list concatenation',
        cypher='RETURN [[1], [2, 3], [4, 5]] + [5, [6, 7], [8, 9], 10][2] AS a,\n             [[1], [2, 3], [4, 5]] + ([5, [6, 7], [8, 9], 10][2]) AS b,\n             ([[1], [2, 3], [4, 5]] + [5, [6, 7], [8, 9], 10])[2] AS c',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'a': '[[1], [2, 3], [4, 5], 8, 9]', 'b': '[[1], [2, 3], [4, 5], 8, 9]', 'c': '[4, 5]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence3-3',
        feature_path='tck/features/expressions/precedence/Precedence3.feature',
        scenario='[3] List slicing takes precedence over list concatenation',
        cypher='RETURN [[1], [2, 3], [4, 5]] + [5, [6, 7], [8, 9], 10][1..3] AS a,\n             [[1], [2, 3], [4, 5]] + ([5, [6, 7], [8, 9], 10][1..3]) AS b,\n             ([[1], [2, 3], [4, 5]] + [5, [6, 7], [8, 9], 10])[1..3] AS c',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'a': '[[1], [2, 3], [4, 5], [6, 7], [8, 9]]', 'b': '[[1], [2, 3], [4, 5], [6, 7], [8, 9]]', 'c': '[[2, 3], [4, 5]]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence3-4',
        feature_path='tck/features/expressions/precedence/Precedence3.feature',
        scenario='[4] List appending takes precedence over list element containment',
        cypher='RETURN [1]+2 IN [3]+4 AS a,\n             ([1]+2) IN ([3]+4) AS b,\n             [1]+(2 IN [3])+4 AS c',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'a': 'false', 'b': 'false', 'c': '[1, false, 4]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence3-5',
        feature_path='tck/features/expressions/precedence/Precedence3.feature',
        scenario='[5] List concatenation takes precedence over list element containment',
        cypher='RETURN [1]+[2] IN [3]+[4] AS a,\n             ([1]+[2]) IN ([3]+[4]) AS b,\n             (([1]+[2]) IN [3])+[4] AS c,\n             [1]+([2] IN [3])+[4] AS d',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'a': 'false', 'b': 'false', 'c': '[false, 4]', 'd': '[1, false, 4]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence3-6-1',
        feature_path='tck/features/expressions/precedence/Precedence3.feature',
        scenario='[6] List element containment takes precedence over comparison operator (example 1)',
        cypher='RETURN [1, 2] = [3, 4] IN [[3, 4], false] AS a,\n             [1, 2] = ([3, 4] IN [[3, 4], false]) AS b,\n             ([1, 2] = [3, 4]) IN [[3, 4], false] AS c',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'a': 'false', 'b': 'false', 'c': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence3-6-2',
        feature_path='tck/features/expressions/precedence/Precedence3.feature',
        scenario='[6] List element containment takes precedence over comparison operator (example 2)',
        cypher='RETURN [1, 2] <> [3, 4] IN [[3, 4], false] AS a,\n             [1, 2] <> ([3, 4] IN [[3, 4], false]) AS b,\n             ([1, 2] <> [3, 4]) IN [[3, 4], false] AS c',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'a': 'true', 'b': 'true', 'c': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence3-6-3',
        feature_path='tck/features/expressions/precedence/Precedence3.feature',
        scenario='[6] List element containment takes precedence over comparison operator (example 3)',
        cypher='RETURN [1, 2] < [3, 4] IN [[3, 4], false] AS a,\n             [1, 2] < ([3, 4] IN [[3, 4], false]) AS b,\n             ([1, 2] < [3, 4]) IN [[3, 4], false] AS c',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'a': 'null', 'b': 'null', 'c': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence3-6-4',
        feature_path='tck/features/expressions/precedence/Precedence3.feature',
        scenario='[6] List element containment takes precedence over comparison operator (example 4)',
        cypher='RETURN [1, 2] > [3, 4] IN [[3, 4], false] AS a,\n             [1, 2] > ([3, 4] IN [[3, 4], false]) AS b,\n             ([1, 2] > [3, 4]) IN [[3, 4], false] AS c',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'a': 'null', 'b': 'null', 'c': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence3-6-5',
        feature_path='tck/features/expressions/precedence/Precedence3.feature',
        scenario='[6] List element containment takes precedence over comparison operator (example 5)',
        cypher='RETURN [1, 2] <= [3, 4] IN [[3, 4], false] AS a,\n             [1, 2] <= ([3, 4] IN [[3, 4], false]) AS b,\n             ([1, 2] <= [3, 4]) IN [[3, 4], false] AS c',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'a': 'null', 'b': 'null', 'c': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence3-6-6',
        feature_path='tck/features/expressions/precedence/Precedence3.feature',
        scenario='[6] List element containment takes precedence over comparison operator (example 6)',
        cypher='RETURN [1, 2] >= [3, 4] IN [[3, 4], false] AS a,\n             [1, 2] >= ([3, 4] IN [[3, 4], false]) AS b,\n             ([1, 2] >= [3, 4]) IN [[3, 4], false] AS c',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'a': 'null', 'b': 'null', 'c': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence4-1-1',
        feature_path='tck/features/expressions/precedence/Precedence4.feature',
        scenario='[1] Null predicate takes precedence over comparison operator (example 1)',
        cypher='RETURN null IS NOT NULL = null IS NULL AS a,\n             (null IS NOT NULL) = (null IS NULL) AS b,\n             (null IS NOT NULL = null) IS NULL AS c',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'a': 'false', 'b': 'false', 'c': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence4-1-2',
        feature_path='tck/features/expressions/precedence/Precedence4.feature',
        scenario='[1] Null predicate takes precedence over comparison operator (example 2)',
        cypher='RETURN null IS NULL <> null IS NULL AS a,\n             (null IS NULL) <> (null IS NULL) AS b,\n             (null IS NULL <> null) IS NULL AS c',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'a': 'false', 'b': 'false', 'c': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence4-1-3',
        feature_path='tck/features/expressions/precedence/Precedence4.feature',
        scenario='[1] Null predicate takes precedence over comparison operator (example 3)',
        cypher='RETURN null IS NULL <> null IS NOT NULL AS a,\n             (null IS NULL) <> (null IS NOT NULL) AS b,\n             (null IS NULL <> null) IS NOT NULL AS c',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'a': 'true', 'b': 'true', 'c': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence4-2',
        feature_path='tck/features/expressions/precedence/Precedence4.feature',
        scenario='[2] Null predicate takes precedence over boolean negation',
        cypher='RETURN NOT null IS NULL AS a,\n             NOT (null IS NULL) AS b,\n             (NOT null) IS NULL AS c',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'a': 'false', 'b': 'false', 'c': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence4-3-1',
        feature_path='tck/features/expressions/precedence/Precedence4.feature',
        scenario='[3] Null predicate takes precedence over binary boolean operator (example 1)',
        cypher='RETURN null AND null IS NULL AS a,\n             null AND (null IS NULL) AS b,\n             (null AND null) IS NULL AS c',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'a': 'null', 'b': 'null', 'c': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence4-3-2',
        feature_path='tck/features/expressions/precedence/Precedence4.feature',
        scenario='[3] Null predicate takes precedence over binary boolean operator (example 2)',
        cypher='RETURN null AND true IS NULL AS a,\n             null AND (true IS NULL) AS b,\n             (null AND true) IS NULL AS c',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'a': 'false', 'b': 'false', 'c': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence4-3-3',
        feature_path='tck/features/expressions/precedence/Precedence4.feature',
        scenario='[3] Null predicate takes precedence over binary boolean operator (example 3)',
        cypher='RETURN false AND false IS NOT NULL AS a,\n             false AND (false IS NOT NULL) AS b,\n             (false AND false) IS NOT NULL AS c',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'a': 'false', 'b': 'false', 'c': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence4-3-4',
        feature_path='tck/features/expressions/precedence/Precedence4.feature',
        scenario='[3] Null predicate takes precedence over binary boolean operator (example 4)',
        cypher='RETURN null OR false IS NULL AS a,\n             null OR (false IS NULL) AS b,\n             (null OR false) IS NULL AS c',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'a': 'null', 'b': 'null', 'c': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence4-3-5',
        feature_path='tck/features/expressions/precedence/Precedence4.feature',
        scenario='[3] Null predicate takes precedence over binary boolean operator (example 5)',
        cypher='RETURN true OR null IS NULL AS a,\n             true OR (null IS NULL) AS b,\n             (true OR null) IS NULL AS c',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'a': 'true', 'b': 'true', 'c': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence4-3-6',
        feature_path='tck/features/expressions/precedence/Precedence4.feature',
        scenario='[3] Null predicate takes precedence over binary boolean operator (example 6)',
        cypher='RETURN true XOR null IS NOT NULL AS a,\n             true XOR (null IS NOT NULL) AS b,\n             (true XOR null) IS NOT NULL AS c',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'a': 'true', 'b': 'true', 'c': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence4-3-7',
        feature_path='tck/features/expressions/precedence/Precedence4.feature',
        scenario='[3] Null predicate takes precedence over binary boolean operator (example 7)',
        cypher='RETURN true XOR false IS NULL AS a,\n             true XOR (false IS NULL) AS b,\n             (true XOR false) IS NULL AS c',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'a': 'true', 'b': 'true', 'c': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-precedence4-4',
        feature_path='tck/features/expressions/precedence/Precedence4.feature',
        scenario='[4] String predicate takes precedence over binary boolean operator',
        cypher="RETURN ('abc' STARTS WITH null OR true) = (('abc' STARTS WITH null) OR true) AS a,\n             ('abc' STARTS WITH null OR true) <> ('abc' STARTS WITH (null OR true)) AS b,\n             (true OR null STARTS WITH 'abc') = (true OR (null STARTS WITH 'abc')) AS c,\n             (true OR null STARTS WITH 'abc') <> ((true OR null) STARTS WITH 'abc') AS d",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'a': 'true', 'b': 'null', 'c': 'true', 'd': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'precedence', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-1',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[1] None quantifier is always true on empty list',
        cypher='RETURN none(x IN [] WHERE true) AS a, none(x IN [] WHERE false) AS b, none(x IN [] WHERE x) AS c',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'a': 'true', 'b': 'true', 'c': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-2-1',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[2] None quantifier on list literal containing booleans (example 1)',
        cypher='RETURN none(x IN [] WHERE x) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-2-2',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[2] None quantifier on list literal containing booleans (example 2)',
        cypher='RETURN none(x IN [true] WHERE x) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-2-3',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[2] None quantifier on list literal containing booleans (example 3)',
        cypher='RETURN none(x IN [false] WHERE x) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-2-4',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[2] None quantifier on list literal containing booleans (example 4)',
        cypher='RETURN none(x IN [true, false] WHERE x) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-2-5',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[2] None quantifier on list literal containing booleans (example 5)',
        cypher='RETURN none(x IN [false, true] WHERE x) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-2-6',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[2] None quantifier on list literal containing booleans (example 6)',
        cypher='RETURN none(x IN [true, false, true] WHERE x) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-2-7',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[2] None quantifier on list literal containing booleans (example 7)',
        cypher='RETURN none(x IN [false, true, false] WHERE x) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-2-8',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[2] None quantifier on list literal containing booleans (example 8)',
        cypher='RETURN none(x IN [true, true, true] WHERE x) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-2-9',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[2] None quantifier on list literal containing booleans (example 9)',
        cypher='RETURN none(x IN [false, false, false] WHERE x) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-3-1',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[3] None quantifier on list literal containing integers (example 1)',
        cypher='RETURN none(x IN [] WHERE x = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-3-2',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[3] None quantifier on list literal containing integers (example 2)',
        cypher='RETURN none(x IN [1] WHERE x = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-3-3',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[3] None quantifier on list literal containing integers (example 3)',
        cypher='RETURN none(x IN [1, 3] WHERE x = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-3-4',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[3] None quantifier on list literal containing integers (example 4)',
        cypher='RETURN none(x IN [1, 3, 20, 5000] WHERE x = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-3-5',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[3] None quantifier on list literal containing integers (example 5)',
        cypher='RETURN none(x IN [20, 3, 5000, -2] WHERE x = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-3-6',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[3] None quantifier on list literal containing integers (example 6)',
        cypher='RETURN none(x IN [2] WHERE x = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-3-7',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[3] None quantifier on list literal containing integers (example 7)',
        cypher='RETURN none(x IN [1, 2] WHERE x = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-3-8',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[3] None quantifier on list literal containing integers (example 8)',
        cypher='RETURN none(x IN [1, 2, 3] WHERE x = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-3-9',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[3] None quantifier on list literal containing integers (example 9)',
        cypher='RETURN none(x IN [2, 2] WHERE x = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-3-10',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[3] None quantifier on list literal containing integers (example 10)',
        cypher='RETURN none(x IN [2, 3] WHERE x = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-3-11',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[3] None quantifier on list literal containing integers (example 11)',
        cypher='RETURN none(x IN [3, 2, 3] WHERE x = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-3-12',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[3] None quantifier on list literal containing integers (example 12)',
        cypher='RETURN none(x IN [2, 3, 2] WHERE x = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-3-13',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[3] None quantifier on list literal containing integers (example 13)',
        cypher='RETURN none(x IN [2, -10, 3, 9, 0] WHERE x < 10) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-3-14',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[3] None quantifier on list literal containing integers (example 14)',
        cypher='RETURN none(x IN [2, -10, 3, 2, 10] WHERE x < 10) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-3-15',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[3] None quantifier on list literal containing integers (example 15)',
        cypher='RETURN none(x IN [2, -10, 3, 21, 10] WHERE x < 10) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-3-16',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[3] None quantifier on list literal containing integers (example 16)',
        cypher='RETURN none(x IN [200, -10, 36, 21, 10] WHERE x < 10) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-3-17',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[3] None quantifier on list literal containing integers (example 17)',
        cypher='RETURN none(x IN [200, 15, 36, 21, 10] WHERE x < 10) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-4-1',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[4] None quantifier on list literal containing floats (example 1)',
        cypher='RETURN none(x IN [] WHERE x = 2.1) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-4-2',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[4] None quantifier on list literal containing floats (example 2)',
        cypher='RETURN none(x IN [1.1] WHERE x = 2.1) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-4-3',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[4] None quantifier on list literal containing floats (example 3)',
        cypher='RETURN none(x IN [1.1, 3.5] WHERE x = 2.1) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-4-4',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[4] None quantifier on list literal containing floats (example 4)',
        cypher='RETURN none(x IN [1.1, 3.5, 20.0, 50.42435] WHERE x = 2.1) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-4-5',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[4] None quantifier on list literal containing floats (example 5)',
        cypher='RETURN none(x IN [20.0, 3.4, 50.2, -2.1] WHERE x = 2.1) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-4-6',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[4] None quantifier on list literal containing floats (example 6)',
        cypher='RETURN none(x IN [2.1] WHERE x = 2.1) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-4-7',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[4] None quantifier on list literal containing floats (example 7)',
        cypher='RETURN none(x IN [1.43, 2.1] WHERE x = 2.1) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-4-8',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[4] None quantifier on list literal containing floats (example 8)',
        cypher='RETURN none(x IN [1.43, 2.1, 3.5] WHERE x = 2.1) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-4-9',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[4] None quantifier on list literal containing floats (example 9)',
        cypher='RETURN none(x IN [2.1, 2.1] WHERE x = 2.1) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-4-10',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[4] None quantifier on list literal containing floats (example 10)',
        cypher='RETURN none(x IN [2.1, 3.5] WHERE x = 2.1) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-4-11',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[4] None quantifier on list literal containing floats (example 11)',
        cypher='RETURN none(x IN [3.5, 2.1, 3.5] WHERE x = 2.1) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-4-12',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[4] None quantifier on list literal containing floats (example 12)',
        cypher='RETURN none(x IN [2.1, 3.5, 2.1] WHERE x = 2.1) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-5-1',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[5] None quantifier on list literal containing strings (example 1)',
        cypher='RETURN none(x IN [] WHERE size(x) = 3) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-5-2',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[5] None quantifier on list literal containing strings (example 2)',
        cypher="RETURN none(x IN ['abc'] WHERE size(x) = 3) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-5-3',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[5] None quantifier on list literal containing strings (example 3)',
        cypher="RETURN none(x IN ['ef'] WHERE size(x) = 3) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-5-4',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[5] None quantifier on list literal containing strings (example 4)',
        cypher="RETURN none(x IN ['abc', 'ef'] WHERE size(x) = 3) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-5-5',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[5] None quantifier on list literal containing strings (example 5)',
        cypher="RETURN none(x IN ['ef', 'abc'] WHERE size(x) = 3) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-5-6',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[5] None quantifier on list literal containing strings (example 6)',
        cypher="RETURN none(x IN ['abc', 'ef', 'abc'] WHERE size(x) = 3) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-5-7',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[5] None quantifier on list literal containing strings (example 7)',
        cypher="RETURN none(x IN ['ef', 'abc', 'ef'] WHERE size(x) = 3) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-5-8',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[5] None quantifier on list literal containing strings (example 8)',
        cypher="RETURN none(x IN ['abc', 'abc', 'abc'] WHERE size(x) = 3) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-5-9',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[5] None quantifier on list literal containing strings (example 9)',
        cypher="RETURN none(x IN ['ef', 'ef', 'ef'] WHERE size(x) = 3) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-6-1',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[6] None quantifier on list literal containing lists (example 1)',
        cypher='RETURN none(x IN [] WHERE size(x) = 3) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-6-2',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[6] None quantifier on list literal containing lists (example 2)',
        cypher='RETURN none(x IN [[1, 2, 3]] WHERE size(x) = 3) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-6-3',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[6] None quantifier on list literal containing lists (example 3)',
        cypher="RETURN none(x IN [['a']] WHERE size(x) = 3) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-6-4',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[6] None quantifier on list literal containing lists (example 4)',
        cypher="RETURN none(x IN [[1, 2, 3], ['a']] WHERE size(x) = 3) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-6-5',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[6] None quantifier on list literal containing lists (example 5)',
        cypher="RETURN none(x IN [['a'], [1, 2, 3]] WHERE size(x) = 3) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-6-6',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[6] None quantifier on list literal containing lists (example 6)',
        cypher="RETURN none(x IN [[1, 2, 3], ['a'], [1, 2, 3]] WHERE size(x) = 3) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-6-7',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[6] None quantifier on list literal containing lists (example 7)',
        cypher="RETURN none(x IN [['a'], [1, 2, 3], ['a']] WHERE size(x) = 3) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-6-8',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[6] None quantifier on list literal containing lists (example 8)',
        cypher='RETURN none(x IN [[1, 2, 3], [1, 2, 3], [1, 2, 3]] WHERE size(x) = 3) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-6-9',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[6] None quantifier on list literal containing lists (example 9)',
        cypher="RETURN none(x IN [['a'], ['a'], ['a']] WHERE size(x) = 3) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-7-1',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[7] None quantifier on list literal containing maps (example 1)',
        cypher='RETURN none(x IN [] WHERE x.a = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-7-2',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[7] None quantifier on list literal containing maps (example 2)',
        cypher='RETURN none(x IN [{a: 2, b: 5}] WHERE x.a = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-7-3',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[7] None quantifier on list literal containing maps (example 3)',
        cypher='RETURN none(x IN [{a: 4}] WHERE x.a = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-7-4',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[7] None quantifier on list literal containing maps (example 4)',
        cypher='RETURN none(x IN [{a: 2, b: 5}, {a: 4}] WHERE x.a = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-7-5',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[7] None quantifier on list literal containing maps (example 5)',
        cypher='RETURN none(x IN [{a: 4}, {a: 2, b: 5}] WHERE x.a = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-7-6',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[7] None quantifier on list literal containing maps (example 6)',
        cypher='RETURN none(x IN [{a: 2, b: 5}, {a: 4}, {a: 2, b: 5}] WHERE x.a = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-7-7',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[7] None quantifier on list literal containing maps (example 7)',
        cypher='RETURN none(x IN [{a: 4}, {a: 2, b: 5}, {a: 4}] WHERE x.a = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-7-8',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[7] None quantifier on list literal containing maps (example 8)',
        cypher='RETURN none(x IN [{a: 2, b: 5}, {a: 2, b: 5}, {a: 2, b: 5}] WHERE x.a = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-7-9',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[7] None quantifier on list literal containing maps (example 9)',
        cypher='RETURN none(x IN [{a: 4}, {a: 4}, {a: 4}] WHERE x.a = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-8',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[8] None quantifier on list containing nodes',
        cypher="MATCH p = (:SNodes)-[*0..3]->(x)\n      WITH tail(nodes(p)) AS nodes\n      RETURN nodes, none(x IN nodes WHERE x.name = 'a') AS result",
        graph=graph_fixture_from_create(
            """
            CREATE (s1:SRelationships), (s2:SNodes)
                  CREATE (a:A {name: 'a'}), (b:B {name: 'b'})
                  CREATE (aa:A {name: 'a'}), (ab:B {name: 'b'}),
                         (ba:A {name: 'a'}), (bb:B {name: 'b'})
                  CREATE (aaa:A {name: 'a'}), (aab:B {name: 'b'}),
                         (aba:A {name: 'a'}), (abb:B {name: 'b'}),
                         (baa:A {name: 'a'}), (bab:B {name: 'b'}),
                         (bba:A {name: 'a'}), (bbb:B {name: 'b'})
                  CREATE (s1)-[:I]->(s2),
                         (s2)-[:RA {name: 'a'}]->(a), (s2)-[:RB {name: 'b'}]->(b)
                  CREATE (a)-[:RA {name: 'a'}]->(aa), (a)-[:RB {name: 'b'}]->(ab),
                         (b)-[:RA {name: 'a'}]->(ba), (b)-[:RB {name: 'b'}]->(bb)
                  CREATE (aa)-[:RA {name: 'a'}]->(aaa), (aa)-[:RB {name: 'b'}]->(aab),
                         (ab)-[:RA {name: 'a'}]->(aba), (ab)-[:RB {name: 'b'}]->(abb),
                         (ba)-[:RA {name: 'a'}]->(baa), (ba)-[:RB {name: 'b'}]->(bab),
                         (bb)-[:RA {name: 'a'}]->(bba), (bb)-[:RB {name: 'b'}]->(bbb)
            """
        ),
        expected=Expected(
            rows=[
            {'nodes': '[]', 'result': 'true'},
            {'nodes': "[(:A {name: 'a'})]", 'result': 'false'},
            {'nodes': "[(:A {name: 'a'}), (:A {name: 'a'})]", 'result': 'false'},
            {'nodes': "[(:A {name: 'a'}), (:A {name: 'a'}), (:A {name: 'a'})]", 'result': 'false'},
            {'nodes': "[(:A {name: 'a'}), (:A {name: 'a'}), (:B {name: 'b'})]", 'result': 'false'},
            {'nodes': "[(:A {name: 'a'}), (:B {name: 'b'})]", 'result': 'false'},
            {'nodes': "[(:A {name: 'a'}), (:B {name: 'b'}), (:A {name: 'a'})]", 'result': 'false'},
            {'nodes': "[(:A {name: 'a'}), (:B {name: 'b'}), (:B {name: 'b'})]", 'result': 'false'},
            {'nodes': "[(:B {name: 'b'})]", 'result': 'true'},
            {'nodes': "[(:B {name: 'b'}), (:A {name: 'a'})]", 'result': 'false'},
            {'nodes': "[(:B {name: 'b'}), (:A {name: 'a'}), (:A {name: 'a'})]", 'result': 'false'},
            {'nodes': "[(:B {name: 'b'}), (:A {name: 'a'}), (:B {name: 'b'})]", 'result': 'false'},
            {'nodes': "[(:B {name: 'b'}), (:B {name: 'b'})]", 'result': 'true'},
            {'nodes': "[(:B {name: 'b'}), (:B {name: 'b'}), (:A {name: 'a'})]", 'result': 'false'},
            {'nodes': "[(:B {name: 'b'}), (:B {name: 'b'}), (:B {name: 'b'})]", 'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-9',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[9] None quantifier on list containing relationships',
        cypher="MATCH p = (:SRelationships)-[*0..4]->(x)\n      WITH tail(relationships(p)) AS relationships, COUNT(*) AS c\n      RETURN relationships, none(x IN relationships WHERE x.name = 'a') AS result",
        graph=graph_fixture_from_create(
            """
            CREATE (s1:SRelationships), (s2:SNodes)
                  CREATE (a:A {name: 'a'}), (b:B {name: 'b'})
                  CREATE (aa:A {name: 'a'}), (ab:B {name: 'b'}),
                         (ba:A {name: 'a'}), (bb:B {name: 'b'})
                  CREATE (aaa:A {name: 'a'}), (aab:B {name: 'b'}),
                         (aba:A {name: 'a'}), (abb:B {name: 'b'}),
                         (baa:A {name: 'a'}), (bab:B {name: 'b'}),
                         (bba:A {name: 'a'}), (bbb:B {name: 'b'})
                  CREATE (s1)-[:I]->(s2),
                         (s2)-[:RA {name: 'a'}]->(a), (s2)-[:RB {name: 'b'}]->(b)
                  CREATE (a)-[:RA {name: 'a'}]->(aa), (a)-[:RB {name: 'b'}]->(ab),
                         (b)-[:RA {name: 'a'}]->(ba), (b)-[:RB {name: 'b'}]->(bb)
                  CREATE (aa)-[:RA {name: 'a'}]->(aaa), (aa)-[:RB {name: 'b'}]->(aab),
                         (ab)-[:RA {name: 'a'}]->(aba), (ab)-[:RB {name: 'b'}]->(abb),
                         (ba)-[:RA {name: 'a'}]->(baa), (ba)-[:RB {name: 'b'}]->(bab),
                         (bb)-[:RA {name: 'a'}]->(bba), (bb)-[:RB {name: 'b'}]->(bbb)
            """
        ),
        expected=Expected(
            rows=[
            {'relationships': '[]', 'result': 'true'},
            {'relationships': "[[:RA {name: 'a'}]]", 'result': 'false'},
            {'relationships': "[[:RA {name: 'a'}], [:RA {name: 'a'}]]", 'result': 'false'},
            {'relationships': "[[:RA {name: 'a'}], [:RA {name: 'a'}], [:RA {name: 'a'}]]", 'result': 'false'},
            {'relationships': "[[:RA {name: 'a'}], [:RA {name: 'a'}], [:RB {name: 'b'}]]", 'result': 'false'},
            {'relationships': "[[:RA {name: 'a'}], [:RB {name: 'b'}]]", 'result': 'false'},
            {'relationships': "[[:RA {name: 'a'}], [:RB {name: 'b'}], [:RA {name: 'a'}]]", 'result': 'false'},
            {'relationships': "[[:RA {name: 'a'}], [:RB {name: 'b'}], [:RB {name: 'b'}]]", 'result': 'false'},
            {'relationships': "[[:RB {name: 'b'}]]", 'result': 'true'},
            {'relationships': "[[:RB {name: 'b'}], [:RA {name: 'a'}]]", 'result': 'false'},
            {'relationships': "[[:RB {name: 'b'}], [:RA {name: 'a'}], [:RA {name: 'a'}]]", 'result': 'false'},
            {'relationships': "[[:RB {name: 'b'}], [:RA {name: 'a'}], [:RB {name: 'b'}]]", 'result': 'false'},
            {'relationships': "[[:RB {name: 'b'}], [:RB {name: 'b'}]]", 'result': 'true'},
            {'relationships': "[[:RB {name: 'b'}], [:RB {name: 'b'}], [:RA {name: 'a'}]]", 'result': 'false'},
            {'relationships': "[[:RB {name: 'b'}], [:RB {name: 'b'}], [:RB {name: 'b'}]]", 'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-10-1',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[10] None quantifier on lists containing nulls (example 1)',
        cypher='RETURN none(x IN [null] WHERE x = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-10-2',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[10] None quantifier on lists containing nulls (example 2)',
        cypher='RETURN none(x IN [null, null] WHERE x = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-10-3',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[10] None quantifier on lists containing nulls (example 3)',
        cypher='RETURN none(x IN [0, null] WHERE x = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-10-4',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[10] None quantifier on lists containing nulls (example 4)',
        cypher='RETURN none(x IN [2, null] WHERE x = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-10-5',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[10] None quantifier on lists containing nulls (example 5)',
        cypher='RETURN none(x IN [null, 2] WHERE x = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-10-6',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[10] None quantifier on lists containing nulls (example 6)',
        cypher='RETURN none(x IN [34, 0, null, 5, 900] WHERE x < 10) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-10-7',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[10] None quantifier on lists containing nulls (example 7)',
        cypher='RETURN none(x IN [34, 10, null, 15, 900] WHERE x < 10) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-10-8',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[10] None quantifier on lists containing nulls (example 8)',
        cypher='RETURN none(x IN [4, 0, null, -15, 9] WHERE x < 10) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-11-1',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[11] None quantifier with IS NULL predicate (example 1)',
        cypher='RETURN none(x IN [] WHERE x IS NULL) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-11-2',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[11] None quantifier with IS NULL predicate (example 2)',
        cypher='RETURN none(x IN [0] WHERE x IS NULL) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-11-3',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[11] None quantifier with IS NULL predicate (example 3)',
        cypher='RETURN none(x IN [34, 0, 8, 900] WHERE x IS NULL) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-11-4',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[11] None quantifier with IS NULL predicate (example 4)',
        cypher='RETURN none(x IN [null] WHERE x IS NULL) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-11-5',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[11] None quantifier with IS NULL predicate (example 5)',
        cypher='RETURN none(x IN [null, null] WHERE x IS NULL) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-11-6',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[11] None quantifier with IS NULL predicate (example 6)',
        cypher='RETURN none(x IN [0, null] WHERE x IS NULL) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-11-7',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[11] None quantifier with IS NULL predicate (example 7)',
        cypher='RETURN none(x IN [2, null] WHERE x IS NULL) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-11-8',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[11] None quantifier with IS NULL predicate (example 8)',
        cypher='RETURN none(x IN [null, 2] WHERE x IS NULL) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-11-9',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[11] None quantifier with IS NULL predicate (example 9)',
        cypher='RETURN none(x IN [34, 0, null, 8, 900] WHERE x IS NULL) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-11-10',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[11] None quantifier with IS NULL predicate (example 10)',
        cypher='RETURN none(x IN [34, 0, null, 8, null] WHERE x IS NULL) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-11-11',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[11] None quantifier with IS NULL predicate (example 11)',
        cypher='RETURN none(x IN [null, 123, null, null] WHERE x IS NULL) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-11-12',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[11] None quantifier with IS NULL predicate (example 12)',
        cypher='RETURN none(x IN [null, null, null, null] WHERE x IS NULL) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-12-1',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[12] None quantifier with IS NOT NULL predicate (example 1)',
        cypher='RETURN none(x IN [] WHERE x IS NOT NULL) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-12-2',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[12] None quantifier with IS NOT NULL predicate (example 2)',
        cypher='RETURN none(x IN [0] WHERE x IS NOT NULL) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-12-3',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[12] None quantifier with IS NOT NULL predicate (example 3)',
        cypher='RETURN none(x IN [34, 0, 8, 900] WHERE x IS NOT NULL) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-12-4',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[12] None quantifier with IS NOT NULL predicate (example 4)',
        cypher='RETURN none(x IN [null] WHERE x IS NOT NULL) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-12-5',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[12] None quantifier with IS NOT NULL predicate (example 5)',
        cypher='RETURN none(x IN [null, null] WHERE x IS NOT NULL) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-12-6',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[12] None quantifier with IS NOT NULL predicate (example 6)',
        cypher='RETURN none(x IN [0, null] WHERE x IS NOT NULL) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-12-7',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[12] None quantifier with IS NOT NULL predicate (example 7)',
        cypher='RETURN none(x IN [2, null] WHERE x IS NOT NULL) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-12-8',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[12] None quantifier with IS NOT NULL predicate (example 8)',
        cypher='RETURN none(x IN [null, 2] WHERE x IS NOT NULL) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-12-9',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[12] None quantifier with IS NOT NULL predicate (example 9)',
        cypher='RETURN none(x IN [34, 0, null, 8, 900] WHERE x IS NOT NULL) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-12-10',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[12] None quantifier with IS NOT NULL predicate (example 10)',
        cypher='RETURN none(x IN [34, 0, null, 8, null] WHERE x IS NOT NULL) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-12-11',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[12] None quantifier with IS NOT NULL predicate (example 11)',
        cypher='RETURN none(x IN [null, 123, null, null] WHERE x IS NOT NULL) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-12-12',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[12] None quantifier with IS NOT NULL predicate (example 12)',
        cypher='RETURN none(x IN [null, null, null, null] WHERE x IS NOT NULL) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-13',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[13] None quantifier is true if the predicate is statically false and the list is not empty',
        cypher="RETURN none(x IN [1, null, true, 4.5, 'abc', false] WHERE false) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-14',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[14] None quantifier is false if the predicate is statically true and the list is not empty',
        cypher="RETURN none(x IN [1, null, true, 4.5, 'abc', false] WHERE true) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-15-1',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[15] Fail none quantifier on type mismatch between list elements and predicate (example 1)',
        cypher="RETURN none(x IN ['Clara'] WHERE x % 2 = 0) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-15-2',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[15] Fail none quantifier on type mismatch between list elements and predicate (example 2)',
        cypher='RETURN none(x IN [false, true] WHERE x % 2 = 0) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier1-15-3',
        feature_path='tck/features/expressions/quantifier/Quantifier1.feature',
        scenario='[15] Fail none quantifier on type mismatch between list elements and predicate (example 3)',
        cypher="RETURN none(x IN ['Clara', 'Bob', 'Dave', 'Alice'] WHERE x % 2 = 0) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier10-1',
        feature_path='tck/features/expressions/quantifier/Quantifier10.feature',
        scenario='[1] Single quantifier is always false if the predicate is statically false and the list is not empty',
        cypher="WITH [1, null, true, 4.5, 'abc', false, '', [234, false], {a: null, b: true, c: 15.2}, {}, [], [null], [[{b: [null]}]]] AS inputList\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      WITH list WHERE size(list) > 0\n      WITH single(x IN list WHERE false) AS result, count(*) AS cnt\n      RETURN result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier10-2',
        feature_path='tck/features/expressions/quantifier/Quantifier10.feature',
        scenario='[2] Single quantifier is always false if the predicate is statically true and the list has more than one element',
        cypher="WITH [1, null, true, 4.5, 'abc', false, '', [234, false], {a: null, b: true, c: 15.2}, {}, [], [null], [[{b: [null]}]]] AS inputList\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      WITH list WHERE size(list) > 1\n      WITH single(x IN list WHERE true) AS result, count(*) AS cnt\n      RETURN result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier10-3',
        feature_path='tck/features/expressions/quantifier/Quantifier10.feature',
        scenario='[3] Single quantifier is always true if the predicate is statically true and the list has exactly one non-null element',
        cypher="WITH [1, true, 4.5, 'abc', false, '', [234, false], {a: null, b: true, c: 15.2}, {}, [], [null], [[{b: [null]}]]] AS inputList\n      UNWIND inputList AS element\n      WITH single(x IN [element] WHERE true) AS result, count(*) AS cnt\n      RETURN result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier10-4-1',
        feature_path='tck/features/expressions/quantifier/Quantifier10.feature',
        scenario='[4] Single quantifier is always equal whether the size of the list filtered with same the predicate is one (example 1)',
        cypher='UNWIND [{list: [2], fixed: true},\n              {list: [6], fixed: true},\n              {list: [7], fixed: true},\n              {list: [1, 2, 3, 4, 5, 6, 7, 8, 9], fixed: false}] AS input\n      WITH CASE WHEN input.fixed THEN input.list ELSE null END AS fixedList,\n           CASE WHEN NOT input.fixed THEN input.list ELSE [1] END AS inputList\n      UNWIND inputList AS x\n      WITH fixedList, inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH fixedList, inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH fixedList, inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH fixedList, inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH fixedList, inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH fixedList, inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      WITH coalesce(fixedList, list) AS list\n      WITH single(x IN list WHERE <predicate>) = (size([x IN list WHERE x = 2 | x]) = 1) AS result, count(*) AS cnt\n      RETURN result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier10-4-2',
        feature_path='tck/features/expressions/quantifier/Quantifier10.feature',
        scenario='[4] Single quantifier is always equal whether the size of the list filtered with same the predicate is one (example 2)',
        cypher='UNWIND [{list: [2], fixed: true},\n              {list: [6], fixed: true},\n              {list: [7], fixed: true},\n              {list: [1, 2, 3, 4, 5, 6, 7, 8, 9], fixed: false}] AS input\n      WITH CASE WHEN input.fixed THEN input.list ELSE null END AS fixedList,\n           CASE WHEN NOT input.fixed THEN input.list ELSE [1] END AS inputList\n      UNWIND inputList AS x\n      WITH fixedList, inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH fixedList, inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH fixedList, inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH fixedList, inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH fixedList, inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH fixedList, inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      WITH coalesce(fixedList, list) AS list\n      WITH single(x IN list WHERE <predicate>) = (size([x IN list WHERE x % 2 = 0 | x]) = 1) AS result, count(*) AS cnt\n      RETURN result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier10-4-3',
        feature_path='tck/features/expressions/quantifier/Quantifier10.feature',
        scenario='[4] Single quantifier is always equal whether the size of the list filtered with same the predicate is one (example 3)',
        cypher='UNWIND [{list: [2], fixed: true},\n              {list: [6], fixed: true},\n              {list: [7], fixed: true},\n              {list: [1, 2, 3, 4, 5, 6, 7, 8, 9], fixed: false}] AS input\n      WITH CASE WHEN input.fixed THEN input.list ELSE null END AS fixedList,\n           CASE WHEN NOT input.fixed THEN input.list ELSE [1] END AS inputList\n      UNWIND inputList AS x\n      WITH fixedList, inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH fixedList, inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH fixedList, inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH fixedList, inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH fixedList, inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH fixedList, inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      WITH coalesce(fixedList, list) AS list\n      WITH single(x IN list WHERE <predicate>) = (size([x IN list WHERE x % 3 = 0 | x]) = 1) AS result, count(*) AS cnt\n      RETURN result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier10-4-4',
        feature_path='tck/features/expressions/quantifier/Quantifier10.feature',
        scenario='[4] Single quantifier is always equal whether the size of the list filtered with same the predicate is one (example 4)',
        cypher='UNWIND [{list: [2], fixed: true},\n              {list: [6], fixed: true},\n              {list: [7], fixed: true},\n              {list: [1, 2, 3, 4, 5, 6, 7, 8, 9], fixed: false}] AS input\n      WITH CASE WHEN input.fixed THEN input.list ELSE null END AS fixedList,\n           CASE WHEN NOT input.fixed THEN input.list ELSE [1] END AS inputList\n      UNWIND inputList AS x\n      WITH fixedList, inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH fixedList, inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH fixedList, inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH fixedList, inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH fixedList, inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH fixedList, inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      WITH coalesce(fixedList, list) AS list\n      WITH single(x IN list WHERE <predicate>) = (size([x IN list WHERE x < 7 | x]) = 1) AS result, count(*) AS cnt\n      RETURN result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier10-4-5',
        feature_path='tck/features/expressions/quantifier/Quantifier10.feature',
        scenario='[4] Single quantifier is always equal whether the size of the list filtered with same the predicate is one (example 5)',
        cypher='UNWIND [{list: [2], fixed: true},\n              {list: [6], fixed: true},\n              {list: [7], fixed: true},\n              {list: [1, 2, 3, 4, 5, 6, 7, 8, 9], fixed: false}] AS input\n      WITH CASE WHEN input.fixed THEN input.list ELSE null END AS fixedList,\n           CASE WHEN NOT input.fixed THEN input.list ELSE [1] END AS inputList\n      UNWIND inputList AS x\n      WITH fixedList, inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH fixedList, inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH fixedList, inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH fixedList, inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH fixedList, inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH fixedList, inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      WITH coalesce(fixedList, list) AS list\n      WITH single(x IN list WHERE <predicate>) = (size([x IN list WHERE x >= 3 | x]) = 1) AS result, count(*) AS cnt\n      RETURN result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier11-1',
        feature_path='tck/features/expressions/quantifier/Quantifier11.feature',
        scenario='[1] Any quantifier is always false if the predicate is statically false and the list is not empty',
        cypher="WITH [1, null, true, 4.5, 'abc', false, '', [234, false], {a: null, b: true, c: 15.2}, {}, [], [null], [[{b: [null]}]]] AS inputList\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      WITH list WHERE size(list) > 0\n      WITH any(x IN list WHERE false) AS result, count(*) AS cnt\n      RETURN result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier11-2',
        feature_path='tck/features/expressions/quantifier/Quantifier11.feature',
        scenario='[2] Any quantifier is always true if the predicate is statically true and the list is not empty',
        cypher="WITH [1, null, true, 4.5, 'abc', false, '', [234, false], {a: null, b: true, c: 15.2}, {}, [], [null], [[{b: [null]}]]] AS inputList\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      WITH list WHERE size(list) > 0\n      WITH any(x IN list WHERE true) AS result, count(*) AS cnt\n      RETURN result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier11-3-1',
        feature_path='tck/features/expressions/quantifier/Quantifier11.feature',
        scenario='[3] Any quantifier is always true if the single or the all quantifier is true (example 1)',
        cypher='UNWIND [{list: [2], fixed: true},\n              {list: [6], fixed: true},\n              {list: [1, 2, 3, 4, 5, 6, 7, 8, 9], fixed: false}] AS input\n      WITH CASE WHEN input.fixed THEN input.list ELSE null END AS fixedList,\n           CASE WHEN NOT input.fixed THEN input.list ELSE [1] END AS inputList\n      UNWIND inputList AS x\n      WITH fixedList, inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH fixedList, inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH fixedList, inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH fixedList, inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH fixedList, inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH fixedList, inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      WITH coalesce(fixedList, list) AS list\n      WITH list WHERE single(<operands>) OR all(x IN list WHERE x = 2)\n      WITH any(x IN list WHERE x = 2) AS result, count(*) AS cnt\n      RETURN result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier11-3-2',
        feature_path='tck/features/expressions/quantifier/Quantifier11.feature',
        scenario='[3] Any quantifier is always true if the single or the all quantifier is true (example 2)',
        cypher='UNWIND [{list: [2], fixed: true},\n              {list: [6], fixed: true},\n              {list: [1, 2, 3, 4, 5, 6, 7, 8, 9], fixed: false}] AS input\n      WITH CASE WHEN input.fixed THEN input.list ELSE null END AS fixedList,\n           CASE WHEN NOT input.fixed THEN input.list ELSE [1] END AS inputList\n      UNWIND inputList AS x\n      WITH fixedList, inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH fixedList, inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH fixedList, inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH fixedList, inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH fixedList, inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH fixedList, inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      WITH coalesce(fixedList, list) AS list\n      WITH list WHERE single(<operands>) OR all(x IN list WHERE x % 2 = 0)\n      WITH any(x IN list WHERE x % 2 = 0) AS result, count(*) AS cnt\n      RETURN result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier11-3-3',
        feature_path='tck/features/expressions/quantifier/Quantifier11.feature',
        scenario='[3] Any quantifier is always true if the single or the all quantifier is true (example 3)',
        cypher='UNWIND [{list: [2], fixed: true},\n              {list: [6], fixed: true},\n              {list: [1, 2, 3, 4, 5, 6, 7, 8, 9], fixed: false}] AS input\n      WITH CASE WHEN input.fixed THEN input.list ELSE null END AS fixedList,\n           CASE WHEN NOT input.fixed THEN input.list ELSE [1] END AS inputList\n      UNWIND inputList AS x\n      WITH fixedList, inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH fixedList, inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH fixedList, inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH fixedList, inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH fixedList, inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH fixedList, inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      WITH coalesce(fixedList, list) AS list\n      WITH list WHERE single(<operands>) OR all(x IN list WHERE x % 3 = 0)\n      WITH any(x IN list WHERE x % 3 = 0) AS result, count(*) AS cnt\n      RETURN result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier11-3-4',
        feature_path='tck/features/expressions/quantifier/Quantifier11.feature',
        scenario='[3] Any quantifier is always true if the single or the all quantifier is true (example 4)',
        cypher='UNWIND [{list: [2], fixed: true},\n              {list: [6], fixed: true},\n              {list: [1, 2, 3, 4, 5, 6, 7, 8, 9], fixed: false}] AS input\n      WITH CASE WHEN input.fixed THEN input.list ELSE null END AS fixedList,\n           CASE WHEN NOT input.fixed THEN input.list ELSE [1] END AS inputList\n      UNWIND inputList AS x\n      WITH fixedList, inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH fixedList, inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH fixedList, inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH fixedList, inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH fixedList, inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH fixedList, inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      WITH coalesce(fixedList, list) AS list\n      WITH list WHERE single(<operands>) OR all(x IN list WHERE x < 7)\n      WITH any(x IN list WHERE x < 7) AS result, count(*) AS cnt\n      RETURN result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier11-3-5',
        feature_path='tck/features/expressions/quantifier/Quantifier11.feature',
        scenario='[3] Any quantifier is always true if the single or the all quantifier is true (example 5)',
        cypher='UNWIND [{list: [2], fixed: true},\n              {list: [6], fixed: true},\n              {list: [1, 2, 3, 4, 5, 6, 7, 8, 9], fixed: false}] AS input\n      WITH CASE WHEN input.fixed THEN input.list ELSE null END AS fixedList,\n           CASE WHEN NOT input.fixed THEN input.list ELSE [1] END AS inputList\n      UNWIND inputList AS x\n      WITH fixedList, inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH fixedList, inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH fixedList, inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH fixedList, inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH fixedList, inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH fixedList, inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      WITH coalesce(fixedList, list) AS list\n      WITH list WHERE single(<operands>) OR all(x IN list WHERE x >= 3)\n      WITH any(x IN list WHERE x >= 3) AS result, count(*) AS cnt\n      RETURN result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier11-4-1',
        feature_path='tck/features/expressions/quantifier/Quantifier11.feature',
        scenario='[4] Any quantifier is always equal the boolean negative of the none quantifier (example 1)',
        cypher='WITH [1, 2, 3, 4, 5, 6, 7, 8, 9] AS inputList\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      WITH any(x IN list WHERE <predicate>) = (NOT none(x IN list WHERE x = 2)) AS result, count(*) AS cnt\n      RETURN result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier11-4-2',
        feature_path='tck/features/expressions/quantifier/Quantifier11.feature',
        scenario='[4] Any quantifier is always equal the boolean negative of the none quantifier (example 2)',
        cypher='WITH [1, 2, 3, 4, 5, 6, 7, 8, 9] AS inputList\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      WITH any(x IN list WHERE <predicate>) = (NOT none(x IN list WHERE x % 2 = 0)) AS result, count(*) AS cnt\n      RETURN result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier11-4-3',
        feature_path='tck/features/expressions/quantifier/Quantifier11.feature',
        scenario='[4] Any quantifier is always equal the boolean negative of the none quantifier (example 3)',
        cypher='WITH [1, 2, 3, 4, 5, 6, 7, 8, 9] AS inputList\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      WITH any(x IN list WHERE <predicate>) = (NOT none(x IN list WHERE x % 3 = 0)) AS result, count(*) AS cnt\n      RETURN result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier11-4-4',
        feature_path='tck/features/expressions/quantifier/Quantifier11.feature',
        scenario='[4] Any quantifier is always equal the boolean negative of the none quantifier (example 4)',
        cypher='WITH [1, 2, 3, 4, 5, 6, 7, 8, 9] AS inputList\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      WITH any(x IN list WHERE <predicate>) = (NOT none(x IN list WHERE x < 7)) AS result, count(*) AS cnt\n      RETURN result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier11-4-5',
        feature_path='tck/features/expressions/quantifier/Quantifier11.feature',
        scenario='[4] Any quantifier is always equal the boolean negative of the none quantifier (example 5)',
        cypher='WITH [1, 2, 3, 4, 5, 6, 7, 8, 9] AS inputList\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      WITH any(x IN list WHERE <predicate>) = (NOT none(x IN list WHERE x >= 3)) AS result, count(*) AS cnt\n      RETURN result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier11-5-1',
        feature_path='tck/features/expressions/quantifier/Quantifier11.feature',
        scenario='[5] Any quantifier is always equal the boolean negative of the all quantifier on the boolean negative of the predicate (example 1)',
        cypher='WITH [1, 2, 3, 4, 5, 6, 7, 8, 9] AS inputList\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      WITH any(x IN list WHERE <predicate>) = (NOT all(x IN list WHERE NOT (x = 2))) AS result, count(*) AS cnt\n      RETURN result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier11-5-2',
        feature_path='tck/features/expressions/quantifier/Quantifier11.feature',
        scenario='[5] Any quantifier is always equal the boolean negative of the all quantifier on the boolean negative of the predicate (example 2)',
        cypher='WITH [1, 2, 3, 4, 5, 6, 7, 8, 9] AS inputList\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      WITH any(x IN list WHERE <predicate>) = (NOT all(x IN list WHERE NOT (x % 2 = 0))) AS result, count(*) AS cnt\n      RETURN result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier11-5-3',
        feature_path='tck/features/expressions/quantifier/Quantifier11.feature',
        scenario='[5] Any quantifier is always equal the boolean negative of the all quantifier on the boolean negative of the predicate (example 3)',
        cypher='WITH [1, 2, 3, 4, 5, 6, 7, 8, 9] AS inputList\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      WITH any(x IN list WHERE <predicate>) = (NOT all(x IN list WHERE NOT (x % 3 = 0))) AS result, count(*) AS cnt\n      RETURN result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier11-5-4',
        feature_path='tck/features/expressions/quantifier/Quantifier11.feature',
        scenario='[5] Any quantifier is always equal the boolean negative of the all quantifier on the boolean negative of the predicate (example 4)',
        cypher='WITH [1, 2, 3, 4, 5, 6, 7, 8, 9] AS inputList\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      WITH any(x IN list WHERE <predicate>) = (NOT all(x IN list WHERE NOT (x < 7))) AS result, count(*) AS cnt\n      RETURN result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier11-5-5',
        feature_path='tck/features/expressions/quantifier/Quantifier11.feature',
        scenario='[5] Any quantifier is always equal the boolean negative of the all quantifier on the boolean negative of the predicate (example 5)',
        cypher='WITH [1, 2, 3, 4, 5, 6, 7, 8, 9] AS inputList\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      WITH any(x IN list WHERE <predicate>) = (NOT all(x IN list WHERE NOT (x >= 3))) AS result, count(*) AS cnt\n      RETURN result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier11-6-1',
        feature_path='tck/features/expressions/quantifier/Quantifier11.feature',
        scenario='[6] Any quantifier is always equal whether the size of the list filtered with same the predicate is grater zero (example 1)',
        cypher='UNWIND [{list: [2], fixed: true},\n              {list: [6], fixed: true},\n              {list: [7], fixed: true},\n              {list: [1, 2, 3, 4, 5, 6, 7, 8, 9], fixed: false}] AS input\n      WITH CASE WHEN input.fixed THEN input.list ELSE null END AS fixedList,\n           CASE WHEN NOT input.fixed THEN input.list ELSE [1] END AS inputList\n      UNWIND inputList AS x\n      WITH fixedList, inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH fixedList, inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH fixedList, inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH fixedList, inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH fixedList, inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH fixedList, inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      WITH coalesce(fixedList, list) AS list\n      WITH any(x IN list WHERE <predicate>) = (size([x IN list WHERE x = 2 | x]) > 0) AS result, count(*) AS cnt\n      RETURN result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier11-6-2',
        feature_path='tck/features/expressions/quantifier/Quantifier11.feature',
        scenario='[6] Any quantifier is always equal whether the size of the list filtered with same the predicate is grater zero (example 2)',
        cypher='UNWIND [{list: [2], fixed: true},\n              {list: [6], fixed: true},\n              {list: [7], fixed: true},\n              {list: [1, 2, 3, 4, 5, 6, 7, 8, 9], fixed: false}] AS input\n      WITH CASE WHEN input.fixed THEN input.list ELSE null END AS fixedList,\n           CASE WHEN NOT input.fixed THEN input.list ELSE [1] END AS inputList\n      UNWIND inputList AS x\n      WITH fixedList, inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH fixedList, inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH fixedList, inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH fixedList, inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH fixedList, inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH fixedList, inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      WITH coalesce(fixedList, list) AS list\n      WITH any(x IN list WHERE <predicate>) = (size([x IN list WHERE x % 2 = 0 | x]) > 0) AS result, count(*) AS cnt\n      RETURN result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier11-6-3',
        feature_path='tck/features/expressions/quantifier/Quantifier11.feature',
        scenario='[6] Any quantifier is always equal whether the size of the list filtered with same the predicate is grater zero (example 3)',
        cypher='UNWIND [{list: [2], fixed: true},\n              {list: [6], fixed: true},\n              {list: [7], fixed: true},\n              {list: [1, 2, 3, 4, 5, 6, 7, 8, 9], fixed: false}] AS input\n      WITH CASE WHEN input.fixed THEN input.list ELSE null END AS fixedList,\n           CASE WHEN NOT input.fixed THEN input.list ELSE [1] END AS inputList\n      UNWIND inputList AS x\n      WITH fixedList, inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH fixedList, inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH fixedList, inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH fixedList, inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH fixedList, inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH fixedList, inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      WITH coalesce(fixedList, list) AS list\n      WITH any(x IN list WHERE <predicate>) = (size([x IN list WHERE x % 3 = 0 | x]) > 0) AS result, count(*) AS cnt\n      RETURN result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier11-6-4',
        feature_path='tck/features/expressions/quantifier/Quantifier11.feature',
        scenario='[6] Any quantifier is always equal whether the size of the list filtered with same the predicate is grater zero (example 4)',
        cypher='UNWIND [{list: [2], fixed: true},\n              {list: [6], fixed: true},\n              {list: [7], fixed: true},\n              {list: [1, 2, 3, 4, 5, 6, 7, 8, 9], fixed: false}] AS input\n      WITH CASE WHEN input.fixed THEN input.list ELSE null END AS fixedList,\n           CASE WHEN NOT input.fixed THEN input.list ELSE [1] END AS inputList\n      UNWIND inputList AS x\n      WITH fixedList, inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH fixedList, inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH fixedList, inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH fixedList, inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH fixedList, inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH fixedList, inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      WITH coalesce(fixedList, list) AS list\n      WITH any(x IN list WHERE <predicate>) = (size([x IN list WHERE x < 7 | x]) > 0) AS result, count(*) AS cnt\n      RETURN result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier11-6-5',
        feature_path='tck/features/expressions/quantifier/Quantifier11.feature',
        scenario='[6] Any quantifier is always equal whether the size of the list filtered with same the predicate is grater zero (example 5)',
        cypher='UNWIND [{list: [2], fixed: true},\n              {list: [6], fixed: true},\n              {list: [7], fixed: true},\n              {list: [1, 2, 3, 4, 5, 6, 7, 8, 9], fixed: false}] AS input\n      WITH CASE WHEN input.fixed THEN input.list ELSE null END AS fixedList,\n           CASE WHEN NOT input.fixed THEN input.list ELSE [1] END AS inputList\n      UNWIND inputList AS x\n      WITH fixedList, inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH fixedList, inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH fixedList, inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH fixedList, inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH fixedList, inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH fixedList, inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      WITH coalesce(fixedList, list) AS list\n      WITH any(x IN list WHERE <predicate>) = (size([x IN list WHERE x >= 3 | x]) > 0) AS result, count(*) AS cnt\n      RETURN result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier12-1',
        feature_path='tck/features/expressions/quantifier/Quantifier12.feature',
        scenario='[1] All quantifier is always false if the predicate is statically false and the list is not empty',
        cypher="WITH [1, null, true, 4.5, 'abc', false, '', [234, false], {a: null, b: true, c: 15.2}, {}, [], [null], [[{b: [null]}]]] AS inputList\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      WITH list WHERE size(list) > 0\n      WITH all(x IN list WHERE false) AS result, count(*) AS cnt\n      RETURN result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier12-2',
        feature_path='tck/features/expressions/quantifier/Quantifier12.feature',
        scenario='[2] All quantifier is always true if the predicate is statically true and the list is not empty',
        cypher="WITH [1, null, true, 4.5, 'abc', false, '', [234, false], {a: null, b: true, c: 15.2}, {}, [], [null], [[{b: [null]}]]] AS inputList\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      WITH list WHERE size(list) > 0\n      WITH all(x IN list WHERE true) AS result, count(*) AS cnt\n      RETURN result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier12-3-1',
        feature_path='tck/features/expressions/quantifier/Quantifier12.feature',
        scenario='[3] All quantifier is always equal the none quantifier on the boolean negative of the predicate (example 1)',
        cypher='WITH [1, 2, 3, 4, 5, 6, 7, 8, 9] AS inputList\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      WITH all(x IN list WHERE <predicate>) = none(x IN list WHERE NOT (x = 2)) AS result, count(*) AS cnt\n      RETURN result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier12-3-2',
        feature_path='tck/features/expressions/quantifier/Quantifier12.feature',
        scenario='[3] All quantifier is always equal the none quantifier on the boolean negative of the predicate (example 2)',
        cypher='WITH [1, 2, 3, 4, 5, 6, 7, 8, 9] AS inputList\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      WITH all(x IN list WHERE <predicate>) = none(x IN list WHERE NOT (x % 2 = 0)) AS result, count(*) AS cnt\n      RETURN result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier12-3-3',
        feature_path='tck/features/expressions/quantifier/Quantifier12.feature',
        scenario='[3] All quantifier is always equal the none quantifier on the boolean negative of the predicate (example 3)',
        cypher='WITH [1, 2, 3, 4, 5, 6, 7, 8, 9] AS inputList\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      WITH all(x IN list WHERE <predicate>) = none(x IN list WHERE NOT (x % 3 = 0)) AS result, count(*) AS cnt\n      RETURN result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier12-3-4',
        feature_path='tck/features/expressions/quantifier/Quantifier12.feature',
        scenario='[3] All quantifier is always equal the none quantifier on the boolean negative of the predicate (example 4)',
        cypher='WITH [1, 2, 3, 4, 5, 6, 7, 8, 9] AS inputList\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      WITH all(x IN list WHERE <predicate>) = none(x IN list WHERE NOT (x < 7)) AS result, count(*) AS cnt\n      RETURN result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier12-3-5',
        feature_path='tck/features/expressions/quantifier/Quantifier12.feature',
        scenario='[3] All quantifier is always equal the none quantifier on the boolean negative of the predicate (example 5)',
        cypher='WITH [1, 2, 3, 4, 5, 6, 7, 8, 9] AS inputList\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      WITH all(x IN list WHERE <predicate>) = none(x IN list WHERE NOT (x >= 3)) AS result, count(*) AS cnt\n      RETURN result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier12-4-1',
        feature_path='tck/features/expressions/quantifier/Quantifier12.feature',
        scenario='[4] All quantifier is always equal the boolean negative of the any quantifier on the boolean negative of the predicate (example 1)',
        cypher='WITH [1, 2, 3, 4, 5, 6, 7, 8, 9] AS inputList\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      WITH all(x IN list WHERE <predicate>) = (NOT any(x IN list WHERE NOT (x = 2))) AS result, count(*) AS cnt\n      RETURN result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier12-4-2',
        feature_path='tck/features/expressions/quantifier/Quantifier12.feature',
        scenario='[4] All quantifier is always equal the boolean negative of the any quantifier on the boolean negative of the predicate (example 2)',
        cypher='WITH [1, 2, 3, 4, 5, 6, 7, 8, 9] AS inputList\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      WITH all(x IN list WHERE <predicate>) = (NOT any(x IN list WHERE NOT (x % 2 = 0))) AS result, count(*) AS cnt\n      RETURN result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier12-4-3',
        feature_path='tck/features/expressions/quantifier/Quantifier12.feature',
        scenario='[4] All quantifier is always equal the boolean negative of the any quantifier on the boolean negative of the predicate (example 3)',
        cypher='WITH [1, 2, 3, 4, 5, 6, 7, 8, 9] AS inputList\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      WITH all(x IN list WHERE <predicate>) = (NOT any(x IN list WHERE NOT (x % 3 = 0))) AS result, count(*) AS cnt\n      RETURN result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier12-4-4',
        feature_path='tck/features/expressions/quantifier/Quantifier12.feature',
        scenario='[4] All quantifier is always equal the boolean negative of the any quantifier on the boolean negative of the predicate (example 4)',
        cypher='WITH [1, 2, 3, 4, 5, 6, 7, 8, 9] AS inputList\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      WITH all(x IN list WHERE <predicate>) = (NOT any(x IN list WHERE NOT (x < 7))) AS result, count(*) AS cnt\n      RETURN result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier12-4-5',
        feature_path='tck/features/expressions/quantifier/Quantifier12.feature',
        scenario='[4] All quantifier is always equal the boolean negative of the any quantifier on the boolean negative of the predicate (example 5)',
        cypher='WITH [1, 2, 3, 4, 5, 6, 7, 8, 9] AS inputList\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      WITH all(x IN list WHERE <predicate>) = (NOT any(x IN list WHERE NOT (x >= 3))) AS result, count(*) AS cnt\n      RETURN result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier12-5-1',
        feature_path='tck/features/expressions/quantifier/Quantifier12.feature',
        scenario='[5] All quantifier is always equal whether the size of the list filtered with same the predicate is equal the size of the unfiltered list (example 1)',
        cypher='UNWIND [{list: [2], fixed: true},\n              {list: [6], fixed: true},\n              {list: [7], fixed: true},\n              {list: [1, 2, 3, 4, 5, 6, 7, 8, 9], fixed: false}] AS input\n      WITH CASE WHEN input.fixed THEN input.list ELSE null END AS fixedList,\n           CASE WHEN NOT input.fixed THEN input.list ELSE [1] END AS inputList\n      UNWIND inputList AS x\n      WITH fixedList, inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH fixedList, inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH fixedList, inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH fixedList, inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH fixedList, inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH fixedList, inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      WITH coalesce(fixedList, list) AS list\n      WITH all(x IN list WHERE <predicate>) = (size([x IN list WHERE x = 2 | x]) = size(list)) AS result, count(*) AS cnt\n      RETURN result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier12-5-2',
        feature_path='tck/features/expressions/quantifier/Quantifier12.feature',
        scenario='[5] All quantifier is always equal whether the size of the list filtered with same the predicate is equal the size of the unfiltered list (example 2)',
        cypher='UNWIND [{list: [2], fixed: true},\n              {list: [6], fixed: true},\n              {list: [7], fixed: true},\n              {list: [1, 2, 3, 4, 5, 6, 7, 8, 9], fixed: false}] AS input\n      WITH CASE WHEN input.fixed THEN input.list ELSE null END AS fixedList,\n           CASE WHEN NOT input.fixed THEN input.list ELSE [1] END AS inputList\n      UNWIND inputList AS x\n      WITH fixedList, inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH fixedList, inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH fixedList, inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH fixedList, inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH fixedList, inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH fixedList, inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      WITH coalesce(fixedList, list) AS list\n      WITH all(x IN list WHERE <predicate>) = (size([x IN list WHERE x % 2 = 0 | x]) = size(list)) AS result, count(*) AS cnt\n      RETURN result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier12-5-3',
        feature_path='tck/features/expressions/quantifier/Quantifier12.feature',
        scenario='[5] All quantifier is always equal whether the size of the list filtered with same the predicate is equal the size of the unfiltered list (example 3)',
        cypher='UNWIND [{list: [2], fixed: true},\n              {list: [6], fixed: true},\n              {list: [7], fixed: true},\n              {list: [1, 2, 3, 4, 5, 6, 7, 8, 9], fixed: false}] AS input\n      WITH CASE WHEN input.fixed THEN input.list ELSE null END AS fixedList,\n           CASE WHEN NOT input.fixed THEN input.list ELSE [1] END AS inputList\n      UNWIND inputList AS x\n      WITH fixedList, inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH fixedList, inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH fixedList, inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH fixedList, inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH fixedList, inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH fixedList, inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      WITH coalesce(fixedList, list) AS list\n      WITH all(x IN list WHERE <predicate>) = (size([x IN list WHERE x % 3 = 0 | x]) = size(list)) AS result, count(*) AS cnt\n      RETURN result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier12-5-4',
        feature_path='tck/features/expressions/quantifier/Quantifier12.feature',
        scenario='[5] All quantifier is always equal whether the size of the list filtered with same the predicate is equal the size of the unfiltered list (example 4)',
        cypher='UNWIND [{list: [2], fixed: true},\n              {list: [6], fixed: true},\n              {list: [7], fixed: true},\n              {list: [1, 2, 3, 4, 5, 6, 7, 8, 9], fixed: false}] AS input\n      WITH CASE WHEN input.fixed THEN input.list ELSE null END AS fixedList,\n           CASE WHEN NOT input.fixed THEN input.list ELSE [1] END AS inputList\n      UNWIND inputList AS x\n      WITH fixedList, inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH fixedList, inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH fixedList, inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH fixedList, inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH fixedList, inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH fixedList, inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      WITH coalesce(fixedList, list) AS list\n      WITH all(x IN list WHERE <predicate>) = (size([x IN list WHERE x < 7 | x]) = size(list)) AS result, count(*) AS cnt\n      RETURN result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier12-5-5',
        feature_path='tck/features/expressions/quantifier/Quantifier12.feature',
        scenario='[5] All quantifier is always equal whether the size of the list filtered with same the predicate is equal the size of the unfiltered list (example 5)',
        cypher='UNWIND [{list: [2], fixed: true},\n              {list: [6], fixed: true},\n              {list: [7], fixed: true},\n              {list: [1, 2, 3, 4, 5, 6, 7, 8, 9], fixed: false}] AS input\n      WITH CASE WHEN input.fixed THEN input.list ELSE null END AS fixedList,\n           CASE WHEN NOT input.fixed THEN input.list ELSE [1] END AS inputList\n      UNWIND inputList AS x\n      WITH fixedList, inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH fixedList, inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH fixedList, inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH fixedList, inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH fixedList, inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH fixedList, inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      WITH coalesce(fixedList, list) AS list\n      WITH all(x IN list WHERE <predicate>) = (size([x IN list WHERE x >= 3 | x]) = size(list)) AS result, count(*) AS cnt\n      RETURN result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-1',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[1] Single quantifier is always false on empty list',
        cypher='RETURN single(x IN [] WHERE true) AS a, single(x IN [] WHERE false) AS b, single(x IN [] WHERE x) AS c',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'a': 'false', 'b': 'false', 'c': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-2-1',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[2] Single quantifier on list literal (example 1)',
        cypher='RETURN single(x IN [] WHERE x) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-2-2',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[2] Single quantifier on list literal (example 2)',
        cypher='RETURN single(x IN [true] WHERE x) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-2-3',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[2] Single quantifier on list literal (example 3)',
        cypher='RETURN single(x IN [false] WHERE x) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-2-4',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[2] Single quantifier on list literal (example 4)',
        cypher='RETURN single(x IN [true, false] WHERE x) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-2-5',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[2] Single quantifier on list literal (example 5)',
        cypher='RETURN single(x IN [false, true] WHERE x) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-2-6',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[2] Single quantifier on list literal (example 6)',
        cypher='RETURN single(x IN [true, false, true] WHERE x) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-2-7',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[2] Single quantifier on list literal (example 7)',
        cypher='RETURN single(x IN [false, true, false] WHERE x) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-2-8',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[2] Single quantifier on list literal (example 8)',
        cypher='RETURN single(x IN [true, true, true] WHERE x) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-2-9',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[2] Single quantifier on list literal (example 9)',
        cypher='RETURN single(x IN [false, false, false] WHERE x) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-3-1',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[3] Single quantifier on list literal containing integers (example 1)',
        cypher='RETURN single(x IN [] WHERE x = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-3-2',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[3] Single quantifier on list literal containing integers (example 2)',
        cypher='RETURN single(x IN [1] WHERE x = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-3-3',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[3] Single quantifier on list literal containing integers (example 3)',
        cypher='RETURN single(x IN [1, 3] WHERE x = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-3-4',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[3] Single quantifier on list literal containing integers (example 4)',
        cypher='RETURN single(x IN [1, 3, 20, 5000] WHERE x = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-3-5',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[3] Single quantifier on list literal containing integers (example 5)',
        cypher='RETURN single(x IN [20, 3, 5000, -2] WHERE x = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-3-6',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[3] Single quantifier on list literal containing integers (example 6)',
        cypher='RETURN single(x IN [2] WHERE x = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-3-7',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[3] Single quantifier on list literal containing integers (example 7)',
        cypher='RETURN single(x IN [1, 2] WHERE x = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-3-8',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[3] Single quantifier on list literal containing integers (example 8)',
        cypher='RETURN single(x IN [1, 2, 3] WHERE x = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-3-9',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[3] Single quantifier on list literal containing integers (example 9)',
        cypher='RETURN single(x IN [2, 2] WHERE x = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-3-10',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[3] Single quantifier on list literal containing integers (example 10)',
        cypher='RETURN single(x IN [2, 3] WHERE x = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-3-11',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[3] Single quantifier on list literal containing integers (example 11)',
        cypher='RETURN single(x IN [3, 2, 3] WHERE x = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-3-12',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[3] Single quantifier on list literal containing integers (example 12)',
        cypher='RETURN single(x IN [2, 3, 2] WHERE x = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-3-13',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[3] Single quantifier on list literal containing integers (example 13)',
        cypher='RETURN single(x IN [2, -10, 3, 9, 0] WHERE x < 10) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-3-14',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[3] Single quantifier on list literal containing integers (example 14)',
        cypher='RETURN single(x IN [2, -10, 3, 2, 10] WHERE x < 10) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-3-15',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[3] Single quantifier on list literal containing integers (example 15)',
        cypher='RETURN single(x IN [2, -10, 3, 21, 10] WHERE x < 10) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-3-16',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[3] Single quantifier on list literal containing integers (example 16)',
        cypher='RETURN single(x IN [200, -10, 36, 21, 10] WHERE x < 10) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-3-17',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[3] Single quantifier on list literal containing integers (example 17)',
        cypher='RETURN single(x IN [200, 15, 36, 21, 10] WHERE x < 10) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-4-1',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[4] Single quantifier on list literal containing floats (example 1)',
        cypher='RETURN single(x IN [] WHERE x = 2.1) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-4-2',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[4] Single quantifier on list literal containing floats (example 2)',
        cypher='RETURN single(x IN [1.1] WHERE x = 2.1) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-4-3',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[4] Single quantifier on list literal containing floats (example 3)',
        cypher='RETURN single(x IN [1.1, 3.5] WHERE x = 2.1) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-4-4',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[4] Single quantifier on list literal containing floats (example 4)',
        cypher='RETURN single(x IN [1.1, 3.5, 20.0, 50.42435] WHERE x = 2.1) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-4-5',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[4] Single quantifier on list literal containing floats (example 5)',
        cypher='RETURN single(x IN [20.0, 3.4, 50.2, -2.1] WHERE x = 2.1) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-4-6',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[4] Single quantifier on list literal containing floats (example 6)',
        cypher='RETURN single(x IN [2.1] WHERE x = 2.1) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-4-7',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[4] Single quantifier on list literal containing floats (example 7)',
        cypher='RETURN single(x IN [1.43, 2.1] WHERE x = 2.1) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-4-8',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[4] Single quantifier on list literal containing floats (example 8)',
        cypher='RETURN single(x IN [1.43, 2.1, 3.5] WHERE x = 2.1) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-4-9',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[4] Single quantifier on list literal containing floats (example 9)',
        cypher='RETURN single(x IN [2.1, 2.1] WHERE x = 2.1) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-4-10',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[4] Single quantifier on list literal containing floats (example 10)',
        cypher='RETURN single(x IN [2.1, 3.5] WHERE x = 2.1) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-4-11',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[4] Single quantifier on list literal containing floats (example 11)',
        cypher='RETURN single(x IN [3.5, 2.1, 3.5] WHERE x = 2.1) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-4-12',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[4] Single quantifier on list literal containing floats (example 12)',
        cypher='RETURN single(x IN [2.1, 3.5, 2.1] WHERE x = 2.1) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-5-1',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[5] Single quantifier on list literal containing strings (example 1)',
        cypher='RETURN single(x IN [] WHERE size(x) = 3) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-5-2',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[5] Single quantifier on list literal containing strings (example 2)',
        cypher="RETURN single(x IN ['abc'] WHERE size(x) = 3) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-5-3',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[5] Single quantifier on list literal containing strings (example 3)',
        cypher="RETURN single(x IN ['ef'] WHERE size(x) = 3) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-5-4',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[5] Single quantifier on list literal containing strings (example 4)',
        cypher="RETURN single(x IN ['abc', 'ef'] WHERE size(x) = 3) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-5-5',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[5] Single quantifier on list literal containing strings (example 5)',
        cypher="RETURN single(x IN ['ef', 'abc'] WHERE size(x) = 3) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-5-6',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[5] Single quantifier on list literal containing strings (example 6)',
        cypher="RETURN single(x IN ['abc', 'ef', 'abc'] WHERE size(x) = 3) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-5-7',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[5] Single quantifier on list literal containing strings (example 7)',
        cypher="RETURN single(x IN ['ef', 'abc', 'ef'] WHERE size(x) = 3) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-5-8',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[5] Single quantifier on list literal containing strings (example 8)',
        cypher="RETURN single(x IN ['abc', 'abc', 'abc'] WHERE size(x) = 3) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-5-9',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[5] Single quantifier on list literal containing strings (example 9)',
        cypher="RETURN single(x IN ['ef', 'ef', 'ef'] WHERE size(x) = 3) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-6-1',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[6] Single quantifier on list literal containing lists (example 1)',
        cypher='RETURN single(x IN [] WHERE size(x) = 3) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-6-2',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[6] Single quantifier on list literal containing lists (example 2)',
        cypher='RETURN single(x IN [[1, 2, 3]] WHERE size(x) = 3) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-6-3',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[6] Single quantifier on list literal containing lists (example 3)',
        cypher="RETURN single(x IN [['a']] WHERE size(x) = 3) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-6-4',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[6] Single quantifier on list literal containing lists (example 4)',
        cypher="RETURN single(x IN [[1, 2, 3], ['a']] WHERE size(x) = 3) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-6-5',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[6] Single quantifier on list literal containing lists (example 5)',
        cypher="RETURN single(x IN [['a'], [1, 2, 3]] WHERE size(x) = 3) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-6-6',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[6] Single quantifier on list literal containing lists (example 6)',
        cypher="RETURN single(x IN [[1, 2, 3], ['a'], [1, 2, 3]] WHERE size(x) = 3) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-6-7',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[6] Single quantifier on list literal containing lists (example 7)',
        cypher="RETURN single(x IN [['a'], [1, 2, 3], ['a']] WHERE size(x) = 3) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-6-8',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[6] Single quantifier on list literal containing lists (example 8)',
        cypher='RETURN single(x IN [[1, 2, 3], [1, 2, 3], [1, 2, 3]] WHERE size(x) = 3) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-6-9',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[6] Single quantifier on list literal containing lists (example 9)',
        cypher="RETURN single(x IN [['a'], ['a'], ['a']] WHERE size(x) = 3) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-7-1',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[7] Single quantifier on list literal containing maps (example 1)',
        cypher='RETURN single(x IN [] WHERE x.a = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-7-2',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[7] Single quantifier on list literal containing maps (example 2)',
        cypher='RETURN single(x IN [{a: 2, b: 5}] WHERE x.a = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-7-3',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[7] Single quantifier on list literal containing maps (example 3)',
        cypher='RETURN single(x IN [{a: 4}] WHERE x.a = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-7-4',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[7] Single quantifier on list literal containing maps (example 4)',
        cypher='RETURN single(x IN [{a: 2, b: 5}, {a: 4}] WHERE x.a = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-7-5',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[7] Single quantifier on list literal containing maps (example 5)',
        cypher='RETURN single(x IN [{a: 4}, {a: 2, b: 5}] WHERE x.a = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-7-6',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[7] Single quantifier on list literal containing maps (example 6)',
        cypher='RETURN single(x IN [{a: 2, b: 5}, {a: 4}, {a: 2, b: 5}] WHERE x.a = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-7-7',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[7] Single quantifier on list literal containing maps (example 7)',
        cypher='RETURN single(x IN [{a: 4}, {a: 2, b: 5}, {a: 4}] WHERE x.a = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-7-8',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[7] Single quantifier on list literal containing maps (example 8)',
        cypher='RETURN single(x IN [{a: 2, b: 5}, {a: 2, b: 5}, {a: 2, b: 5}] WHERE x.a = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-7-9',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[7] Single quantifier on list literal containing maps (example 9)',
        cypher='RETURN single(x IN [{a: 4}, {a: 4}, {a: 4}] WHERE x.a = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-8',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[8] Single quantifier on list containing nodes',
        cypher="MATCH p = (:SNodes)-[*0..3]->(x)\n      WITH tail(nodes(p)) AS nodes\n      RETURN nodes, single(x IN nodes WHERE x.name = 'a') AS result",
        graph=graph_fixture_from_create(
            """
            CREATE (s1:SRelationships), (s2:SNodes)
                  CREATE (a:A {name: 'a'}), (b:B {name: 'b'})
                  CREATE (aa:A {name: 'a'}), (ab:B {name: 'b'}),
                         (ba:A {name: 'a'}), (bb:B {name: 'b'})
                  CREATE (aaa:A {name: 'a'}), (aab:B {name: 'b'}),
                         (aba:A {name: 'a'}), (abb:B {name: 'b'}),
                         (baa:A {name: 'a'}), (bab:B {name: 'b'}),
                         (bba:A {name: 'a'}), (bbb:B {name: 'b'})
                  CREATE (s1)-[:I]->(s2),
                         (s2)-[:RA {name: 'a'}]->(a), (s2)-[:RB {name: 'b'}]->(b)
                  CREATE (a)-[:RA {name: 'a'}]->(aa), (a)-[:RB {name: 'b'}]->(ab),
                         (b)-[:RA {name: 'a'}]->(ba), (b)-[:RB {name: 'b'}]->(bb)
                  CREATE (aa)-[:RA {name: 'a'}]->(aaa), (aa)-[:RB {name: 'b'}]->(aab),
                         (ab)-[:RA {name: 'a'}]->(aba), (ab)-[:RB {name: 'b'}]->(abb),
                         (ba)-[:RA {name: 'a'}]->(baa), (ba)-[:RB {name: 'b'}]->(bab),
                         (bb)-[:RA {name: 'a'}]->(bba), (bb)-[:RB {name: 'b'}]->(bbb)
            """
        ),
        expected=Expected(
            rows=[
            {'nodes': '[]', 'result': 'false'},
            {'nodes': "[(:A {name: 'a'})]", 'result': 'true'},
            {'nodes': "[(:A {name: 'a'}), (:A {name: 'a'})]", 'result': 'false'},
            {'nodes': "[(:A {name: 'a'}), (:A {name: 'a'}), (:A {name: 'a'})]", 'result': 'false'},
            {'nodes': "[(:A {name: 'a'}), (:A {name: 'a'}), (:B {name: 'b'})]", 'result': 'false'},
            {'nodes': "[(:A {name: 'a'}), (:B {name: 'b'})]", 'result': 'true'},
            {'nodes': "[(:A {name: 'a'}), (:B {name: 'b'}), (:A {name: 'a'})]", 'result': 'false'},
            {'nodes': "[(:A {name: 'a'}), (:B {name: 'b'}), (:B {name: 'b'})]", 'result': 'true'},
            {'nodes': "[(:B {name: 'b'})]", 'result': 'false'},
            {'nodes': "[(:B {name: 'b'}), (:A {name: 'a'})]", 'result': 'true'},
            {'nodes': "[(:B {name: 'b'}), (:A {name: 'a'}), (:A {name: 'a'})]", 'result': 'false'},
            {'nodes': "[(:B {name: 'b'}), (:A {name: 'a'}), (:B {name: 'b'})]", 'result': 'true'},
            {'nodes': "[(:B {name: 'b'}), (:B {name: 'b'})]", 'result': 'false'},
            {'nodes': "[(:B {name: 'b'}), (:B {name: 'b'}), (:A {name: 'a'})]", 'result': 'true'},
            {'nodes': "[(:B {name: 'b'}), (:B {name: 'b'}), (:B {name: 'b'})]", 'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-9',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[9] Single quantifier on list containing relationships',
        cypher="MATCH p = (:SRelationships)-[*0..4]->(x)\n      WITH tail(relationships(p)) AS relationships, COUNT(*) AS c\n      RETURN relationships, single(x IN relationships WHERE x.name = 'a') AS result",
        graph=graph_fixture_from_create(
            """
            CREATE (s1:SRelationships), (s2:SNodes)
                  CREATE (a:A {name: 'a'}), (b:B {name: 'b'})
                  CREATE (aa:A {name: 'a'}), (ab:B {name: 'b'}),
                         (ba:A {name: 'a'}), (bb:B {name: 'b'})
                  CREATE (aaa:A {name: 'a'}), (aab:B {name: 'b'}),
                         (aba:A {name: 'a'}), (abb:B {name: 'b'}),
                         (baa:A {name: 'a'}), (bab:B {name: 'b'}),
                         (bba:A {name: 'a'}), (bbb:B {name: 'b'})
                  CREATE (s1)-[:I]->(s2),
                         (s2)-[:RA {name: 'a'}]->(a), (s2)-[:RB {name: 'b'}]->(b)
                  CREATE (a)-[:RA {name: 'a'}]->(aa), (a)-[:RB {name: 'b'}]->(ab),
                         (b)-[:RA {name: 'a'}]->(ba), (b)-[:RB {name: 'b'}]->(bb)
                  CREATE (aa)-[:RA {name: 'a'}]->(aaa), (aa)-[:RB {name: 'b'}]->(aab),
                         (ab)-[:RA {name: 'a'}]->(aba), (ab)-[:RB {name: 'b'}]->(abb),
                         (ba)-[:RA {name: 'a'}]->(baa), (ba)-[:RB {name: 'b'}]->(bab),
                         (bb)-[:RA {name: 'a'}]->(bba), (bb)-[:RB {name: 'b'}]->(bbb)
            """
        ),
        expected=Expected(
            rows=[
            {'relationships': '[]', 'result': 'false'},
            {'relationships': "[[:RA {name: 'a'}]]", 'result': 'true'},
            {'relationships': "[[:RA {name: 'a'}], [:RA {name: 'a'}]]", 'result': 'false'},
            {'relationships': "[[:RA {name: 'a'}], [:RA {name: 'a'}], [:RA {name: 'a'}]]", 'result': 'false'},
            {'relationships': "[[:RA {name: 'a'}], [:RA {name: 'a'}], [:RB {name: 'b'}]]", 'result': 'false'},
            {'relationships': "[[:RA {name: 'a'}], [:RB {name: 'b'}]]", 'result': 'true'},
            {'relationships': "[[:RA {name: 'a'}], [:RB {name: 'b'}], [:RA {name: 'a'}]]", 'result': 'false'},
            {'relationships': "[[:RA {name: 'a'}], [:RB {name: 'b'}], [:RB {name: 'b'}]]", 'result': 'true'},
            {'relationships': "[[:RB {name: 'b'}]]", 'result': 'false'},
            {'relationships': "[[:RB {name: 'b'}], [:RA {name: 'a'}]]", 'result': 'true'},
            {'relationships': "[[:RB {name: 'b'}], [:RA {name: 'a'}], [:RA {name: 'a'}]]", 'result': 'false'},
            {'relationships': "[[:RB {name: 'b'}], [:RA {name: 'a'}], [:RB {name: 'b'}]]", 'result': 'true'},
            {'relationships': "[[:RB {name: 'b'}], [:RB {name: 'b'}]]", 'result': 'false'},
            {'relationships': "[[:RB {name: 'b'}], [:RB {name: 'b'}], [:RA {name: 'a'}]]", 'result': 'true'},
            {'relationships': "[[:RB {name: 'b'}], [:RB {name: 'b'}], [:RB {name: 'b'}]]", 'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-10-1',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[10] Single quantifier on lists containing nulls (example 1)',
        cypher='RETURN single(x IN [null] WHERE x = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-10-2',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[10] Single quantifier on lists containing nulls (example 2)',
        cypher='RETURN single(x IN [null, null] WHERE x = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-10-3',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[10] Single quantifier on lists containing nulls (example 3)',
        cypher='RETURN single(x IN [0, null] WHERE x = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-10-4',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[10] Single quantifier on lists containing nulls (example 4)',
        cypher='RETURN single(x IN [2, null] WHERE x = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-10-5',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[10] Single quantifier on lists containing nulls (example 5)',
        cypher='RETURN single(x IN [null, 2] WHERE x = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-10-6',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[10] Single quantifier on lists containing nulls (example 6)',
        cypher='RETURN single(x IN [34, 0, null, 5, 900] WHERE x < 10) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-10-7',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[10] Single quantifier on lists containing nulls (example 7)',
        cypher='RETURN single(x IN [34, 10, null, 15, 900] WHERE x < 10) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-10-8',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[10] Single quantifier on lists containing nulls (example 8)',
        cypher='RETURN single(x IN [4, 0, null, -15, 9] WHERE x < 10) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-11-1',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[11] Single quantifier with IS NULL predicate (example 1)',
        cypher='RETURN single(x IN [] WHERE x IS NULL) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-11-2',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[11] Single quantifier with IS NULL predicate (example 2)',
        cypher='RETURN single(x IN [0] WHERE x IS NULL) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-11-3',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[11] Single quantifier with IS NULL predicate (example 3)',
        cypher='RETURN single(x IN [34, 0, 8, 900] WHERE x IS NULL) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-11-4',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[11] Single quantifier with IS NULL predicate (example 4)',
        cypher='RETURN single(x IN [null] WHERE x IS NULL) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-11-5',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[11] Single quantifier with IS NULL predicate (example 5)',
        cypher='RETURN single(x IN [null, null] WHERE x IS NULL) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-11-6',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[11] Single quantifier with IS NULL predicate (example 6)',
        cypher='RETURN single(x IN [0, null] WHERE x IS NULL) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-11-7',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[11] Single quantifier with IS NULL predicate (example 7)',
        cypher='RETURN single(x IN [2, null] WHERE x IS NULL) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-11-8',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[11] Single quantifier with IS NULL predicate (example 8)',
        cypher='RETURN single(x IN [null, 2] WHERE x IS NULL) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-11-9',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[11] Single quantifier with IS NULL predicate (example 9)',
        cypher='RETURN single(x IN [34, 0, null, 8, 900] WHERE x IS NULL) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-11-10',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[11] Single quantifier with IS NULL predicate (example 10)',
        cypher='RETURN single(x IN [34, 0, null, 8, null] WHERE x IS NULL) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-11-11',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[11] Single quantifier with IS NULL predicate (example 11)',
        cypher='RETURN single(x IN [null, 123, null, null] WHERE x IS NULL) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-11-12',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[11] Single quantifier with IS NULL predicate (example 12)',
        cypher='RETURN single(x IN [null, null, null, null] WHERE x IS NULL) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-12-1',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[12] Single quantifier with IS NOT NULL predicate (example 1)',
        cypher='RETURN single(x IN [] WHERE x IS NOT NULL) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-12-2',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[12] Single quantifier with IS NOT NULL predicate (example 2)',
        cypher='RETURN single(x IN [0] WHERE x IS NOT NULL) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-12-3',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[12] Single quantifier with IS NOT NULL predicate (example 3)',
        cypher='RETURN single(x IN [34, 0, 8, 900] WHERE x IS NOT NULL) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-12-4',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[12] Single quantifier with IS NOT NULL predicate (example 4)',
        cypher='RETURN single(x IN [null] WHERE x IS NOT NULL) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-12-5',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[12] Single quantifier with IS NOT NULL predicate (example 5)',
        cypher='RETURN single(x IN [null, null] WHERE x IS NOT NULL) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-12-6',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[12] Single quantifier with IS NOT NULL predicate (example 6)',
        cypher='RETURN single(x IN [0, null] WHERE x IS NOT NULL) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-12-7',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[12] Single quantifier with IS NOT NULL predicate (example 7)',
        cypher='RETURN single(x IN [2, null] WHERE x IS NOT NULL) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-12-8',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[12] Single quantifier with IS NOT NULL predicate (example 8)',
        cypher='RETURN single(x IN [null, 2] WHERE x IS NOT NULL) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-12-9',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[12] Single quantifier with IS NOT NULL predicate (example 9)',
        cypher='RETURN single(x IN [34, 0, null, 8, 900] WHERE x IS NOT NULL) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-12-10',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[12] Single quantifier with IS NOT NULL predicate (example 10)',
        cypher='RETURN single(x IN [34, 0, null, 8, null] WHERE x IS NOT NULL) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-12-11',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[12] Single quantifier with IS NOT NULL predicate (example 11)',
        cypher='RETURN single(x IN [null, 123, null, null] WHERE x IS NOT NULL) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-12-12',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[12] Single quantifier with IS NOT NULL predicate (example 12)',
        cypher='RETURN single(x IN [null, null, null, null] WHERE x IS NOT NULL) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-13',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[13] Single quantifier is false if the predicate is statically false and the list is not empty',
        cypher="RETURN single(x IN [1, null, true, 4.5, 'abc', false] WHERE false) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-14',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[14] Single quantifier is false if the predicate is statically true and the list has more than one element',
        cypher="RETURN single(x IN [1, null, true, 4.5, 'abc', false] WHERE true) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-15',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[15] Single quantifier is true if the predicate is statically true and the list has exactly one non-null element',
        cypher='RETURN single(x IN [1] WHERE true) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-16-1',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[16] Fail single quantifier on type mismatch between list elements and predicate (example 1)',
        cypher="RETURN single(x IN ['Clara'] WHERE x % 2 = 0) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-16-2',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[16] Fail single quantifier on type mismatch between list elements and predicate (example 2)',
        cypher='RETURN single(x IN [false, true] WHERE x % 2 = 0) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier2-16-3',
        feature_path='tck/features/expressions/quantifier/Quantifier2.feature',
        scenario='[16] Fail single quantifier on type mismatch between list elements and predicate (example 3)',
        cypher="RETURN single(x IN ['Clara', 'Bob', 'Dave', 'Alice'] WHERE x % 2 = 0) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-1',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[1] Any quantifier is always false on empty list',
        cypher='RETURN any(x IN [] WHERE true) AS a, any(x IN [] WHERE false) AS b, any(x IN [] WHERE x) AS c',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'a': 'false', 'b': 'false', 'c': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-2-1',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[2] Any quantifier on list literal (example 1)',
        cypher='RETURN any(x IN [] WHERE x) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-2-2',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[2] Any quantifier on list literal (example 2)',
        cypher='RETURN any(x IN [true] WHERE x) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-2-3',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[2] Any quantifier on list literal (example 3)',
        cypher='RETURN any(x IN [false] WHERE x) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-2-4',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[2] Any quantifier on list literal (example 4)',
        cypher='RETURN any(x IN [true, false] WHERE x) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-2-5',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[2] Any quantifier on list literal (example 5)',
        cypher='RETURN any(x IN [false, true] WHERE x) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-2-6',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[2] Any quantifier on list literal (example 6)',
        cypher='RETURN any(x IN [true, false, true] WHERE x) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-2-7',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[2] Any quantifier on list literal (example 7)',
        cypher='RETURN any(x IN [false, true, false] WHERE x) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-2-8',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[2] Any quantifier on list literal (example 8)',
        cypher='RETURN any(x IN [true, true, true] WHERE x) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-2-9',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[2] Any quantifier on list literal (example 9)',
        cypher='RETURN any(x IN [false, false, false] WHERE x) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-3-1',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[3] Any quantifier on list literal containing integers (example 1)',
        cypher='RETURN any(x IN [] WHERE x = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-3-2',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[3] Any quantifier on list literal containing integers (example 2)',
        cypher='RETURN any(x IN [1] WHERE x = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-3-3',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[3] Any quantifier on list literal containing integers (example 3)',
        cypher='RETURN any(x IN [1, 3] WHERE x = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-3-4',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[3] Any quantifier on list literal containing integers (example 4)',
        cypher='RETURN any(x IN [1, 3, 20, 5000] WHERE x = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-3-5',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[3] Any quantifier on list literal containing integers (example 5)',
        cypher='RETURN any(x IN [20, 3, 5000, -2] WHERE x = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-3-6',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[3] Any quantifier on list literal containing integers (example 6)',
        cypher='RETURN any(x IN [2] WHERE x = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-3-7',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[3] Any quantifier on list literal containing integers (example 7)',
        cypher='RETURN any(x IN [1, 2] WHERE x = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-3-8',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[3] Any quantifier on list literal containing integers (example 8)',
        cypher='RETURN any(x IN [1, 2, 3] WHERE x = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-3-9',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[3] Any quantifier on list literal containing integers (example 9)',
        cypher='RETURN any(x IN [2, 2] WHERE x = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-3-10',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[3] Any quantifier on list literal containing integers (example 10)',
        cypher='RETURN any(x IN [2, 3] WHERE x = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-3-11',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[3] Any quantifier on list literal containing integers (example 11)',
        cypher='RETURN any(x IN [3, 2, 3] WHERE x = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-3-12',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[3] Any quantifier on list literal containing integers (example 12)',
        cypher='RETURN any(x IN [2, 3, 2] WHERE x = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-3-13',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[3] Any quantifier on list literal containing integers (example 13)',
        cypher='RETURN any(x IN [2, -10, 3, 9, 0] WHERE x < 10) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-3-14',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[3] Any quantifier on list literal containing integers (example 14)',
        cypher='RETURN any(x IN [2, -10, 3, 2, 10] WHERE x < 10) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-3-15',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[3] Any quantifier on list literal containing integers (example 15)',
        cypher='RETURN any(x IN [2, -10, 3, 21, 10] WHERE x < 10) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-3-16',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[3] Any quantifier on list literal containing integers (example 16)',
        cypher='RETURN any(x IN [200, -10, 36, 21, 10] WHERE x < 10) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-3-17',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[3] Any quantifier on list literal containing integers (example 17)',
        cypher='RETURN any(x IN [200, 15, 36, 21, 10] WHERE x < 10) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-4-1',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[4] Any quantifier on list literal containing floats (example 1)',
        cypher='RETURN any(x IN [] WHERE x = 2.1) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-4-2',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[4] Any quantifier on list literal containing floats (example 2)',
        cypher='RETURN any(x IN [1.1] WHERE x = 2.1) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-4-3',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[4] Any quantifier on list literal containing floats (example 3)',
        cypher='RETURN any(x IN [1.1, 3.5] WHERE x = 2.1) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-4-4',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[4] Any quantifier on list literal containing floats (example 4)',
        cypher='RETURN any(x IN [1.1, 3.5, 20.0, 50.42435] WHERE x = 2.1) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-4-5',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[4] Any quantifier on list literal containing floats (example 5)',
        cypher='RETURN any(x IN [20.0, 3.4, 50.2, -2.1] WHERE x = 2.1) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-4-6',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[4] Any quantifier on list literal containing floats (example 6)',
        cypher='RETURN any(x IN [2.1] WHERE x = 2.1) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-4-7',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[4] Any quantifier on list literal containing floats (example 7)',
        cypher='RETURN any(x IN [1.43, 2.1] WHERE x = 2.1) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-4-8',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[4] Any quantifier on list literal containing floats (example 8)',
        cypher='RETURN any(x IN [1.43, 2.1, 3.5] WHERE x = 2.1) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-4-9',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[4] Any quantifier on list literal containing floats (example 9)',
        cypher='RETURN any(x IN [2.1, 2.1] WHERE x = 2.1) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-4-10',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[4] Any quantifier on list literal containing floats (example 10)',
        cypher='RETURN any(x IN [2.1, 3.5] WHERE x = 2.1) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-4-11',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[4] Any quantifier on list literal containing floats (example 11)',
        cypher='RETURN any(x IN [3.5, 2.1, 3.5] WHERE x = 2.1) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-4-12',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[4] Any quantifier on list literal containing floats (example 12)',
        cypher='RETURN any(x IN [2.1, 3.5, 2.1] WHERE x = 2.1) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-5-1',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[5] Any quantifier on list literal containing strings (example 1)',
        cypher='RETURN any(x IN [] WHERE size(x) = 3) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-5-2',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[5] Any quantifier on list literal containing strings (example 2)',
        cypher="RETURN any(x IN ['abc'] WHERE size(x) = 3) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-5-3',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[5] Any quantifier on list literal containing strings (example 3)',
        cypher="RETURN any(x IN ['ef'] WHERE size(x) = 3) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-5-4',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[5] Any quantifier on list literal containing strings (example 4)',
        cypher="RETURN any(x IN ['abc', 'ef'] WHERE size(x) = 3) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-5-5',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[5] Any quantifier on list literal containing strings (example 5)',
        cypher="RETURN any(x IN ['ef', 'abc'] WHERE size(x) = 3) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-5-6',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[5] Any quantifier on list literal containing strings (example 6)',
        cypher="RETURN any(x IN ['abc', 'ef', 'abc'] WHERE size(x) = 3) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-5-7',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[5] Any quantifier on list literal containing strings (example 7)',
        cypher="RETURN any(x IN ['ef', 'abc', 'ef'] WHERE size(x) = 3) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-5-8',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[5] Any quantifier on list literal containing strings (example 8)',
        cypher="RETURN any(x IN ['abc', 'abc', 'abc'] WHERE size(x) = 3) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-5-9',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[5] Any quantifier on list literal containing strings (example 9)',
        cypher="RETURN any(x IN ['ef', 'ef', 'ef'] WHERE size(x) = 3) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-6-1',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[6] Any quantifier on list literal containing lists (example 1)',
        cypher='RETURN any(x IN [] WHERE size(x) = 3) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-6-2',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[6] Any quantifier on list literal containing lists (example 2)',
        cypher='RETURN any(x IN [[1, 2, 3]] WHERE size(x) = 3) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-6-3',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[6] Any quantifier on list literal containing lists (example 3)',
        cypher="RETURN any(x IN [['a']] WHERE size(x) = 3) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-6-4',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[6] Any quantifier on list literal containing lists (example 4)',
        cypher="RETURN any(x IN [[1, 2, 3], ['a']] WHERE size(x) = 3) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-6-5',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[6] Any quantifier on list literal containing lists (example 5)',
        cypher="RETURN any(x IN [['a'], [1, 2, 3]] WHERE size(x) = 3) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-6-6',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[6] Any quantifier on list literal containing lists (example 6)',
        cypher="RETURN any(x IN [[1, 2, 3], ['a'], [1, 2, 3]] WHERE size(x) = 3) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-6-7',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[6] Any quantifier on list literal containing lists (example 7)',
        cypher="RETURN any(x IN [['a'], [1, 2, 3], ['a']] WHERE size(x) = 3) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-6-8',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[6] Any quantifier on list literal containing lists (example 8)',
        cypher='RETURN any(x IN [[1, 2, 3], [1, 2, 3], [1, 2, 3]] WHERE size(x) = 3) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-6-9',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[6] Any quantifier on list literal containing lists (example 9)',
        cypher="RETURN any(x IN [['a'], ['a'], ['a']] WHERE size(x) = 3) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-7-1',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[7] Any quantifier on list literal containing maps (example 1)',
        cypher='RETURN any(x IN [] WHERE x.a = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-7-2',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[7] Any quantifier on list literal containing maps (example 2)',
        cypher='RETURN any(x IN [{a: 2, b: 5}] WHERE x.a = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-7-3',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[7] Any quantifier on list literal containing maps (example 3)',
        cypher='RETURN any(x IN [{a: 4}] WHERE x.a = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-7-4',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[7] Any quantifier on list literal containing maps (example 4)',
        cypher='RETURN any(x IN [{a: 2, b: 5}, {a: 4}] WHERE x.a = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-7-5',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[7] Any quantifier on list literal containing maps (example 5)',
        cypher='RETURN any(x IN [{a: 4}, {a: 2, b: 5}] WHERE x.a = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-7-6',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[7] Any quantifier on list literal containing maps (example 6)',
        cypher='RETURN any(x IN [{a: 2, b: 5}, {a: 4}, {a: 2, b: 5}] WHERE x.a = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-7-7',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[7] Any quantifier on list literal containing maps (example 7)',
        cypher='RETURN any(x IN [{a: 4}, {a: 2, b: 5}, {a: 4}] WHERE x.a = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-7-8',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[7] Any quantifier on list literal containing maps (example 8)',
        cypher='RETURN any(x IN [{a: 2, b: 5}, {a: 2, b: 5}, {a: 2, b: 5}] WHERE x.a = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-7-9',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[7] Any quantifier on list literal containing maps (example 9)',
        cypher='RETURN any(x IN [{a: 4}, {a: 4}, {a: 4}] WHERE x.a = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-8',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[8] Any quantifier on list containing nodes',
        cypher="MATCH p = (:SNodes)-[*0..3]->(x)\n      WITH tail(nodes(p)) AS nodes\n      RETURN nodes, any(x IN nodes WHERE x.name = 'a') AS result",
        graph=graph_fixture_from_create(
            """
            CREATE (s1:SRelationships), (s2:SNodes)
                  CREATE (a:A {name: 'a'}), (b:B {name: 'b'})
                  CREATE (aa:A {name: 'a'}), (ab:B {name: 'b'}),
                         (ba:A {name: 'a'}), (bb:B {name: 'b'})
                  CREATE (aaa:A {name: 'a'}), (aab:B {name: 'b'}),
                         (aba:A {name: 'a'}), (abb:B {name: 'b'}),
                         (baa:A {name: 'a'}), (bab:B {name: 'b'}),
                         (bba:A {name: 'a'}), (bbb:B {name: 'b'})
                  CREATE (s1)-[:I]->(s2),
                         (s2)-[:RA {name: 'a'}]->(a), (s2)-[:RB {name: 'b'}]->(b)
                  CREATE (a)-[:RA {name: 'a'}]->(aa), (a)-[:RB {name: 'b'}]->(ab),
                         (b)-[:RA {name: 'a'}]->(ba), (b)-[:RB {name: 'b'}]->(bb)
                  CREATE (aa)-[:RA {name: 'a'}]->(aaa), (aa)-[:RB {name: 'b'}]->(aab),
                         (ab)-[:RA {name: 'a'}]->(aba), (ab)-[:RB {name: 'b'}]->(abb),
                         (ba)-[:RA {name: 'a'}]->(baa), (ba)-[:RB {name: 'b'}]->(bab),
                         (bb)-[:RA {name: 'a'}]->(bba), (bb)-[:RB {name: 'b'}]->(bbb)
            """
        ),
        expected=Expected(
            rows=[
            {'nodes': '[]', 'result': 'false'},
            {'nodes': "[(:A {name: 'a'})]", 'result': 'true'},
            {'nodes': "[(:A {name: 'a'}), (:A {name: 'a'})]", 'result': 'true'},
            {'nodes': "[(:A {name: 'a'}), (:A {name: 'a'}), (:A {name: 'a'})]", 'result': 'true'},
            {'nodes': "[(:A {name: 'a'}), (:A {name: 'a'}), (:B {name: 'b'})]", 'result': 'true'},
            {'nodes': "[(:A {name: 'a'}), (:B {name: 'b'})]", 'result': 'true'},
            {'nodes': "[(:A {name: 'a'}), (:B {name: 'b'}), (:A {name: 'a'})]", 'result': 'true'},
            {'nodes': "[(:A {name: 'a'}), (:B {name: 'b'}), (:B {name: 'b'})]", 'result': 'true'},
            {'nodes': "[(:B {name: 'b'})]", 'result': 'false'},
            {'nodes': "[(:B {name: 'b'}), (:A {name: 'a'})]", 'result': 'true'},
            {'nodes': "[(:B {name: 'b'}), (:A {name: 'a'}), (:A {name: 'a'})]", 'result': 'true'},
            {'nodes': "[(:B {name: 'b'}), (:A {name: 'a'}), (:B {name: 'b'})]", 'result': 'true'},
            {'nodes': "[(:B {name: 'b'}), (:B {name: 'b'})]", 'result': 'false'},
            {'nodes': "[(:B {name: 'b'}), (:B {name: 'b'}), (:A {name: 'a'})]", 'result': 'true'},
            {'nodes': "[(:B {name: 'b'}), (:B {name: 'b'}), (:B {name: 'b'})]", 'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-9',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[9] Any quantifier on list containing relationships',
        cypher="MATCH p = (:SRelationships)-[*0..4]->(x)\n      WITH tail(relationships(p)) AS relationships, COUNT(*) AS c\n      RETURN relationships, any(x IN relationships WHERE x.name = 'a') AS result",
        graph=graph_fixture_from_create(
            """
            CREATE (s1:SRelationships), (s2:SNodes)
                  CREATE (a:A {name: 'a'}), (b:B {name: 'b'})
                  CREATE (aa:A {name: 'a'}), (ab:B {name: 'b'}),
                         (ba:A {name: 'a'}), (bb:B {name: 'b'})
                  CREATE (aaa:A {name: 'a'}), (aab:B {name: 'b'}),
                         (aba:A {name: 'a'}), (abb:B {name: 'b'}),
                         (baa:A {name: 'a'}), (bab:B {name: 'b'}),
                         (bba:A {name: 'a'}), (bbb:B {name: 'b'})
                  CREATE (s1)-[:I]->(s2),
                         (s2)-[:RA {name: 'a'}]->(a), (s2)-[:RB {name: 'b'}]->(b)
                  CREATE (a)-[:RA {name: 'a'}]->(aa), (a)-[:RB {name: 'b'}]->(ab),
                         (b)-[:RA {name: 'a'}]->(ba), (b)-[:RB {name: 'b'}]->(bb)
                  CREATE (aa)-[:RA {name: 'a'}]->(aaa), (aa)-[:RB {name: 'b'}]->(aab),
                         (ab)-[:RA {name: 'a'}]->(aba), (ab)-[:RB {name: 'b'}]->(abb),
                         (ba)-[:RA {name: 'a'}]->(baa), (ba)-[:RB {name: 'b'}]->(bab),
                         (bb)-[:RA {name: 'a'}]->(bba), (bb)-[:RB {name: 'b'}]->(bbb)
            """
        ),
        expected=Expected(
            rows=[
            {'relationships': '[]', 'result': 'false'},
            {'relationships': "[[:RA {name: 'a'}]]", 'result': 'true'},
            {'relationships': "[[:RA {name: 'a'}], [:RA {name: 'a'}]]", 'result': 'true'},
            {'relationships': "[[:RA {name: 'a'}], [:RA {name: 'a'}], [:RA {name: 'a'}]]", 'result': 'true'},
            {'relationships': "[[:RA {name: 'a'}], [:RA {name: 'a'}], [:RB {name: 'b'}]]", 'result': 'true'},
            {'relationships': "[[:RA {name: 'a'}], [:RB {name: 'b'}]]", 'result': 'true'},
            {'relationships': "[[:RA {name: 'a'}], [:RB {name: 'b'}], [:RA {name: 'a'}]]", 'result': 'true'},
            {'relationships': "[[:RA {name: 'a'}], [:RB {name: 'b'}], [:RB {name: 'b'}]]", 'result': 'true'},
            {'relationships': "[[:RB {name: 'b'}]]", 'result': 'false'},
            {'relationships': "[[:RB {name: 'b'}], [:RA {name: 'a'}]]", 'result': 'true'},
            {'relationships': "[[:RB {name: 'b'}], [:RA {name: 'a'}], [:RA {name: 'a'}]]", 'result': 'true'},
            {'relationships': "[[:RB {name: 'b'}], [:RA {name: 'a'}], [:RB {name: 'b'}]]", 'result': 'true'},
            {'relationships': "[[:RB {name: 'b'}], [:RB {name: 'b'}]]", 'result': 'false'},
            {'relationships': "[[:RB {name: 'b'}], [:RB {name: 'b'}], [:RA {name: 'a'}]]", 'result': 'true'},
            {'relationships': "[[:RB {name: 'b'}], [:RB {name: 'b'}], [:RB {name: 'b'}]]", 'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-10-1',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[10] Any quantifier on lists containing nulls (example 1)',
        cypher='RETURN any(x IN [null] WHERE x = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-10-2',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[10] Any quantifier on lists containing nulls (example 2)',
        cypher='RETURN any(x IN [null, null] WHERE x = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-10-3',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[10] Any quantifier on lists containing nulls (example 3)',
        cypher='RETURN any(x IN [0, null] WHERE x = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-10-4',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[10] Any quantifier on lists containing nulls (example 4)',
        cypher='RETURN any(x IN [2, null] WHERE x = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-10-5',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[10] Any quantifier on lists containing nulls (example 5)',
        cypher='RETURN any(x IN [null, 2] WHERE x = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-10-6',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[10] Any quantifier on lists containing nulls (example 6)',
        cypher='RETURN any(x IN [34, 0, null, 5, 900] WHERE x < 10) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-10-7',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[10] Any quantifier on lists containing nulls (example 7)',
        cypher='RETURN any(x IN [34, 10, null, 15, 900] WHERE x < 10) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-10-8',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[10] Any quantifier on lists containing nulls (example 8)',
        cypher='RETURN any(x IN [4, 0, null, -15, 9] WHERE x < 10) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-11-1',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[11] Any quantifier with IS NULL predicate (example 1)',
        cypher='RETURN any(x IN [] WHERE x IS NULL) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-11-2',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[11] Any quantifier with IS NULL predicate (example 2)',
        cypher='RETURN any(x IN [0] WHERE x IS NULL) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-11-3',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[11] Any quantifier with IS NULL predicate (example 3)',
        cypher='RETURN any(x IN [34, 0, 8, 900] WHERE x IS NULL) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-11-4',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[11] Any quantifier with IS NULL predicate (example 4)',
        cypher='RETURN any(x IN [null] WHERE x IS NULL) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-11-5',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[11] Any quantifier with IS NULL predicate (example 5)',
        cypher='RETURN any(x IN [null, null] WHERE x IS NULL) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-11-6',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[11] Any quantifier with IS NULL predicate (example 6)',
        cypher='RETURN any(x IN [0, null] WHERE x IS NULL) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-11-7',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[11] Any quantifier with IS NULL predicate (example 7)',
        cypher='RETURN any(x IN [2, null] WHERE x IS NULL) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-11-8',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[11] Any quantifier with IS NULL predicate (example 8)',
        cypher='RETURN any(x IN [null, 2] WHERE x IS NULL) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-11-9',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[11] Any quantifier with IS NULL predicate (example 9)',
        cypher='RETURN any(x IN [34, 0, null, 8, 900] WHERE x IS NULL) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-11-10',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[11] Any quantifier with IS NULL predicate (example 10)',
        cypher='RETURN any(x IN [34, 0, null, 8, null] WHERE x IS NULL) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-11-11',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[11] Any quantifier with IS NULL predicate (example 11)',
        cypher='RETURN any(x IN [null, 123, null, null] WHERE x IS NULL) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-11-12',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[11] Any quantifier with IS NULL predicate (example 12)',
        cypher='RETURN any(x IN [null, null, null, null] WHERE x IS NULL) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-12-1',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[12] Any quantifier with IS NOT NULL predicate (example 1)',
        cypher='RETURN any(x IN [] WHERE x IS NOT NULL) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-12-2',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[12] Any quantifier with IS NOT NULL predicate (example 2)',
        cypher='RETURN any(x IN [0] WHERE x IS NOT NULL) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-12-3',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[12] Any quantifier with IS NOT NULL predicate (example 3)',
        cypher='RETURN any(x IN [34, 0, 8, 900] WHERE x IS NOT NULL) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-12-4',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[12] Any quantifier with IS NOT NULL predicate (example 4)',
        cypher='RETURN any(x IN [null] WHERE x IS NOT NULL) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-12-5',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[12] Any quantifier with IS NOT NULL predicate (example 5)',
        cypher='RETURN any(x IN [null, null] WHERE x IS NOT NULL) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-12-6',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[12] Any quantifier with IS NOT NULL predicate (example 6)',
        cypher='RETURN any(x IN [0, null] WHERE x IS NOT NULL) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-12-7',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[12] Any quantifier with IS NOT NULL predicate (example 7)',
        cypher='RETURN any(x IN [2, null] WHERE x IS NOT NULL) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-12-8',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[12] Any quantifier with IS NOT NULL predicate (example 8)',
        cypher='RETURN any(x IN [null, 2] WHERE x IS NOT NULL) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-12-9',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[12] Any quantifier with IS NOT NULL predicate (example 9)',
        cypher='RETURN any(x IN [34, 0, null, 8, 900] WHERE x IS NOT NULL) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-12-10',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[12] Any quantifier with IS NOT NULL predicate (example 10)',
        cypher='RETURN any(x IN [34, 0, null, 8, null] WHERE x IS NOT NULL) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-12-11',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[12] Any quantifier with IS NOT NULL predicate (example 11)',
        cypher='RETURN any(x IN [null, 123, null, null] WHERE x IS NOT NULL) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-12-12',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[12] Any quantifier with IS NOT NULL predicate (example 12)',
        cypher='RETURN any(x IN [null, null, null, null] WHERE x IS NOT NULL) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-13',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[13] Any quantifier is false if the predicate is statically false and the list is not empty',
        cypher="RETURN any(x IN [1, null, true, 4.5, 'abc', false] WHERE false) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-14',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[14] Any quantifier is true if the predicate is statically true and the list is not empty',
        cypher="RETURN any(x IN [1, null, true, 4.5, 'abc', false] WHERE true) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-15-1',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[15] Fail any quantifier on type mismatch between list elements and predicate (example 1)',
        cypher="RETURN any(x IN ['Clara'] WHERE x % 2 = 0) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-15-2',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[15] Fail any quantifier on type mismatch between list elements and predicate (example 2)',
        cypher='RETURN any(x IN [false, true] WHERE x % 2 = 0) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier3-15-3',
        feature_path='tck/features/expressions/quantifier/Quantifier3.feature',
        scenario='[15] Fail any quantifier on type mismatch between list elements and predicate (example 3)',
        cypher="RETURN any(x IN ['Clara', 'Bob', 'Dave', 'Alice'] WHERE x % 2 = 0) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-1',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[1] All quantifier is always true on empty list',
        cypher='RETURN all(x IN [] WHERE true) AS a, all(x IN [] WHERE false) AS b, all(x IN [] WHERE x) AS c',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'a': 'true', 'b': 'true', 'c': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-2-1',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[2] All quantifier on list literal (example 1)',
        cypher='RETURN all(x IN [] WHERE x) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-2-2',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[2] All quantifier on list literal (example 2)',
        cypher='RETURN all(x IN [true] WHERE x) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-2-3',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[2] All quantifier on list literal (example 3)',
        cypher='RETURN all(x IN [false] WHERE x) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-2-4',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[2] All quantifier on list literal (example 4)',
        cypher='RETURN all(x IN [true, false] WHERE x) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-2-5',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[2] All quantifier on list literal (example 5)',
        cypher='RETURN all(x IN [false, true] WHERE x) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-2-6',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[2] All quantifier on list literal (example 6)',
        cypher='RETURN all(x IN [true, false, true] WHERE x) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-2-7',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[2] All quantifier on list literal (example 7)',
        cypher='RETURN all(x IN [false, true, false] WHERE x) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-2-8',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[2] All quantifier on list literal (example 8)',
        cypher='RETURN all(x IN [true, true, true] WHERE x) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-2-9',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[2] All quantifier on list literal (example 9)',
        cypher='RETURN all(x IN [false, false, false] WHERE x) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-3-1',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[3] All quantifier on list literal containing integers (example 1)',
        cypher='RETURN all(x IN [] WHERE x = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-3-2',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[3] All quantifier on list literal containing integers (example 2)',
        cypher='RETURN all(x IN [1] WHERE x = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-3-3',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[3] All quantifier on list literal containing integers (example 3)',
        cypher='RETURN all(x IN [1, 3] WHERE x = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-3-4',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[3] All quantifier on list literal containing integers (example 4)',
        cypher='RETURN all(x IN [1, 3, 20, 5000] WHERE x = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-3-5',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[3] All quantifier on list literal containing integers (example 5)',
        cypher='RETURN all(x IN [20, 3, 5000, -2] WHERE x = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-3-6',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[3] All quantifier on list literal containing integers (example 6)',
        cypher='RETURN all(x IN [2] WHERE x = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-3-7',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[3] All quantifier on list literal containing integers (example 7)',
        cypher='RETURN all(x IN [1, 2] WHERE x = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-3-8',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[3] All quantifier on list literal containing integers (example 8)',
        cypher='RETURN all(x IN [1, 2, 3] WHERE x = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-3-9',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[3] All quantifier on list literal containing integers (example 9)',
        cypher='RETURN all(x IN [2, 2] WHERE x = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-3-10',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[3] All quantifier on list literal containing integers (example 10)',
        cypher='RETURN all(x IN [2, 3] WHERE x = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-3-11',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[3] All quantifier on list literal containing integers (example 11)',
        cypher='RETURN all(x IN [3, 2, 3] WHERE x = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-3-12',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[3] All quantifier on list literal containing integers (example 12)',
        cypher='RETURN all(x IN [2, 3, 2] WHERE x = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-3-13',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[3] All quantifier on list literal containing integers (example 13)',
        cypher='RETURN all(x IN [2, -10, 3, 9, 0] WHERE x < 10) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-3-14',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[3] All quantifier on list literal containing integers (example 14)',
        cypher='RETURN all(x IN [2, -10, 3, 2, 10] WHERE x < 10) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-3-15',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[3] All quantifier on list literal containing integers (example 15)',
        cypher='RETURN all(x IN [2, -10, 3, 21, 10] WHERE x < 10) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-3-16',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[3] All quantifier on list literal containing integers (example 16)',
        cypher='RETURN all(x IN [200, -10, 36, 21, 10] WHERE x < 10) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-3-17',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[3] All quantifier on list literal containing integers (example 17)',
        cypher='RETURN all(x IN [200, 15, 36, 21, 10] WHERE x < 10) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-4-1',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[4] All quantifier on list literal containing floats (example 1)',
        cypher='RETURN all(x IN [] WHERE x = 2.1) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-4-2',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[4] All quantifier on list literal containing floats (example 2)',
        cypher='RETURN all(x IN [1.1] WHERE x = 2.1) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-4-3',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[4] All quantifier on list literal containing floats (example 3)',
        cypher='RETURN all(x IN [1.1, 3.5] WHERE x = 2.1) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-4-4',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[4] All quantifier on list literal containing floats (example 4)',
        cypher='RETURN all(x IN [1.1, 3.5, 20.0, 50.42435] WHERE x = 2.1) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-4-5',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[4] All quantifier on list literal containing floats (example 5)',
        cypher='RETURN all(x IN [20.0, 3.4, 50.2, -2.1] WHERE x = 2.1) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-4-6',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[4] All quantifier on list literal containing floats (example 6)',
        cypher='RETURN all(x IN [2.1] WHERE x = 2.1) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-4-7',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[4] All quantifier on list literal containing floats (example 7)',
        cypher='RETURN all(x IN [1.43, 2.1] WHERE x = 2.1) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-4-8',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[4] All quantifier on list literal containing floats (example 8)',
        cypher='RETURN all(x IN [1.43, 2.1, 3.5] WHERE x = 2.1) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-4-9',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[4] All quantifier on list literal containing floats (example 9)',
        cypher='RETURN all(x IN [2.1, 2.1] WHERE x = 2.1) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-4-10',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[4] All quantifier on list literal containing floats (example 10)',
        cypher='RETURN all(x IN [2.1, 3.5] WHERE x = 2.1) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-4-11',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[4] All quantifier on list literal containing floats (example 11)',
        cypher='RETURN all(x IN [3.5, 2.1, 3.5] WHERE x = 2.1) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-4-12',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[4] All quantifier on list literal containing floats (example 12)',
        cypher='RETURN all(x IN [2.1, 3.5, 2.1] WHERE x = 2.1) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-5-1',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[5] All quantifier on list literal containing strings (example 1)',
        cypher='RETURN all(x IN [] WHERE size(x) = 3) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-5-2',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[5] All quantifier on list literal containing strings (example 2)',
        cypher="RETURN all(x IN ['abc'] WHERE size(x) = 3) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-5-3',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[5] All quantifier on list literal containing strings (example 3)',
        cypher="RETURN all(x IN ['ef'] WHERE size(x) = 3) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-5-4',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[5] All quantifier on list literal containing strings (example 4)',
        cypher="RETURN all(x IN ['abc', 'ef'] WHERE size(x) = 3) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-5-5',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[5] All quantifier on list literal containing strings (example 5)',
        cypher="RETURN all(x IN ['ef', 'abc'] WHERE size(x) = 3) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-5-6',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[5] All quantifier on list literal containing strings (example 6)',
        cypher="RETURN all(x IN ['abc', 'ef', 'abc'] WHERE size(x) = 3) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-5-7',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[5] All quantifier on list literal containing strings (example 7)',
        cypher="RETURN all(x IN ['ef', 'abc', 'ef'] WHERE size(x) = 3) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-5-8',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[5] All quantifier on list literal containing strings (example 8)',
        cypher="RETURN all(x IN ['abc', 'abc', 'abc'] WHERE size(x) = 3) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-5-9',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[5] All quantifier on list literal containing strings (example 9)',
        cypher="RETURN all(x IN ['ef', 'ef', 'ef'] WHERE size(x) = 3) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-6-1',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[6] All quantifier on list literal containing lists (example 1)',
        cypher='RETURN all(x IN [] WHERE size(x) = 3) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-6-2',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[6] All quantifier on list literal containing lists (example 2)',
        cypher='RETURN all(x IN [[1, 2, 3]] WHERE size(x) = 3) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-6-3',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[6] All quantifier on list literal containing lists (example 3)',
        cypher="RETURN all(x IN [['a']] WHERE size(x) = 3) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-6-4',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[6] All quantifier on list literal containing lists (example 4)',
        cypher="RETURN all(x IN [[1, 2, 3], ['a']] WHERE size(x) = 3) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-6-5',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[6] All quantifier on list literal containing lists (example 5)',
        cypher="RETURN all(x IN [['a'], [1, 2, 3]] WHERE size(x) = 3) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-6-6',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[6] All quantifier on list literal containing lists (example 6)',
        cypher="RETURN all(x IN [[1, 2, 3], ['a'], [1, 2, 3]] WHERE size(x) = 3) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-6-7',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[6] All quantifier on list literal containing lists (example 7)',
        cypher="RETURN all(x IN [['a'], [1, 2, 3], ['a']] WHERE size(x) = 3) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-6-8',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[6] All quantifier on list literal containing lists (example 8)',
        cypher='RETURN all(x IN [[1, 2, 3], [1, 2, 3], [1, 2, 3]] WHERE size(x) = 3) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-6-9',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[6] All quantifier on list literal containing lists (example 9)',
        cypher="RETURN all(x IN [['a'], ['a'], ['a']] WHERE size(x) = 3) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-7-1',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[7] All quantifier on list literal containing maps (example 1)',
        cypher='RETURN all(x IN [] WHERE x.a = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-7-2',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[7] All quantifier on list literal containing maps (example 2)',
        cypher='RETURN all(x IN [{a: 2, b: 5}] WHERE x.a = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-7-3',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[7] All quantifier on list literal containing maps (example 3)',
        cypher='RETURN all(x IN [{a: 4}] WHERE x.a = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-7-4',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[7] All quantifier on list literal containing maps (example 4)',
        cypher='RETURN all(x IN [{a: 2, b: 5}, {a: 4}] WHERE x.a = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-7-5',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[7] All quantifier on list literal containing maps (example 5)',
        cypher='RETURN all(x IN [{a: 4}, {a: 2, b: 5}] WHERE x.a = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-7-6',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[7] All quantifier on list literal containing maps (example 6)',
        cypher='RETURN all(x IN [{a: 2, b: 5}, {a: 4}, {a: 2, b: 5}] WHERE x.a = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-7-7',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[7] All quantifier on list literal containing maps (example 7)',
        cypher='RETURN all(x IN [{a: 4}, {a: 2, b: 5}, {a: 4}] WHERE x.a = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-7-8',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[7] All quantifier on list literal containing maps (example 8)',
        cypher='RETURN all(x IN [{a: 2, b: 5}, {a: 2, b: 5}, {a: 2, b: 5}] WHERE x.a = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-7-9',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[7] All quantifier on list literal containing maps (example 9)',
        cypher='RETURN all(x IN [{a: 4}, {a: 4}, {a: 4}] WHERE x.a = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-8',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[8] All quantifier on list containing nodes',
        cypher="MATCH p = (:SNodes)-[*0..3]->(x)\n      WITH tail(nodes(p)) AS nodes\n      RETURN nodes, all(x IN nodes WHERE x.name = 'a') AS result",
        graph=graph_fixture_from_create(
            """
            CREATE (s1:SRelationships), (s2:SNodes)
                  CREATE (a:A {name: 'a'}), (b:B {name: 'b'})
                  CREATE (aa:A {name: 'a'}), (ab:B {name: 'b'}),
                         (ba:A {name: 'a'}), (bb:B {name: 'b'})
                  CREATE (aaa:A {name: 'a'}), (aab:B {name: 'b'}),
                         (aba:A {name: 'a'}), (abb:B {name: 'b'}),
                         (baa:A {name: 'a'}), (bab:B {name: 'b'}),
                         (bba:A {name: 'a'}), (bbb:B {name: 'b'})
                  CREATE (s1)-[:I]->(s2),
                         (s2)-[:RA {name: 'a'}]->(a), (s2)-[:RB {name: 'b'}]->(b)
                  CREATE (a)-[:RA {name: 'a'}]->(aa), (a)-[:RB {name: 'b'}]->(ab),
                         (b)-[:RA {name: 'a'}]->(ba), (b)-[:RB {name: 'b'}]->(bb)
                  CREATE (aa)-[:RA {name: 'a'}]->(aaa), (aa)-[:RB {name: 'b'}]->(aab),
                         (ab)-[:RA {name: 'a'}]->(aba), (ab)-[:RB {name: 'b'}]->(abb),
                         (ba)-[:RA {name: 'a'}]->(baa), (ba)-[:RB {name: 'b'}]->(bab),
                         (bb)-[:RA {name: 'a'}]->(bba), (bb)-[:RB {name: 'b'}]->(bbb)
            """
        ),
        expected=Expected(
            rows=[
            {'nodes': '[]', 'result': 'true'},
            {'nodes': "[(:A {name: 'a'})]", 'result': 'true'},
            {'nodes': "[(:A {name: 'a'}), (:A {name: 'a'})]", 'result': 'true'},
            {'nodes': "[(:A {name: 'a'}), (:A {name: 'a'}), (:A {name: 'a'})]", 'result': 'true'},
            {'nodes': "[(:A {name: 'a'}), (:A {name: 'a'}), (:B {name: 'b'})]", 'result': 'false'},
            {'nodes': "[(:A {name: 'a'}), (:B {name: 'b'})]", 'result': 'false'},
            {'nodes': "[(:A {name: 'a'}), (:B {name: 'b'}), (:A {name: 'a'})]", 'result': 'false'},
            {'nodes': "[(:A {name: 'a'}), (:B {name: 'b'}), (:B {name: 'b'})]", 'result': 'false'},
            {'nodes': "[(:B {name: 'b'})]", 'result': 'false'},
            {'nodes': "[(:B {name: 'b'}), (:A {name: 'a'})]", 'result': 'false'},
            {'nodes': "[(:B {name: 'b'}), (:A {name: 'a'}), (:A {name: 'a'})]", 'result': 'false'},
            {'nodes': "[(:B {name: 'b'}), (:A {name: 'a'}), (:B {name: 'b'})]", 'result': 'false'},
            {'nodes': "[(:B {name: 'b'}), (:B {name: 'b'})]", 'result': 'false'},
            {'nodes': "[(:B {name: 'b'}), (:B {name: 'b'}), (:A {name: 'a'})]", 'result': 'false'},
            {'nodes': "[(:B {name: 'b'}), (:B {name: 'b'}), (:B {name: 'b'})]", 'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-9',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[9] All quantifier on list containing relationships',
        cypher="MATCH p = (:SRelationships)-[*0..4]->(x)\n      WITH tail(relationships(p)) AS relationships, COUNT(*) AS c\n      RETURN relationships, all(x IN relationships WHERE x.name = 'a') AS result",
        graph=graph_fixture_from_create(
            """
            CREATE (s1:SRelationships), (s2:SNodes)
                  CREATE (a:A {name: 'a'}), (b:B {name: 'b'})
                  CREATE (aa:A {name: 'a'}), (ab:B {name: 'b'}),
                         (ba:A {name: 'a'}), (bb:B {name: 'b'})
                  CREATE (aaa:A {name: 'a'}), (aab:B {name: 'b'}),
                         (aba:A {name: 'a'}), (abb:B {name: 'b'}),
                         (baa:A {name: 'a'}), (bab:B {name: 'b'}),
                         (bba:A {name: 'a'}), (bbb:B {name: 'b'})
                  CREATE (s1)-[:I]->(s2),
                         (s2)-[:RA {name: 'a'}]->(a), (s2)-[:RB {name: 'b'}]->(b)
                  CREATE (a)-[:RA {name: 'a'}]->(aa), (a)-[:RB {name: 'b'}]->(ab),
                         (b)-[:RA {name: 'a'}]->(ba), (b)-[:RB {name: 'b'}]->(bb)
                  CREATE (aa)-[:RA {name: 'a'}]->(aaa), (aa)-[:RB {name: 'b'}]->(aab),
                         (ab)-[:RA {name: 'a'}]->(aba), (ab)-[:RB {name: 'b'}]->(abb),
                         (ba)-[:RA {name: 'a'}]->(baa), (ba)-[:RB {name: 'b'}]->(bab),
                         (bb)-[:RA {name: 'a'}]->(bba), (bb)-[:RB {name: 'b'}]->(bbb)
            """
        ),
        expected=Expected(
            rows=[
            {'relationships': '[]', 'result': 'true'},
            {'relationships': "[[:RA {name: 'a'}]]", 'result': 'true'},
            {'relationships': "[[:RA {name: 'a'}], [:RA {name: 'a'}]]", 'result': 'true'},
            {'relationships': "[[:RA {name: 'a'}], [:RA {name: 'a'}], [:RA {name: 'a'}]]", 'result': 'true'},
            {'relationships': "[[:RA {name: 'a'}], [:RA {name: 'a'}], [:RB {name: 'b'}]]", 'result': 'false'},
            {'relationships': "[[:RA {name: 'a'}], [:RB {name: 'b'}]]", 'result': 'false'},
            {'relationships': "[[:RA {name: 'a'}], [:RB {name: 'b'}], [:RA {name: 'a'}]]", 'result': 'false'},
            {'relationships': "[[:RA {name: 'a'}], [:RB {name: 'b'}], [:RB {name: 'b'}]]", 'result': 'false'},
            {'relationships': "[[:RB {name: 'b'}]]", 'result': 'false'},
            {'relationships': "[[:RB {name: 'b'}], [:RA {name: 'a'}]]", 'result': 'false'},
            {'relationships': "[[:RB {name: 'b'}], [:RA {name: 'a'}], [:RA {name: 'a'}]]", 'result': 'false'},
            {'relationships': "[[:RB {name: 'b'}], [:RA {name: 'a'}], [:RB {name: 'b'}]]", 'result': 'false'},
            {'relationships': "[[:RB {name: 'b'}], [:RB {name: 'b'}]]", 'result': 'false'},
            {'relationships': "[[:RB {name: 'b'}], [:RB {name: 'b'}], [:RA {name: 'a'}]]", 'result': 'false'},
            {'relationships': "[[:RB {name: 'b'}], [:RB {name: 'b'}], [:RB {name: 'b'}]]", 'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-10-1',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[10] All quantifier on lists containing nulls (example 1)',
        cypher='RETURN all(x IN [null] WHERE x = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-10-2',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[10] All quantifier on lists containing nulls (example 2)',
        cypher='RETURN all(x IN [null, null] WHERE x = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-10-3',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[10] All quantifier on lists containing nulls (example 3)',
        cypher='RETURN all(x IN [0, null] WHERE x = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-10-4',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[10] All quantifier on lists containing nulls (example 4)',
        cypher='RETURN all(x IN [2, null] WHERE x = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-10-5',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[10] All quantifier on lists containing nulls (example 5)',
        cypher='RETURN all(x IN [null, 2] WHERE x = 2) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-10-6',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[10] All quantifier on lists containing nulls (example 6)',
        cypher='RETURN all(x IN [34, 0, null, 5, 900] WHERE x < 10) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-10-7',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[10] All quantifier on lists containing nulls (example 7)',
        cypher='RETURN all(x IN [34, 10, null, 15, 900] WHERE x < 10) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-10-8',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[10] All quantifier on lists containing nulls (example 8)',
        cypher='RETURN all(x IN [4, 0, null, -15, 9] WHERE x < 10) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-11-1',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[11] All quantifier with IS NULL predicate (example 1)',
        cypher='RETURN all(x IN [] WHERE x IS NULL) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-11-2',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[11] All quantifier with IS NULL predicate (example 2)',
        cypher='RETURN all(x IN [0] WHERE x IS NULL) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-11-3',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[11] All quantifier with IS NULL predicate (example 3)',
        cypher='RETURN all(x IN [34, 0, 8, 900] WHERE x IS NULL) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-11-4',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[11] All quantifier with IS NULL predicate (example 4)',
        cypher='RETURN all(x IN [null] WHERE x IS NULL) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-11-5',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[11] All quantifier with IS NULL predicate (example 5)',
        cypher='RETURN all(x IN [null, null] WHERE x IS NULL) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-11-6',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[11] All quantifier with IS NULL predicate (example 6)',
        cypher='RETURN all(x IN [0, null] WHERE x IS NULL) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-11-7',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[11] All quantifier with IS NULL predicate (example 7)',
        cypher='RETURN all(x IN [2, null] WHERE x IS NULL) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-11-8',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[11] All quantifier with IS NULL predicate (example 8)',
        cypher='RETURN all(x IN [null, 2] WHERE x IS NULL) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-11-9',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[11] All quantifier with IS NULL predicate (example 9)',
        cypher='RETURN all(x IN [34, 0, null, 8, 900] WHERE x IS NULL) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-11-10',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[11] All quantifier with IS NULL predicate (example 10)',
        cypher='RETURN all(x IN [34, 0, null, 8, null] WHERE x IS NULL) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-11-11',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[11] All quantifier with IS NULL predicate (example 11)',
        cypher='RETURN all(x IN [null, 123, null, null] WHERE x IS NULL) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-11-12',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[11] All quantifier with IS NULL predicate (example 12)',
        cypher='RETURN all(x IN [null, null, null, null] WHERE x IS NULL) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-12-1',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[12] All quantifier with IS NOT NULL predicate (example 1)',
        cypher='RETURN all(x IN [] WHERE x IS NOT NULL) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-12-2',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[12] All quantifier with IS NOT NULL predicate (example 2)',
        cypher='RETURN all(x IN [0] WHERE x IS NOT NULL) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-12-3',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[12] All quantifier with IS NOT NULL predicate (example 3)',
        cypher='RETURN all(x IN [34, 0, 8, 900] WHERE x IS NOT NULL) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-12-4',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[12] All quantifier with IS NOT NULL predicate (example 4)',
        cypher='RETURN all(x IN [null] WHERE x IS NOT NULL) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-12-5',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[12] All quantifier with IS NOT NULL predicate (example 5)',
        cypher='RETURN all(x IN [null, null] WHERE x IS NOT NULL) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-12-6',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[12] All quantifier with IS NOT NULL predicate (example 6)',
        cypher='RETURN all(x IN [0, null] WHERE x IS NOT NULL) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-12-7',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[12] All quantifier with IS NOT NULL predicate (example 7)',
        cypher='RETURN all(x IN [2, null] WHERE x IS NOT NULL) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-12-8',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[12] All quantifier with IS NOT NULL predicate (example 8)',
        cypher='RETURN all(x IN [null, 2] WHERE x IS NOT NULL) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-12-9',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[12] All quantifier with IS NOT NULL predicate (example 9)',
        cypher='RETURN all(x IN [34, 0, null, 8, 900] WHERE x IS NOT NULL) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-12-10',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[12] All quantifier with IS NOT NULL predicate (example 10)',
        cypher='RETURN all(x IN [34, 0, null, 8, null] WHERE x IS NOT NULL) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-12-11',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[12] All quantifier with IS NOT NULL predicate (example 11)',
        cypher='RETURN all(x IN [null, 123, null, null] WHERE x IS NOT NULL) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-12-12',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[12] All quantifier with IS NOT NULL predicate (example 12)',
        cypher='RETURN all(x IN [null, null, null, null] WHERE x IS NOT NULL) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-13',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[13] All quantifier is false if the predicate is statically false and the list is not empty',
        cypher="RETURN all(x IN [1, null, true, 4.5, 'abc', false] WHERE false) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-14',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[14] All quantifier is true if the predicate is statically true and the list is not empty',
        cypher="RETURN all(x IN [1, null, true, 4.5, 'abc', false] WHERE true) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-15-1',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[15] Fail all quantifier on type mismatch between list elements and predicate (example 1)',
        cypher="RETURN all(x IN ['Clara'] WHERE x % 2 = 0) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-15-2',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[15] Fail all quantifier on type mismatch between list elements and predicate (example 2)',
        cypher='RETURN all(x IN [false, true] WHERE x % 2 = 0) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier4-15-3',
        feature_path='tck/features/expressions/quantifier/Quantifier4.feature',
        scenario='[15] Fail all quantifier on type mismatch between list elements and predicate (example 3)',
        cypher="RETURN all(x IN ['Clara', 'Bob', 'Dave', 'Alice'] WHERE x % 2 = 0) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Compile-time validation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'syntax-error', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier5-1-1',
        feature_path='tck/features/expressions/quantifier/Quantifier5.feature',
        scenario='[1] None quantifier can nest itself and other quantifiers on nested lists (example 1)',
        cypher="RETURN none(x IN [['abc'], ['abc', 'def']] WHERE none(y IN x WHERE y = 'abc')) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier5-1-2',
        feature_path='tck/features/expressions/quantifier/Quantifier5.feature',
        scenario='[1] None quantifier can nest itself and other quantifiers on nested lists (example 2)',
        cypher="RETURN none(x IN [['abc'], ['abc', 'def']] WHERE none(y IN x WHERE y = 'ghi')) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier5-1-3',
        feature_path='tck/features/expressions/quantifier/Quantifier5.feature',
        scenario='[1] None quantifier can nest itself and other quantifiers on nested lists (example 3)',
        cypher="RETURN none(x IN [['abc'], ['abc', 'def']] WHERE single(y IN x WHERE y = 'ghi')) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier5-1-4',
        feature_path='tck/features/expressions/quantifier/Quantifier5.feature',
        scenario='[1] None quantifier can nest itself and other quantifiers on nested lists (example 4)',
        cypher="RETURN none(x IN [['abc'], ['abc', 'def']] WHERE single(y IN x WHERE y = 'abc')) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier5-1-5',
        feature_path='tck/features/expressions/quantifier/Quantifier5.feature',
        scenario='[1] None quantifier can nest itself and other quantifiers on nested lists (example 5)',
        cypher="RETURN none(x IN [['abc'], ['abc', 'def']] WHERE any(y IN x WHERE y = 'ghi')) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier5-1-6',
        feature_path='tck/features/expressions/quantifier/Quantifier5.feature',
        scenario='[1] None quantifier can nest itself and other quantifiers on nested lists (example 6)',
        cypher="RETURN none(x IN [['abc'], ['abc', 'def']] WHERE any(y IN x WHERE y = 'abc')) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier5-1-7',
        feature_path='tck/features/expressions/quantifier/Quantifier5.feature',
        scenario='[1] None quantifier can nest itself and other quantifiers on nested lists (example 7)',
        cypher="RETURN none(x IN [['abc'], ['abc', 'def']] WHERE all(y IN x WHERE y = 'def')) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier5-1-8',
        feature_path='tck/features/expressions/quantifier/Quantifier5.feature',
        scenario='[1] None quantifier can nest itself and other quantifiers on nested lists (example 8)',
        cypher="RETURN none(x IN [['abc'], ['abc', 'def']] WHERE all(y IN x WHERE y = 'abc')) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier5-2-1',
        feature_path='tck/features/expressions/quantifier/Quantifier5.feature',
        scenario='[2] None quantifier can nest itself and other quantifiers on the same list (example 1)',
        cypher='WITH [1, 2, 3, 4, 5, 6, 7, 8, 9] AS list\n      RETURN none(x IN list WHERE none(y IN list WHERE x <= y)) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier5-2-2',
        feature_path='tck/features/expressions/quantifier/Quantifier5.feature',
        scenario='[2] None quantifier can nest itself and other quantifiers on the same list (example 2)',
        cypher='WITH [1, 2, 3, 4, 5, 6, 7, 8, 9] AS list\n      RETURN none(x IN list WHERE none(y IN list WHERE x < y)) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier5-2-3',
        feature_path='tck/features/expressions/quantifier/Quantifier5.feature',
        scenario='[2] None quantifier can nest itself and other quantifiers on the same list (example 3)',
        cypher='WITH [1, 2, 3, 4, 5, 6, 7, 8, 9] AS list\n      RETURN none(x IN list WHERE single(y IN list WHERE abs(x - y) < 3)) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier5-2-4',
        feature_path='tck/features/expressions/quantifier/Quantifier5.feature',
        scenario='[2] None quantifier can nest itself and other quantifiers on the same list (example 4)',
        cypher='WITH [1, 2, 3, 4, 5, 6, 7, 8, 9] AS list\n      RETURN none(x IN list WHERE single(y IN list WHERE x + y = 15)) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier5-2-5',
        feature_path='tck/features/expressions/quantifier/Quantifier5.feature',
        scenario='[2] None quantifier can nest itself and other quantifiers on the same list (example 5)',
        cypher='WITH [1, 2, 3, 4, 5, 6, 7, 8, 9] AS list\n      RETURN none(x IN list WHERE any(y IN list WHERE x + y < 2)) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier5-2-6',
        feature_path='tck/features/expressions/quantifier/Quantifier5.feature',
        scenario='[2] None quantifier can nest itself and other quantifiers on the same list (example 6)',
        cypher='WITH [1, 2, 3, 4, 5, 6, 7, 8, 9] AS list\n      RETURN none(x IN list WHERE any(y IN list WHERE x + y <= 3)) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier5-2-7',
        feature_path='tck/features/expressions/quantifier/Quantifier5.feature',
        scenario='[2] None quantifier can nest itself and other quantifiers on the same list (example 7)',
        cypher='WITH [1, 2, 3, 4, 5, 6, 7, 8, 9] AS list\n      RETURN none(x IN list WHERE all(y IN list WHERE x < y)) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier5-2-8',
        feature_path='tck/features/expressions/quantifier/Quantifier5.feature',
        scenario='[2] None quantifier can nest itself and other quantifiers on the same list (example 8)',
        cypher='WITH [1, 2, 3, 4, 5, 6, 7, 8, 9] AS list\n      RETURN none(x IN list WHERE all(y IN list WHERE x <= y)) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier5-3-1',
        feature_path='tck/features/expressions/quantifier/Quantifier5.feature',
        scenario='[3] None quantifier is equal the boolean negative of the any quantifier (example 1)',
        cypher='RETURN none(x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE x = 2) = (NOT any(x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE x = 2)) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier5-3-2',
        feature_path='tck/features/expressions/quantifier/Quantifier5.feature',
        scenario='[3] None quantifier is equal the boolean negative of the any quantifier (example 2)',
        cypher='RETURN none(x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE x % 2 = 0) = (NOT any(x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE x % 2 = 0)) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier5-3-3',
        feature_path='tck/features/expressions/quantifier/Quantifier5.feature',
        scenario='[3] None quantifier is equal the boolean negative of the any quantifier (example 3)',
        cypher='RETURN none(x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE x % 3 = 0) = (NOT any(x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE x % 3 = 0)) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier5-3-4',
        feature_path='tck/features/expressions/quantifier/Quantifier5.feature',
        scenario='[3] None quantifier is equal the boolean negative of the any quantifier (example 4)',
        cypher='RETURN none(x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE x < 7) = (NOT any(x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE x < 7)) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier5-3-5',
        feature_path='tck/features/expressions/quantifier/Quantifier5.feature',
        scenario='[3] None quantifier is equal the boolean negative of the any quantifier (example 5)',
        cypher='RETURN none(x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE x >= 3) = (NOT any(x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE x >= 3)) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier5-4-1',
        feature_path='tck/features/expressions/quantifier/Quantifier5.feature',
        scenario='[4] None quantifier is equal the all quantifier on the boolean negative of the predicate (example 1)',
        cypher='RETURN none(x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE x = 2) = all(x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE NOT (x = 2)) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier5-4-2',
        feature_path='tck/features/expressions/quantifier/Quantifier5.feature',
        scenario='[4] None quantifier is equal the all quantifier on the boolean negative of the predicate (example 2)',
        cypher='RETURN none(x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE x % 2 = 0) = all(x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE NOT (x % 2 = 0)) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier5-4-3',
        feature_path='tck/features/expressions/quantifier/Quantifier5.feature',
        scenario='[4] None quantifier is equal the all quantifier on the boolean negative of the predicate (example 3)',
        cypher='RETURN none(x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE x % 3 = 0) = all(x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE NOT (x % 3 = 0)) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier5-4-4',
        feature_path='tck/features/expressions/quantifier/Quantifier5.feature',
        scenario='[4] None quantifier is equal the all quantifier on the boolean negative of the predicate (example 4)',
        cypher='RETURN none(x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE x < 7) = all(x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE NOT (x < 7)) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier5-4-5',
        feature_path='tck/features/expressions/quantifier/Quantifier5.feature',
        scenario='[4] None quantifier is equal the all quantifier on the boolean negative of the predicate (example 5)',
        cypher='RETURN none(x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE x >= 3) = all(x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE NOT (x >= 3)) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier5-5-1',
        feature_path='tck/features/expressions/quantifier/Quantifier5.feature',
        scenario='[5] None quantifier is equal whether the size of the list filtered with same the predicate is zero (example 1)',
        cypher='RETURN none(x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE x = 2) = (size([x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE x = 2 | x]) = 0) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier5-5-2',
        feature_path='tck/features/expressions/quantifier/Quantifier5.feature',
        scenario='[5] None quantifier is equal whether the size of the list filtered with same the predicate is zero (example 2)',
        cypher='RETURN none(x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE x % 2 = 0) = (size([x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE x % 2 = 0 | x]) = 0) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier5-5-3',
        feature_path='tck/features/expressions/quantifier/Quantifier5.feature',
        scenario='[5] None quantifier is equal whether the size of the list filtered with same the predicate is zero (example 3)',
        cypher='RETURN none(x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE x % 3 = 0) = (size([x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE x % 3 = 0 | x]) = 0) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier5-5-4',
        feature_path='tck/features/expressions/quantifier/Quantifier5.feature',
        scenario='[5] None quantifier is equal whether the size of the list filtered with same the predicate is zero (example 4)',
        cypher='RETURN none(x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE x < 7) = (size([x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE x < 7 | x]) = 0) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier5-5-5',
        feature_path='tck/features/expressions/quantifier/Quantifier5.feature',
        scenario='[5] None quantifier is equal whether the size of the list filtered with same the predicate is zero (example 5)',
        cypher='RETURN none(x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE x >= 3) = (size([x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE x >= 3 | x]) = 0) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier6-1-1',
        feature_path='tck/features/expressions/quantifier/Quantifier6.feature',
        scenario='[1] Single quantifier can nest itself and other quantifiers on nested lists (example 1)',
        cypher="RETURN single(x IN [['abc'], ['abc', 'def']] WHERE none(y IN x WHERE y = 'def')) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier6-1-2',
        feature_path='tck/features/expressions/quantifier/Quantifier6.feature',
        scenario='[1] Single quantifier can nest itself and other quantifiers on nested lists (example 2)',
        cypher="RETURN single(x IN [['abc'], ['abc', 'def']] WHERE none(y IN x WHERE y = 'ghi')) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier6-1-3',
        feature_path='tck/features/expressions/quantifier/Quantifier6.feature',
        scenario='[1] Single quantifier can nest itself and other quantifiers on nested lists (example 3)',
        cypher="RETURN single(x IN [['abc'], ['abc', 'def']] WHERE single(y IN x WHERE y = 'def')) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier6-1-4',
        feature_path='tck/features/expressions/quantifier/Quantifier6.feature',
        scenario='[1] Single quantifier can nest itself and other quantifiers on nested lists (example 4)',
        cypher="RETURN single(x IN [['abc'], ['abc', 'def']] WHERE single(y IN x WHERE y = 'abc')) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier6-1-5',
        feature_path='tck/features/expressions/quantifier/Quantifier6.feature',
        scenario='[1] Single quantifier can nest itself and other quantifiers on nested lists (example 5)',
        cypher="RETURN single(x IN [['abc'], ['abc', 'def']] WHERE any(y IN x WHERE y = 'def')) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier6-1-6',
        feature_path='tck/features/expressions/quantifier/Quantifier6.feature',
        scenario='[1] Single quantifier can nest itself and other quantifiers on nested lists (example 6)',
        cypher="RETURN single(x IN [['abc'], ['abc', 'def']] WHERE any(y IN x WHERE y = 'abc')) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier6-1-7',
        feature_path='tck/features/expressions/quantifier/Quantifier6.feature',
        scenario='[1] Single quantifier can nest itself and other quantifiers on nested lists (example 7)',
        cypher="RETURN single(x IN [['abc'], ['abc', 'def']] WHERE all(y IN x WHERE y = 'abc')) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier6-1-8',
        feature_path='tck/features/expressions/quantifier/Quantifier6.feature',
        scenario='[1] Single quantifier can nest itself and other quantifiers on nested lists (example 8)',
        cypher="RETURN single(x IN [['abc'], ['abc', 'def']] WHERE all(y IN x WHERE y = 'def')) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier6-2-1',
        feature_path='tck/features/expressions/quantifier/Quantifier6.feature',
        scenario='[2] Single quantifier can nest itself and other quantifiers on the same list (example 1)',
        cypher='WITH [1, 2, 3, 4, 5, 6, 7, 8, 9] AS list\n      RETURN single(x IN list WHERE none(y IN list WHERE x < y)) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier6-2-2',
        feature_path='tck/features/expressions/quantifier/Quantifier6.feature',
        scenario='[2] Single quantifier can nest itself and other quantifiers on the same list (example 2)',
        cypher='WITH [1, 2, 3, 4, 5, 6, 7, 8, 9] AS list\n      RETURN single(x IN list WHERE none(y IN list WHERE x % y = 0)) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier6-2-3',
        feature_path='tck/features/expressions/quantifier/Quantifier6.feature',
        scenario='[2] Single quantifier can nest itself and other quantifiers on the same list (example 3)',
        cypher='WITH [1, 2, 3, 4, 5, 6, 7, 8, 9] AS list\n      RETURN single(x IN list WHERE single(y IN list WHERE x + y < 5)) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier6-2-4',
        feature_path='tck/features/expressions/quantifier/Quantifier6.feature',
        scenario='[2] Single quantifier can nest itself and other quantifiers on the same list (example 4)',
        cypher='WITH [1, 2, 3, 4, 5, 6, 7, 8, 9] AS list\n      RETURN single(x IN list WHERE single(y IN list WHERE x % y = 1)) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier6-2-5',
        feature_path='tck/features/expressions/quantifier/Quantifier6.feature',
        scenario='[2] Single quantifier can nest itself and other quantifiers on the same list (example 5)',
        cypher='WITH [1, 2, 3, 4, 5, 6, 7, 8, 9] AS list\n      RETURN single(x IN list WHERE any(y IN list WHERE 2 * x + y > 25)) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier6-2-6',
        feature_path='tck/features/expressions/quantifier/Quantifier6.feature',
        scenario='[2] Single quantifier can nest itself and other quantifiers on the same list (example 6)',
        cypher='WITH [1, 2, 3, 4, 5, 6, 7, 8, 9] AS list\n      RETURN single(x IN list WHERE any(y IN list WHERE x < y)) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier6-2-7',
        feature_path='tck/features/expressions/quantifier/Quantifier6.feature',
        scenario='[2] Single quantifier can nest itself and other quantifiers on the same list (example 7)',
        cypher='WITH [1, 2, 3, 4, 5, 6, 7, 8, 9] AS list\n      RETURN single(x IN list WHERE all(y IN list WHERE x <= y)) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier6-2-8',
        feature_path='tck/features/expressions/quantifier/Quantifier6.feature',
        scenario='[2] Single quantifier can nest itself and other quantifiers on the same list (example 8)',
        cypher='WITH [1, 2, 3, 4, 5, 6, 7, 8, 9] AS list\n      RETURN single(x IN list WHERE all(y IN list WHERE x <= y + 1)) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier6-3-1',
        feature_path='tck/features/expressions/quantifier/Quantifier6.feature',
        scenario='[3] Single quantifier is equal whether the size of the list filtered with same the predicate is one (example 1)',
        cypher='RETURN single(x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE x = 2) = (size([x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE x = 2 | x]) = 1) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier6-3-2',
        feature_path='tck/features/expressions/quantifier/Quantifier6.feature',
        scenario='[3] Single quantifier is equal whether the size of the list filtered with same the predicate is one (example 2)',
        cypher='RETURN single(x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE x % 2 = 0) = (size([x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE x % 2 = 0 | x]) = 1) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier6-3-3',
        feature_path='tck/features/expressions/quantifier/Quantifier6.feature',
        scenario='[3] Single quantifier is equal whether the size of the list filtered with same the predicate is one (example 3)',
        cypher='RETURN single(x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE x % 3 = 0) = (size([x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE x % 3 = 0 | x]) = 1) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier6-3-4',
        feature_path='tck/features/expressions/quantifier/Quantifier6.feature',
        scenario='[3] Single quantifier is equal whether the size of the list filtered with same the predicate is one (example 4)',
        cypher='RETURN single(x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE x < 7) = (size([x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE x < 7 | x]) = 1) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier6-3-5',
        feature_path='tck/features/expressions/quantifier/Quantifier6.feature',
        scenario='[3] Single quantifier is equal whether the size of the list filtered with same the predicate is one (example 5)',
        cypher='RETURN single(x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE x >= 3) = (size([x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE x >= 3 | x]) = 1) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier7-1-1',
        feature_path='tck/features/expressions/quantifier/Quantifier7.feature',
        scenario='[1] Any quantifier can nest itself and other quantifiers on nested lists (example 1)',
        cypher="RETURN any(x IN [['abc'], ['abc', 'def']] WHERE none(y IN x WHERE y = 'def')) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier7-1-2',
        feature_path='tck/features/expressions/quantifier/Quantifier7.feature',
        scenario='[1] Any quantifier can nest itself and other quantifiers on nested lists (example 2)',
        cypher="RETURN any(x IN [['abc'], ['abc', 'def']] WHERE none(y IN x WHERE y = 'abc')) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier7-1-3',
        feature_path='tck/features/expressions/quantifier/Quantifier7.feature',
        scenario='[1] Any quantifier can nest itself and other quantifiers on nested lists (example 3)',
        cypher="RETURN any(x IN [['abc'], ['abc', 'def']] WHERE single(y IN x WHERE y = 'def')) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier7-1-4',
        feature_path='tck/features/expressions/quantifier/Quantifier7.feature',
        scenario='[1] Any quantifier can nest itself and other quantifiers on nested lists (example 4)',
        cypher="RETURN any(x IN [['abc'], ['abc', 'def']] WHERE single(y IN x WHERE y = 'ghi')) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier7-1-5',
        feature_path='tck/features/expressions/quantifier/Quantifier7.feature',
        scenario='[1] Any quantifier can nest itself and other quantifiers on nested lists (example 5)',
        cypher="RETURN any(x IN [['abc'], ['abc', 'def']] WHERE any(y IN x WHERE y = 'abc')) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier7-1-6',
        feature_path='tck/features/expressions/quantifier/Quantifier7.feature',
        scenario='[1] Any quantifier can nest itself and other quantifiers on nested lists (example 6)',
        cypher="RETURN any(x IN [['abc'], ['abc', 'def']] WHERE any(y IN x WHERE y = 'ghi')) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier7-1-7',
        feature_path='tck/features/expressions/quantifier/Quantifier7.feature',
        scenario='[1] Any quantifier can nest itself and other quantifiers on nested lists (example 7)',
        cypher="RETURN any(x IN [['abc'], ['abc', 'def']] WHERE all(y IN x WHERE y = 'abc')) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier7-1-8',
        feature_path='tck/features/expressions/quantifier/Quantifier7.feature',
        scenario='[1] Any quantifier can nest itself and other quantifiers on nested lists (example 8)',
        cypher="RETURN any(x IN [['abc'], ['abc', 'def']] WHERE all(y IN x WHERE y = 'def')) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier7-2-1',
        feature_path='tck/features/expressions/quantifier/Quantifier7.feature',
        scenario='[2] Any quantifier can nest itself and other quantifiers on the same list (example 1)',
        cypher='WITH [1, 2, 3, 4, 5, 6, 7, 8, 9] AS list\n      RETURN any(x IN list WHERE none(y IN list WHERE x = y * y)) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier7-2-2',
        feature_path='tck/features/expressions/quantifier/Quantifier7.feature',
        scenario='[2] Any quantifier can nest itself and other quantifiers on the same list (example 2)',
        cypher='WITH [1, 2, 3, 4, 5, 6, 7, 8, 9] AS list\n      RETURN any(x IN list WHERE none(y IN list WHERE x % y = 0)) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier7-2-3',
        feature_path='tck/features/expressions/quantifier/Quantifier7.feature',
        scenario='[2] Any quantifier can nest itself and other quantifiers on the same list (example 3)',
        cypher='WITH [1, 2, 3, 4, 5, 6, 7, 8, 9] AS list\n      RETURN any(x IN list WHERE single(y IN list WHERE x = y * y)) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier7-2-4',
        feature_path='tck/features/expressions/quantifier/Quantifier7.feature',
        scenario='[2] Any quantifier can nest itself and other quantifiers on the same list (example 4)',
        cypher='WITH [1, 2, 3, 4, 5, 6, 7, 8, 9] AS list\n      RETURN any(x IN list WHERE single(y IN list WHERE x < y * y)) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier7-2-5',
        feature_path='tck/features/expressions/quantifier/Quantifier7.feature',
        scenario='[2] Any quantifier can nest itself and other quantifiers on the same list (example 5)',
        cypher='WITH [1, 2, 3, 4, 5, 6, 7, 8, 9] AS list\n      RETURN any(x IN list WHERE any(y IN list WHERE x = y)) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier7-2-6',
        feature_path='tck/features/expressions/quantifier/Quantifier7.feature',
        scenario='[2] Any quantifier can nest itself and other quantifiers on the same list (example 6)',
        cypher='WITH [1, 2, 3, 4, 5, 6, 7, 8, 9] AS list\n      RETURN any(x IN list WHERE any(y IN list WHERE x = 10 * y)) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier7-2-7',
        feature_path='tck/features/expressions/quantifier/Quantifier7.feature',
        scenario='[2] Any quantifier can nest itself and other quantifiers on the same list (example 7)',
        cypher='WITH [1, 2, 3, 4, 5, 6, 7, 8, 9] AS list\n      RETURN any(x IN list WHERE all(y IN list WHERE x <= y)) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier7-2-8',
        feature_path='tck/features/expressions/quantifier/Quantifier7.feature',
        scenario='[2] Any quantifier can nest itself and other quantifiers on the same list (example 8)',
        cypher='WITH [1, 2, 3, 4, 5, 6, 7, 8, 9] AS list\n      RETURN any(x IN list WHERE all(y IN list WHERE x < y)) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier7-3-1',
        feature_path='tck/features/expressions/quantifier/Quantifier7.feature',
        scenario='[3] Any quantifier is true if the single or the all quantifier is true (example 1)',
        cypher='RETURN (single(x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE x = 2) OR all(x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE x = 2)) <= any(<operands>) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier7-3-2',
        feature_path='tck/features/expressions/quantifier/Quantifier7.feature',
        scenario='[3] Any quantifier is true if the single or the all quantifier is true (example 2)',
        cypher='RETURN (single(x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE x % 2 = 0) OR all(x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE x % 2 = 0)) <= any(<operands>) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier7-3-3',
        feature_path='tck/features/expressions/quantifier/Quantifier7.feature',
        scenario='[3] Any quantifier is true if the single or the all quantifier is true (example 3)',
        cypher='RETURN (single(x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE x % 3 = 0) OR all(x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE x % 3 = 0)) <= any(<operands>) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier7-3-4',
        feature_path='tck/features/expressions/quantifier/Quantifier7.feature',
        scenario='[3] Any quantifier is true if the single or the all quantifier is true (example 4)',
        cypher='RETURN (single(x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE x < 7) OR all(x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE x < 7)) <= any(<operands>) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier7-3-5',
        feature_path='tck/features/expressions/quantifier/Quantifier7.feature',
        scenario='[3] Any quantifier is true if the single or the all quantifier is true (example 5)',
        cypher='RETURN (single(x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE x >= 3) OR all(x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE x >= 3)) <= any(<operands>) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier7-4-1',
        feature_path='tck/features/expressions/quantifier/Quantifier7.feature',
        scenario='[4] Any quantifier is equal the boolean negative of the none quantifier (example 1)',
        cypher='RETURN any(x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE x = 2) = (NOT none(x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE x = 2)) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier7-4-2',
        feature_path='tck/features/expressions/quantifier/Quantifier7.feature',
        scenario='[4] Any quantifier is equal the boolean negative of the none quantifier (example 2)',
        cypher='RETURN any(x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE x % 2 = 0) = (NOT none(x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE x % 2 = 0)) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier7-4-3',
        feature_path='tck/features/expressions/quantifier/Quantifier7.feature',
        scenario='[4] Any quantifier is equal the boolean negative of the none quantifier (example 3)',
        cypher='RETURN any(x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE x % 3 = 0) = (NOT none(x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE x % 3 = 0)) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier7-4-4',
        feature_path='tck/features/expressions/quantifier/Quantifier7.feature',
        scenario='[4] Any quantifier is equal the boolean negative of the none quantifier (example 4)',
        cypher='RETURN any(x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE x < 7) = (NOT none(x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE x < 7)) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier7-4-5',
        feature_path='tck/features/expressions/quantifier/Quantifier7.feature',
        scenario='[4] Any quantifier is equal the boolean negative of the none quantifier (example 5)',
        cypher='RETURN any(x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE x >= 3) = (NOT none(x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE x >= 3)) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier7-5-1',
        feature_path='tck/features/expressions/quantifier/Quantifier7.feature',
        scenario='[5] Any quantifier is equal the boolean negative of the all quantifier on the boolean negative of the predicate (example 1)',
        cypher='RETURN any(x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE x = 2) = (NOT all(x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE NOT (x = 2))) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier7-5-2',
        feature_path='tck/features/expressions/quantifier/Quantifier7.feature',
        scenario='[5] Any quantifier is equal the boolean negative of the all quantifier on the boolean negative of the predicate (example 2)',
        cypher='RETURN any(x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE x % 2 = 0) = (NOT all(x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE NOT (x % 2 = 0))) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier7-5-3',
        feature_path='tck/features/expressions/quantifier/Quantifier7.feature',
        scenario='[5] Any quantifier is equal the boolean negative of the all quantifier on the boolean negative of the predicate (example 3)',
        cypher='RETURN any(x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE x % 3 = 0) = (NOT all(x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE NOT (x % 3 = 0))) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier7-5-4',
        feature_path='tck/features/expressions/quantifier/Quantifier7.feature',
        scenario='[5] Any quantifier is equal the boolean negative of the all quantifier on the boolean negative of the predicate (example 4)',
        cypher='RETURN any(x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE x < 7) = (NOT all(x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE NOT (x < 7))) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier7-5-5',
        feature_path='tck/features/expressions/quantifier/Quantifier7.feature',
        scenario='[5] Any quantifier is equal the boolean negative of the all quantifier on the boolean negative of the predicate (example 5)',
        cypher='RETURN any(x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE x >= 3) = (NOT all(x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE NOT (x >= 3))) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier7-6-1',
        feature_path='tck/features/expressions/quantifier/Quantifier7.feature',
        scenario='[6] Any quantifier is equal whether the size of the list filtered with same the predicate is grater zero (example 1)',
        cypher='RETURN any(x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE x = 2) = (size([x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE x = 2 | x]) > 0) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier7-6-2',
        feature_path='tck/features/expressions/quantifier/Quantifier7.feature',
        scenario='[6] Any quantifier is equal whether the size of the list filtered with same the predicate is grater zero (example 2)',
        cypher='RETURN any(x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE x % 2 = 0) = (size([x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE x % 2 = 0 | x]) > 0) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier7-6-3',
        feature_path='tck/features/expressions/quantifier/Quantifier7.feature',
        scenario='[6] Any quantifier is equal whether the size of the list filtered with same the predicate is grater zero (example 3)',
        cypher='RETURN any(x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE x % 3 = 0) = (size([x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE x % 3 = 0 | x]) > 0) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier7-6-4',
        feature_path='tck/features/expressions/quantifier/Quantifier7.feature',
        scenario='[6] Any quantifier is equal whether the size of the list filtered with same the predicate is grater zero (example 4)',
        cypher='RETURN any(x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE x < 7) = (size([x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE x < 7 | x]) > 0) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier7-6-5',
        feature_path='tck/features/expressions/quantifier/Quantifier7.feature',
        scenario='[6] Any quantifier is equal whether the size of the list filtered with same the predicate is grater zero (example 5)',
        cypher='RETURN any(x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE x >= 3) = (size([x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE x >= 3 | x]) > 0) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier8-1-1',
        feature_path='tck/features/expressions/quantifier/Quantifier8.feature',
        scenario='[1] All quantifier can nest itself and other quantifiers on nested lists (example 1)',
        cypher="RETURN all(x IN [['abc'], ['abc', 'def']] WHERE none(y IN x WHERE y = 'ghi')) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier8-1-2',
        feature_path='tck/features/expressions/quantifier/Quantifier8.feature',
        scenario='[1] All quantifier can nest itself and other quantifiers on nested lists (example 2)',
        cypher="RETURN all(x IN [['abc'], ['abc', 'def']] WHERE none(y IN x WHERE y = 'def')) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier8-1-3',
        feature_path='tck/features/expressions/quantifier/Quantifier8.feature',
        scenario='[1] All quantifier can nest itself and other quantifiers on nested lists (example 3)',
        cypher="RETURN all(x IN [['abc'], ['abc', 'def']] WHERE single(y IN x WHERE y = 'abc')) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier8-1-4',
        feature_path='tck/features/expressions/quantifier/Quantifier8.feature',
        scenario='[1] All quantifier can nest itself and other quantifiers on nested lists (example 4)',
        cypher="RETURN all(x IN [['abc'], ['abc', 'def']] WHERE single(y IN x WHERE y = 'ghi')) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier8-1-5',
        feature_path='tck/features/expressions/quantifier/Quantifier8.feature',
        scenario='[1] All quantifier can nest itself and other quantifiers on nested lists (example 5)',
        cypher="RETURN all(x IN [['abc'], ['abc', 'def']] WHERE any(y IN x WHERE y = 'abc')) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier8-1-6',
        feature_path='tck/features/expressions/quantifier/Quantifier8.feature',
        scenario='[1] All quantifier can nest itself and other quantifiers on nested lists (example 6)',
        cypher="RETURN all(x IN [['abc'], ['abc', 'def']] WHERE any(y IN x WHERE y = 'ghi')) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier8-1-7',
        feature_path='tck/features/expressions/quantifier/Quantifier8.feature',
        scenario='[1] All quantifier can nest itself and other quantifiers on nested lists (example 7)',
        cypher="RETURN all(x IN [['abc'], ['abc', 'def']] WHERE all(y IN x WHERE y <> 'ghi')) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier8-1-8',
        feature_path='tck/features/expressions/quantifier/Quantifier8.feature',
        scenario='[1] All quantifier can nest itself and other quantifiers on nested lists (example 8)',
        cypher="RETURN all(x IN [['abc'], ['abc', 'def']] WHERE all(y IN x WHERE y = 'abc')) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier8-2-1',
        feature_path='tck/features/expressions/quantifier/Quantifier8.feature',
        scenario='[2] All quantifier can nest itself and other quantifiers on the same list (example 1)',
        cypher='WITH [1, 2, 3, 4, 5, 6, 7, 8, 9] AS list\n      RETURN all(x IN list WHERE none(y IN list WHERE x = 10 * y)) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier8-2-2',
        feature_path='tck/features/expressions/quantifier/Quantifier8.feature',
        scenario='[2] All quantifier can nest itself and other quantifiers on the same list (example 2)',
        cypher='WITH [1, 2, 3, 4, 5, 6, 7, 8, 9] AS list\n      RETURN all(x IN list WHERE none(y IN list WHERE x = y)) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier8-2-3',
        feature_path='tck/features/expressions/quantifier/Quantifier8.feature',
        scenario='[2] All quantifier can nest itself and other quantifiers on the same list (example 3)',
        cypher='WITH [1, 2, 3, 4, 5, 6, 7, 8, 9] AS list\n      RETURN all(x IN list WHERE single(y IN list WHERE x = y)) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier8-2-4',
        feature_path='tck/features/expressions/quantifier/Quantifier8.feature',
        scenario='[2] All quantifier can nest itself and other quantifiers on the same list (example 4)',
        cypher='WITH [1, 2, 3, 4, 5, 6, 7, 8, 9] AS list\n      RETURN all(x IN list WHERE single(y IN list WHERE x < y)) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier8-2-5',
        feature_path='tck/features/expressions/quantifier/Quantifier8.feature',
        scenario='[2] All quantifier can nest itself and other quantifiers on the same list (example 5)',
        cypher='WITH [1, 2, 3, 4, 5, 6, 7, 8, 9] AS list\n      RETURN all(x IN list WHERE any(y IN list WHERE x % y = 0)) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier8-2-6',
        feature_path='tck/features/expressions/quantifier/Quantifier8.feature',
        scenario='[2] All quantifier can nest itself and other quantifiers on the same list (example 6)',
        cypher='WITH [1, 2, 3, 4, 5, 6, 7, 8, 9] AS list\n      RETURN all(x IN list WHERE any(y IN list WHERE x < y)) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier8-2-7',
        feature_path='tck/features/expressions/quantifier/Quantifier8.feature',
        scenario='[2] All quantifier can nest itself and other quantifiers on the same list (example 7)',
        cypher='WITH [1, 2, 3, 4, 5, 6, 7, 8, 9] AS list\n      RETURN all(x IN list WHERE all(y IN list WHERE abs(x - y) < 10)) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier8-2-8',
        feature_path='tck/features/expressions/quantifier/Quantifier8.feature',
        scenario='[2] All quantifier can nest itself and other quantifiers on the same list (example 8)',
        cypher='WITH [1, 2, 3, 4, 5, 6, 7, 8, 9] AS list\n      RETURN all(x IN list WHERE all(y IN list WHERE x < y + 7)) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier8-3-1',
        feature_path='tck/features/expressions/quantifier/Quantifier8.feature',
        scenario='[3] All quantifier is equal the none quantifier on the boolean negative of the predicate (example 1)',
        cypher='RETURN all(x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE x = 2) = none(x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE NOT (x = 2)) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier8-3-2',
        feature_path='tck/features/expressions/quantifier/Quantifier8.feature',
        scenario='[3] All quantifier is equal the none quantifier on the boolean negative of the predicate (example 2)',
        cypher='RETURN all(x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE x % 2 = 0) = none(x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE NOT (x % 2 = 0)) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier8-3-3',
        feature_path='tck/features/expressions/quantifier/Quantifier8.feature',
        scenario='[3] All quantifier is equal the none quantifier on the boolean negative of the predicate (example 3)',
        cypher='RETURN all(x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE x % 3 = 0) = none(x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE NOT (x % 3 = 0)) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier8-3-4',
        feature_path='tck/features/expressions/quantifier/Quantifier8.feature',
        scenario='[3] All quantifier is equal the none quantifier on the boolean negative of the predicate (example 4)',
        cypher='RETURN all(x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE x < 7) = none(x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE NOT (x < 7)) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier8-3-5',
        feature_path='tck/features/expressions/quantifier/Quantifier8.feature',
        scenario='[3] All quantifier is equal the none quantifier on the boolean negative of the predicate (example 5)',
        cypher='RETURN all(x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE x >= 3) = none(x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE NOT (x >= 3)) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier8-4-1',
        feature_path='tck/features/expressions/quantifier/Quantifier8.feature',
        scenario='[4] All quantifier is equal the boolean negative of the any quantifier on the boolean negative of the predicate (example 1)',
        cypher='RETURN all(x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE x = 2) = (NOT any(x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE NOT (x = 2))) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier8-4-2',
        feature_path='tck/features/expressions/quantifier/Quantifier8.feature',
        scenario='[4] All quantifier is equal the boolean negative of the any quantifier on the boolean negative of the predicate (example 2)',
        cypher='RETURN all(x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE x % 2 = 0) = (NOT any(x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE NOT (x % 2 = 0))) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier8-4-3',
        feature_path='tck/features/expressions/quantifier/Quantifier8.feature',
        scenario='[4] All quantifier is equal the boolean negative of the any quantifier on the boolean negative of the predicate (example 3)',
        cypher='RETURN all(x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE x % 3 = 0) = (NOT any(x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE NOT (x % 3 = 0))) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier8-4-4',
        feature_path='tck/features/expressions/quantifier/Quantifier8.feature',
        scenario='[4] All quantifier is equal the boolean negative of the any quantifier on the boolean negative of the predicate (example 4)',
        cypher='RETURN all(x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE x < 7) = (NOT any(x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE NOT (x < 7))) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier8-4-5',
        feature_path='tck/features/expressions/quantifier/Quantifier8.feature',
        scenario='[4] All quantifier is equal the boolean negative of the any quantifier on the boolean negative of the predicate (example 5)',
        cypher='RETURN all(x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE x >= 3) = (NOT any(x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE NOT (x >= 3))) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier8-5-1',
        feature_path='tck/features/expressions/quantifier/Quantifier8.feature',
        scenario='[5] All quantifier is equal whether the size of the list filtered with same the predicate is equal the size of the unfiltered list (example 1)',
        cypher='RETURN all(x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE x = 2) = (size([x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE x = 2 | x]) = size([1, 2, 3, 4, 5, 6, 7, 8, 9])) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier8-5-2',
        feature_path='tck/features/expressions/quantifier/Quantifier8.feature',
        scenario='[5] All quantifier is equal whether the size of the list filtered with same the predicate is equal the size of the unfiltered list (example 2)',
        cypher='RETURN all(x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE x % 2 = 0) = (size([x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE x % 2 = 0 | x]) = size([1, 2, 3, 4, 5, 6, 7, 8, 9])) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier8-5-3',
        feature_path='tck/features/expressions/quantifier/Quantifier8.feature',
        scenario='[5] All quantifier is equal whether the size of the list filtered with same the predicate is equal the size of the unfiltered list (example 3)',
        cypher='RETURN all(x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE x % 3 = 0) = (size([x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE x % 3 = 0 | x]) = size([1, 2, 3, 4, 5, 6, 7, 8, 9])) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier8-5-4',
        feature_path='tck/features/expressions/quantifier/Quantifier8.feature',
        scenario='[5] All quantifier is equal whether the size of the list filtered with same the predicate is equal the size of the unfiltered list (example 4)',
        cypher='RETURN all(x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE x < 7) = (size([x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE x < 7 | x]) = size([1, 2, 3, 4, 5, 6, 7, 8, 9])) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier8-5-5',
        feature_path='tck/features/expressions/quantifier/Quantifier8.feature',
        scenario='[5] All quantifier is equal whether the size of the list filtered with same the predicate is equal the size of the unfiltered list (example 5)',
        cypher='RETURN all(x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE x >= 3) = (size([x IN [1, 2, 3, 4, 5, 6, 7, 8, 9] WHERE x >= 3 | x]) = size([1, 2, 3, 4, 5, 6, 7, 8, 9])) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier9-1',
        feature_path='tck/features/expressions/quantifier/Quantifier9.feature',
        scenario='[1] None quantifier is always true if the predicate is statically false and the list is not empty',
        cypher="WITH [1, null, true, 4.5, 'abc', false, '', [234, false], {a: null, b: true, c: 15.2}, {}, [], [null], [[{b: [null]}]]] AS inputList\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      WITH list WHERE size(list) > 0\n      WITH none(x IN list WHERE false) AS result, count(*) AS cnt\n      RETURN result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier9-2',
        feature_path='tck/features/expressions/quantifier/Quantifier9.feature',
        scenario='[2] None quantifier is always false if the predicate is statically true and the list is not empty',
        cypher="WITH [1, null, true, 4.5, 'abc', false, '', [234, false], {a: null, b: true, c: 15.2}, {}, [], [null], [[{b: [null]}]]] AS inputList\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      WITH list WHERE size(list) > 0\n      WITH none(x IN list WHERE true) AS result, count(*) AS cnt\n      RETURN result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier9-3-1',
        feature_path='tck/features/expressions/quantifier/Quantifier9.feature',
        scenario='[3] None quantifier is always equal the boolean negative of the any quantifier (example 1)',
        cypher='WITH [1, 2, 3, 4, 5, 6, 7, 8, 9] AS inputList\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      WITH none(x IN list WHERE <predicate>) = (NOT any(x IN list WHERE x = 2)) AS result, count(*) AS cnt\n      RETURN result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier9-3-2',
        feature_path='tck/features/expressions/quantifier/Quantifier9.feature',
        scenario='[3] None quantifier is always equal the boolean negative of the any quantifier (example 2)',
        cypher='WITH [1, 2, 3, 4, 5, 6, 7, 8, 9] AS inputList\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      WITH none(x IN list WHERE <predicate>) = (NOT any(x IN list WHERE x % 2 = 0)) AS result, count(*) AS cnt\n      RETURN result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier9-3-3',
        feature_path='tck/features/expressions/quantifier/Quantifier9.feature',
        scenario='[3] None quantifier is always equal the boolean negative of the any quantifier (example 3)',
        cypher='WITH [1, 2, 3, 4, 5, 6, 7, 8, 9] AS inputList\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      WITH none(x IN list WHERE <predicate>) = (NOT any(x IN list WHERE x % 3 = 0)) AS result, count(*) AS cnt\n      RETURN result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier9-3-4',
        feature_path='tck/features/expressions/quantifier/Quantifier9.feature',
        scenario='[3] None quantifier is always equal the boolean negative of the any quantifier (example 4)',
        cypher='WITH [1, 2, 3, 4, 5, 6, 7, 8, 9] AS inputList\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      WITH none(x IN list WHERE <predicate>) = (NOT any(x IN list WHERE x < 7)) AS result, count(*) AS cnt\n      RETURN result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier9-3-5',
        feature_path='tck/features/expressions/quantifier/Quantifier9.feature',
        scenario='[3] None quantifier is always equal the boolean negative of the any quantifier (example 5)',
        cypher='WITH [1, 2, 3, 4, 5, 6, 7, 8, 9] AS inputList\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      WITH none(x IN list WHERE <predicate>) = (NOT any(x IN list WHERE x >= 3)) AS result, count(*) AS cnt\n      RETURN result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier9-4-1',
        feature_path='tck/features/expressions/quantifier/Quantifier9.feature',
        scenario='[4] None quantifier is always equal the all quantifier on the boolean negative of the predicate (example 1)',
        cypher='WITH [1, 2, 3, 4, 5, 6, 7, 8, 9] AS inputList\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      WITH none(x IN list WHERE <predicate>) = all(x IN list WHERE NOT (x = 2)) AS result, count(*) AS cnt\n      RETURN result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier9-4-2',
        feature_path='tck/features/expressions/quantifier/Quantifier9.feature',
        scenario='[4] None quantifier is always equal the all quantifier on the boolean negative of the predicate (example 2)',
        cypher='WITH [1, 2, 3, 4, 5, 6, 7, 8, 9] AS inputList\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      WITH none(x IN list WHERE <predicate>) = all(x IN list WHERE NOT (x % 2 = 0)) AS result, count(*) AS cnt\n      RETURN result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier9-4-3',
        feature_path='tck/features/expressions/quantifier/Quantifier9.feature',
        scenario='[4] None quantifier is always equal the all quantifier on the boolean negative of the predicate (example 3)',
        cypher='WITH [1, 2, 3, 4, 5, 6, 7, 8, 9] AS inputList\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      WITH none(x IN list WHERE <predicate>) = all(x IN list WHERE NOT (x % 3 = 0)) AS result, count(*) AS cnt\n      RETURN result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier9-4-4',
        feature_path='tck/features/expressions/quantifier/Quantifier9.feature',
        scenario='[4] None quantifier is always equal the all quantifier on the boolean negative of the predicate (example 4)',
        cypher='WITH [1, 2, 3, 4, 5, 6, 7, 8, 9] AS inputList\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      WITH none(x IN list WHERE <predicate>) = all(x IN list WHERE NOT (x < 7)) AS result, count(*) AS cnt\n      RETURN result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier9-4-5',
        feature_path='tck/features/expressions/quantifier/Quantifier9.feature',
        scenario='[4] None quantifier is always equal the all quantifier on the boolean negative of the predicate (example 5)',
        cypher='WITH [1, 2, 3, 4, 5, 6, 7, 8, 9] AS inputList\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      WITH none(x IN list WHERE <predicate>) = all(x IN list WHERE NOT (x >= 3)) AS result, count(*) AS cnt\n      RETURN result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier9-5-1',
        feature_path='tck/features/expressions/quantifier/Quantifier9.feature',
        scenario='[5] None quantifier is always equal whether the size of the list filtered with same the predicate is zero (example 1)',
        cypher='UNWIND [{list: [2], fixed: true},\n              {list: [6], fixed: true},\n              {list: [7], fixed: true},\n              {list: [1, 2, 3, 4, 5, 6, 7, 8, 9], fixed: false}] AS input\n      WITH CASE WHEN input.fixed THEN input.list ELSE null END AS fixedList,\n           CASE WHEN NOT input.fixed THEN input.list ELSE [1] END AS inputList\n      UNWIND inputList AS x\n      WITH fixedList, inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH fixedList, inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH fixedList, inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH fixedList, inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH fixedList, inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH fixedList, inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      WITH coalesce(fixedList, list) AS list\n      WITH none(x IN list WHERE <predicate>) = (size([x IN list WHERE x = 2 | x]) = 0) AS result, count(*) AS cnt\n      RETURN result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier9-5-2',
        feature_path='tck/features/expressions/quantifier/Quantifier9.feature',
        scenario='[5] None quantifier is always equal whether the size of the list filtered with same the predicate is zero (example 2)',
        cypher='UNWIND [{list: [2], fixed: true},\n              {list: [6], fixed: true},\n              {list: [7], fixed: true},\n              {list: [1, 2, 3, 4, 5, 6, 7, 8, 9], fixed: false}] AS input\n      WITH CASE WHEN input.fixed THEN input.list ELSE null END AS fixedList,\n           CASE WHEN NOT input.fixed THEN input.list ELSE [1] END AS inputList\n      UNWIND inputList AS x\n      WITH fixedList, inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH fixedList, inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH fixedList, inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH fixedList, inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH fixedList, inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH fixedList, inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      WITH coalesce(fixedList, list) AS list\n      WITH none(x IN list WHERE <predicate>) = (size([x IN list WHERE x % 2 = 0 | x]) = 0) AS result, count(*) AS cnt\n      RETURN result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier9-5-3',
        feature_path='tck/features/expressions/quantifier/Quantifier9.feature',
        scenario='[5] None quantifier is always equal whether the size of the list filtered with same the predicate is zero (example 3)',
        cypher='UNWIND [{list: [2], fixed: true},\n              {list: [6], fixed: true},\n              {list: [7], fixed: true},\n              {list: [1, 2, 3, 4, 5, 6, 7, 8, 9], fixed: false}] AS input\n      WITH CASE WHEN input.fixed THEN input.list ELSE null END AS fixedList,\n           CASE WHEN NOT input.fixed THEN input.list ELSE [1] END AS inputList\n      UNWIND inputList AS x\n      WITH fixedList, inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH fixedList, inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH fixedList, inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH fixedList, inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH fixedList, inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH fixedList, inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      WITH coalesce(fixedList, list) AS list\n      WITH none(x IN list WHERE <predicate>) = (size([x IN list WHERE x % 3 = 0 | x]) = 0) AS result, count(*) AS cnt\n      RETURN result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier9-5-4',
        feature_path='tck/features/expressions/quantifier/Quantifier9.feature',
        scenario='[5] None quantifier is always equal whether the size of the list filtered with same the predicate is zero (example 4)',
        cypher='UNWIND [{list: [2], fixed: true},\n              {list: [6], fixed: true},\n              {list: [7], fixed: true},\n              {list: [1, 2, 3, 4, 5, 6, 7, 8, 9], fixed: false}] AS input\n      WITH CASE WHEN input.fixed THEN input.list ELSE null END AS fixedList,\n           CASE WHEN NOT input.fixed THEN input.list ELSE [1] END AS inputList\n      UNWIND inputList AS x\n      WITH fixedList, inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH fixedList, inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH fixedList, inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH fixedList, inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH fixedList, inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH fixedList, inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      WITH coalesce(fixedList, list) AS list\n      WITH none(x IN list WHERE <predicate>) = (size([x IN list WHERE x < 7 | x]) = 0) AS result, count(*) AS cnt\n      RETURN result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-quantifier9-5-5',
        feature_path='tck/features/expressions/quantifier/Quantifier9.feature',
        scenario='[5] None quantifier is always equal whether the size of the list filtered with same the predicate is zero (example 5)',
        cypher='UNWIND [{list: [2], fixed: true},\n              {list: [6], fixed: true},\n              {list: [7], fixed: true},\n              {list: [1, 2, 3, 4, 5, 6, 7, 8, 9], fixed: false}] AS input\n      WITH CASE WHEN input.fixed THEN input.list ELSE null END AS fixedList,\n           CASE WHEN NOT input.fixed THEN input.list ELSE [1] END AS inputList\n      UNWIND inputList AS x\n      WITH fixedList, inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH fixedList, inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH fixedList, inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH fixedList, inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      UNWIND inputList AS x\n      WITH fixedList, inputList, x, [ y IN inputList WHERE rand() > 0.5 | y] AS list\n      WITH fixedList, inputList, CASE WHEN rand() < 0.5 THEN reverse(list) ELSE list END + x AS list\n      WITH coalesce(fixedList, list) AS list\n      WITH none(x IN list WHERE <predicate>) = (size([x IN list WHERE x >= 3 | x]) = 0) AS result, count(*) AS cnt\n      RETURN result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'quantifier', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-string1-1',
        feature_path='tck/features/expressions/string/String1.feature',
        scenario='[1] `substring()` with default second argument',
        cypher="RETURN substring('0123456789', 1) AS s",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'s': "'123456789'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'string', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-string10-1',
        feature_path='tck/features/expressions/string/String10.feature',
        scenario='[1] Finding exact matches with non-proper substring',
        cypher="MATCH (a)\n      WHERE a.name CONTAINS 'ABCDEF'\n      RETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:TheLabel {name: 'ABCDEF'}), (:TheLabel {name: 'AB'}),
                         (:TheLabel {name: 'abcdef'}), (:TheLabel {name: 'ab'}),
                         (:TheLabel {name: ''}), (:TheLabel)
            """
        ),
        expected=Expected(
            rows=[
            {'a': "(:TheLabel {name: 'ABCDEF'})"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'string', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-string10-2',
        feature_path='tck/features/expressions/string/String10.feature',
        scenario='[2] Finding substring of string',
        cypher="MATCH (a)\n      WHERE a.name CONTAINS 'CD'\n      RETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:TheLabel {name: 'ABCDEF'}), (:TheLabel {name: 'AB'}),
                         (:TheLabel {name: 'abcdef'}), (:TheLabel {name: 'ab'}),
                         (:TheLabel {name: ''}), (:TheLabel)
            """
        ),
        expected=Expected(
            rows=[
            {'a': "(:TheLabel {name: 'ABCDEF'})"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'string', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-string10-3',
        feature_path='tck/features/expressions/string/String10.feature',
        scenario='[3] Finding the empty substring',
        cypher="MATCH (a)\n      WHERE a.name CONTAINS ''\n      RETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:TheLabel {name: 'ABCDEF'}), (:TheLabel {name: 'AB'}),
                         (:TheLabel {name: 'abcdef'}), (:TheLabel {name: 'ab'}),
                         (:TheLabel {name: ''}), (:TheLabel)
            """
        ),
        expected=Expected(
            rows=[
            {'a': "(:TheLabel {name: 'ABCDEF'})"},
            {'a': "(:TheLabel {name: 'AB'})"},
            {'a': "(:TheLabel {name: 'abcdef'})"},
            {'a': "(:TheLabel {name: 'ab'})"},
            {'a': "(:TheLabel {name: ''})"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'string', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-string10-4',
        feature_path='tck/features/expressions/string/String10.feature',
        scenario='[4] Finding strings containing whitespace',
        cypher="MATCH (a)\n      WHERE a.name CONTAINS ' '\n      RETURN a.name AS name",
        graph=graph_fixture_from_create(
            """
            CREATE (:TheLabel {name: 'ABCDEF'}), (:TheLabel {name: 'AB'}),
                         (:TheLabel {name: 'abcdef'}), (:TheLabel {name: 'ab'}),
                         (:TheLabel {name: ''}), (:TheLabel),
                         (:TheLabel {name: 'Foo Foo'}),
                         (:TheLabel {name: 'Foo\nFoo'}),
                         (:TheLabel {name: 'Foo\tFoo'})
            """
        ),
        expected=Expected(
            rows=[
            {'name': "'Foo Foo'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'string', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-string10-5',
        feature_path='tck/features/expressions/string/String10.feature',
        scenario='[5] Finding strings containing newline',
        cypher="MATCH (a)\n      WHERE a.name CONTAINS '\\n'\n      RETURN a.name AS name",
        graph=graph_fixture_from_create(
            """
            CREATE (:TheLabel {name: 'ABCDEF'}), (:TheLabel {name: 'AB'}),
                         (:TheLabel {name: 'abcdef'}), (:TheLabel {name: 'ab'}),
                         (:TheLabel {name: ''}), (:TheLabel),
                         (:TheLabel {name: 'Foo Foo'}),
                         (:TheLabel {name: 'Foo\nFoo'}),
                         (:TheLabel {name: 'Foo\tFoo'})
            """
        ),
        expected=Expected(
            rows=[
            {'name': "'Foo\\nFoo'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'string', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-string10-6',
        feature_path='tck/features/expressions/string/String10.feature',
        scenario='[6] No string contains null',
        cypher='MATCH (a)\n      WHERE a.name CONTAINS null\n      RETURN a',
        graph=graph_fixture_from_create(
            """
            CREATE (:TheLabel {name: 'ABCDEF'}), (:TheLabel {name: 'AB'}),
                         (:TheLabel {name: 'abcdef'}), (:TheLabel {name: 'ab'}),
                         (:TheLabel {name: ''}), (:TheLabel)
            """
        ),
        expected=Expected(
            rows=[

            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'string', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-string10-7',
        feature_path='tck/features/expressions/string/String10.feature',
        scenario='[7] No string does not contain null',
        cypher='MATCH (a)\n      WHERE NOT a.name CONTAINS null\n      RETURN a',
        graph=graph_fixture_from_create(
            """
            CREATE (:TheLabel {name: 'ABCDEF'}), (:TheLabel {name: 'AB'}),
                         (:TheLabel {name: 'abcdef'}), (:TheLabel {name: 'ab'}),
                         (:TheLabel {name: ''}), (:TheLabel)
            """
        ),
        expected=Expected(
            rows=[

            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'string', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-string10-8',
        feature_path='tck/features/expressions/string/String10.feature',
        scenario='[8] Handling non-string operands for CONTAINS',
        cypher='WITH [1, 3.14, true, [], {}, null] AS operands\n      UNWIND operands AS op1\n      UNWIND operands AS op2\n      WITH op1 CONTAINS op2 AS v\n      RETURN v, count(*)',
        graph=graph_fixture_from_create(
            """
            CREATE (:TheLabel {name: 'ABCDEF'}), (:TheLabel {name: 'AB'}),
                         (:TheLabel {name: 'abcdef'}), (:TheLabel {name: 'ab'}),
                         (:TheLabel {name: ''}), (:TheLabel)
            """
        ),
        expected=Expected(
            rows=[
            {'v': 'null', 'count(*)': 36}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'string', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-string10-9',
        feature_path='tck/features/expressions/string/String10.feature',
        scenario='[9] NOT with CONTAINS',
        cypher="MATCH (a)\n      WHERE NOT a.name CONTAINS 'b'\n      RETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:TheLabel {name: 'ABCDEF'}), (:TheLabel {name: 'AB'}),
                         (:TheLabel {name: 'abcdef'}), (:TheLabel {name: 'ab'}),
                         (:TheLabel {name: ''}), (:TheLabel)
            """
        ),
        expected=Expected(
            rows=[
            {'a': "(:TheLabel {name: 'ABCDEF'})"},
            {'a': "(:TheLabel {name: 'AB'})"},
            {'a': "(:TheLabel {name: ''})"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'string', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-string11-1',
        feature_path='tck/features/expressions/string/String11.feature',
        scenario='[1] Combining prefix and suffix search',
        cypher="MATCH (a)\n      WHERE a.name STARTS WITH 'a'\n        AND a.name ENDS WITH 'f'\n      RETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:TheLabel {name: 'ABCDEF'}), (:TheLabel {name: 'AB'}),
                         (:TheLabel {name: 'abcdef'}), (:TheLabel {name: 'ab'}),
                         (:TheLabel {name: ''}), (:TheLabel)
            """
        ),
        expected=Expected(
            rows=[
            {'a': "(:TheLabel {name: 'abcdef'})"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'string', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-string11-2',
        feature_path='tck/features/expressions/string/String11.feature',
        scenario='[2] Combining prefix, suffix, and substring search',
        cypher="MATCH (a)\n      WHERE a.name STARTS WITH 'A'\n        AND a.name CONTAINS 'C'\n        AND a.name ENDS WITH 'EF'\n      RETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:TheLabel {name: 'ABCDEF'}), (:TheLabel {name: 'AB'}),
                         (:TheLabel {name: 'abcdef'}), (:TheLabel {name: 'ab'}),
                         (:TheLabel {name: ''}), (:TheLabel)
            """
        ),
        expected=Expected(
            rows=[
            {'a': "(:TheLabel {name: 'ABCDEF'})"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'string', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-string3-1',
        feature_path='tck/features/expressions/string/String3.feature',
        scenario='[1] `reverse()`',
        cypher="RETURN reverse('raksO')",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {"reverse('raksO')": "'Oskar'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'string', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-string4-1',
        feature_path='tck/features/expressions/string/String4.feature',
        scenario='[1] `split()`',
        cypher="UNWIND split('one1two', '1') AS item\n      RETURN count(item) AS item",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'item': 2}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'string', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-string8-1',
        feature_path='tck/features/expressions/string/String8.feature',
        scenario='[1] Finding exact matches with non-proper prefix',
        cypher="MATCH (a)\n      WHERE a.name STARTS WITH 'ABCDEF'\n      RETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:TheLabel {name: 'ABCDEF'}), (:TheLabel {name: 'AB'}),
                         (:TheLabel {name: 'abcdef'}), (:TheLabel {name: 'ab'}),
                         (:TheLabel {name: ''}), (:TheLabel)
            """
        ),
        expected=Expected(
            rows=[
            {'a': "(:TheLabel {name: 'ABCDEF'})"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'string', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-string8-2',
        feature_path='tck/features/expressions/string/String8.feature',
        scenario='[2] Finding beginning of string',
        cypher="MATCH (a)\n      WHERE a.name STARTS WITH 'ABC'\n      RETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:TheLabel {name: 'ABCDEF'}), (:TheLabel {name: 'AB'}),
                         (:TheLabel {name: 'abcdef'}), (:TheLabel {name: 'ab'}),
                         (:TheLabel {name: ''}), (:TheLabel)
            """
        ),
        expected=Expected(
            rows=[
            {'a': "(:TheLabel {name: 'ABCDEF'})"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'string', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-string8-3',
        feature_path='tck/features/expressions/string/String8.feature',
        scenario='[3] Finding the empty prefix',
        cypher="MATCH (a)\n      WHERE a.name STARTS WITH ''\n      RETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:TheLabel {name: 'ABCDEF'}), (:TheLabel {name: 'AB'}),
                         (:TheLabel {name: 'abcdef'}), (:TheLabel {name: 'ab'}),
                         (:TheLabel {name: ''}), (:TheLabel)
            """
        ),
        expected=Expected(
            rows=[
            {'a': "(:TheLabel {name: 'ABCDEF'})"},
            {'a': "(:TheLabel {name: 'AB'})"},
            {'a': "(:TheLabel {name: 'abcdef'})"},
            {'a': "(:TheLabel {name: 'ab'})"},
            {'a': "(:TheLabel {name: ''})"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'string', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-string8-4',
        feature_path='tck/features/expressions/string/String8.feature',
        scenario='[4] Finding strings starting with whitespace',
        cypher="MATCH (a)\n      WHERE a.name STARTS WITH ' '\n      RETURN a.name AS name",
        graph=graph_fixture_from_create(
            """
            CREATE (:TheLabel {name: 'ABCDEF'}), (:TheLabel {name: 'AB'}),
                         (:TheLabel {name: 'abcdef'}), (:TheLabel {name: 'ab'}),
                         (:TheLabel {name: ''}), (:TheLabel),
                         (:TheLabel {name: ' Foo '}),
                         (:TheLabel {name: '\nFoo\n'}),
                         (:TheLabel {name: '\tFoo\t'})
            """
        ),
        expected=Expected(
            rows=[
            {'name': "' Foo '"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'string', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-string8-5',
        feature_path='tck/features/expressions/string/String8.feature',
        scenario='[5] Finding strings starting with newline',
        cypher="MATCH (a)\n      WHERE a.name STARTS WITH '\\n'\n      RETURN a.name AS name",
        graph=graph_fixture_from_create(
            """
            CREATE (:TheLabel {name: 'ABCDEF'}), (:TheLabel {name: 'AB'}),
                         (:TheLabel {name: 'abcdef'}), (:TheLabel {name: 'ab'}),
                         (:TheLabel {name: ''}), (:TheLabel),
                         (:TheLabel {name: ' Foo '}),
                         (:TheLabel {name: '\nFoo\n'}),
                         (:TheLabel {name: '\tFoo\t'})
            """
        ),
        expected=Expected(
            rows=[
            {'name': "'\\nFoo\\n'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'string', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-string8-6',
        feature_path='tck/features/expressions/string/String8.feature',
        scenario='[6] No string starts with null',
        cypher='MATCH (a)\n      WHERE a.name STARTS WITH null\n      RETURN a',
        graph=graph_fixture_from_create(
            """
            CREATE (:TheLabel {name: 'ABCDEF'}), (:TheLabel {name: 'AB'}),
                         (:TheLabel {name: 'abcdef'}), (:TheLabel {name: 'ab'}),
                         (:TheLabel {name: ''}), (:TheLabel)
            """
        ),
        expected=Expected(
            rows=[

            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'string', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-string8-7',
        feature_path='tck/features/expressions/string/String8.feature',
        scenario='[7] No string does not start with null',
        cypher='MATCH (a)\n      WHERE NOT a.name STARTS WITH null\n      RETURN a',
        graph=graph_fixture_from_create(
            """
            CREATE (:TheLabel {name: 'ABCDEF'}), (:TheLabel {name: 'AB'}),
                         (:TheLabel {name: 'abcdef'}), (:TheLabel {name: 'ab'}),
                         (:TheLabel {name: ''}), (:TheLabel)
            """
        ),
        expected=Expected(
            rows=[

            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'string', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-string8-8',
        feature_path='tck/features/expressions/string/String8.feature',
        scenario='[8] Handling non-string operands for STARTS WITH',
        cypher='WITH [1, 3.14, true, [], {}, null] AS operands\n      UNWIND operands AS op1\n      UNWIND operands AS op2\n      WITH op1 STARTS WITH op2 AS v\n      RETURN v, count(*)',
        graph=graph_fixture_from_create(
            """
            CREATE (:TheLabel {name: 'ABCDEF'}), (:TheLabel {name: 'AB'}),
                         (:TheLabel {name: 'abcdef'}), (:TheLabel {name: 'ab'}),
                         (:TheLabel {name: ''}), (:TheLabel)
            """
        ),
        expected=Expected(
            rows=[
            {'v': 'null', 'count(*)': 36}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'string', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-string8-9',
        feature_path='tck/features/expressions/string/String8.feature',
        scenario='[9] NOT with STARTS WITH',
        cypher="MATCH (a)\n      WHERE NOT a.name STARTS WITH 'ab'\n      RETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:TheLabel {name: 'ABCDEF'}), (:TheLabel {name: 'AB'}),
                         (:TheLabel {name: 'abcdef'}), (:TheLabel {name: 'ab'}),
                         (:TheLabel {name: ''}), (:TheLabel)
            """
        ),
        expected=Expected(
            rows=[
            {'a': "(:TheLabel {name: 'ABCDEF'})"},
            {'a': "(:TheLabel {name: 'AB'})"},
            {'a': "(:TheLabel {name: ''})"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'string', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-string9-1',
        feature_path='tck/features/expressions/string/String9.feature',
        scenario='[1] Finding exact matches with non-proper suffix',
        cypher="MATCH (a)\n      WHERE a.name ENDS WITH 'AB'\n      RETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:TheLabel {name: 'ABCDEF'}), (:TheLabel {name: 'AB'}),
                         (:TheLabel {name: 'abcdef'}), (:TheLabel {name: 'ab'}),
                         (:TheLabel {name: ''}), (:TheLabel)
            """
        ),
        expected=Expected(
            rows=[
            {'a': "(:TheLabel {name: 'AB'})"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'string', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-string9-2',
        feature_path='tck/features/expressions/string/String9.feature',
        scenario='[2] Finding end of string',
        cypher="MATCH (a)\n      WHERE a.name ENDS WITH 'DEF'\n      RETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:TheLabel {name: 'ABCDEF'}), (:TheLabel {name: 'AB'}),
                         (:TheLabel {name: 'abcdef'}), (:TheLabel {name: 'ab'}),
                         (:TheLabel {name: ''}), (:TheLabel)
            """
        ),
        expected=Expected(
            rows=[
            {'a': "(:TheLabel {name: 'ABCDEF'})"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'string', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-string9-3',
        feature_path='tck/features/expressions/string/String9.feature',
        scenario='[3] Finding the empty suffix',
        cypher="MATCH (a)\n      WHERE a.name ENDS WITH ''\n      RETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:TheLabel {name: 'ABCDEF'}), (:TheLabel {name: 'AB'}),
                         (:TheLabel {name: 'abcdef'}), (:TheLabel {name: 'ab'}),
                         (:TheLabel {name: ''}), (:TheLabel)
            """
        ),
        expected=Expected(
            rows=[
            {'a': "(:TheLabel {name: 'ABCDEF'})"},
            {'a': "(:TheLabel {name: 'AB'})"},
            {'a': "(:TheLabel {name: 'abcdef'})"},
            {'a': "(:TheLabel {name: 'ab'})"},
            {'a': "(:TheLabel {name: ''})"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'string', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-string9-4',
        feature_path='tck/features/expressions/string/String9.feature',
        scenario='[4] Finding strings ending with whitespace',
        cypher="MATCH (a)\n      WHERE a.name ENDS WITH ' '\n      RETURN a.name AS name",
        graph=graph_fixture_from_create(
            """
            CREATE (:TheLabel {name: 'ABCDEF'}), (:TheLabel {name: 'AB'}),
                         (:TheLabel {name: 'abcdef'}), (:TheLabel {name: 'ab'}),
                         (:TheLabel {name: ''}), (:TheLabel),
                         (:TheLabel {name: ' Foo '}),
                         (:TheLabel {name: '\nFoo\n'}),
                         (:TheLabel {name: '\tFoo\t'})
            """
        ),
        expected=Expected(
            rows=[
            {'name': "' Foo '"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'string', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-string9-5',
        feature_path='tck/features/expressions/string/String9.feature',
        scenario='[5] Finding strings ending with newline',
        cypher="MATCH (a)\n      WHERE a.name ENDS WITH '\\n'\n      RETURN a.name AS name",
        graph=graph_fixture_from_create(
            """
            CREATE (:TheLabel {name: 'ABCDEF'}), (:TheLabel {name: 'AB'}),
                         (:TheLabel {name: 'abcdef'}), (:TheLabel {name: 'ab'}),
                         (:TheLabel {name: ''}), (:TheLabel),
                         (:TheLabel {name: ' Foo '}),
                         (:TheLabel {name: '\nFoo\n'}),
                         (:TheLabel {name: '\tFoo\t'})
            """
        ),
        expected=Expected(
            rows=[
            {'name': "'\\nFoo\\n'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'string', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-string9-6',
        feature_path='tck/features/expressions/string/String9.feature',
        scenario='[6] No string ends with null',
        cypher='MATCH (a)\n      WHERE a.name ENDS WITH null\n      RETURN a',
        graph=graph_fixture_from_create(
            """
            CREATE (:TheLabel {name: 'ABCDEF'}), (:TheLabel {name: 'AB'}),
                         (:TheLabel {name: 'abcdef'}), (:TheLabel {name: 'ab'}),
                         (:TheLabel {name: ''}), (:TheLabel)
            """
        ),
        expected=Expected(
            rows=[

            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'string', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-string9-7',
        feature_path='tck/features/expressions/string/String9.feature',
        scenario='[7] No string does not end with null',
        cypher='MATCH (a)\n      WHERE NOT a.name ENDS WITH null\n      RETURN a',
        graph=graph_fixture_from_create(
            """
            CREATE (:TheLabel {name: 'ABCDEF'}), (:TheLabel {name: 'AB'}),
                         (:TheLabel {name: 'abcdef'}), (:TheLabel {name: 'ab'}),
                         (:TheLabel {name: ''}), (:TheLabel)
            """
        ),
        expected=Expected(
            rows=[

            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'string', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-string9-8',
        feature_path='tck/features/expressions/string/String9.feature',
        scenario='[8] Handling non-string operands for ENDS WITH',
        cypher='WITH [1, 3.14, true, [], {}, null] AS operands\n      UNWIND operands AS op1\n      UNWIND operands AS op2\n      WITH op1 ENDS WITH op2 AS v\n      RETURN v, count(*)',
        graph=graph_fixture_from_create(
            """
            CREATE (:TheLabel {name: 'ABCDEF'}), (:TheLabel {name: 'AB'}),
                         (:TheLabel {name: 'abcdef'}), (:TheLabel {name: 'ab'}),
                         (:TheLabel {name: ''}), (:TheLabel)
            """
        ),
        expected=Expected(
            rows=[
            {'v': 'null', 'count(*)': 36}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'string', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-string9-9',
        feature_path='tck/features/expressions/string/String9.feature',
        scenario='[9] NOT with ENDS WITH',
        cypher="MATCH (a)\n      WHERE NOT a.name ENDS WITH 'def'\n      RETURN a",
        graph=graph_fixture_from_create(
            """
            CREATE (:TheLabel {name: 'ABCDEF'}), (:TheLabel {name: 'AB'}),
                         (:TheLabel {name: 'abcdef'}), (:TheLabel {name: 'ab'}),
                         (:TheLabel {name: ''}), (:TheLabel)
            """
        ),
        expected=Expected(
            rows=[
            {'a': "(:TheLabel {name: 'ABCDEF'})"},
            {'a': "(:TheLabel {name: 'AB'})"},
            {'a': "(:TheLabel {name: 'ab'})"},
            {'a': "(:TheLabel {name: ''})"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'string', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-1-1',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[1] Should construct week date (example 1)',
        cypher='RETURN date({year: 1816, week: 1}) AS d',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'d': "'1816-01-01'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-1-2',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[1] Should construct week date (example 2)',
        cypher='RETURN date({year: 1816, week: 52}) AS d',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'d': "'1816-12-23'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-1-3',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[1] Should construct week date (example 3)',
        cypher='RETURN date({year: 1817, week: 1}) AS d',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'d': "'1816-12-30'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-1-4',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[1] Should construct week date (example 4)',
        cypher='RETURN date({year: 1817, week: 10}) AS d',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'d': "'1817-03-03'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-1-5',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[1] Should construct week date (example 5)',
        cypher='RETURN date({year: 1817, week: 30}) AS d',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'d': "'1817-07-21'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-1-6',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[1] Should construct week date (example 6)',
        cypher='RETURN date({year: 1817, week: 52}) AS d',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'d': "'1817-12-22'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-1-7',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[1] Should construct week date (example 7)',
        cypher='RETURN date({year: 1818, week: 1}) AS d',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'d': "'1817-12-29'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-1-8',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[1] Should construct week date (example 8)',
        cypher='RETURN date({year: 1818, week: 52}) AS d',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'d': "'1818-12-21'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-1-9',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[1] Should construct week date (example 9)',
        cypher='RETURN date({year: 1818, week: 53}) AS d',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'d': "'1818-12-28'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-1-10',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[1] Should construct week date (example 10)',
        cypher='RETURN date({year: 1819, week: 1}) AS d',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'d': "'1819-01-04'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-1-11',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[1] Should construct week date (example 11)',
        cypher='RETURN date({year: 1819, week: 52}) AS d',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'d': "'1819-12-27'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-1-12',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[1] Should construct week date (example 12)',
        cypher='RETURN date({dayOfWeek: 2, year: 1817, week: 1}) AS d',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'d': "'1816-12-31'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-1-13',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[1] Should construct week date (example 13)',
        cypher="RETURN date({date: date('1816-12-30'), week: 2, dayOfWeek: 3}) AS d",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'d': "'1817-01-08'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-1-14',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[1] Should construct week date (example 14)',
        cypher="RETURN date({date: date('1816-12-31'), week: 2}) AS d",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'d': "'1817-01-07'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-1-15',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[1] Should construct week date (example 15)',
        cypher="RETURN date({date: date('1816-12-31'), year: 1817, week: 2}) AS d",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'d': "'1817-01-07'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-2-1',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[2] Should construct week localdatetime (example 1)',
        cypher='RETURN localdatetime({year: 1816, week: 1}) AS d',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'d': "'1816-01-01T00:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-2-2',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[2] Should construct week localdatetime (example 2)',
        cypher='RETURN localdatetime({year: 1816, week: 52}) AS d',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'d': "'1816-12-23T00:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-2-3',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[2] Should construct week localdatetime (example 3)',
        cypher='RETURN localdatetime({year: 1817, week: 1}) AS d',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'d': "'1816-12-30T00:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-2-4',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[2] Should construct week localdatetime (example 4)',
        cypher='RETURN localdatetime({year: 1817, week: 10}) AS d',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'d': "'1817-03-03T00:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-2-5',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[2] Should construct week localdatetime (example 5)',
        cypher='RETURN localdatetime({year: 1817, week: 30}) AS d',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'d': "'1817-07-21T00:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-2-6',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[2] Should construct week localdatetime (example 6)',
        cypher='RETURN localdatetime({year: 1817, week: 52}) AS d',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'d': "'1817-12-22T00:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-2-7',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[2] Should construct week localdatetime (example 7)',
        cypher='RETURN localdatetime({year: 1818, week: 1}) AS d',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'d': "'1817-12-29T00:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-2-8',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[2] Should construct week localdatetime (example 8)',
        cypher='RETURN localdatetime({year: 1818, week: 52}) AS d',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'d': "'1818-12-21T00:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-2-9',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[2] Should construct week localdatetime (example 9)',
        cypher='RETURN localdatetime({year: 1818, week: 53}) AS d',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'d': "'1818-12-28T00:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-2-10',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[2] Should construct week localdatetime (example 10)',
        cypher='RETURN localdatetime({year: 1819, week: 1}) AS d',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'d': "'1819-01-04T00:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-2-11',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[2] Should construct week localdatetime (example 11)',
        cypher='RETURN localdatetime({year: 1819, week: 52}) AS d',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'d': "'1819-12-27T00:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-2-12',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[2] Should construct week localdatetime (example 12)',
        cypher='RETURN localdatetime({dayOfWeek: 2, year: 1817, week: 1}) AS d',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'d': "'1816-12-31T00:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-2-13',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[2] Should construct week localdatetime (example 13)',
        cypher="RETURN localdatetime({date: date('1816-12-30'), week: 2, dayOfWeek: 3}) AS d",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'d': "'1817-01-08T00:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-2-14',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[2] Should construct week localdatetime (example 14)',
        cypher="RETURN localdatetime({date: date('1816-12-31'), week: 2}) AS d",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'d': "'1817-01-07T00:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-2-15',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[2] Should construct week localdatetime (example 15)',
        cypher="RETURN localdatetime({date: date('1816-12-31'), year: 1817, week: 2}) AS d",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'d': "'1817-01-07T00:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-3-1',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[3] Should construct week datetime (example 1)',
        cypher='RETURN datetime({year: 1816, week: 1}) AS d',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'d': "'1816-01-01T00:00Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-3-2',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[3] Should construct week datetime (example 2)',
        cypher='RETURN datetime({year: 1816, week: 52}) AS d',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'d': "'1816-12-23T00:00Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-3-3',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[3] Should construct week datetime (example 3)',
        cypher='RETURN datetime({year: 1817, week: 1}) AS d',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'d': "'1816-12-30T00:00Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-3-4',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[3] Should construct week datetime (example 4)',
        cypher='RETURN datetime({year: 1817, week: 10}) AS d',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'d': "'1817-03-03T00:00Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-3-5',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[3] Should construct week datetime (example 5)',
        cypher='RETURN datetime({year: 1817, week: 30}) AS d',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'d': "'1817-07-21T00:00Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-3-6',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[3] Should construct week datetime (example 6)',
        cypher='RETURN datetime({year: 1817, week: 52}) AS d',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'d': "'1817-12-22T00:00Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-3-7',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[3] Should construct week datetime (example 7)',
        cypher='RETURN datetime({year: 1818, week: 1}) AS d',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'d': "'1817-12-29T00:00Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-3-8',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[3] Should construct week datetime (example 8)',
        cypher='RETURN datetime({year: 1818, week: 52}) AS d',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'d': "'1818-12-21T00:00Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-3-9',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[3] Should construct week datetime (example 9)',
        cypher='RETURN datetime({year: 1818, week: 53}) AS d',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'d': "'1818-12-28T00:00Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-3-10',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[3] Should construct week datetime (example 10)',
        cypher='RETURN datetime({year: 1819, week: 1}) AS d',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'d': "'1819-01-04T00:00Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-3-11',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[3] Should construct week datetime (example 11)',
        cypher='RETURN datetime({year: 1819, week: 52}) AS d',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'d': "'1819-12-27T00:00Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-3-12',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[3] Should construct week datetime (example 12)',
        cypher='RETURN datetime({dayOfWeek: 2, year: 1817, week: 1}) AS d',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'d': "'1816-12-31T00:00Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-3-13',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[3] Should construct week datetime (example 13)',
        cypher="RETURN datetime({date: date('1816-12-30'), week: 2, dayOfWeek: 3}) AS d",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'d': "'1817-01-08T00:00Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-3-14',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[3] Should construct week datetime (example 14)',
        cypher="RETURN datetime({date: date('1816-12-31'), week: 2}) AS d",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'d': "'1817-01-07T00:00Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-3-15',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[3] Should construct week datetime (example 15)',
        cypher="RETURN datetime({date: date('1816-12-31'), year: 1817, week: 2}) AS d",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'d': "'1817-01-07T00:00Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-4-1',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[4] Should construct date (example 1)',
        cypher='RETURN date({year: 1984, month: 10, day: 11}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-4-2',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[4] Should construct date (example 2)',
        cypher='RETURN date({year: 1984, month: 10}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-01'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-4-3',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[4] Should construct date (example 3)',
        cypher='RETURN date({year: 1984, week: 10, dayOfWeek: 3}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-03-07'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-4-4',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[4] Should construct date (example 4)',
        cypher='RETURN date({year: 1984, week: 10}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-03-05'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-4-5',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[4] Should construct date (example 5)',
        cypher='RETURN date({year: 1984}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-01-01'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-4-6',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[4] Should construct date (example 6)',
        cypher='RETURN date({year: 1984, ordinalDay: 202}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-07-20'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-4-7',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[4] Should construct date (example 7)',
        cypher='RETURN date({year: 1984, quarter: 3, dayOfQuarter: 45}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-08-14'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-4-8',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[4] Should construct date (example 8)',
        cypher='RETURN date({year: 1984, quarter: 3}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-07-01'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-5-1',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[5] Should construct local time (example 1)',
        cypher='RETURN localtime({hour: 12, minute: 31, second: 14, nanosecond: 789, millisecond: 123, microsecond: 456}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31:14.123456789'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-5-2',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[5] Should construct local time (example 2)',
        cypher='RETURN localtime({hour: 12, minute: 31, second: 14, nanosecond: 645876123}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31:14.645876123'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-5-3',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[5] Should construct local time (example 3)',
        cypher='RETURN localtime({hour: 12, minute: 31, second: 14, microsecond: 645876}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31:14.645876'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-5-4',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[5] Should construct local time (example 4)',
        cypher='RETURN localtime({hour: 12, minute: 31, second: 14, millisecond: 645}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31:14.645'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-5-5',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[5] Should construct local time (example 5)',
        cypher='RETURN localtime({hour: 12, minute: 31, second: 14}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31:14'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-5-6',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[5] Should construct local time (example 6)',
        cypher='RETURN localtime({hour: 12, minute: 31}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-5-7',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[5] Should construct local time (example 7)',
        cypher='RETURN localtime({hour: 12}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-6-1',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[6] Should construct time (example 1)',
        cypher='RETURN time({hour: 12, minute: 31, second: 14, nanosecond: 789, millisecond: 123, microsecond: 456}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31:14.123456789Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-6-2',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[6] Should construct time (example 2)',
        cypher='RETURN time({hour: 12, minute: 31, second: 14, nanosecond: 645876123}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31:14.645876123Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-6-3',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[6] Should construct time (example 3)',
        cypher='RETURN time({hour: 12, minute: 31, second: 14, nanosecond: 3}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31:14.000000003Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-6-4',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[6] Should construct time (example 4)',
        cypher='RETURN time({hour: 12, minute: 31, second: 14, microsecond: 645876}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31:14.645876Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-6-5',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[6] Should construct time (example 5)',
        cypher='RETURN time({hour: 12, minute: 31, second: 14, millisecond: 645}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31:14.645Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-6-6',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[6] Should construct time (example 6)',
        cypher='RETURN time({hour: 12, minute: 31, second: 14}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31:14Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-6-7',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[6] Should construct time (example 7)',
        cypher='RETURN time({hour: 12, minute: 31}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-6-8',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[6] Should construct time (example 8)',
        cypher='RETURN time({hour: 12}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:00Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-6-9',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[6] Should construct time (example 9)',
        cypher="RETURN time({hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31:14.645876123+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-6-10',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[6] Should construct time (example 10)',
        cypher="RETURN time({hour: 12, minute: 31, second: 14, microsecond: 645876, timezone: '+01:00'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31:14.645876+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-6-11',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[6] Should construct time (example 11)',
        cypher="RETURN time({hour: 12, minute: 31, second: 14, millisecond: 645, timezone: '+01:00'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31:14.645+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-6-12',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[6] Should construct time (example 12)',
        cypher="RETURN time({hour: 12, minute: 31, second: 14, timezone: '+01:00'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31:14+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-6-13',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[6] Should construct time (example 13)',
        cypher="RETURN time({hour: 12, minute: 31, timezone: '+01:00'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-6-14',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[6] Should construct time (example 14)',
        cypher="RETURN time({hour: 12, timezone: '+01:00'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:00+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-7-1',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[7] Should construct local date time (example 1)',
        cypher='RETURN localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 789, millisecond: 123, microsecond: 456}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:31:14.123456789'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-7-2',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[7] Should construct local date time (example 2)',
        cypher='RETURN localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:31:14.645876123'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-7-3',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[7] Should construct local date time (example 3)',
        cypher='RETURN localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 3}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:31:14.000000003'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-7-4',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[7] Should construct local date time (example 4)',
        cypher='RETURN localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, microsecond: 645876}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:31:14.645876'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-7-5',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[7] Should construct local date time (example 5)',
        cypher='RETURN localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, millisecond: 645}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:31:14.645'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-7-6',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[7] Should construct local date time (example 6)',
        cypher='RETURN localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:31:14'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-7-7',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[7] Should construct local date time (example 7)',
        cypher='RETURN localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:31'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-7-8',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[7] Should construct local date time (example 8)',
        cypher='RETURN localdatetime({year: 1984, month: 10, day: 11, hour: 12}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-7-9',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[7] Should construct local date time (example 9)',
        cypher='RETURN localdatetime({year: 1984, month: 10, day: 11}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T00:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-7-10',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[7] Should construct local date time (example 10)',
        cypher='RETURN localdatetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31, second: 14, nanosecond: 645876123}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-03-07T12:31:14.645876123'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-7-11',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[7] Should construct local date time (example 11)',
        cypher='RETURN localdatetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31, second: 14, microsecond: 645876}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-03-07T12:31:14.645876'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-7-12',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[7] Should construct local date time (example 12)',
        cypher='RETURN localdatetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31, second: 14, millisecond: 645}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-03-07T12:31:14.645'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-7-13',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[7] Should construct local date time (example 13)',
        cypher='RETURN localdatetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31, second: 14}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-03-07T12:31:14'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-7-14',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[7] Should construct local date time (example 14)',
        cypher='RETURN localdatetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-03-07T12:31'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-7-15',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[7] Should construct local date time (example 15)',
        cypher='RETURN localdatetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-03-07T12:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-7-16',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[7] Should construct local date time (example 16)',
        cypher='RETURN localdatetime({year: 1984, week: 10, dayOfWeek: 3}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-03-07T00:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-7-17',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[7] Should construct local date time (example 17)',
        cypher='RETURN localdatetime({year: 1984, ordinalDay: 202, hour: 12, minute: 31, second: 14, nanosecond: 645876123}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-07-20T12:31:14.645876123'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-7-18',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[7] Should construct local date time (example 18)',
        cypher='RETURN localdatetime({year: 1984, ordinalDay: 202, hour: 12, minute: 31, second: 14, microsecond: 645876}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-07-20T12:31:14.645876'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-7-19',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[7] Should construct local date time (example 19)',
        cypher='RETURN localdatetime({year: 1984, ordinalDay: 202, hour: 12, minute: 31, second: 14, millisecond: 645}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-07-20T12:31:14.645'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-7-20',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[7] Should construct local date time (example 20)',
        cypher='RETURN localdatetime({year: 1984, ordinalDay: 202, hour: 12, minute: 31, second: 14}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-07-20T12:31:14'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-7-21',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[7] Should construct local date time (example 21)',
        cypher='RETURN localdatetime({year: 1984, ordinalDay: 202, hour: 12, minute: 31}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-07-20T12:31'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-7-22',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[7] Should construct local date time (example 22)',
        cypher='RETURN localdatetime({year: 1984, ordinalDay: 202, hour: 12}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-07-20T12:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-7-23',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[7] Should construct local date time (example 23)',
        cypher='RETURN localdatetime({year: 1984, ordinalDay: 202}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-07-20T00:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-7-24',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[7] Should construct local date time (example 24)',
        cypher='RETURN localdatetime({year: 1984, quarter: 3, dayOfQuarter: 45, hour: 12, minute: 31, second: 14, nanosecond: 645876123}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-08-14T12:31:14.645876123'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-7-25',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[7] Should construct local date time (example 25)',
        cypher='RETURN localdatetime({year: 1984, quarter: 3, dayOfQuarter: 45, hour: 12, minute: 31, second: 14, microsecond: 645876}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-08-14T12:31:14.645876'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-7-26',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[7] Should construct local date time (example 26)',
        cypher='RETURN localdatetime({year: 1984, quarter: 3, dayOfQuarter: 45, hour: 12, minute: 31, second: 14, millisecond: 645}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-08-14T12:31:14.645'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-7-27',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[7] Should construct local date time (example 27)',
        cypher='RETURN localdatetime({year: 1984, quarter: 3, dayOfQuarter: 45, hour: 12, minute: 31, second: 14}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-08-14T12:31:14'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-7-28',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[7] Should construct local date time (example 28)',
        cypher='RETURN localdatetime({year: 1984, quarter: 3, dayOfQuarter: 45, hour: 12, minute: 31}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-08-14T12:31'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-7-29',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[7] Should construct local date time (example 29)',
        cypher='RETURN localdatetime({year: 1984, quarter: 3, dayOfQuarter: 45, hour: 12}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-08-14T12:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-7-30',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[7] Should construct local date time (example 30)',
        cypher='RETURN localdatetime({year: 1984, quarter: 3, dayOfQuarter: 45}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-08-14T00:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-7-31',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[7] Should construct local date time (example 31)',
        cypher='RETURN localdatetime({year: 1984}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-01-01T00:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-8-1',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[8] Should construct date time with default time zone (example 1)',
        cypher='RETURN datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 789, millisecond: 123, microsecond: 456}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:31:14.123456789Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-8-2',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[8] Should construct date time with default time zone (example 2)',
        cypher='RETURN datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:31:14.645876123Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-8-3',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[8] Should construct date time with default time zone (example 3)',
        cypher='RETURN datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, microsecond: 645876}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:31:14.645876Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-8-4',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[8] Should construct date time with default time zone (example 4)',
        cypher='RETURN datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, millisecond: 645}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:31:14.645Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-8-5',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[8] Should construct date time with default time zone (example 5)',
        cypher='RETURN datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:31:14Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-8-6',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[8] Should construct date time with default time zone (example 6)',
        cypher='RETURN datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:31Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-8-7',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[8] Should construct date time with default time zone (example 7)',
        cypher='RETURN datetime({year: 1984, month: 10, day: 11, hour: 12}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:00Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-8-8',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[8] Should construct date time with default time zone (example 8)',
        cypher='RETURN datetime({year: 1984, month: 10, day: 11}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T00:00Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-8-9',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[8] Should construct date time with default time zone (example 9)',
        cypher='RETURN datetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31, second: 14, nanosecond: 645876123}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-03-07T12:31:14.645876123Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-8-10',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[8] Should construct date time with default time zone (example 10)',
        cypher='RETURN datetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31, second: 14, microsecond: 645876}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-03-07T12:31:14.645876Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-8-11',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[8] Should construct date time with default time zone (example 11)',
        cypher='RETURN datetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31, second: 14, millisecond: 645}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-03-07T12:31:14.645Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-8-12',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[8] Should construct date time with default time zone (example 12)',
        cypher='RETURN datetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31, second: 14}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-03-07T12:31:14Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-8-13',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[8] Should construct date time with default time zone (example 13)',
        cypher='RETURN datetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-03-07T12:31Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-8-14',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[8] Should construct date time with default time zone (example 14)',
        cypher='RETURN datetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-03-07T12:00Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-8-15',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[8] Should construct date time with default time zone (example 15)',
        cypher='RETURN datetime({year: 1984, week: 10, dayOfWeek: 3}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-03-07T00:00Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-8-16',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[8] Should construct date time with default time zone (example 16)',
        cypher='RETURN datetime({year: 1984, ordinalDay: 202, hour: 12, minute: 31, second: 14, nanosecond: 645876123}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-07-20T12:31:14.645876123Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-8-17',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[8] Should construct date time with default time zone (example 17)',
        cypher='RETURN datetime({year: 1984, ordinalDay: 202, hour: 12, minute: 31, second: 14, microsecond: 645876}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-07-20T12:31:14.645876Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-8-18',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[8] Should construct date time with default time zone (example 18)',
        cypher='RETURN datetime({year: 1984, ordinalDay: 202, hour: 12, minute: 31, second: 14, millisecond: 645}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-07-20T12:31:14.645Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-8-19',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[8] Should construct date time with default time zone (example 19)',
        cypher='RETURN datetime({year: 1984, ordinalDay: 202, hour: 12, minute: 31, second: 14}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-07-20T12:31:14Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-8-20',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[8] Should construct date time with default time zone (example 20)',
        cypher='RETURN datetime({year: 1984, ordinalDay: 202, hour: 12, minute: 31}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-07-20T12:31Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-8-21',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[8] Should construct date time with default time zone (example 21)',
        cypher='RETURN datetime({year: 1984, ordinalDay: 202, hour: 12}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-07-20T12:00Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-8-22',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[8] Should construct date time with default time zone (example 22)',
        cypher='RETURN datetime({year: 1984, ordinalDay: 202}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-07-20T00:00Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-8-23',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[8] Should construct date time with default time zone (example 23)',
        cypher='RETURN datetime({year: 1984, quarter: 3, dayOfQuarter: 45, hour: 12, minute: 31, second: 14, nanosecond: 645876123}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-08-14T12:31:14.645876123Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-8-24',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[8] Should construct date time with default time zone (example 24)',
        cypher='RETURN datetime({year: 1984, quarter: 3, dayOfQuarter: 45, hour: 12, minute: 31, second: 14, microsecond: 645876}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-08-14T12:31:14.645876Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-8-25',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[8] Should construct date time with default time zone (example 25)',
        cypher='RETURN datetime({year: 1984, quarter: 3, dayOfQuarter: 45, hour: 12, minute: 31, second: 14, millisecond: 645}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-08-14T12:31:14.645Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-8-26',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[8] Should construct date time with default time zone (example 26)',
        cypher='RETURN datetime({year: 1984, quarter: 3, dayOfQuarter: 45, hour: 12, minute: 31, second: 14}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-08-14T12:31:14Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-8-27',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[8] Should construct date time with default time zone (example 27)',
        cypher='RETURN datetime({year: 1984, quarter: 3, dayOfQuarter: 45, hour: 12, minute: 31}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-08-14T12:31Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-8-28',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[8] Should construct date time with default time zone (example 28)',
        cypher='RETURN datetime({year: 1984, quarter: 3, dayOfQuarter: 45, hour: 12}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-08-14T12:00Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-8-29',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[8] Should construct date time with default time zone (example 29)',
        cypher='RETURN datetime({year: 1984, quarter: 3, dayOfQuarter: 45}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-08-14T00:00Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-8-30',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[8] Should construct date time with default time zone (example 30)',
        cypher='RETURN datetime({year: 1984}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-01-01T00:00Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-9-1',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[9] Should construct date time with offset time zone (example 1)',
        cypher="RETURN datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:31:14.645876123+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-9-2',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[9] Should construct date time with offset time zone (example 2)',
        cypher="RETURN datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, microsecond: 645876, timezone: '+01:00'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:31:14.645876+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-9-3',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[9] Should construct date time with offset time zone (example 3)',
        cypher="RETURN datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, millisecond: 645, timezone: '+01:00'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:31:14.645+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-9-4',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[9] Should construct date time with offset time zone (example 4)',
        cypher="RETURN datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, timezone: '+01:00'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:31:14+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-9-5',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[9] Should construct date time with offset time zone (example 5)',
        cypher="RETURN datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, timezone: '+01:00'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:31+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-9-6',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[9] Should construct date time with offset time zone (example 6)',
        cypher="RETURN datetime({year: 1984, month: 10, day: 11, hour: 12, timezone: '+01:00'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:00+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-9-7',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[9] Should construct date time with offset time zone (example 7)',
        cypher="RETURN datetime({year: 1984, month: 10, day: 11, timezone: '+01:00'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T00:00+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-9-8',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[9] Should construct date time with offset time zone (example 8)',
        cypher="RETURN datetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-03-07T12:31:14.645876123+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-9-9',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[9] Should construct date time with offset time zone (example 9)',
        cypher="RETURN datetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31, second: 14, microsecond: 645876, timezone: '+01:00'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-03-07T12:31:14.645876+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-9-10',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[9] Should construct date time with offset time zone (example 10)',
        cypher="RETURN datetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31, second: 14, millisecond: 645, timezone: '+01:00'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-03-07T12:31:14.645+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-9-11',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[9] Should construct date time with offset time zone (example 11)',
        cypher="RETURN datetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31, second: 14, timezone: '+01:00'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-03-07T12:31:14+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-9-12',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[9] Should construct date time with offset time zone (example 12)',
        cypher="RETURN datetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31, timezone: '+01:00'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-03-07T12:31+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-9-13',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[9] Should construct date time with offset time zone (example 13)',
        cypher="RETURN datetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, timezone: '+01:00'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-03-07T12:00+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-9-14',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[9] Should construct date time with offset time zone (example 14)',
        cypher="RETURN datetime({year: 1984, week: 10, dayOfWeek: 3, timezone: '+01:00'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-03-07T00:00+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-9-15',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[9] Should construct date time with offset time zone (example 15)',
        cypher="RETURN datetime({year: 1984, ordinalDay: 202, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-07-20T12:31:14.645876123+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-9-16',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[9] Should construct date time with offset time zone (example 16)',
        cypher="RETURN datetime({year: 1984, ordinalDay: 202, hour: 12, minute: 31, second: 14, microsecond: 645876, timezone: '+01:00'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-07-20T12:31:14.645876+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-9-17',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[9] Should construct date time with offset time zone (example 17)',
        cypher="RETURN datetime({year: 1984, ordinalDay: 202, hour: 12, minute: 31, second: 14, millisecond: 645, timezone: '+01:00'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-07-20T12:31:14.645+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-9-18',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[9] Should construct date time with offset time zone (example 18)',
        cypher="RETURN datetime({year: 1984, ordinalDay: 202, hour: 12, minute: 31, second: 14, timezone: '+01:00'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-07-20T12:31:14+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-9-19',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[9] Should construct date time with offset time zone (example 19)',
        cypher="RETURN datetime({year: 1984, ordinalDay: 202, hour: 12, minute: 31, timezone: '+01:00'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-07-20T12:31+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-9-20',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[9] Should construct date time with offset time zone (example 20)',
        cypher="RETURN datetime({year: 1984, ordinalDay: 202, hour: 12, timezone: '+01:00'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-07-20T12:00+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-9-21',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[9] Should construct date time with offset time zone (example 21)',
        cypher="RETURN datetime({year: 1984, ordinalDay: 202, timezone: '+01:00'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-07-20T00:00+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-9-22',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[9] Should construct date time with offset time zone (example 22)',
        cypher="RETURN datetime({year: 1984, quarter: 3, dayOfQuarter: 45, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-08-14T12:31:14.645876123+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-9-23',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[9] Should construct date time with offset time zone (example 23)',
        cypher="RETURN datetime({year: 1984, quarter: 3, dayOfQuarter: 45, hour: 12, minute: 31, second: 14, microsecond: 645876, timezone: '+01:00'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-08-14T12:31:14.645876+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-9-24',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[9] Should construct date time with offset time zone (example 24)',
        cypher="RETURN datetime({year: 1984, quarter: 3, dayOfQuarter: 45, hour: 12, minute: 31, second: 14, millisecond: 645, timezone: '+01:00'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-08-14T12:31:14.645+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-9-25',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[9] Should construct date time with offset time zone (example 25)',
        cypher="RETURN datetime({year: 1984, quarter: 3, dayOfQuarter: 45, hour: 12, minute: 31, second: 14, timezone: '+01:00'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-08-14T12:31:14+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-9-26',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[9] Should construct date time with offset time zone (example 26)',
        cypher="RETURN datetime({year: 1984, quarter: 3, dayOfQuarter: 45, hour: 12, minute: 31, timezone: '+01:00'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-08-14T12:31+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-9-27',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[9] Should construct date time with offset time zone (example 27)',
        cypher="RETURN datetime({year: 1984, quarter: 3, dayOfQuarter: 45, hour: 12, timezone: '+01:00'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-08-14T12:00+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-9-28',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[9] Should construct date time with offset time zone (example 28)',
        cypher="RETURN datetime({year: 1984, quarter: 3, dayOfQuarter: 45, timezone: '+01:00'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-08-14T00:00+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-9-29',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[9] Should construct date time with offset time zone (example 29)',
        cypher="RETURN datetime({year: 1984, timezone: '+01:00'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-01-01T00:00+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-10-1',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[10] Should construct date time with named time zone (example 1)',
        cypher="RETURN datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: 'Europe/Stockholm'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:31:14.645876123+01:00[Europe/Stockholm]'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-10-2',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[10] Should construct date time with named time zone (example 2)',
        cypher="RETURN datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, microsecond: 645876, timezone: 'Europe/Stockholm'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:31:14.645876+01:00[Europe/Stockholm]'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-10-3',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[10] Should construct date time with named time zone (example 3)',
        cypher="RETURN datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, millisecond: 645, timezone: 'Europe/Stockholm'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:31:14.645+01:00[Europe/Stockholm]'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-10-4',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[10] Should construct date time with named time zone (example 4)',
        cypher="RETURN datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, timezone: 'Europe/Stockholm'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:31:14+01:00[Europe/Stockholm]'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-10-5',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[10] Should construct date time with named time zone (example 5)',
        cypher="RETURN datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, timezone: 'Europe/Stockholm'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:31+01:00[Europe/Stockholm]'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-10-6',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[10] Should construct date time with named time zone (example 6)',
        cypher="RETURN datetime({year: 1984, month: 10, day: 11, hour: 12, timezone: 'Europe/Stockholm'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:00+01:00[Europe/Stockholm]'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-10-7',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[10] Should construct date time with named time zone (example 7)',
        cypher="RETURN datetime({year: 1984, month: 10, day: 11, timezone: 'Europe/Stockholm'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T00:00+01:00[Europe/Stockholm]'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-10-8',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[10] Should construct date time with named time zone (example 8)',
        cypher="RETURN datetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: 'Europe/Stockholm'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-03-07T12:31:14.645876123+01:00[Europe/Stockholm]'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-10-9',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[10] Should construct date time with named time zone (example 9)',
        cypher="RETURN datetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31, second: 14, microsecond: 645876, timezone: 'Europe/Stockholm'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-03-07T12:31:14.645876+01:00[Europe/Stockholm]'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-10-10',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[10] Should construct date time with named time zone (example 10)',
        cypher="RETURN datetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31, second: 14, millisecond: 645, timezone: 'Europe/Stockholm'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-03-07T12:31:14.645+01:00[Europe/Stockholm]'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-10-11',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[10] Should construct date time with named time zone (example 11)',
        cypher="RETURN datetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31, second: 14, timezone: 'Europe/Stockholm'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-03-07T12:31:14+01:00[Europe/Stockholm]'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-10-12',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[10] Should construct date time with named time zone (example 12)',
        cypher="RETURN datetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31, timezone: 'Europe/Stockholm'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-03-07T12:31+01:00[Europe/Stockholm]'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-10-13',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[10] Should construct date time with named time zone (example 13)',
        cypher="RETURN datetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, timezone: 'Europe/Stockholm'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-03-07T12:00+01:00[Europe/Stockholm]'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-10-14',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[10] Should construct date time with named time zone (example 14)',
        cypher="RETURN datetime({year: 1984, week: 10, dayOfWeek: 3, timezone: 'Europe/Stockholm'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-03-07T00:00+01:00[Europe/Stockholm]'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-10-15',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[10] Should construct date time with named time zone (example 15)',
        cypher="RETURN datetime({year: 1984, ordinalDay: 202, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: 'Europe/Stockholm'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-07-20T12:31:14.645876123+02:00[Europe/Stockholm]'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-10-16',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[10] Should construct date time with named time zone (example 16)',
        cypher="RETURN datetime({year: 1984, ordinalDay: 202, hour: 12, minute: 31, second: 14, microsecond: 645876, timezone: 'Europe/Stockholm'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-07-20T12:31:14.645876+02:00[Europe/Stockholm]'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-10-17',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[10] Should construct date time with named time zone (example 17)',
        cypher="RETURN datetime({year: 1984, ordinalDay: 202, hour: 12, minute: 31, second: 14, millisecond: 645, timezone: 'Europe/Stockholm'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-07-20T12:31:14.645+02:00[Europe/Stockholm]'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-10-18',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[10] Should construct date time with named time zone (example 18)',
        cypher="RETURN datetime({year: 1984, ordinalDay: 202, hour: 12, minute: 31, second: 14, timezone: 'Europe/Stockholm'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-07-20T12:31:14+02:00[Europe/Stockholm]'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-10-19',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[10] Should construct date time with named time zone (example 19)',
        cypher="RETURN datetime({year: 1984, ordinalDay: 202, hour: 12, minute: 31, timezone: 'Europe/Stockholm'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-07-20T12:31+02:00[Europe/Stockholm]'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-10-20',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[10] Should construct date time with named time zone (example 20)',
        cypher="RETURN datetime({year: 1984, ordinalDay: 202, hour: 12, timezone: 'Europe/Stockholm'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-07-20T12:00+02:00[Europe/Stockholm]'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-10-21',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[10] Should construct date time with named time zone (example 21)',
        cypher="RETURN datetime({year: 1984, ordinalDay: 202, timezone: 'Europe/Stockholm'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-07-20T00:00+02:00[Europe/Stockholm]'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-10-22',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[10] Should construct date time with named time zone (example 22)',
        cypher="RETURN datetime({year: 1984, quarter: 3, dayOfQuarter: 45, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: 'Europe/Stockholm'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-08-14T12:31:14.645876123+02:00[Europe/Stockholm]'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-10-23',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[10] Should construct date time with named time zone (example 23)',
        cypher="RETURN datetime({year: 1984, quarter: 3, dayOfQuarter: 45, hour: 12, minute: 31, second: 14, microsecond: 645876, timezone: 'Europe/Stockholm'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-08-14T12:31:14.645876+02:00[Europe/Stockholm]'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-10-24',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[10] Should construct date time with named time zone (example 24)',
        cypher="RETURN datetime({year: 1984, quarter: 3, dayOfQuarter: 45, hour: 12, minute: 31, second: 14, millisecond: 645, timezone: 'Europe/Stockholm'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-08-14T12:31:14.645+02:00[Europe/Stockholm]'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-10-25',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[10] Should construct date time with named time zone (example 25)',
        cypher="RETURN datetime({year: 1984, quarter: 3, dayOfQuarter: 45, hour: 12, minute: 31, second: 14, timezone: 'Europe/Stockholm'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-08-14T12:31:14+02:00[Europe/Stockholm]'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-10-26',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[10] Should construct date time with named time zone (example 26)',
        cypher="RETURN datetime({year: 1984, quarter: 3, dayOfQuarter: 45, hour: 12, minute: 31, timezone: 'Europe/Stockholm'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-08-14T12:31+02:00[Europe/Stockholm]'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-10-27',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[10] Should construct date time with named time zone (example 27)',
        cypher="RETURN datetime({year: 1984, quarter: 3, dayOfQuarter: 45, hour: 12, timezone: 'Europe/Stockholm'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-08-14T12:00+02:00[Europe/Stockholm]'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-10-28',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[10] Should construct date time with named time zone (example 28)',
        cypher="RETURN datetime({year: 1984, quarter: 3, dayOfQuarter: 45, timezone: 'Europe/Stockholm'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-08-14T00:00+02:00[Europe/Stockholm]'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-10-29',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[10] Should construct date time with named time zone (example 29)',
        cypher="RETURN datetime({year: 1984, timezone: 'Europe/Stockholm'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-01-01T00:00+01:00[Europe/Stockholm]'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-11',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[11] Should construct date time from epoch',
        cypher='RETURN datetime.fromepoch(416779, 999999999) AS d1,\n             datetime.fromepochmillis(237821673987) AS d2',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'d1': "'1970-01-05T19:46:19.999999999Z'", 'd2': "'1977-07-15T13:34:33.987Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-12-1',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[12] Should construct duration (example 1)',
        cypher='RETURN duration({days: 14, hours: 16, minutes: 12}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'P14DT16H12M'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-12-2',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[12] Should construct duration (example 2)',
        cypher='RETURN duration({months: 5, days: 1.5}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'P5M1DT12H'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-12-3',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[12] Should construct duration (example 3)',
        cypher='RETURN duration({months: 0.75}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'P22DT19H51M49.5S'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-12-4',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[12] Should construct duration (example 4)',
        cypher='RETURN duration({weeks: 2.5}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'P17DT12H'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-12-5',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[12] Should construct duration (example 5)',
        cypher='RETURN duration({years: 12, months: 5, days: 14, hours: 16, minutes: 12, seconds: 70}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'P12Y5M14DT16H13M10S'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-12-6',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[12] Should construct duration (example 6)',
        cypher='RETURN duration({days: 14, seconds: 70, milliseconds: 1}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'P14DT1M10.001S'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-12-7',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[12] Should construct duration (example 7)',
        cypher='RETURN duration({days: 14, seconds: 70, microseconds: 1}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'P14DT1M10.000001S'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-12-8',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[12] Should construct duration (example 8)',
        cypher='RETURN duration({days: 14, seconds: 70, nanoseconds: 1}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'P14DT1M10.000000001S'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-12-9',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[12] Should construct duration (example 9)',
        cypher='RETURN duration({minutes: 1.5, seconds: 1}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'PT1M31S'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-13-1',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[13] Should construct temporal with time offset with second precision (example 1)',
        cypher="RETURN time({hour: 12, minute: 34, second: 56, timezone: '+02:05:00'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:34:56+02:05'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-13-2',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[13] Should construct temporal with time offset with second precision (example 2)',
        cypher="RETURN time({hour: 12, minute: 34, second: 56, timezone: '+02:05:59'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:34:56+02:05:59'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-13-3',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[13] Should construct temporal with time offset with second precision (example 3)',
        cypher="RETURN time({hour: 12, minute: 34, second: 56, timezone: '-02:05:07'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:34:56-02:05:07'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal1-13-4',
        feature_path='tck/features/expressions/temporal/Temporal1.feature',
        scenario='[13] Should construct temporal with time offset with second precision (example 4)',
        cypher="RETURN datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 34, second: 56, timezone: '+02:05:59'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:34:56+02:05:59'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-1-1',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[1] Should split between boundaries correctly (example 1)',
        cypher="WITH duration.between(localdatetime('2018-01-01T12:00'), localdatetime('2018-01-02T10:00')) AS dur\n      RETURN dur, dur.days, dur.seconds, dur.nanosecondsOfSecond",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'dur': "'PT22H'", 'dur.days': 0, 'dur.seconds': 79200, 'dur.nanosecondsOfSecond': 0}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-1-2',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[1] Should split between boundaries correctly (example 2)',
        cypher="WITH duration.between(localdatetime('2018-01-02T10:00'), localdatetime('2018-01-01T12:00')) AS dur\n      RETURN dur, dur.days, dur.seconds, dur.nanosecondsOfSecond",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'dur': "'PT-22H'", 'dur.days': 0, 'dur.seconds': -79200, 'dur.nanosecondsOfSecond': 0}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-1-3',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[1] Should split between boundaries correctly (example 3)',
        cypher="WITH duration.between(localdatetime('2018-01-01T10:00:00.2'), localdatetime('2018-01-02T10:00:00.1')) AS dur\n      RETURN dur, dur.days, dur.seconds, dur.nanosecondsOfSecond",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'dur': "'PT23H59M59.9S'", 'dur.days': 0, 'dur.seconds': 86399, 'dur.nanosecondsOfSecond': 900000000}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-1-4',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[1] Should split between boundaries correctly (example 4)',
        cypher="WITH duration.between(localdatetime('2018-01-02T10:00:00.1'), localdatetime('2018-01-01T10:00:00.2')) AS dur\n      RETURN dur, dur.days, dur.seconds, dur.nanosecondsOfSecond",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'dur': "'PT-23H-59M-59.9S'", 'dur.days': 0, 'dur.seconds': -86400, 'dur.nanosecondsOfSecond': 100000000}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-1-5',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[1] Should split between boundaries correctly (example 5)',
        cypher="WITH duration.between(datetime('2017-10-28T23:00+02:00[Europe/Stockholm]'), datetime('2017-10-29T04:00+01:00[Europe/Stockholm]')) AS dur\n      RETURN dur, dur.days, dur.seconds, dur.nanosecondsOfSecond",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'dur': "'PT6H'", 'dur.days': 0, 'dur.seconds': 21600, 'dur.nanosecondsOfSecond': 0}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-1-6',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[1] Should split between boundaries correctly (example 6)',
        cypher="WITH duration.between(datetime('2017-10-29T04:00+01:00[Europe/Stockholm]'), datetime('2017-10-28T23:00+02:00[Europe/Stockholm]')) AS dur\n      RETURN dur, dur.days, dur.seconds, dur.nanosecondsOfSecond",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'dur': "'PT-6H'", 'dur.days': 0, 'dur.seconds': -21600, 'dur.nanosecondsOfSecond': 0}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-2-1',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[2] Should compute duration between two temporals (example 1)',
        cypher="RETURN duration.between(date('1984-10-11'), date('2015-06-24')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'P30Y8M13D'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-2-2',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[2] Should compute duration between two temporals (example 2)',
        cypher="RETURN duration.between(date('1984-10-11'), localdatetime('2016-07-21T21:45:22.142')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'P31Y9M10DT21H45M22.142S'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-2-3',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[2] Should compute duration between two temporals (example 3)',
        cypher="RETURN duration.between(date('1984-10-11'), datetime('2015-07-21T21:40:32.142+0100')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'P30Y9M10DT21H40M32.142S'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-2-4',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[2] Should compute duration between two temporals (example 4)',
        cypher="RETURN duration.between(date('1984-10-11'), localtime('16:30')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'PT16H30M'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-2-5',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[2] Should compute duration between two temporals (example 5)',
        cypher="RETURN duration.between(date('1984-10-11'), time('16:30+0100')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'PT16H30M'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-2-6',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[2] Should compute duration between two temporals (example 6)',
        cypher="RETURN duration.between(localtime('14:30'), date('2015-06-24')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'PT-14H-30M'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-2-7',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[2] Should compute duration between two temporals (example 7)',
        cypher="RETURN duration.between(localtime('14:30'), localdatetime('2016-07-21T21:45:22.142')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'PT7H15M22.142S'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-2-8',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[2] Should compute duration between two temporals (example 8)',
        cypher="RETURN duration.between(localtime('14:30'), datetime('2015-07-21T21:40:32.142+0100')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'PT7H10M32.142S'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-2-9',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[2] Should compute duration between two temporals (example 9)',
        cypher="RETURN duration.between(localtime('14:30'), localtime('16:30')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'PT2H'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-2-10',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[2] Should compute duration between two temporals (example 10)',
        cypher="RETURN duration.between(localtime('14:30'), time('16:30+0100')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'PT2H'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-2-11',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[2] Should compute duration between two temporals (example 11)',
        cypher="RETURN duration.between(time('14:30'), date('2015-06-24')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'PT-14H-30M'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-2-12',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[2] Should compute duration between two temporals (example 12)',
        cypher="RETURN duration.between(time('14:30'), localdatetime('2016-07-21T21:45:22.142')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'PT7H15M22.142S'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-2-13',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[2] Should compute duration between two temporals (example 13)',
        cypher="RETURN duration.between(time('14:30'), datetime('2015-07-21T21:40:32.142+0100')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'PT6H10M32.142S'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-2-14',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[2] Should compute duration between two temporals (example 14)',
        cypher="RETURN duration.between(time('14:30'), localtime('16:30')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'PT2H'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-2-15',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[2] Should compute duration between two temporals (example 15)',
        cypher="RETURN duration.between(time('14:30'), time('16:30+0100')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'PT1H'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-2-16',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[2] Should compute duration between two temporals (example 16)',
        cypher="RETURN duration.between(localdatetime('2015-07-21T21:40:32.142'), date('2015-06-24')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'P-27DT-21H-40M-32.142S'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-2-17',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[2] Should compute duration between two temporals (example 17)',
        cypher="RETURN duration.between(localdatetime('2015-07-21T21:40:32.142'), localdatetime('2016-07-21T21:45:22.142')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'P1YT4M50S'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-2-18',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[2] Should compute duration between two temporals (example 18)',
        cypher="RETURN duration.between(localdatetime('2015-07-21T21:40:32.142'), datetime('2015-07-21T21:40:32.142+0100')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'PT0S'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-2-19',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[2] Should compute duration between two temporals (example 19)',
        cypher="RETURN duration.between(localdatetime('2015-07-21T21:40:32.142'), localtime('16:30')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'PT-5H-10M-32.142S'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-2-20',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[2] Should compute duration between two temporals (example 20)',
        cypher="RETURN duration.between(localdatetime('2015-07-21T21:40:32.142'), time('16:30+0100')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'PT-5H-10M-32.142S'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-2-21',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[2] Should compute duration between two temporals (example 21)',
        cypher="RETURN duration.between(datetime('2014-07-21T21:40:36.143+0200'), date('2015-06-24')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'P11M2DT2H19M23.857S'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-2-22',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[2] Should compute duration between two temporals (example 22)',
        cypher="RETURN duration.between(datetime('2014-07-21T21:40:36.143+0200'), localdatetime('2016-07-21T21:45:22.142')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'P2YT4M45.999S'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-2-23',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[2] Should compute duration between two temporals (example 23)',
        cypher="RETURN duration.between(datetime('2014-07-21T21:40:36.143+0200'), datetime('2015-07-21T21:40:32.142+0100')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'P1YT59M55.999S'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-2-24',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[2] Should compute duration between two temporals (example 24)',
        cypher="RETURN duration.between(datetime('2014-07-21T21:40:36.143+0200'), localtime('16:30')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'PT-5H-10M-36.143S'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-2-25',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[2] Should compute duration between two temporals (example 25)',
        cypher="RETURN duration.between(datetime('2014-07-21T21:40:36.143+0200'), time('16:30+0100')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'PT-4H-10M-36.143S'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-3-1',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[3] Should compute duration between two temporals in months (example 1)',
        cypher="RETURN duration.inMonths(date('1984-10-11'), date('2015-06-24')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'P30Y8M'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-3-2',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[3] Should compute duration between two temporals in months (example 2)',
        cypher="RETURN duration.inMonths(date('1984-10-11'), localdatetime('2016-07-21T21:45:22.142')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'P31Y9M'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-3-3',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[3] Should compute duration between two temporals in months (example 3)',
        cypher="RETURN duration.inMonths(date('1984-10-11'), datetime('2015-07-21T21:40:32.142+0100')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'P30Y9M'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-3-4',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[3] Should compute duration between two temporals in months (example 4)',
        cypher="RETURN duration.inMonths(date('1984-10-11'), localtime('16:30')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'PT0S'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-3-5',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[3] Should compute duration between two temporals in months (example 5)',
        cypher="RETURN duration.inMonths(date('1984-10-11'), time('16:30+0100')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'PT0S'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-3-6',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[3] Should compute duration between two temporals in months (example 6)',
        cypher="RETURN duration.inMonths(localtime('14:30'), date('2015-06-24')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'PT0S'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-3-7',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[3] Should compute duration between two temporals in months (example 7)',
        cypher="RETURN duration.inMonths(localtime('14:30'), localdatetime('2016-07-21T21:45:22.142')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'PT0S'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-3-8',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[3] Should compute duration between two temporals in months (example 8)',
        cypher="RETURN duration.inMonths(localtime('14:30'), datetime('2015-07-21T21:40:32.142+0100')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'PT0S'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-3-9',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[3] Should compute duration between two temporals in months (example 9)',
        cypher="RETURN duration.inMonths(time('14:30'), date('2015-06-24')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'PT0S'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-3-10',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[3] Should compute duration between two temporals in months (example 10)',
        cypher="RETURN duration.inMonths(time('14:30'), localdatetime('2016-07-21T21:45:22.142')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'PT0S'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-3-11',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[3] Should compute duration between two temporals in months (example 11)',
        cypher="RETURN duration.inMonths(time('14:30'), datetime('2015-07-21T21:40:32.142+0100')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'PT0S'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-3-12',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[3] Should compute duration between two temporals in months (example 12)',
        cypher="RETURN duration.inMonths(localdatetime('2015-07-21T21:40:32.142'), date('2015-06-24')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'PT0S'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-3-13',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[3] Should compute duration between two temporals in months (example 13)',
        cypher="RETURN duration.inMonths(localdatetime('2015-07-21T21:40:32.142'), localdatetime('2016-07-21T21:45:22.142')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'P1Y'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-3-14',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[3] Should compute duration between two temporals in months (example 14)',
        cypher="RETURN duration.inMonths(localdatetime('2015-07-21T21:40:32.142'), datetime('2015-07-21T21:40:32.142+0100')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'PT0S'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-3-15',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[3] Should compute duration between two temporals in months (example 15)',
        cypher="RETURN duration.inMonths(localdatetime('2015-07-21T21:40:32.142'), localtime('16:30')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'PT0S'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-3-16',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[3] Should compute duration between two temporals in months (example 16)',
        cypher="RETURN duration.inMonths(localdatetime('2015-07-21T21:40:32.142'), time('16:30+0100')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'PT0S'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-3-17',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[3] Should compute duration between two temporals in months (example 17)',
        cypher="RETURN duration.inMonths(datetime('2014-07-21T21:40:36.143+0200'), date('2015-06-24')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'P11M'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-3-18',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[3] Should compute duration between two temporals in months (example 18)',
        cypher="RETURN duration.inMonths(datetime('2014-07-21T21:40:36.143+0200'), localdatetime('2016-07-21T21:45:22.142')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'P2Y'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-3-19',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[3] Should compute duration between two temporals in months (example 19)',
        cypher="RETURN duration.inMonths(datetime('2014-07-21T21:40:36.143+0200'), datetime('2015-07-21T21:40:32.142+0100')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'P1Y'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-3-20',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[3] Should compute duration between two temporals in months (example 20)',
        cypher="RETURN duration.inMonths(datetime('2014-07-21T21:40:36.143+0200'), localtime('16:30')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'PT0S'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-3-21',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[3] Should compute duration between two temporals in months (example 21)',
        cypher="RETURN duration.inMonths(datetime('2014-07-21T21:40:36.143+0200'), time('16:30+0100')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'PT0S'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-4-1',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[4] Should compute duration between two temporals in days (example 1)',
        cypher="RETURN duration.inDays(date('1984-10-11'), date('2015-06-24')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'P11213D'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-4-2',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[4] Should compute duration between two temporals in days (example 2)',
        cypher="RETURN duration.inDays(date('1984-10-11'), localdatetime('2016-07-21T21:45:22.142')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'P11606D'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-4-3',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[4] Should compute duration between two temporals in days (example 3)',
        cypher="RETURN duration.inDays(date('1984-10-11'), datetime('2015-07-21T21:40:32.142+0100')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'P11240D'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-4-4',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[4] Should compute duration between two temporals in days (example 4)',
        cypher="RETURN duration.inDays(date('1984-10-11'), localtime('16:30')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'PT0S'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-4-5',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[4] Should compute duration between two temporals in days (example 5)',
        cypher="RETURN duration.inDays(date('1984-10-11'), time('16:30+0100')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'PT0S'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-4-6',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[4] Should compute duration between two temporals in days (example 6)',
        cypher="RETURN duration.inDays(localtime('14:30'), date('2015-06-24')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'PT0S'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-4-7',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[4] Should compute duration between two temporals in days (example 7)',
        cypher="RETURN duration.inDays(localtime('14:30'), localdatetime('2016-07-21T21:45:22.142')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'PT0S'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-4-8',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[4] Should compute duration between two temporals in days (example 8)',
        cypher="RETURN duration.inDays(localtime('14:30'), datetime('2015-07-21T21:40:32.142+0100')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'PT0S'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-4-9',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[4] Should compute duration between two temporals in days (example 9)',
        cypher="RETURN duration.inDays(time('14:30'), date('2015-06-24')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'PT0S'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-4-10',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[4] Should compute duration between two temporals in days (example 10)',
        cypher="RETURN duration.inDays(time('14:30'), localdatetime('2016-07-21T21:45:22.142')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'PT0S'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-4-11',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[4] Should compute duration between two temporals in days (example 11)',
        cypher="RETURN duration.inDays(time('14:30'), datetime('2015-07-21T21:40:32.142+0100')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'PT0S'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-4-12',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[4] Should compute duration between two temporals in days (example 12)',
        cypher="RETURN duration.inDays(localdatetime('2015-07-21T21:40:32.142'), date('2015-06-24')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'P-27D'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-4-13',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[4] Should compute duration between two temporals in days (example 13)',
        cypher="RETURN duration.inDays(localdatetime('2015-07-21T21:40:32.142'), localdatetime('2016-07-21T21:45:22.142')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'P366D'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-4-14',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[4] Should compute duration between two temporals in days (example 14)',
        cypher="RETURN duration.inDays(localdatetime('2015-07-21T21:40:32.142'), datetime('2015-07-21T21:40:32.142+0100')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'PT0S'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-4-15',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[4] Should compute duration between two temporals in days (example 15)',
        cypher="RETURN duration.inDays(localdatetime('2015-07-21T21:40:32.142'), localtime('16:30')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'PT0S'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-4-16',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[4] Should compute duration between two temporals in days (example 16)',
        cypher="RETURN duration.inDays(localdatetime('2015-07-21T21:40:32.142'), time('16:30+0100')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'PT0S'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-4-17',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[4] Should compute duration between two temporals in days (example 17)',
        cypher="RETURN duration.inDays(datetime('2014-07-21T21:40:36.143+0200'), date('2015-06-24')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'P337D'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-4-18',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[4] Should compute duration between two temporals in days (example 18)',
        cypher="RETURN duration.inDays(datetime('2014-07-21T21:40:36.143+0200'), localdatetime('2016-07-21T21:45:22.142')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'P731D'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-4-19',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[4] Should compute duration between two temporals in days (example 19)',
        cypher="RETURN duration.inDays(datetime('2014-07-21T21:40:36.143+0200'), datetime('2015-07-21T21:40:32.142+0100')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'P365D'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-4-20',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[4] Should compute duration between two temporals in days (example 20)',
        cypher="RETURN duration.inDays(datetime('2014-07-21T21:40:36.143+0200'), localtime('16:30')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'PT0S'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-4-21',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[4] Should compute duration between two temporals in days (example 21)',
        cypher="RETURN duration.inDays(datetime('2014-07-21T21:40:36.143+0200'), time('16:30+0100')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'PT0S'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-5-1',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[5] Should compute duration between two temporals in seconds (example 1)',
        cypher="RETURN duration.inSeconds(date('1984-10-11'), date('2015-06-24')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'PT269112H'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-5-2',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[5] Should compute duration between two temporals in seconds (example 2)',
        cypher="RETURN duration.inSeconds(date('1984-10-11'), localdatetime('2016-07-21T21:45:22.142')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'PT278565H45M22.142S'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-5-3',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[5] Should compute duration between two temporals in seconds (example 3)',
        cypher="RETURN duration.inSeconds(date('1984-10-11'), datetime('2015-07-21T21:40:32.142+0100')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'PT269781H40M32.142S'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-5-4',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[5] Should compute duration between two temporals in seconds (example 4)',
        cypher="RETURN duration.inSeconds(date('1984-10-11'), localtime('16:30')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'PT16H30M'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-5-5',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[5] Should compute duration between two temporals in seconds (example 5)',
        cypher="RETURN duration.inSeconds(date('1984-10-11'), time('16:30+0100')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'PT16H30M'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-5-6',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[5] Should compute duration between two temporals in seconds (example 6)',
        cypher="RETURN duration.inSeconds(localtime('14:30'), date('2015-06-24')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'PT-14H-30M'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-5-7',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[5] Should compute duration between two temporals in seconds (example 7)',
        cypher="RETURN duration.inSeconds(localtime('14:30'), localdatetime('2016-07-21T21:45:22.142')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'PT7H15M22.142S'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-5-8',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[5] Should compute duration between two temporals in seconds (example 8)',
        cypher="RETURN duration.inSeconds(localtime('14:30'), datetime('2015-07-21T21:40:32.142+0100')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'PT7H10M32.142S'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-5-9',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[5] Should compute duration between two temporals in seconds (example 9)',
        cypher="RETURN duration.inSeconds(localtime('14:30'), localtime('16:30')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'PT2H'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-5-10',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[5] Should compute duration between two temporals in seconds (example 10)',
        cypher="RETURN duration.inSeconds(localtime('14:30'), time('16:30+0100')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'PT2H'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-5-11',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[5] Should compute duration between two temporals in seconds (example 11)',
        cypher="RETURN duration.inSeconds(time('14:30'), date('2015-06-24')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'PT-14H-30M'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-5-12',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[5] Should compute duration between two temporals in seconds (example 12)',
        cypher="RETURN duration.inSeconds(time('14:30'), localdatetime('2016-07-21T21:45:22.142')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'PT7H15M22.142S'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-5-13',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[5] Should compute duration between two temporals in seconds (example 13)',
        cypher="RETURN duration.inSeconds(time('14:30'), datetime('2015-07-21T21:40:32.142+0100')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'PT6H10M32.142S'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-5-14',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[5] Should compute duration between two temporals in seconds (example 14)',
        cypher="RETURN duration.inSeconds(time('14:30'), localtime('16:30')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'PT2H'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-5-15',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[5] Should compute duration between two temporals in seconds (example 15)',
        cypher="RETURN duration.inSeconds(time('14:30'), time('16:30+0100')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'PT1H'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-5-16',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[5] Should compute duration between two temporals in seconds (example 16)',
        cypher="RETURN duration.inSeconds(localdatetime('2015-07-21T21:40:32.142'), date('2015-06-24')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'PT-669H-40M-32.142S'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-5-17',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[5] Should compute duration between two temporals in seconds (example 17)',
        cypher="RETURN duration.inSeconds(localdatetime('2015-07-21T21:40:32.142'), localdatetime('2016-07-21T21:45:22.142')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'PT8784H4M50S'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-5-18',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[5] Should compute duration between two temporals in seconds (example 18)',
        cypher="RETURN duration.inSeconds(localdatetime('2015-07-21T21:40:32.142'), datetime('2015-07-21T21:40:32.142+0100')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'PT0S'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-5-19',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[5] Should compute duration between two temporals in seconds (example 19)',
        cypher="RETURN duration.inSeconds(localdatetime('2015-07-21T21:40:32.142'), localtime('16:30')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'PT-5H-10M-32.142S'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-5-20',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[5] Should compute duration between two temporals in seconds (example 20)',
        cypher="RETURN duration.inSeconds(localdatetime('2015-07-21T21:40:32.142'), time('16:30+0100')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'PT-5H-10M-32.142S'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-5-21',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[5] Should compute duration between two temporals in seconds (example 21)',
        cypher="RETURN duration.inSeconds(datetime('2014-07-21T21:40:36.143+0200'), date('2015-06-24')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'PT8090H19M23.857S'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-5-22',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[5] Should compute duration between two temporals in seconds (example 22)',
        cypher="RETURN duration.inSeconds(datetime('2014-07-21T21:40:36.143+0200'), localdatetime('2016-07-21T21:45:22.142')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'PT17544H4M45.999S'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-5-23',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[5] Should compute duration between two temporals in seconds (example 23)',
        cypher="RETURN duration.inSeconds(datetime('2014-07-21T21:40:36.143+0200'), datetime('2015-07-21T21:40:32.142+0100')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'PT8760H59M55.999S'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-5-24',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[5] Should compute duration between two temporals in seconds (example 24)',
        cypher="RETURN duration.inSeconds(datetime('2014-07-21T21:40:36.143+0200'), localtime('16:30')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'PT-5H-10M-36.143S'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-5-25',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[5] Should compute duration between two temporals in seconds (example 25)',
        cypher="RETURN duration.inSeconds(datetime('2014-07-21T21:40:36.143+0200'), time('16:30+0100')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'PT-4H-10M-36.143S'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-6',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[6] Should compute duration between if they differ only by a fraction of a second and the first comes after the second.',
        cypher="RETURN duration.inSeconds(localdatetime('2014-07-21T21:40:36.143'), localdatetime('2014-07-21T21:40:36.142')) AS d",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'d': "'PT-0.001S'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-7-1',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[7] Should compute negative duration between in big units (example 1)',
        cypher="RETURN duration.inMonths(date('2018-03-11'), date('2016-06-24')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'P-1Y-8M'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-7-2',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[7] Should compute negative duration between in big units (example 2)',
        cypher="RETURN duration.inMonths(date('2018-07-21'), datetime('2016-07-21T21:40:32.142+0100')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'P-1Y-11M'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-7-3',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[7] Should compute negative duration between in big units (example 3)',
        cypher="RETURN duration.inMonths(localdatetime('2018-07-21T21:40:32.142'), date('2016-07-21')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'P-2Y'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-7-4',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[7] Should compute negative duration between in big units (example 4)',
        cypher="RETURN duration.inMonths(datetime('2018-07-21T21:40:36.143+0200'), localdatetime('2016-07-21T21:40:36.143')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'P-2Y'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-7-5',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[7] Should compute negative duration between in big units (example 5)',
        cypher="RETURN duration.inMonths(datetime('2018-07-21T21:40:36.143+0500'), datetime('1984-07-21T22:40:36.143+0200')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'P-33Y-11M'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-8-1',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[8] Should handle durations at daylight saving time day (example 1)',
        cypher="RETURN duration.inSeconds(datetime({year: 2017, month: 10, day: 29, hour: 0, timezone: 'Europe/Stockholm'}), localdatetime({year: 2017, month: 10, day: 29, hour: 4})) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'PT5H'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-8-2',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[8] Should handle durations at daylight saving time day (example 2)',
        cypher="RETURN duration.inSeconds(datetime({year: 2017, month: 10, day: 29, hour: 0, timezone: 'Europe/Stockholm'}), localtime({hour: 4})) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'PT5H'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-8-3',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[8] Should handle durations at daylight saving time day (example 3)',
        cypher="RETURN duration.inSeconds(localdatetime({year: 2017, month: 10, day: 29, hour: 0 }), datetime({year: 2017, month: 10, day: 29, hour: 4, timezone: 'Europe/Stockholm'})) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'PT5H'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-8-4',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[8] Should handle durations at daylight saving time day (example 4)',
        cypher="RETURN duration.inSeconds(localtime({hour: 0 }), datetime({year: 2017, month: 10, day: 29, hour: 4, timezone: 'Europe/Stockholm'})) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'PT5H'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-8-5',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[8] Should handle durations at daylight saving time day (example 5)',
        cypher="RETURN duration.inSeconds(date({year: 2017, month: 10, day: 29}), datetime({year: 2017, month: 10, day: 29, hour: 4, timezone: 'Europe/Stockholm'})) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'PT5H'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-8-6',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[8] Should handle durations at daylight saving time day (example 6)',
        cypher="RETURN duration.inSeconds(datetime({year: 2017, month: 10, day: 29, hour: 0, timezone: 'Europe/Stockholm'}), date({year: 2017, month: 10, day: 30})) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'PT25H'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-9',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[9] Should handle large durations',
        cypher="RETURN duration.between(date('-999999999-01-01'), date('+999999999-12-31')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'P1999999998Y11M30D'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-10',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[10] Should handle large durations in seconds',
        cypher="RETURN duration.inSeconds(localdatetime('-999999999-01-01'), localdatetime('+999999999-12-31T23:59:59')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'PT17531639991215H59M59S'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-11-1',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[11] Should handle when seconds and subseconds have different signs (example 1)',
        cypher="RETURN duration.inSeconds(localtime('12:34:54.7'), localtime('12:34:54.3')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'PT-0.4S'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-11-2',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[11] Should handle when seconds and subseconds have different signs (example 2)',
        cypher="RETURN duration.inSeconds(localtime('12:34:54.3'), localtime('12:34:54.7')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'PT0.4S'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-11-3',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[11] Should handle when seconds and subseconds have different signs (example 3)',
        cypher="RETURN duration.inSeconds(localtime('12:34:54.7'), localtime('12:34:55.3')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'PT0.6S'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-11-4',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[11] Should handle when seconds and subseconds have different signs (example 4)',
        cypher="RETURN duration.inSeconds(localtime('12:34:54.7'), localtime('12:44:55.3')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'PT10M0.6S'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-11-5',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[11] Should handle when seconds and subseconds have different signs (example 5)',
        cypher="RETURN duration.inSeconds(localtime('12:44:54.7'), localtime('12:34:55.3')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'PT-9M-59.4S'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-11-6',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[11] Should handle when seconds and subseconds have different signs (example 6)',
        cypher="RETURN duration.inSeconds(localtime('12:34:56'), localtime('12:34:55.7')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'PT-0.3S'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-11-7',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[11] Should handle when seconds and subseconds have different signs (example 7)',
        cypher="RETURN duration.inSeconds(localtime('12:34:56'), localtime('12:44:55.7')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'PT9M59.7S'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-11-8',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[11] Should handle when seconds and subseconds have different signs (example 8)',
        cypher="RETURN duration.inSeconds(localtime('12:44:56'), localtime('12:34:55.7')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'PT-10M-0.3S'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-11-9',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[11] Should handle when seconds and subseconds have different signs (example 9)',
        cypher="RETURN duration.inSeconds(localtime('12:34:56.3'), localtime('12:34:54.7')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'PT-1.6S'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-11-10',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[11] Should handle when seconds and subseconds have different signs (example 10)',
        cypher="RETURN duration.inSeconds(localtime('12:34:54.7'), localtime('12:34:56.3')) AS duration",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'PT1.6S'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-12-1',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[12] Should compute durations with no difference (example 1)',
        cypher='RETURN duration.inSeconds(localtime(), localtime()) AS duration',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'PT0S'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-12-2',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[12] Should compute durations with no difference (example 2)',
        cypher='RETURN duration.inSeconds(time(), time()) AS duration',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'PT0S'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-12-3',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[12] Should compute durations with no difference (example 3)',
        cypher='RETURN duration.inSeconds(date(), date()) AS duration',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'PT0S'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-12-4',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[12] Should compute durations with no difference (example 4)',
        cypher='RETURN duration.inSeconds(localdatetime(), localdatetime()) AS duration',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'PT0S'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-12-5',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[12] Should compute durations with no difference (example 5)',
        cypher='RETURN duration.inSeconds(datetime(), datetime()) AS duration',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'duration': "'PT0S'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-13-1',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[13] Should propagate null (example 1)',
        cypher='RETURN duration.between(null, null) AS t',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'t': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-13-2',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[13] Should propagate null (example 2)',
        cypher='RETURN duration.inMonths(null, null) AS t',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'t': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-13-3',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[13] Should propagate null (example 3)',
        cypher='RETURN duration.inDays(null, null) AS t',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'t': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal10-13-4',
        feature_path='tck/features/expressions/temporal/Temporal10.feature',
        scenario='[13] Should propagate null (example 4)',
        cypher='RETURN duration.inSeconds(null, null) AS t',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'t': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal2-1-1',
        feature_path='tck/features/expressions/temporal/Temporal2.feature',
        scenario='[1] Should parse date from string (example 1)',
        cypher="RETURN date('2015-07-21') AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'2015-07-21'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal2-1-2',
        feature_path='tck/features/expressions/temporal/Temporal2.feature',
        scenario='[1] Should parse date from string (example 2)',
        cypher="RETURN date('20150721') AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'2015-07-21'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal2-1-3',
        feature_path='tck/features/expressions/temporal/Temporal2.feature',
        scenario='[1] Should parse date from string (example 3)',
        cypher="RETURN date('2015-07') AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'2015-07-01'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal2-1-4',
        feature_path='tck/features/expressions/temporal/Temporal2.feature',
        scenario='[1] Should parse date from string (example 4)',
        cypher="RETURN date('201507') AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'2015-07-01'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal2-1-5',
        feature_path='tck/features/expressions/temporal/Temporal2.feature',
        scenario='[1] Should parse date from string (example 5)',
        cypher="RETURN date('2015-W30-2') AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'2015-07-21'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal2-1-6',
        feature_path='tck/features/expressions/temporal/Temporal2.feature',
        scenario='[1] Should parse date from string (example 6)',
        cypher="RETURN date('2015W302') AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'2015-07-21'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal2-1-7',
        feature_path='tck/features/expressions/temporal/Temporal2.feature',
        scenario='[1] Should parse date from string (example 7)',
        cypher="RETURN date('2015-W30') AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'2015-07-20'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal2-1-8',
        feature_path='tck/features/expressions/temporal/Temporal2.feature',
        scenario='[1] Should parse date from string (example 8)',
        cypher="RETURN date('2015W30') AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'2015-07-20'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal2-1-9',
        feature_path='tck/features/expressions/temporal/Temporal2.feature',
        scenario='[1] Should parse date from string (example 9)',
        cypher="RETURN date('2015-202') AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'2015-07-21'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal2-1-10',
        feature_path='tck/features/expressions/temporal/Temporal2.feature',
        scenario='[1] Should parse date from string (example 10)',
        cypher="RETURN date('2015202') AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'2015-07-21'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal2-1-11',
        feature_path='tck/features/expressions/temporal/Temporal2.feature',
        scenario='[1] Should parse date from string (example 11)',
        cypher="RETURN date('2015') AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'2015-01-01'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal2-2-1',
        feature_path='tck/features/expressions/temporal/Temporal2.feature',
        scenario='[2] Should parse local time from string (example 1)',
        cypher="RETURN localtime('21:40:32.142') AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'21:40:32.142'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal2-2-2',
        feature_path='tck/features/expressions/temporal/Temporal2.feature',
        scenario='[2] Should parse local time from string (example 2)',
        cypher="RETURN localtime('214032.142') AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'21:40:32.142'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal2-2-3',
        feature_path='tck/features/expressions/temporal/Temporal2.feature',
        scenario='[2] Should parse local time from string (example 3)',
        cypher="RETURN localtime('21:40:32') AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'21:40:32'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal2-2-4',
        feature_path='tck/features/expressions/temporal/Temporal2.feature',
        scenario='[2] Should parse local time from string (example 4)',
        cypher="RETURN localtime('214032') AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'21:40:32'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal2-2-5',
        feature_path='tck/features/expressions/temporal/Temporal2.feature',
        scenario='[2] Should parse local time from string (example 5)',
        cypher="RETURN localtime('21:40') AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'21:40'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal2-2-6',
        feature_path='tck/features/expressions/temporal/Temporal2.feature',
        scenario='[2] Should parse local time from string (example 6)',
        cypher="RETURN localtime('2140') AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'21:40'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal2-2-7',
        feature_path='tck/features/expressions/temporal/Temporal2.feature',
        scenario='[2] Should parse local time from string (example 7)',
        cypher="RETURN localtime('21') AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'21:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal2-3-1',
        feature_path='tck/features/expressions/temporal/Temporal2.feature',
        scenario='[3] Should parse time from string (example 1)',
        cypher="RETURN time('21:40:32.142+0100') AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'21:40:32.142+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal2-3-2',
        feature_path='tck/features/expressions/temporal/Temporal2.feature',
        scenario='[3] Should parse time from string (example 2)',
        cypher="RETURN time('214032.142Z') AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'21:40:32.142Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal2-3-3',
        feature_path='tck/features/expressions/temporal/Temporal2.feature',
        scenario='[3] Should parse time from string (example 3)',
        cypher="RETURN time('21:40:32+01:00') AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'21:40:32+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal2-3-4',
        feature_path='tck/features/expressions/temporal/Temporal2.feature',
        scenario='[3] Should parse time from string (example 4)',
        cypher="RETURN time('214032-0100') AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'21:40:32-01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal2-3-5',
        feature_path='tck/features/expressions/temporal/Temporal2.feature',
        scenario='[3] Should parse time from string (example 5)',
        cypher="RETURN time('21:40-01:30') AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'21:40-01:30'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal2-3-6',
        feature_path='tck/features/expressions/temporal/Temporal2.feature',
        scenario='[3] Should parse time from string (example 6)',
        cypher="RETURN time('2140-00:00') AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'21:40Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal2-3-7',
        feature_path='tck/features/expressions/temporal/Temporal2.feature',
        scenario='[3] Should parse time from string (example 7)',
        cypher="RETURN time('2140-02') AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'21:40-02:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal2-3-8',
        feature_path='tck/features/expressions/temporal/Temporal2.feature',
        scenario='[3] Should parse time from string (example 8)',
        cypher="RETURN time('22+18:00') AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'22:00+18:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal2-4-1',
        feature_path='tck/features/expressions/temporal/Temporal2.feature',
        scenario='[4] Should parse local date time from string (example 1)',
        cypher="RETURN localdatetime('2015-07-21T21:40:32.142') AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'2015-07-21T21:40:32.142'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal2-4-2',
        feature_path='tck/features/expressions/temporal/Temporal2.feature',
        scenario='[4] Should parse local date time from string (example 2)',
        cypher="RETURN localdatetime('2015-W30-2T214032.142') AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'2015-07-21T21:40:32.142'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal2-4-3',
        feature_path='tck/features/expressions/temporal/Temporal2.feature',
        scenario='[4] Should parse local date time from string (example 3)',
        cypher="RETURN localdatetime('2015-202T21:40:32') AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'2015-07-21T21:40:32'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal2-4-4',
        feature_path='tck/features/expressions/temporal/Temporal2.feature',
        scenario='[4] Should parse local date time from string (example 4)',
        cypher="RETURN localdatetime('2015T214032') AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'2015-01-01T21:40:32'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal2-4-5',
        feature_path='tck/features/expressions/temporal/Temporal2.feature',
        scenario='[4] Should parse local date time from string (example 5)',
        cypher="RETURN localdatetime('20150721T21:40') AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'2015-07-21T21:40'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal2-4-6',
        feature_path='tck/features/expressions/temporal/Temporal2.feature',
        scenario='[4] Should parse local date time from string (example 6)',
        cypher="RETURN localdatetime('2015-W30T2140') AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'2015-07-20T21:40'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal2-4-7',
        feature_path='tck/features/expressions/temporal/Temporal2.feature',
        scenario='[4] Should parse local date time from string (example 7)',
        cypher="RETURN localdatetime('2015202T21') AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'2015-07-21T21:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal2-5-1',
        feature_path='tck/features/expressions/temporal/Temporal2.feature',
        scenario='[5] Should parse date time from string (example 1)',
        cypher="RETURN datetime('2015-07-21T21:40:32.142+0100') AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'2015-07-21T21:40:32.142+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal2-5-2',
        feature_path='tck/features/expressions/temporal/Temporal2.feature',
        scenario='[5] Should parse date time from string (example 2)',
        cypher="RETURN datetime('2015-W30-2T214032.142Z') AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'2015-07-21T21:40:32.142Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal2-5-3',
        feature_path='tck/features/expressions/temporal/Temporal2.feature',
        scenario='[5] Should parse date time from string (example 3)',
        cypher="RETURN datetime('2015-202T21:40:32+01:00') AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'2015-07-21T21:40:32+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal2-5-4',
        feature_path='tck/features/expressions/temporal/Temporal2.feature',
        scenario='[5] Should parse date time from string (example 4)',
        cypher="RETURN datetime('2015T214032-0100') AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'2015-01-01T21:40:32-01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal2-5-5',
        feature_path='tck/features/expressions/temporal/Temporal2.feature',
        scenario='[5] Should parse date time from string (example 5)',
        cypher="RETURN datetime('20150721T21:40-01:30') AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'2015-07-21T21:40-01:30'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal2-5-6',
        feature_path='tck/features/expressions/temporal/Temporal2.feature',
        scenario='[5] Should parse date time from string (example 6)',
        cypher="RETURN datetime('2015-W30T2140-00:00') AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'2015-07-20T21:40Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal2-5-7',
        feature_path='tck/features/expressions/temporal/Temporal2.feature',
        scenario='[5] Should parse date time from string (example 7)',
        cypher="RETURN datetime('2015-W30T2140-02') AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'2015-07-20T21:40-02:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal2-5-8',
        feature_path='tck/features/expressions/temporal/Temporal2.feature',
        scenario='[5] Should parse date time from string (example 8)',
        cypher="RETURN datetime('2015202T21+18:00') AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'2015-07-21T21:00+18:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal2-6-1',
        feature_path='tck/features/expressions/temporal/Temporal2.feature',
        scenario='[6] Should parse date time with named time zone from string (example 1)',
        cypher="RETURN datetime('2015-07-21T21:40:32.142+02:00[Europe/Stockholm]') AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'2015-07-21T21:40:32.142+02:00[Europe/Stockholm]'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal2-6-2',
        feature_path='tck/features/expressions/temporal/Temporal2.feature',
        scenario='[6] Should parse date time with named time zone from string (example 2)',
        cypher="RETURN datetime('2015-07-21T21:40:32.142+0845[Australia/Eucla]') AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'2015-07-21T21:40:32.142+08:45[Australia/Eucla]'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal2-6-3',
        feature_path='tck/features/expressions/temporal/Temporal2.feature',
        scenario='[6] Should parse date time with named time zone from string (example 3)',
        cypher="RETURN datetime('2015-07-21T21:40:32.142-04[America/New_York]') AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'2015-07-21T21:40:32.142-04:00[America/New_York]'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal2-6-4',
        feature_path='tck/features/expressions/temporal/Temporal2.feature',
        scenario='[6] Should parse date time with named time zone from string (example 4)',
        cypher="RETURN datetime('2015-07-21T21:40:32.142[Europe/London]') AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'2015-07-21T21:40:32.142+01:00[Europe/London]'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal2-6-5',
        feature_path='tck/features/expressions/temporal/Temporal2.feature',
        scenario='[6] Should parse date time with named time zone from string (example 5)',
        cypher="RETURN datetime('1818-07-21T21:40:32.142[Europe/Stockholm]') AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1818-07-21T21:40:32.142+00:53:28[Europe/Stockholm]'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal2-7-1',
        feature_path='tck/features/expressions/temporal/Temporal2.feature',
        scenario='[7] Should parse duration from string (example 1)',
        cypher="RETURN duration('P14DT16H12M') AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'P14DT16H12M'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal2-7-2',
        feature_path='tck/features/expressions/temporal/Temporal2.feature',
        scenario='[7] Should parse duration from string (example 2)',
        cypher="RETURN duration('P5M1.5D') AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'P5M1DT12H'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal2-7-3',
        feature_path='tck/features/expressions/temporal/Temporal2.feature',
        scenario='[7] Should parse duration from string (example 3)',
        cypher="RETURN duration('P0.75M') AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'P22DT19H51M49.5S'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal2-7-4',
        feature_path='tck/features/expressions/temporal/Temporal2.feature',
        scenario='[7] Should parse duration from string (example 4)',
        cypher="RETURN duration('PT0.75M') AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'PT45S'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal2-7-5',
        feature_path='tck/features/expressions/temporal/Temporal2.feature',
        scenario='[7] Should parse duration from string (example 5)',
        cypher="RETURN duration('P2.5W') AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'P17DT12H'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal2-7-6',
        feature_path='tck/features/expressions/temporal/Temporal2.feature',
        scenario='[7] Should parse duration from string (example 6)',
        cypher="RETURN duration('P12Y5M14DT16H12M70S') AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'P12Y5M14DT16H13M10S'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal2-7-7',
        feature_path='tck/features/expressions/temporal/Temporal2.feature',
        scenario='[7] Should parse duration from string (example 7)',
        cypher="RETURN duration('P2012-02-02T14:37:21.545') AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'P2012Y2M2DT14H37M21.545S'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-1-1',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[1] Should select date (example 1)',
        cypher='WITH date({year: 1984, month: 11, day: 11}) AS other\n      RETURN date(other) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-11-11'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-1-2',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[1] Should select date (example 2)',
        cypher='WITH date({year: 1984, month: 11, day: 11}) AS other\n      RETURN date({date: other}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-11-11'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-1-3',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[1] Should select date (example 3)',
        cypher='WITH date({year: 1984, month: 11, day: 11}) AS other\n      RETURN date({date: other, year: 28}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'0028-11-11'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-1-4',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[1] Should select date (example 4)',
        cypher='WITH date({year: 1984, month: 11, day: 11}) AS other\n      RETURN date({date: other, day: 28}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-11-28'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-1-5',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[1] Should select date (example 5)',
        cypher='WITH date({year: 1984, month: 11, day: 11}) AS other\n      RETURN date({date: other, week: 1}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-01-08'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-1-6',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[1] Should select date (example 6)',
        cypher='WITH date({year: 1984, month: 11, day: 11}) AS other\n      RETURN date({date: other, ordinalDay: 28}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-01-28'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-1-7',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[1] Should select date (example 7)',
        cypher='WITH date({year: 1984, month: 11, day: 11}) AS other\n      RETURN date({date: other, quarter: 3}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-08-11'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-1-8',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[1] Should select date (example 8)',
        cypher='WITH localdatetime({year: 1984, month: 11, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}) AS other\n      RETURN date(other) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-11-11'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-1-9',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[1] Should select date (example 9)',
        cypher='WITH localdatetime({year: 1984, month: 11, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}) AS other\n      RETURN date({date: other}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-11-11'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-1-10',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[1] Should select date (example 10)',
        cypher='WITH localdatetime({year: 1984, month: 11, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}) AS other\n      RETURN date({date: other, year: 28}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'0028-11-11'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-1-11',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[1] Should select date (example 11)',
        cypher='WITH localdatetime({year: 1984, month: 11, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}) AS other\n      RETURN date({date: other, day: 28}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-11-28'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-1-12',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[1] Should select date (example 12)',
        cypher='WITH localdatetime({year: 1984, month: 11, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}) AS other\n      RETURN date({date: other, week: 1}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-01-08'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-1-13',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[1] Should select date (example 13)',
        cypher='WITH localdatetime({year: 1984, month: 11, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}) AS other\n      RETURN date({date: other, ordinalDay: 28}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-01-28'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-1-14',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[1] Should select date (example 14)',
        cypher='WITH localdatetime({year: 1984, month: 11, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}) AS other\n      RETURN date({date: other, quarter: 3}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-08-11'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-1-15',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[1] Should select date (example 15)',
        cypher="WITH datetime({year: 1984, month: 11, day: 11, hour: 12, timezone: '+01:00'}) AS other\n      RETURN date(other) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-11-11'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-1-16',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[1] Should select date (example 16)',
        cypher="WITH datetime({year: 1984, month: 11, day: 11, hour: 12, timezone: '+01:00'}) AS other\n      RETURN date({date: other}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-11-11'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-1-17',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[1] Should select date (example 17)',
        cypher="WITH datetime({year: 1984, month: 11, day: 11, hour: 12, timezone: '+01:00'}) AS other\n      RETURN date({date: other, year: 28}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'0028-11-11'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-1-18',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[1] Should select date (example 18)',
        cypher="WITH datetime({year: 1984, month: 11, day: 11, hour: 12, timezone: '+01:00'}) AS other\n      RETURN date({date: other, day: 28}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-11-28'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-1-19',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[1] Should select date (example 19)',
        cypher="WITH datetime({year: 1984, month: 11, day: 11, hour: 12, timezone: '+01:00'}) AS other\n      RETURN date({date: other, week: 1}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-01-08'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-1-20',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[1] Should select date (example 20)',
        cypher="WITH datetime({year: 1984, month: 11, day: 11, hour: 12, timezone: '+01:00'}) AS other\n      RETURN date({date: other, ordinalDay: 28}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-01-28'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-1-21',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[1] Should select date (example 21)',
        cypher="WITH datetime({year: 1984, month: 11, day: 11, hour: 12, timezone: '+01:00'}) AS other\n      RETURN date({date: other, quarter: 3}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-08-11'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-2-1',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[2] Should select local time (example 1)',
        cypher='WITH localtime({hour: 12, minute: 31, second: 14, nanosecond: 645876123}) AS other\n      RETURN localtime(other) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31:14.645876123'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-2-2',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[2] Should select local time (example 2)',
        cypher='WITH localtime({hour: 12, minute: 31, second: 14, nanosecond: 645876123}) AS other\n      RETURN localtime({time: other}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31:14.645876123'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-2-3',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[2] Should select local time (example 3)',
        cypher='WITH localtime({hour: 12, minute: 31, second: 14, nanosecond: 645876123}) AS other\n      RETURN localtime({time: other, second: 42}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31:42.645876123'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-2-4',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[2] Should select local time (example 4)',
        cypher="WITH time({hour: 12, minute: 31, second: 14, microsecond: 645876, timezone: '+01:00'}) AS other\n      RETURN localtime(other) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31:14.645876'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-2-5',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[2] Should select local time (example 5)',
        cypher="WITH time({hour: 12, minute: 31, second: 14, microsecond: 645876, timezone: '+01:00'}) AS other\n      RETURN localtime({time: other}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31:14.645876'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-2-6',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[2] Should select local time (example 6)',
        cypher="WITH time({hour: 12, minute: 31, second: 14, microsecond: 645876, timezone: '+01:00'}) AS other\n      RETURN localtime({time: other, second: 42}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31:42.645876'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-2-7',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[2] Should select local time (example 7)',
        cypher='WITH localdatetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31, second: 14, millisecond: 645}) AS other\n      RETURN localtime(other) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31:14.645'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-2-8',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[2] Should select local time (example 8)',
        cypher='WITH localdatetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31, second: 14, millisecond: 645}) AS other\n      RETURN localtime({time: other}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31:14.645'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-2-9',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[2] Should select local time (example 9)',
        cypher='WITH localdatetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31, second: 14, millisecond: 645}) AS other\n      RETURN localtime({time: other, second: 42}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31:42.645'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-2-10',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[2] Should select local time (example 10)',
        cypher="WITH datetime({year: 1984, month: 10, day: 11, hour: 12, timezone: '+01:00'}) AS other\n      RETURN localtime(other) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-2-11',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[2] Should select local time (example 11)',
        cypher="WITH datetime({year: 1984, month: 10, day: 11, hour: 12, timezone: '+01:00'}) AS other\n      RETURN localtime({time: other}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-2-12',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[2] Should select local time (example 12)',
        cypher="WITH datetime({year: 1984, month: 10, day: 11, hour: 12, timezone: '+01:00'}) AS other\n      RETURN localtime({time: other, second: 42}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:00:42'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-3-1',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[3] Should select time (example 1)',
        cypher='WITH localtime({hour: 12, minute: 31, second: 14, nanosecond: 645876123}) AS other\n      RETURN time(other) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31:14.645876123Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-3-2',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[3] Should select time (example 2)',
        cypher='WITH localtime({hour: 12, minute: 31, second: 14, nanosecond: 645876123}) AS other\n      RETURN time({time: other}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31:14.645876123Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-3-3',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[3] Should select time (example 3)',
        cypher="WITH localtime({hour: 12, minute: 31, second: 14, nanosecond: 645876123}) AS other\n      RETURN time({time: other, timezone: '+05:00'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31:14.645876123+05:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-3-4',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[3] Should select time (example 4)',
        cypher='WITH localtime({hour: 12, minute: 31, second: 14, nanosecond: 645876123}) AS other\n      RETURN time({time: other, second: 42}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31:42.645876123Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-3-5',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[3] Should select time (example 5)',
        cypher="WITH localtime({hour: 12, minute: 31, second: 14, nanosecond: 645876123}) AS other\n      RETURN time({time: other, second: 42, timezone: '+05:00'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31:42.645876123+05:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-3-6',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[3] Should select time (example 6)',
        cypher="WITH time({hour: 12, minute: 31, second: 14, microsecond: 645876, timezone: '+01:00'}) AS other\n      RETURN time(other) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31:14.645876+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-3-7',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[3] Should select time (example 7)',
        cypher="WITH time({hour: 12, minute: 31, second: 14, microsecond: 645876, timezone: '+01:00'}) AS other\n      RETURN time({time: other}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31:14.645876+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-3-8',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[3] Should select time (example 8)',
        cypher="WITH time({hour: 12, minute: 31, second: 14, microsecond: 645876, timezone: '+01:00'}) AS other\n      RETURN time({time: other, timezone: '+05:00'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'16:31:14.645876+05:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-3-9',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[3] Should select time (example 9)',
        cypher="WITH time({hour: 12, minute: 31, second: 14, microsecond: 645876, timezone: '+01:00'}) AS other\n      RETURN time({time: other, second: 42}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31:42.645876+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-3-10',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[3] Should select time (example 10)',
        cypher="WITH time({hour: 12, minute: 31, second: 14, microsecond: 645876, timezone: '+01:00'}) AS other\n      RETURN time({time: other, second: 42, timezone: '+05:00'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'16:31:42.645876+05:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-3-11',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[3] Should select time (example 11)',
        cypher='WITH localdatetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31, second: 14, millisecond: 645}) AS other\n      RETURN time(other) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31:14.645Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-3-12',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[3] Should select time (example 12)',
        cypher='WITH localdatetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31, second: 14, millisecond: 645}) AS other\n      RETURN time({time: other}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31:14.645Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-3-13',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[3] Should select time (example 13)',
        cypher="WITH localdatetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31, second: 14, millisecond: 645}) AS other\n      RETURN time({time: other, timezone: '+05:00'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31:14.645+05:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-3-14',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[3] Should select time (example 14)',
        cypher='WITH localdatetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31, second: 14, millisecond: 645}) AS other\n      RETURN time({time: other, second: 42}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31:42.645Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-3-15',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[3] Should select time (example 15)',
        cypher="WITH localdatetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31, second: 14, millisecond: 645}) AS other\n      RETURN time({time: other, second: 42, timezone: '+05:00'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31:42.645+05:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-3-16',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[3] Should select time (example 16)',
        cypher="WITH datetime({year: 1984, month: 10, day: 11, hour: 12, timezone: 'Europe/Stockholm'}) AS other\n      RETURN time(other) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:00+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-3-17',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[3] Should select time (example 17)',
        cypher="WITH datetime({year: 1984, month: 10, day: 11, hour: 12, timezone: 'Europe/Stockholm'}) AS other\n      RETURN time({time: other}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:00+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-3-18',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[3] Should select time (example 18)',
        cypher="WITH datetime({year: 1984, month: 10, day: 11, hour: 12, timezone: 'Europe/Stockholm'}) AS other\n      RETURN time({time: other, timezone: '+05:00'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'16:00+05:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-3-19',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[3] Should select time (example 19)',
        cypher="WITH datetime({year: 1984, month: 10, day: 11, hour: 12, timezone: 'Europe/Stockholm'}) AS other\n      RETURN time({time: other, second: 42}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:00:42+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-3-20',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[3] Should select time (example 20)',
        cypher="WITH datetime({year: 1984, month: 10, day: 11, hour: 12, timezone: 'Europe/Stockholm'}) AS other\n      RETURN time({time: other, second: 42, timezone: '+05:00'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'16:00:42+05:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-4-1',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[4] Should select date into local date time (example 1)',
        cypher='WITH date({year: 1984, month: 10, day: 11}) AS other\n      RETURN localdatetime({date: other, hour: 10, minute: 10, second: 10}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T10:10:10'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-4-2',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[4] Should select date into local date time (example 2)',
        cypher='WITH date({year: 1984, month: 10, day: 11}) AS other\n      RETURN localdatetime({date: other, day: 28, hour: 10, minute: 10, second: 10}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-28T10:10:10'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-4-3',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[4] Should select date into local date time (example 3)',
        cypher='WITH localdatetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31, second: 14, millisecond: 645}) AS other\n      RETURN localdatetime({date: other, hour: 10, minute: 10, second: 10}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-03-07T10:10:10'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-4-4',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[4] Should select date into local date time (example 4)',
        cypher='WITH localdatetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31, second: 14, millisecond: 645}) AS other\n      RETURN localdatetime({date: other, day: 28, hour: 10, minute: 10, second: 10}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-03-28T10:10:10'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-4-5',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[4] Should select date into local date time (example 5)',
        cypher="WITH datetime({year: 1984, month: 10, day: 11, hour: 12, timezone: '+01:00'}) AS other\n      RETURN localdatetime({date: other, hour: 10, minute: 10, second: 10}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T10:10:10'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-4-6',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[4] Should select date into local date time (example 6)',
        cypher="WITH datetime({year: 1984, month: 10, day: 11, hour: 12, timezone: '+01:00'}) AS other\n      RETURN localdatetime({date: other, day: 28, hour: 10, minute: 10, second: 10}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-28T10:10:10'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-5-1',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[5] Should select time into local date time (example 1)',
        cypher='WITH localtime({hour: 12, minute: 31, second: 14, nanosecond: 645876123}) AS other\n      RETURN localdatetime({year: 1984, month: 10, day: 11, time: other}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:31:14.645876123'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-5-2',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[5] Should select time into local date time (example 2)',
        cypher='WITH localtime({hour: 12, minute: 31, second: 14, nanosecond: 645876123}) AS other\n      RETURN localdatetime({year: 1984, month: 10, day: 11, time: other, second: 42}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:31:42.645876123'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-5-3',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[5] Should select time into local date time (example 3)',
        cypher="WITH time({hour: 12, minute: 31, second: 14, microsecond: 645876, timezone: '+01:00'}) AS other\n      RETURN localdatetime({year: 1984, month: 10, day: 11, time: other}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:31:14.645876'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-5-4',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[5] Should select time into local date time (example 4)',
        cypher="WITH time({hour: 12, minute: 31, second: 14, microsecond: 645876, timezone: '+01:00'}) AS other\n      RETURN localdatetime({year: 1984, month: 10, day: 11, time: other, second: 42}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:31:42.645876'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-5-5',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[5] Should select time into local date time (example 5)',
        cypher='WITH localdatetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31, second: 14, millisecond: 645}) AS other\n      RETURN localdatetime({year: 1984, month: 10, day: 11, time: other}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:31:14.645'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-5-6',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[5] Should select time into local date time (example 6)',
        cypher='WITH localdatetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31, second: 14, millisecond: 645}) AS other\n      RETURN localdatetime({year: 1984, month: 10, day: 11, time: other, second: 42}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:31:42.645'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-5-7',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[5] Should select time into local date time (example 7)',
        cypher="WITH datetime({year: 1984, month: 10, day: 11, hour: 12, timezone: '+01:00'}) AS other\n      RETURN localdatetime({year: 1984, month: 10, day: 11, time: other}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-5-8',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[5] Should select time into local date time (example 8)',
        cypher="WITH datetime({year: 1984, month: 10, day: 11, hour: 12, timezone: '+01:00'}) AS other\n      RETURN localdatetime({year: 1984, month: 10, day: 11, time: other, second: 42}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:00:42'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-6-1',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[6] Should select date and time into local date time (example 1)',
        cypher='WITH date({year: 1984, month: 10, day: 11}) AS otherDate, localtime({hour: 12, minute: 31, second: 14, nanosecond: 645876123}) AS otherTime\n      RETURN localdatetime({date: otherDate, time: otherTime}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:31:14.645876123'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-6-2',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[6] Should select date and time into local date time (example 2)',
        cypher='WITH date({year: 1984, month: 10, day: 11}) AS otherDate, localtime({hour: 12, minute: 31, second: 14, nanosecond: 645876123}) AS otherTime\n      RETURN localdatetime({date: otherDate, time: otherTime, day: 28, second: 42}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-28T12:31:42.645876123'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-6-3',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[6] Should select date and time into local date time (example 3)',
        cypher="WITH date({year: 1984, month: 10, day: 11}) AS otherDate, time({hour: 12, minute: 31, second: 14, microsecond: 645876, timezone: '+01:00'}) AS otherTime\n      RETURN localdatetime({date: otherDate, time: otherTime}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:31:14.645876'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-6-4',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[6] Should select date and time into local date time (example 4)',
        cypher="WITH date({year: 1984, month: 10, day: 11}) AS otherDate, time({hour: 12, minute: 31, second: 14, microsecond: 645876, timezone: '+01:00'}) AS otherTime\n      RETURN localdatetime({date: otherDate, time: otherTime, day: 28, second: 42}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-28T12:31:42.645876'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-6-5',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[6] Should select date and time into local date time (example 5)',
        cypher='WITH date({year: 1984, month: 10, day: 11}) AS otherDate, localdatetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31, second: 14, millisecond: 645}) AS otherTime\n      RETURN localdatetime({date: otherDate, time: otherTime}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:31:14.645'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-6-6',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[6] Should select date and time into local date time (example 6)',
        cypher='WITH date({year: 1984, month: 10, day: 11}) AS otherDate, localdatetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31, second: 14, millisecond: 645}) AS otherTime\n      RETURN localdatetime({date: otherDate, time: otherTime, day: 28, second: 42}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-28T12:31:42.645'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-6-7',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[6] Should select date and time into local date time (example 7)',
        cypher="WITH date({year: 1984, month: 10, day: 11}) AS otherDate, datetime({year: 1984, month: 10, day: 11, hour: 12, timezone: '+01:00'}) AS otherTime\n      RETURN localdatetime({date: otherDate, time: otherTime}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-6-8',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[6] Should select date and time into local date time (example 8)',
        cypher="WITH date({year: 1984, month: 10, day: 11}) AS otherDate, datetime({year: 1984, month: 10, day: 11, hour: 12, timezone: '+01:00'}) AS otherTime\n      RETURN localdatetime({date: otherDate, time: otherTime, day: 28, second: 42}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-28T12:00:42'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-6-9',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[6] Should select date and time into local date time (example 9)',
        cypher='WITH localdatetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31, second: 14, millisecond: 645}) AS otherDate, localtime({hour: 12, minute: 31, second: 14, nanosecond: 645876123}) AS otherTime\n      RETURN localdatetime({date: otherDate, time: otherTime}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-03-07T12:31:14.645876123'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-6-10',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[6] Should select date and time into local date time (example 10)',
        cypher='WITH localdatetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31, second: 14, millisecond: 645}) AS otherDate, localtime({hour: 12, minute: 31, second: 14, nanosecond: 645876123}) AS otherTime\n      RETURN localdatetime({date: otherDate, time: otherTime, day: 28, second: 42}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-03-28T12:31:42.645876123'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-6-11',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[6] Should select date and time into local date time (example 11)',
        cypher="WITH localdatetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31, second: 14, millisecond: 645}) AS otherDate, time({hour: 12, minute: 31, second: 14, microsecond: 645876, timezone: '+01:00'}) AS otherTime\n      RETURN localdatetime({date: otherDate, time: otherTime}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-03-07T12:31:14.645876'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-6-12',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[6] Should select date and time into local date time (example 12)',
        cypher="WITH localdatetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31, second: 14, millisecond: 645}) AS otherDate, time({hour: 12, minute: 31, second: 14, microsecond: 645876, timezone: '+01:00'}) AS otherTime\n      RETURN localdatetime({date: otherDate, time: otherTime, day: 28, second: 42}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-03-28T12:31:42.645876'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-6-13',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[6] Should select date and time into local date time (example 13)',
        cypher='WITH localdatetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31, second: 14, millisecond: 645}) AS otherDate, localdatetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31, second: 14, millisecond: 645}) AS otherTime\n      RETURN localdatetime({date: otherDate, time: otherTime}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-03-07T12:31:14.645'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-6-14',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[6] Should select date and time into local date time (example 14)',
        cypher='WITH localdatetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31, second: 14, millisecond: 645}) AS otherDate, localdatetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31, second: 14, millisecond: 645}) AS otherTime\n      RETURN localdatetime({date: otherDate, time: otherTime, day: 28, second: 42}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-03-28T12:31:42.645'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-6-15',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[6] Should select date and time into local date time (example 15)',
        cypher="WITH localdatetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31, second: 14, millisecond: 645}) AS otherDate, datetime({year: 1984, month: 10, day: 11, hour: 12, timezone: '+01:00'}) AS otherTime\n      RETURN localdatetime({date: otherDate, time: otherTime}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-03-07T12:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-6-16',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[6] Should select date and time into local date time (example 16)',
        cypher="WITH localdatetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31, second: 14, millisecond: 645}) AS otherDate, datetime({year: 1984, month: 10, day: 11, hour: 12, timezone: '+01:00'}) AS otherTime\n      RETURN localdatetime({date: otherDate, time: otherTime, day: 28, second: 42}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-03-28T12:00:42'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-6-17',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[6] Should select date and time into local date time (example 17)',
        cypher="WITH datetime({year: 1984, month: 10, day: 11, hour: 12, timezone: '+01:00'}) AS otherDate, localtime({hour: 12, minute: 31, second: 14, nanosecond: 645876123}) AS otherTime\n      RETURN localdatetime({date: otherDate, time: otherTime}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:31:14.645876123'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-6-18',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[6] Should select date and time into local date time (example 18)',
        cypher="WITH datetime({year: 1984, month: 10, day: 11, hour: 12, timezone: '+01:00'}) AS otherDate, localtime({hour: 12, minute: 31, second: 14, nanosecond: 645876123}) AS otherTime\n      RETURN localdatetime({date: otherDate, time: otherTime, day: 28, second: 42}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-28T12:31:42.645876123'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-6-19',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[6] Should select date and time into local date time (example 19)',
        cypher="WITH datetime({year: 1984, month: 10, day: 11, hour: 12, timezone: '+01:00'}) AS otherDate, time({hour: 12, minute: 31, second: 14, microsecond: 645876, timezone: '+01:00'}) AS otherTime\n      RETURN localdatetime({date: otherDate, time: otherTime}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:31:14.645876'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-6-20',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[6] Should select date and time into local date time (example 20)',
        cypher="WITH datetime({year: 1984, month: 10, day: 11, hour: 12, timezone: '+01:00'}) AS otherDate, time({hour: 12, minute: 31, second: 14, microsecond: 645876, timezone: '+01:00'}) AS otherTime\n      RETURN localdatetime({date: otherDate, time: otherTime, day: 28, second: 42}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-28T12:31:42.645876'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-6-21',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[6] Should select date and time into local date time (example 21)',
        cypher="WITH datetime({year: 1984, month: 10, day: 11, hour: 12, timezone: '+01:00'}) AS otherDate, localdatetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31, second: 14, millisecond: 645}) AS otherTime\n      RETURN localdatetime({date: otherDate, time: otherTime}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:31:14.645'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-6-22',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[6] Should select date and time into local date time (example 22)',
        cypher="WITH datetime({year: 1984, month: 10, day: 11, hour: 12, timezone: '+01:00'}) AS otherDate, localdatetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31, second: 14, millisecond: 645}) AS otherTime\n      RETURN localdatetime({date: otherDate, time: otherTime, day: 28, second: 42}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-28T12:31:42.645'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-6-23',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[6] Should select date and time into local date time (example 23)',
        cypher="WITH datetime({year: 1984, month: 10, day: 11, hour: 12, timezone: '+01:00'}) AS otherDate, datetime({year: 1984, month: 10, day: 11, hour: 12, timezone: '+01:00'}) AS otherTime\n      RETURN localdatetime({date: otherDate, time: otherTime}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-6-24',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[6] Should select date and time into local date time (example 24)',
        cypher="WITH datetime({year: 1984, month: 10, day: 11, hour: 12, timezone: '+01:00'}) AS otherDate, datetime({year: 1984, month: 10, day: 11, hour: 12, timezone: '+01:00'}) AS otherTime\n      RETURN localdatetime({date: otherDate, time: otherTime, day: 28, second: 42}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-28T12:00:42'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-7-1',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[7] Should select datetime into local date time (example 1)',
        cypher='WITH localdatetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31, second: 14, millisecond: 645}) AS other\n      RETURN localdatetime(other) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-03-07T12:31:14.645'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-7-2',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[7] Should select datetime into local date time (example 2)',
        cypher='WITH localdatetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31, second: 14, millisecond: 645}) AS other\n      RETURN localdatetime({datetime: other}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-03-07T12:31:14.645'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-7-3',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[7] Should select datetime into local date time (example 3)',
        cypher='WITH localdatetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31, second: 14, millisecond: 645}) AS other\n      RETURN localdatetime({datetime: other, day: 28, second: 42}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-03-28T12:31:42.645'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-7-4',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[7] Should select datetime into local date time (example 4)',
        cypher="WITH datetime({year: 1984, month: 10, day: 11, hour: 12, timezone: '+01:00'}) AS other\n      RETURN localdatetime(other) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-7-5',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[7] Should select datetime into local date time (example 5)',
        cypher="WITH datetime({year: 1984, month: 10, day: 11, hour: 12, timezone: '+01:00'}) AS other\n      RETURN localdatetime({datetime: other}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-7-6',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[7] Should select datetime into local date time (example 6)',
        cypher="WITH datetime({year: 1984, month: 10, day: 11, hour: 12, timezone: '+01:00'}) AS other\n      RETURN localdatetime({datetime: other, day: 28, second: 42}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-28T12:00:42'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-8-1',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[8] Should select date into date time (example 1)',
        cypher='WITH date({year: 1984, month: 10, day: 11}) AS other\n      RETURN datetime({date: other, hour: 10, minute: 10, second: 10}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T10:10:10Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-8-2',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[8] Should select date into date time (example 2)',
        cypher="WITH date({year: 1984, month: 10, day: 11}) AS other\n      RETURN datetime({date: other, hour: 10, minute: 10, second: 10, timezone: '+05:00'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T10:10:10+05:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-8-3',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[8] Should select date into date time (example 3)',
        cypher='WITH date({year: 1984, month: 10, day: 11}) AS other\n      RETURN datetime({date: other, day: 28, hour: 10, minute: 10, second: 10}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-28T10:10:10Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-8-4',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[8] Should select date into date time (example 4)',
        cypher="WITH date({year: 1984, month: 10, day: 11}) AS other\n      RETURN datetime({date: other, day: 28, hour: 10, minute: 10, second: 10, timezone: 'Pacific/Honolulu'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-28T10:10:10-10:00[Pacific/Honolulu]'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-8-5',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[8] Should select date into date time (example 5)',
        cypher='WITH localdatetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31, second: 14, millisecond: 645}) AS other\n      RETURN datetime({date: other, hour: 10, minute: 10, second: 10}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-03-07T10:10:10Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-8-6',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[8] Should select date into date time (example 6)',
        cypher="WITH localdatetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31, second: 14, millisecond: 645}) AS other\n      RETURN datetime({date: other, hour: 10, minute: 10, second: 10, timezone: '+05:00'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-03-07T10:10:10+05:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-8-7',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[8] Should select date into date time (example 7)',
        cypher='WITH localdatetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31, second: 14, millisecond: 645}) AS other\n      RETURN datetime({date: other, day: 28, hour: 10, minute: 10, second: 10}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-03-28T10:10:10Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-8-8',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[8] Should select date into date time (example 8)',
        cypher="WITH localdatetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31, second: 14, millisecond: 645}) AS other\n      RETURN datetime({date: other, day: 28, hour: 10, minute: 10, second: 10, timezone: 'Pacific/Honolulu'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-03-28T10:10:10-10:00[Pacific/Honolulu]'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-8-9',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[8] Should select date into date time (example 9)',
        cypher="WITH datetime({year: 1984, month: 10, day: 11, hour: 12, timezone: '+01:00'}) AS other\n      RETURN datetime({date: other, hour: 10, minute: 10, second: 10}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T10:10:10Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-8-10',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[8] Should select date into date time (example 10)',
        cypher="WITH datetime({year: 1984, month: 10, day: 11, hour: 12, timezone: '+01:00'}) AS other\n      RETURN datetime({date: other, hour: 10, minute: 10, second: 10, timezone: '+05:00'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T10:10:10+05:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-8-11',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[8] Should select date into date time (example 11)',
        cypher="WITH datetime({year: 1984, month: 10, day: 11, hour: 12, timezone: '+01:00'}) AS other\n      RETURN datetime({date: other, day: 28, hour: 10, minute: 10, second: 10}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-28T10:10:10Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-8-12',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[8] Should select date into date time (example 12)',
        cypher="WITH datetime({year: 1984, month: 10, day: 11, hour: 12, timezone: '+01:00'}) AS other\n      RETURN datetime({date: other, day: 28, hour: 10, minute: 10, second: 10, timezone: 'Pacific/Honolulu'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-28T10:10:10-10:00[Pacific/Honolulu]'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-9-1',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[9] Should select time into date time (example 1)',
        cypher='WITH localtime({hour: 12, minute: 31, second: 14, nanosecond: 645876123}) AS other\n      RETURN datetime({year: 1984, month: 10, day: 11, time: other}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:31:14.645876123Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-9-2',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[9] Should select time into date time (example 2)',
        cypher="WITH localtime({hour: 12, minute: 31, second: 14, nanosecond: 645876123}) AS other\n      RETURN datetime({year: 1984, month: 10, day: 11, time: other, timezone: '+05:00'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:31:14.645876123+05:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-9-3',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[9] Should select time into date time (example 3)',
        cypher='WITH localtime({hour: 12, minute: 31, second: 14, nanosecond: 645876123}) AS other\n      RETURN datetime({year: 1984, month: 10, day: 11, time: other, second: 42}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:31:42.645876123Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-9-4',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[9] Should select time into date time (example 4)',
        cypher="WITH localtime({hour: 12, minute: 31, second: 14, nanosecond: 645876123}) AS other\n      RETURN datetime({year: 1984, month: 10, day: 11, time: other, second: 42, timezone: 'Pacific/Honolulu'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:31:42.645876123-10:00[Pacific/Honolulu]'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-9-5',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[9] Should select time into date time (example 5)',
        cypher="WITH time({hour: 12, minute: 31, second: 14, microsecond: 645876, timezone: '+01:00'}) AS other\n      RETURN datetime({year: 1984, month: 10, day: 11, time: other}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:31:14.645876+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-9-6',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[9] Should select time into date time (example 6)',
        cypher="WITH time({hour: 12, minute: 31, second: 14, microsecond: 645876, timezone: '+01:00'}) AS other\n      RETURN datetime({year: 1984, month: 10, day: 11, time: other, timezone: '+05:00'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T16:31:14.645876+05:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-9-7',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[9] Should select time into date time (example 7)',
        cypher="WITH time({hour: 12, minute: 31, second: 14, microsecond: 645876, timezone: '+01:00'}) AS other\n      RETURN datetime({year: 1984, month: 10, day: 11, time: other, second: 42}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:31:42.645876+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-9-8',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[9] Should select time into date time (example 8)',
        cypher="WITH time({hour: 12, minute: 31, second: 14, microsecond: 645876, timezone: '+01:00'}) AS other\n      RETURN datetime({year: 1984, month: 10, day: 11, time: other, second: 42, timezone: 'Pacific/Honolulu'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T01:31:42.645876-10:00[Pacific/Honolulu]'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-9-9',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[9] Should select time into date time (example 9)',
        cypher='WITH localdatetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31, second: 14, millisecond: 645}) AS other\n      RETURN datetime({year: 1984, month: 10, day: 11, time: other}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:31:14.645Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-9-10',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[9] Should select time into date time (example 10)',
        cypher="WITH localdatetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31, second: 14, millisecond: 645}) AS other\n      RETURN datetime({year: 1984, month: 10, day: 11, time: other, timezone: '+05:00'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:31:14.645+05:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-9-11',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[9] Should select time into date time (example 11)',
        cypher='WITH localdatetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31, second: 14, millisecond: 645}) AS other\n      RETURN datetime({year: 1984, month: 10, day: 11, time: other, second: 42}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:31:42.645Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-9-12',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[9] Should select time into date time (example 12)',
        cypher="WITH localdatetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31, second: 14, millisecond: 645}) AS other\n      RETURN datetime({year: 1984, month: 10, day: 11, time: other, second: 42, timezone: 'Pacific/Honolulu'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:31:42.645-10:00[Pacific/Honolulu]'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-9-13',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[9] Should select time into date time (example 13)',
        cypher="WITH datetime({year: 1984, month: 10, day: 11, hour: 12, timezone: 'Europe/Stockholm'}) AS other\n      RETURN datetime({year: 1984, month: 10, day: 11, time: other}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:00+01:00[Europe/Stockholm]'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-9-14',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[9] Should select time into date time (example 14)',
        cypher="WITH datetime({year: 1984, month: 10, day: 11, hour: 12, timezone: 'Europe/Stockholm'}) AS other\n      RETURN datetime({year: 1984, month: 10, day: 11, time: other, timezone: '+05:00'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T16:00+05:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-9-15',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[9] Should select time into date time (example 15)',
        cypher="WITH datetime({year: 1984, month: 10, day: 11, hour: 12, timezone: 'Europe/Stockholm'}) AS other\n      RETURN datetime({year: 1984, month: 10, day: 11, time: other, second: 42}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:00:42+01:00[Europe/Stockholm]'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-9-16',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[9] Should select time into date time (example 16)',
        cypher="WITH datetime({year: 1984, month: 10, day: 11, hour: 12, timezone: 'Europe/Stockholm'}) AS other\n      RETURN datetime({year: 1984, month: 10, day: 11, time: other, second: 42, timezone: 'Pacific/Honolulu'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T01:00:42-10:00[Pacific/Honolulu]'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-10-1',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[10] Should select date and time into date time (example 1)',
        cypher='WITH date({year: 1984, month: 10, day: 11}) AS otherDate, localtime({hour: 12, minute: 31, second: 14, nanosecond: 645876123}) AS otherTime\n      RETURN datetime({date: otherDate, time: otherTime}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:31:14.645876123Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-10-2',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[10] Should select date and time into date time (example 2)',
        cypher="WITH date({year: 1984, month: 10, day: 11}) AS otherDate, localtime({hour: 12, minute: 31, second: 14, nanosecond: 645876123}) AS otherTime\n      RETURN datetime({date: otherDate, time: otherTime, timezone: '+05:00'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:31:14.645876123+05:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-10-3',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[10] Should select date and time into date time (example 3)',
        cypher='WITH date({year: 1984, month: 10, day: 11}) AS otherDate, localtime({hour: 12, minute: 31, second: 14, nanosecond: 645876123}) AS otherTime\n      RETURN datetime({date: otherDate, time: otherTime, day: 28, second: 42}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-28T12:31:42.645876123Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-10-4',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[10] Should select date and time into date time (example 4)',
        cypher="WITH date({year: 1984, month: 10, day: 11}) AS otherDate, localtime({hour: 12, minute: 31, second: 14, nanosecond: 645876123}) AS otherTime\n      RETURN datetime({date: otherDate, time: otherTime, day: 28, second: 42, timezone: 'Pacific/Honolulu'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-28T12:31:42.645876123-10:00[Pacific/Honolulu]'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-10-5',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[10] Should select date and time into date time (example 5)',
        cypher="WITH date({year: 1984, month: 10, day: 11}) AS otherDate, time({hour: 12, minute: 31, second: 14, microsecond: 645876, timezone: '+01:00'}) AS otherTime\n      RETURN datetime({date: otherDate, time: otherTime}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:31:14.645876+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-10-6',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[10] Should select date and time into date time (example 6)',
        cypher="WITH date({year: 1984, month: 10, day: 11}) AS otherDate, time({hour: 12, minute: 31, second: 14, microsecond: 645876, timezone: '+01:00'}) AS otherTime\n      RETURN datetime({date: otherDate, time: otherTime, timezone: '+05:00'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T16:31:14.645876+05:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-10-7',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[10] Should select date and time into date time (example 7)',
        cypher="WITH date({year: 1984, month: 10, day: 11}) AS otherDate, time({hour: 12, minute: 31, second: 14, microsecond: 645876, timezone: '+01:00'}) AS otherTime\n      RETURN datetime({date: otherDate, time: otherTime, day: 28, second: 42}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-28T12:31:42.645876+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-10-8',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[10] Should select date and time into date time (example 8)',
        cypher="WITH date({year: 1984, month: 10, day: 11}) AS otherDate, time({hour: 12, minute: 31, second: 14, microsecond: 645876, timezone: '+01:00'}) AS otherTime\n      RETURN datetime({date: otherDate, time: otherTime, day: 28, second: 42, timezone: 'Pacific/Honolulu'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-28T01:31:42.645876-10:00[Pacific/Honolulu]'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-10-9',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[10] Should select date and time into date time (example 9)',
        cypher='WITH date({year: 1984, month: 10, day: 11}) AS otherDate, localdatetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31, second: 14, millisecond: 645}) AS otherTime\n      RETURN datetime({date: otherDate, time: otherTime}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:31:14.645Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-10-10',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[10] Should select date and time into date time (example 10)',
        cypher="WITH date({year: 1984, month: 10, day: 11}) AS otherDate, localdatetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31, second: 14, millisecond: 645}) AS otherTime\n      RETURN datetime({date: otherDate, time: otherTime, timezone: '+05:00'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:31:14.645+05:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-10-11',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[10] Should select date and time into date time (example 11)',
        cypher='WITH date({year: 1984, month: 10, day: 11}) AS otherDate, localdatetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31, second: 14, millisecond: 645}) AS otherTime\n      RETURN datetime({date: otherDate, time: otherTime, day: 28, second: 42}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-28T12:31:42.645Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-10-12',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[10] Should select date and time into date time (example 12)',
        cypher="WITH date({year: 1984, month: 10, day: 11}) AS otherDate, localdatetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31, second: 14, millisecond: 645}) AS otherTime\n      RETURN datetime({date: otherDate, time: otherTime, day: 28, second: 42, timezone: 'Pacific/Honolulu'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-28T12:31:42.645-10:00[Pacific/Honolulu]'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-10-13',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[10] Should select date and time into date time (example 13)',
        cypher="WITH date({year: 1984, month: 10, day: 11}) AS otherDate, datetime({year: 1984, month: 10, day: 11, hour: 12, timezone: 'Europe/Stockholm'}) AS otherTime\n      RETURN datetime({date: otherDate, time: otherTime}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:00+01:00[Europe/Stockholm]'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-10-14',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[10] Should select date and time into date time (example 14)',
        cypher="WITH date({year: 1984, month: 10, day: 11}) AS otherDate, datetime({year: 1984, month: 10, day: 11, hour: 12, timezone: 'Europe/Stockholm'}) AS otherTime\n      RETURN datetime({date: otherDate, time: otherTime, timezone: '+05:00'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T16:00+05:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-10-15',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[10] Should select date and time into date time (example 15)',
        cypher="WITH date({year: 1984, month: 10, day: 11}) AS otherDate, datetime({year: 1984, month: 10, day: 11, hour: 12, timezone: 'Europe/Stockholm'}) AS otherTime\n      RETURN datetime({date: otherDate, time: otherTime, day: 28, second: 42}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-28T12:00:42+01:00[Europe/Stockholm]'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-10-16',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[10] Should select date and time into date time (example 16)',
        cypher="WITH date({year: 1984, month: 10, day: 11}) AS otherDate, datetime({year: 1984, month: 10, day: 11, hour: 12, timezone: 'Europe/Stockholm'}) AS otherTime\n      RETURN datetime({date: otherDate, time: otherTime, day: 28, second: 42, timezone: 'Pacific/Honolulu'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-28T01:00:42-10:00[Pacific/Honolulu]'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-10-17',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[10] Should select date and time into date time (example 17)',
        cypher='WITH localdatetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31, second: 14, millisecond: 645}) AS otherDate, localtime({hour: 12, minute: 31, second: 14, nanosecond: 645876123}) AS otherTime\n      RETURN datetime({date: otherDate, time: otherTime}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-03-07T12:31:14.645876123Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-10-18',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[10] Should select date and time into date time (example 18)',
        cypher="WITH localdatetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31, second: 14, millisecond: 645}) AS otherDate, localtime({hour: 12, minute: 31, second: 14, nanosecond: 645876123}) AS otherTime\n      RETURN datetime({date: otherDate, time: otherTime, timezone: '+05:00'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-03-07T12:31:14.645876123+05:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-10-19',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[10] Should select date and time into date time (example 19)',
        cypher='WITH localdatetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31, second: 14, millisecond: 645}) AS otherDate, localtime({hour: 12, minute: 31, second: 14, nanosecond: 645876123}) AS otherTime\n      RETURN datetime({date: otherDate, time: otherTime, day: 28, second: 42}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-03-28T12:31:42.645876123Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-10-20',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[10] Should select date and time into date time (example 20)',
        cypher="WITH localdatetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31, second: 14, millisecond: 645}) AS otherDate, localtime({hour: 12, minute: 31, second: 14, nanosecond: 645876123}) AS otherTime\n      RETURN datetime({date: otherDate, time: otherTime, day: 28, second: 42, timezone: 'Pacific/Honolulu'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-03-28T12:31:42.645876123-10:00[Pacific/Honolulu]'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-10-21',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[10] Should select date and time into date time (example 21)',
        cypher="WITH localdatetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31, second: 14, millisecond: 645}) AS otherDate, time({hour: 12, minute: 31, second: 14, microsecond: 645876, timezone: '+01:00'}) AS otherTime\n      RETURN datetime({date: otherDate, time: otherTime}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-03-07T12:31:14.645876+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-10-22',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[10] Should select date and time into date time (example 22)',
        cypher="WITH localdatetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31, second: 14, millisecond: 645}) AS otherDate, time({hour: 12, minute: 31, second: 14, microsecond: 645876, timezone: '+01:00'}) AS otherTime\n      RETURN datetime({date: otherDate, time: otherTime, timezone: '+05:00'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-03-07T16:31:14.645876+05:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-10-23',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[10] Should select date and time into date time (example 23)',
        cypher="WITH localdatetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31, second: 14, millisecond: 645}) AS otherDate, time({hour: 12, minute: 31, second: 14, microsecond: 645876, timezone: '+01:00'}) AS otherTime\n      RETURN datetime({date: otherDate, time: otherTime, day: 28, second: 42}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-03-28T12:31:42.645876+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-10-24',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[10] Should select date and time into date time (example 24)',
        cypher="WITH localdatetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31, second: 14, millisecond: 645}) AS otherDate, time({hour: 12, minute: 31, second: 14, microsecond: 645876, timezone: '+01:00'}) AS otherTime\n      RETURN datetime({date: otherDate, time: otherTime, day: 28, second: 42, timezone: 'Pacific/Honolulu'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-03-28T01:31:42.645876-10:00[Pacific/Honolulu]'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-10-25',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[10] Should select date and time into date time (example 25)',
        cypher='WITH localdatetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31, second: 14, millisecond: 645}) AS otherDate, localdatetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31, second: 14, millisecond: 645}) AS otherTime\n      RETURN datetime({date: otherDate, time: otherTime}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-03-07T12:31:14.645Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-10-26',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[10] Should select date and time into date time (example 26)',
        cypher="WITH localdatetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31, second: 14, millisecond: 645}) AS otherDate, localdatetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31, second: 14, millisecond: 645}) AS otherTime\n      RETURN datetime({date: otherDate, time: otherTime, timezone: '+05:00'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-03-07T12:31:14.645+05:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-10-27',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[10] Should select date and time into date time (example 27)',
        cypher='WITH localdatetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31, second: 14, millisecond: 645}) AS otherDate, localdatetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31, second: 14, millisecond: 645}) AS otherTime\n      RETURN datetime({date: otherDate, time: otherTime, day: 28, second: 42}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-03-28T12:31:42.645Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-10-28',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[10] Should select date and time into date time (example 28)',
        cypher="WITH localdatetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31, second: 14, millisecond: 645}) AS otherDate, localdatetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31, second: 14, millisecond: 645}) AS otherTime\n      RETURN datetime({date: otherDate, time: otherTime, day: 28, second: 42, timezone: 'Pacific/Honolulu'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-03-28T12:31:42.645-10:00[Pacific/Honolulu]'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-10-29',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[10] Should select date and time into date time (example 29)',
        cypher="WITH localdatetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31, second: 14, millisecond: 645}) AS otherDate, datetime({year: 1984, month: 10, day: 11, hour: 12, timezone: 'Europe/Stockholm'}) AS otherTime\n      RETURN datetime({date: otherDate, time: otherTime}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-03-07T12:00+01:00[Europe/Stockholm]'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-10-30',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[10] Should select date and time into date time (example 30)',
        cypher="WITH localdatetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31, second: 14, millisecond: 645}) AS otherDate, datetime({year: 1984, month: 10, day: 11, hour: 12, timezone: 'Europe/Stockholm'}) AS otherTime\n      RETURN datetime({date: otherDate, time: otherTime, timezone: '+05:00'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-03-07T16:00+05:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-10-31',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[10] Should select date and time into date time (example 31)',
        cypher="WITH localdatetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31, second: 14, millisecond: 645}) AS otherDate, datetime({year: 1984, month: 10, day: 11, hour: 12, timezone: 'Europe/Stockholm'}) AS otherTime\n      RETURN datetime({date: otherDate, time: otherTime, day: 28, second: 42}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-03-28T12:00:42+02:00[Europe/Stockholm]'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-10-32',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[10] Should select date and time into date time (example 32)',
        cypher="WITH localdatetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31, second: 14, millisecond: 645}) AS otherDate, datetime({year: 1984, month: 10, day: 11, hour: 12, timezone: 'Europe/Stockholm'}) AS otherTime\n      RETURN datetime({date: otherDate, time: otherTime, day: 28, second: 42, timezone: 'Pacific/Honolulu'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-03-28T00:00:42-10:00[Pacific/Honolulu]'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-10-33',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[10] Should select date and time into date time (example 33)',
        cypher="WITH datetime({year: 1984, month: 10, day: 11, hour: 12, timezone: '+01:00'}) AS otherDate, localtime({hour: 12, minute: 31, second: 14, nanosecond: 645876123}) AS otherTime\n      RETURN datetime({date: otherDate, time: otherTime}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:31:14.645876123Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-10-34',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[10] Should select date and time into date time (example 34)',
        cypher="WITH datetime({year: 1984, month: 10, day: 11, hour: 12, timezone: '+01:00'}) AS otherDate, localtime({hour: 12, minute: 31, second: 14, nanosecond: 645876123}) AS otherTime\n      RETURN datetime({date: otherDate, time: otherTime, timezone: '+05:00'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:31:14.645876123+05:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-10-35',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[10] Should select date and time into date time (example 35)',
        cypher="WITH datetime({year: 1984, month: 10, day: 11, hour: 12, timezone: '+01:00'}) AS otherDate, localtime({hour: 12, minute: 31, second: 14, nanosecond: 645876123}) AS otherTime\n      RETURN datetime({date: otherDate, time: otherTime, day: 28, second: 42}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-28T12:31:42.645876123Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-10-36',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[10] Should select date and time into date time (example 36)',
        cypher="WITH datetime({year: 1984, month: 10, day: 11, hour: 12, timezone: '+01:00'}) AS otherDate, localtime({hour: 12, minute: 31, second: 14, nanosecond: 645876123}) AS otherTime\n      RETURN datetime({date: otherDate, time: otherTime, day: 28, second: 42, timezone: 'Pacific/Honolulu'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-28T12:31:42.645876123-10:00[Pacific/Honolulu]'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-10-37',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[10] Should select date and time into date time (example 37)',
        cypher="WITH datetime({year: 1984, month: 10, day: 11, hour: 12, timezone: '+01:00'}) AS otherDate, time({hour: 12, minute: 31, second: 14, microsecond: 645876, timezone: '+01:00'}) AS otherTime\n      RETURN datetime({date: otherDate, time: otherTime}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:31:14.645876+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-10-38',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[10] Should select date and time into date time (example 38)',
        cypher="WITH datetime({year: 1984, month: 10, day: 11, hour: 12, timezone: '+01:00'}) AS otherDate, time({hour: 12, minute: 31, second: 14, microsecond: 645876, timezone: '+01:00'}) AS otherTime\n      RETURN datetime({date: otherDate, time: otherTime, timezone: '+05:00'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T16:31:14.645876+05:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-10-39',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[10] Should select date and time into date time (example 39)',
        cypher="WITH datetime({year: 1984, month: 10, day: 11, hour: 12, timezone: '+01:00'}) AS otherDate, time({hour: 12, minute: 31, second: 14, microsecond: 645876, timezone: '+01:00'}) AS otherTime\n      RETURN datetime({date: otherDate, time: otherTime, day: 28, second: 42}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-28T12:31:42.645876+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-10-40',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[10] Should select date and time into date time (example 40)',
        cypher="WITH datetime({year: 1984, month: 10, day: 11, hour: 12, timezone: '+01:00'}) AS otherDate, time({hour: 12, minute: 31, second: 14, microsecond: 645876, timezone: '+01:00'}) AS otherTime\n      RETURN datetime({date: otherDate, time: otherTime, day: 28, second: 42, timezone: 'Pacific/Honolulu'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-28T01:31:42.645876-10:00[Pacific/Honolulu]'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-10-41',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[10] Should select date and time into date time (example 41)',
        cypher="WITH datetime({year: 1984, month: 10, day: 11, hour: 12, timezone: '+01:00'}) AS otherDate, localdatetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31, second: 14, millisecond: 645}) AS otherTime\n      RETURN datetime({date: otherDate, time: otherTime}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:31:14.645Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-10-42',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[10] Should select date and time into date time (example 42)',
        cypher="WITH datetime({year: 1984, month: 10, day: 11, hour: 12, timezone: '+01:00'}) AS otherDate, localdatetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31, second: 14, millisecond: 645}) AS otherTime\n      RETURN datetime({date: otherDate, time: otherTime, timezone: '+05:00'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:31:14.645+05:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-10-43',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[10] Should select date and time into date time (example 43)',
        cypher="WITH datetime({year: 1984, month: 10, day: 11, hour: 12, timezone: '+01:00'}) AS otherDate, localdatetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31, second: 14, millisecond: 645}) AS otherTime\n      RETURN datetime({date: otherDate, time: otherTime, day: 28, second: 42}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-28T12:31:42.645Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-10-44',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[10] Should select date and time into date time (example 44)',
        cypher="WITH datetime({year: 1984, month: 10, day: 11, hour: 12, timezone: '+01:00'}) AS otherDate, localdatetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31, second: 14, millisecond: 645}) AS otherTime\n      RETURN datetime({date: otherDate, time: otherTime, day: 28, second: 42, timezone: 'Pacific/Honolulu'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-28T12:31:42.645-10:00[Pacific/Honolulu]'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-10-45',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[10] Should select date and time into date time (example 45)',
        cypher="WITH datetime({year: 1984, month: 10, day: 11, hour: 12, timezone: '+01:00'}) AS otherDate, datetime({year: 1984, month: 10, day: 11, hour: 12, timezone: 'Europe/Stockholm'}) AS otherTime\n      RETURN datetime({date: otherDate, time: otherTime}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:00+01:00[Europe/Stockholm]'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-10-46',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[10] Should select date and time into date time (example 46)',
        cypher="WITH datetime({year: 1984, month: 10, day: 11, hour: 12, timezone: '+01:00'}) AS otherDate, datetime({year: 1984, month: 10, day: 11, hour: 12, timezone: 'Europe/Stockholm'}) AS otherTime\n      RETURN datetime({date: otherDate, time: otherTime, timezone: '+05:00'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T16:00+05:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-10-47',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[10] Should select date and time into date time (example 47)',
        cypher="WITH datetime({year: 1984, month: 10, day: 11, hour: 12, timezone: '+01:00'}) AS otherDate, datetime({year: 1984, month: 10, day: 11, hour: 12, timezone: 'Europe/Stockholm'}) AS otherTime\n      RETURN datetime({date: otherDate, time: otherTime, day: 28, second: 42}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-28T12:00:42+01:00[Europe/Stockholm]'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-10-48',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[10] Should select date and time into date time (example 48)',
        cypher="WITH datetime({year: 1984, month: 10, day: 11, hour: 12, timezone: '+01:00'}) AS otherDate, datetime({year: 1984, month: 10, day: 11, hour: 12, timezone: 'Europe/Stockholm'}) AS otherTime\n      RETURN datetime({date: otherDate, time: otherTime, day: 28, second: 42, timezone: 'Pacific/Honolulu'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-28T01:00:42-10:00[Pacific/Honolulu]'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-11-1',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[11] Should datetime into date time (example 1)',
        cypher='WITH localdatetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31, second: 14, millisecond: 645}) AS other\n      RETURN datetime(other) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-03-07T12:31:14.645Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-11-2',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[11] Should datetime into date time (example 2)',
        cypher='WITH localdatetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31, second: 14, millisecond: 645}) AS other\n      RETURN datetime({datetime: other}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-03-07T12:31:14.645Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-11-3',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[11] Should datetime into date time (example 3)',
        cypher="WITH localdatetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31, second: 14, millisecond: 645}) AS other\n      RETURN datetime({datetime: other, timezone: '+05:00'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-03-07T12:31:14.645+05:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-11-4',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[11] Should datetime into date time (example 4)',
        cypher='WITH localdatetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31, second: 14, millisecond: 645}) AS other\n      RETURN datetime({datetime: other, day: 28, second: 42}) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-03-28T12:31:42.645Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-11-5',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[11] Should datetime into date time (example 5)',
        cypher="WITH localdatetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31, second: 14, millisecond: 645}) AS other\n      RETURN datetime({datetime: other, day: 28, second: 42, timezone: 'Pacific/Honolulu'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-03-28T12:31:42.645-10:00[Pacific/Honolulu]'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-11-6',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[11] Should datetime into date time (example 6)',
        cypher="WITH datetime({year: 1984, month: 10, day: 11, hour: 12, timezone: 'Europe/Stockholm'}) AS other\n      RETURN datetime(other) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:00+01:00[Europe/Stockholm]'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-11-7',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[11] Should datetime into date time (example 7)',
        cypher="WITH datetime({year: 1984, month: 10, day: 11, hour: 12, timezone: 'Europe/Stockholm'}) AS other\n      RETURN datetime({datetime: other}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:00+01:00[Europe/Stockholm]'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-11-8',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[11] Should datetime into date time (example 8)',
        cypher="WITH datetime({year: 1984, month: 10, day: 11, hour: 12, timezone: 'Europe/Stockholm'}) AS other\n      RETURN datetime({datetime: other, timezone: '+05:00'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T16:00+05:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-11-9',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[11] Should datetime into date time (example 9)',
        cypher="WITH datetime({year: 1984, month: 10, day: 11, hour: 12, timezone: 'Europe/Stockholm'}) AS other\n      RETURN datetime({datetime: other, day: 28, second: 42}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-28T12:00:42+01:00[Europe/Stockholm]'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal3-11-10',
        feature_path='tck/features/expressions/temporal/Temporal3.feature',
        scenario='[11] Should datetime into date time (example 10)',
        cypher="WITH datetime({year: 1984, month: 10, day: 11, hour: 12, timezone: 'Europe/Stockholm'}) AS other\n      RETURN datetime({datetime: other, day: 28, second: 42, timezone: 'Pacific/Honolulu'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-28T01:00:42-10:00[Pacific/Honolulu]'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal4-1-1',
        feature_path='tck/features/expressions/temporal/Temporal4.feature',
        scenario='[1] Should store date (example 1)',
        cypher='CREATE ({created: date({year: 1984, month: 10, day: 11})})',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal4-2-1',
        feature_path='tck/features/expressions/temporal/Temporal4.feature',
        scenario='[2] Should store date array (example 1)',
        cypher='CREATE ({dates: [date({year: 1984, month: 10, day: 12})]})',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal4-2-2',
        feature_path='tck/features/expressions/temporal/Temporal4.feature',
        scenario='[2] Should store date array (example 2)',
        cypher='CREATE ({dates: [date({year: 1984, month: 10, day: 13}), date({year: 1984, month: 10, day: 14}), date({year: 1984, month: 10, day: 15})]})',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal4-3-1',
        feature_path='tck/features/expressions/temporal/Temporal4.feature',
        scenario='[3] Should store local time (example 1)',
        cypher='CREATE ({created: localtime({hour: 12})})',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal4-4-1',
        feature_path='tck/features/expressions/temporal/Temporal4.feature',
        scenario='[4] Should store local time array (example 1)',
        cypher='CREATE ({dates: [localtime({hour: 13})]})',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal4-4-2',
        feature_path='tck/features/expressions/temporal/Temporal4.feature',
        scenario='[4] Should store local time array (example 2)',
        cypher='CREATE ({dates: [localtime({hour: 14}), localtime({hour: 15}), localtime({hour: 16})]})',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal4-5-1',
        feature_path='tck/features/expressions/temporal/Temporal4.feature',
        scenario='[5] Should store time (example 1)',
        cypher='CREATE ({created: time({hour: 12})})',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal4-6-1',
        feature_path='tck/features/expressions/temporal/Temporal4.feature',
        scenario='[6] Should store time array (example 1)',
        cypher='CREATE ({dates: [time({hour: 13})]})',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal4-6-2',
        feature_path='tck/features/expressions/temporal/Temporal4.feature',
        scenario='[6] Should store time array (example 2)',
        cypher='CREATE ({dates: [time({hour: 14}), time({hour: 15}), time({hour: 16})]})',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal4-7-1',
        feature_path='tck/features/expressions/temporal/Temporal4.feature',
        scenario='[7] Should store local date time (example 1)',
        cypher='CREATE ({created: localdatetime({year: 1912})})',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal4-8-1',
        feature_path='tck/features/expressions/temporal/Temporal4.feature',
        scenario='[8] Should store local date time array (example 1)',
        cypher='CREATE ({dates: [localdatetime({year: 1913})]})',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal4-8-2',
        feature_path='tck/features/expressions/temporal/Temporal4.feature',
        scenario='[8] Should store local date time array (example 2)',
        cypher='CREATE ({dates: [localdatetime({year: 1914}), localdatetime({year: 1915}), localdatetime({year: 1916})]})',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal4-9-1',
        feature_path='tck/features/expressions/temporal/Temporal4.feature',
        scenario='[9] Should store date time (example 1)',
        cypher='CREATE ({created: datetime({year: 1912})})',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal4-10-1',
        feature_path='tck/features/expressions/temporal/Temporal4.feature',
        scenario='[10] Should store date time array (example 1)',
        cypher='CREATE ({dates: [datetime({year: 1913})]})',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal4-10-2',
        feature_path='tck/features/expressions/temporal/Temporal4.feature',
        scenario='[10] Should store date time array (example 2)',
        cypher='CREATE ({dates: [datetime({year: 1914}), datetime({year: 1915}), datetime({year: 1916})]})',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal4-11-1',
        feature_path='tck/features/expressions/temporal/Temporal4.feature',
        scenario='[11] Should store duration (example 1)',
        cypher='CREATE ({created: duration({seconds: 12})})',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal4-12-1',
        feature_path='tck/features/expressions/temporal/Temporal4.feature',
        scenario='[12] Should store duration array (example 1)',
        cypher='CREATE ({dates: [duration({seconds: 13})]})',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal4-12-2',
        feature_path='tck/features/expressions/temporal/Temporal4.feature',
        scenario='[12] Should store duration array (example 2)',
        cypher='CREATE ({dates: [duration({seconds: 14}), duration({seconds: 15}), duration({seconds: 16})]})',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(rows=[]),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal4-13-1',
        feature_path='tck/features/expressions/temporal/Temporal4.feature',
        scenario='[13] Should propagate null (example 1)',
        cypher='RETURN date(null) AS t',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'t': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal4-13-2',
        feature_path='tck/features/expressions/temporal/Temporal4.feature',
        scenario='[13] Should propagate null (example 2)',
        cypher='RETURN date.transaction(null) AS t',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'t': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal4-13-3',
        feature_path='tck/features/expressions/temporal/Temporal4.feature',
        scenario='[13] Should propagate null (example 3)',
        cypher='RETURN date.statement(null) AS t',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'t': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal4-13-4',
        feature_path='tck/features/expressions/temporal/Temporal4.feature',
        scenario='[13] Should propagate null (example 4)',
        cypher='RETURN date.realtime(null) AS t',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'t': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal4-13-5',
        feature_path='tck/features/expressions/temporal/Temporal4.feature',
        scenario='[13] Should propagate null (example 5)',
        cypher='RETURN localtime(null) AS t',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'t': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal4-13-6',
        feature_path='tck/features/expressions/temporal/Temporal4.feature',
        scenario='[13] Should propagate null (example 6)',
        cypher='RETURN localtime.transaction(null) AS t',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'t': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal4-13-7',
        feature_path='tck/features/expressions/temporal/Temporal4.feature',
        scenario='[13] Should propagate null (example 7)',
        cypher='RETURN localtime.statement(null) AS t',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'t': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal4-13-8',
        feature_path='tck/features/expressions/temporal/Temporal4.feature',
        scenario='[13] Should propagate null (example 8)',
        cypher='RETURN localtime.realtime(null) AS t',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'t': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal4-13-9',
        feature_path='tck/features/expressions/temporal/Temporal4.feature',
        scenario='[13] Should propagate null (example 9)',
        cypher='RETURN time(null) AS t',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'t': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal4-13-10',
        feature_path='tck/features/expressions/temporal/Temporal4.feature',
        scenario='[13] Should propagate null (example 10)',
        cypher='RETURN time.transaction(null) AS t',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'t': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal4-13-11',
        feature_path='tck/features/expressions/temporal/Temporal4.feature',
        scenario='[13] Should propagate null (example 11)',
        cypher='RETURN time.statement(null) AS t',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'t': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal4-13-12',
        feature_path='tck/features/expressions/temporal/Temporal4.feature',
        scenario='[13] Should propagate null (example 12)',
        cypher='RETURN time.realtime(null) AS t',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'t': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal4-13-13',
        feature_path='tck/features/expressions/temporal/Temporal4.feature',
        scenario='[13] Should propagate null (example 13)',
        cypher='RETURN localdatetime(null) AS t',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'t': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal4-13-14',
        feature_path='tck/features/expressions/temporal/Temporal4.feature',
        scenario='[13] Should propagate null (example 14)',
        cypher='RETURN localdatetime.transaction(null) AS t',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'t': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal4-13-15',
        feature_path='tck/features/expressions/temporal/Temporal4.feature',
        scenario='[13] Should propagate null (example 15)',
        cypher='RETURN localdatetime.statement(null) AS t',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'t': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal4-13-16',
        feature_path='tck/features/expressions/temporal/Temporal4.feature',
        scenario='[13] Should propagate null (example 16)',
        cypher='RETURN localdatetime.realtime(null) AS t',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'t': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal4-13-17',
        feature_path='tck/features/expressions/temporal/Temporal4.feature',
        scenario='[13] Should propagate null (example 17)',
        cypher='RETURN datetime(null) AS t',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'t': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal4-13-18',
        feature_path='tck/features/expressions/temporal/Temporal4.feature',
        scenario='[13] Should propagate null (example 18)',
        cypher='RETURN datetime.transaction(null) AS t',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'t': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal4-13-19',
        feature_path='tck/features/expressions/temporal/Temporal4.feature',
        scenario='[13] Should propagate null (example 19)',
        cypher='RETURN datetime.statement(null) AS t',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'t': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal4-13-20',
        feature_path='tck/features/expressions/temporal/Temporal4.feature',
        scenario='[13] Should propagate null (example 20)',
        cypher='RETURN datetime.realtime(null) AS t',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'t': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal4-13-21',
        feature_path='tck/features/expressions/temporal/Temporal4.feature',
        scenario='[13] Should propagate null (example 21)',
        cypher='RETURN duration(null) AS t',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'t': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal5-1',
        feature_path='tck/features/expressions/temporal/Temporal5.feature',
        scenario='[1] Should provide accessors for date',
        cypher='MATCH (v:Val)\n      WITH v.date AS d\n      RETURN d.year, d.quarter, d.month, d.week, d.weekYear, d.day, d.ordinalDay, d.weekDay, d.dayOfQuarter',
        graph=graph_fixture_from_create(
            """
            CREATE (:Val {date: date({year: 1984, month: 10, day: 11})})
            """
        ),
        expected=Expected(
            rows=[
            {'d.year': 1984, 'd.quarter': 4, 'd.month': 10, 'd.week': 41, 'd.weekYear': 1984, 'd.day': 11, 'd.ordinalDay': 285, 'd.weekDay': 4, 'd.dayOfQuarter': 11}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal5-2',
        feature_path='tck/features/expressions/temporal/Temporal5.feature',
        scenario='[2] Should provide accessors for date in last weekYear',
        cypher='MATCH (v:Val)\n      WITH v.date AS d\n      RETURN d.year, d.weekYear, d.week, d.weekDay',
        graph=graph_fixture_from_create(
            """
            CREATE (:Val {date: date({year: 1984, month: 1, day: 1})})
            """
        ),
        expected=Expected(
            rows=[
            {'d.year': 1984, 'd.weekYear': 1983, 'd.week': 52, 'd.weekDay': 7}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal5-3',
        feature_path='tck/features/expressions/temporal/Temporal5.feature',
        scenario='[3] Should provide accessors for local time',
        cypher='MATCH (v:Val)\n      WITH v.date AS d\n      RETURN d.hour, d.minute, d.second, d.millisecond, d.microsecond, d.nanosecond',
        graph=graph_fixture_from_create(
            """
            CREATE (:Val {date: localtime({hour: 12, minute: 31, second: 14, nanosecond: 645876123})})
            """
        ),
        expected=Expected(
            rows=[
            {'d.hour': 12, 'd.minute': 31, 'd.second': 14, 'd.millisecond': 645, 'd.microsecond': 645876, 'd.nanosecond': 645876123}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal5-4',
        feature_path='tck/features/expressions/temporal/Temporal5.feature',
        scenario='[4] Should provide accessors for time',
        cypher='MATCH (v:Val)\n      WITH v.date AS d\n      RETURN d.hour, d.minute, d.second, d.millisecond, d.microsecond, d.nanosecond, d.timezone, d.offset, d.offsetMinutes, d.offsetSeconds',
        graph=graph_fixture_from_create(
            """
            CREATE (:Val {date: time({hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'})})
            """
        ),
        expected=Expected(
            rows=[
            {'d.hour': 12, 'd.minute': 31, 'd.second': 14, 'd.millisecond': 645, 'd.microsecond': 645876, 'd.nanosecond': 645876123, 'd.timezone': "'+01:00'", 'd.offset': "'+01:00'", 'd.offsetMinutes': 60, 'd.offsetSeconds': 3600}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal5-5',
        feature_path='tck/features/expressions/temporal/Temporal5.feature',
        scenario='[5] Should provide accessors for local date time',
        cypher='MATCH (v:Val)\n      WITH v.date AS d\n      RETURN d.year, d.quarter, d.month, d.week, d.weekYear, d.day, d.ordinalDay, d.weekDay, d.dayOfQuarter,\n             d.hour, d.minute, d.second, d.millisecond, d.microsecond, d.nanosecond',
        graph=graph_fixture_from_create(
            """
            CREATE (:Val {date: localdatetime({year: 1984, month: 11, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123})})
            """
        ),
        expected=Expected(
            rows=[
            {'d.year': 1984, 'd.quarter': 4, 'd.month': 11, 'd.week': 45, 'd.weekYear': 1984, 'd.day': 11, 'd.ordinalDay': 316, 'd.weekDay': 7, 'd.dayOfQuarter': 42, 'd.hour': 12, 'd.minute': 31, 'd.second': 14, 'd.millisecond': 645, 'd.microsecond': 645876, 'd.nanosecond': 645876123}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal5-6',
        feature_path='tck/features/expressions/temporal/Temporal5.feature',
        scenario='[6] Should provide accessors for date time',
        cypher='MATCH (v:Val)\n      WITH v.date AS d\n      RETURN d.year, d.quarter, d.month, d.week, d.weekYear, d.day, d.ordinalDay, d.weekDay, d.dayOfQuarter,\n             d.hour, d.minute, d.second, d.millisecond, d.microsecond, d.nanosecond,\n             d.timezone, d.offset, d.offsetMinutes, d.offsetSeconds, d.epochSeconds, d.epochMillis',
        graph=graph_fixture_from_create(
            """
            CREATE (:Val {date: datetime({year: 1984, month: 11, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: 'Europe/Stockholm'})})
            """
        ),
        expected=Expected(
            rows=[
            {'d.year': 1984, 'd.quarter': 4, 'd.month': 11, 'd.week': 45, 'd.weekYear': 1984, 'd.day': 11, 'd.ordinalDay': 316, 'd.weekDay': 7, 'd.dayOfQuarter': 42, 'd.hour': 12, 'd.minute': 31, 'd.second': 14, 'd.millisecond': 645, 'd.microsecond': 645876, 'd.nanosecond': 645876123, 'd.timezone': "'Europe/Stockholm'", 'd.offset': "'+01:00'", 'd.offsetMinutes': 60, 'd.offsetSeconds': 3600, 'd.epochSeconds': 469020674, 'd.epochMillis': 469020674645}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal5-7',
        feature_path='tck/features/expressions/temporal/Temporal5.feature',
        scenario='[7] Should provide accessors for duration',
        cypher='MATCH (v:Val)\n      WITH v.date AS d\n      RETURN d.years, d.quarters, d.months, d.weeks, d.days,\n             d.hours, d.minutes, d.seconds, d.milliseconds, d.microseconds, d.nanoseconds,\n             d.quartersOfYear, d.monthsOfQuarter, d.monthsOfYear, d.daysOfWeek, d.minutesOfHour, d.secondsOfMinute, d.millisecondsOfSecond, d.microsecondsOfSecond, d.nanosecondsOfSecond',
        graph=graph_fixture_from_create(
            """
            CREATE (:Val {date: duration({years: 1, months: 4, days: 10, hours: 1, minutes: 1, seconds: 1, nanoseconds: 111111111})})
            """
        ),
        expected=Expected(
            rows=[
            {'d.years': 1, 'd.quarters': 5, 'd.months': 16, 'd.weeks': 1, 'd.days': 10, 'd.hours': 1, 'd.minutes': 61, 'd.seconds': 3661, 'd.milliseconds': 3661111, 'd.microseconds': 3661111111, 'd.nanoseconds': 3661111111111, 'd.quartersOfYear': 1, 'd.monthsOfQuarter': 1, 'd.monthsOfYear': 4, 'd.daysOfWeek': 3, 'd.minutesOfHour': 1, 'd.secondsOfMinute': 1, 'd.millisecondsOfSecond': 111, 'd.microsecondsOfSecond': 111111, 'd.nanosecondsOfSecond': 111111111}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal6-1',
        feature_path='tck/features/expressions/temporal/Temporal6.feature',
        scenario='[1] Should serialize date',
        cypher='WITH date({year: 1984, month: 10, day: 11}) AS d\n      RETURN toString(d) AS ts, date(toString(d)) = d AS b',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'ts': "'1984-10-11'", 'b': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal6-2',
        feature_path='tck/features/expressions/temporal/Temporal6.feature',
        scenario='[2] Should serialize local time',
        cypher='WITH localtime({hour: 12, minute: 31, second: 14, nanosecond: 645876123}) AS d\n      RETURN toString(d) AS ts, localtime(toString(d)) = d AS b',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'ts': "'12:31:14.645876123'", 'b': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal6-3',
        feature_path='tck/features/expressions/temporal/Temporal6.feature',
        scenario='[3] Should serialize time',
        cypher="WITH time({hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}) AS d\n      RETURN toString(d) AS ts, time(toString(d)) = d AS b",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'ts': "'12:31:14.645876123+01:00'", 'b': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal6-4',
        feature_path='tck/features/expressions/temporal/Temporal6.feature',
        scenario='[4] Should serialize local date time',
        cypher='WITH localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}) AS d\n      RETURN toString(d) AS ts, localdatetime(toString(d)) = d AS b',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'ts': "'1984-10-11T12:31:14.645876123'", 'b': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal6-5',
        feature_path='tck/features/expressions/temporal/Temporal6.feature',
        scenario='[5] Should serialize date time',
        cypher="WITH datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}) AS d\n      RETURN toString(d) AS ts, datetime(toString(d)) = d AS b",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'ts': "'1984-10-11T12:31:14.645876123+01:00'", 'b': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal6-6-1',
        feature_path='tck/features/expressions/temporal/Temporal6.feature',
        scenario='[6] Should serialize duration (example 1)',
        cypher='WITH duration({years: 12, months: 5, days: 14, hours: 16, minutes: 12, seconds: 70, nanoseconds: 1}) AS d\n      RETURN toString(d) AS ts, duration(toString(d)) = d AS b',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'ts': "'P12Y5M14DT16H13M10.000000001S'", 'b': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal6-6-2',
        feature_path='tck/features/expressions/temporal/Temporal6.feature',
        scenario='[6] Should serialize duration (example 2)',
        cypher='WITH duration({years: 12, months: 5, days: -14, hours: 16}) AS d\n      RETURN toString(d) AS ts, duration(toString(d)) = d AS b',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'ts': "'P12Y5M-14DT16H'", 'b': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal6-6-3',
        feature_path='tck/features/expressions/temporal/Temporal6.feature',
        scenario='[6] Should serialize duration (example 3)',
        cypher='WITH duration({minutes: 12, seconds: -60}) AS d\n      RETURN toString(d) AS ts, duration(toString(d)) = d AS b',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'ts': "'PT11M'", 'b': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal6-6-4',
        feature_path='tck/features/expressions/temporal/Temporal6.feature',
        scenario='[6] Should serialize duration (example 4)',
        cypher='WITH duration({seconds: 2, milliseconds: -1}) AS d\n      RETURN toString(d) AS ts, duration(toString(d)) = d AS b',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'ts': "'PT1.999S'", 'b': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal6-6-5',
        feature_path='tck/features/expressions/temporal/Temporal6.feature',
        scenario='[6] Should serialize duration (example 5)',
        cypher='WITH duration({seconds: -2, milliseconds: 1}) AS d\n      RETURN toString(d) AS ts, duration(toString(d)) = d AS b',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'ts': "'PT-1.999S'", 'b': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal6-6-6',
        feature_path='tck/features/expressions/temporal/Temporal6.feature',
        scenario='[6] Should serialize duration (example 6)',
        cypher='WITH duration({seconds: -2, milliseconds: -1}) AS d\n      RETURN toString(d) AS ts, duration(toString(d)) = d AS b',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'ts': "'PT-2.001S'", 'b': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal6-6-7',
        feature_path='tck/features/expressions/temporal/Temporal6.feature',
        scenario='[6] Should serialize duration (example 7)',
        cypher='WITH duration({days: 1, milliseconds: 1}) AS d\n      RETURN toString(d) AS ts, duration(toString(d)) = d AS b',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'ts': "'P1DT0.001S'", 'b': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal6-6-8',
        feature_path='tck/features/expressions/temporal/Temporal6.feature',
        scenario='[6] Should serialize duration (example 8)',
        cypher='WITH duration({days: 1, milliseconds: -1}) AS d\n      RETURN toString(d) AS ts, duration(toString(d)) = d AS b',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'ts': "'P1DT-0.001S'", 'b': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal6-6-9',
        feature_path='tck/features/expressions/temporal/Temporal6.feature',
        scenario='[6] Should serialize duration (example 9)',
        cypher='WITH duration({seconds: 60, milliseconds: -1}) AS d\n      RETURN toString(d) AS ts, duration(toString(d)) = d AS b',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'ts': "'PT59.999S'", 'b': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal6-6-10',
        feature_path='tck/features/expressions/temporal/Temporal6.feature',
        scenario='[6] Should serialize duration (example 10)',
        cypher='WITH duration({seconds: -60, milliseconds: 1}) AS d\n      RETURN toString(d) AS ts, duration(toString(d)) = d AS b',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'ts': "'PT-59.999S'", 'b': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal6-6-11',
        feature_path='tck/features/expressions/temporal/Temporal6.feature',
        scenario='[6] Should serialize duration (example 11)',
        cypher='WITH duration({seconds: -60, milliseconds: -1}) AS d\n      RETURN toString(d) AS ts, duration(toString(d)) = d AS b',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'ts': "'PT-1M-0.001S'", 'b': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal6-7',
        feature_path='tck/features/expressions/temporal/Temporal6.feature',
        scenario='[7] Should serialize timezones correctly',
        cypher="WITH datetime({year: 2017, month: 8, day: 8, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: 'Europe/Stockholm'}) AS d\n      RETURN toString(d) AS ts",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'ts': "'2017-08-08T12:31:14.645876123+02:00[Europe/Stockholm]'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal7-1-1',
        feature_path='tck/features/expressions/temporal/Temporal7.feature',
        scenario='[1] Should compare dates (example 1)',
        cypher='WITH date({year: 1980, month: 12, day: 24}) AS x, date({year: 1984, month: 10, day: 11}) AS d\n      RETURN x > d, x < d, x >= d, x <= d, x = d',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'x > d': '<gt>', 'x < d': 'true', 'x >= d': 'false', 'x <= d': 'true', 'x = d': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal7-1-2',
        feature_path='tck/features/expressions/temporal/Temporal7.feature',
        scenario='[1] Should compare dates (example 2)',
        cypher='WITH date({year: 1984, month: 10, day: 11}) AS x, date({year: 1984, month: 10, day: 11}) AS d\n      RETURN x > d, x < d, x >= d, x <= d, x = d',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'x > d': '<gt>', 'x < d': 'false', 'x >= d': 'true', 'x <= d': 'true', 'x = d': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal7-2-1',
        feature_path='tck/features/expressions/temporal/Temporal7.feature',
        scenario='[2] Should compare local times (example 1)',
        cypher='WITH localtime({hour: 10, minute: 35}) AS x, localtime({hour: 12, minute: 31, second: 14, nanosecond: 645876123}) AS d\n      RETURN x > d, x < d, x >= d, x <= d, x = d',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'x > d': '<gt>', 'x < d': 'true', 'x >= d': 'false', 'x <= d': 'true', 'x = d': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal7-2-2',
        feature_path='tck/features/expressions/temporal/Temporal7.feature',
        scenario='[2] Should compare local times (example 2)',
        cypher='WITH localtime({hour: 12, minute: 31, second: 14, nanosecond: 645876123}) AS x, localtime({hour: 12, minute: 31, second: 14, nanosecond: 645876123}) AS d\n      RETURN x > d, x < d, x >= d, x <= d, x = d',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'x > d': '<gt>', 'x < d': 'false', 'x >= d': 'true', 'x <= d': 'true', 'x = d': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal7-3-1',
        feature_path='tck/features/expressions/temporal/Temporal7.feature',
        scenario='[3] Should compare times (example 1)',
        cypher="WITH time({hour: 10, minute: 0, timezone: '+01:00'}) AS x, time({hour: 9, minute: 35, second: 14, nanosecond: 645876123, timezone: '+00:00'}) AS d\n      RETURN x > d, x < d, x >= d, x <= d, x = d",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'x > d': '<gt>', 'x < d': 'true', 'x >= d': 'false', 'x <= d': 'true', 'x = d': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal7-3-2',
        feature_path='tck/features/expressions/temporal/Temporal7.feature',
        scenario='[3] Should compare times (example 2)',
        cypher="WITH time({hour: 9, minute: 35, second: 14, nanosecond: 645876123, timezone: '+00:00'}) AS x, time({hour: 9, minute: 35, second: 14, nanosecond: 645876123, timezone: '+00:00'}) AS d\n      RETURN x > d, x < d, x >= d, x <= d, x = d",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'x > d': '<gt>', 'x < d': 'false', 'x >= d': 'true', 'x <= d': 'true', 'x = d': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal7-4-1',
        feature_path='tck/features/expressions/temporal/Temporal7.feature',
        scenario='[4] Should compare local date times (example 1)',
        cypher='WITH localdatetime({year: 1980, month: 12, day: 11, hour: 12, minute: 31, second: 14}) AS x, localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}) AS d\n      RETURN x > d, x < d, x >= d, x <= d, x = d',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'x > d': '<gt>', 'x < d': 'true', 'x >= d': 'false', 'x <= d': 'true', 'x = d': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal7-4-2',
        feature_path='tck/features/expressions/temporal/Temporal7.feature',
        scenario='[4] Should compare local date times (example 2)',
        cypher='WITH localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}) AS x, localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}) AS d\n      RETURN x > d, x < d, x >= d, x <= d, x = d',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'x > d': '<gt>', 'x < d': 'false', 'x >= d': 'true', 'x <= d': 'true', 'x = d': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal7-5-1',
        feature_path='tck/features/expressions/temporal/Temporal7.feature',
        scenario='[5] Should compare date times (example 1)',
        cypher="WITH datetime({year: 1980, month: 12, day: 11, hour: 12, minute: 31, second: 14, timezone: '+00:00'}) AS x, datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, timezone: '+05:00'}) AS d\n      RETURN x > d, x < d, x >= d, x <= d, x = d",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'x > d': '<gt>', 'x < d': 'true', 'x >= d': 'false', 'x <= d': 'true', 'x = d': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal7-5-2',
        feature_path='tck/features/expressions/temporal/Temporal7.feature',
        scenario='[5] Should compare date times (example 2)',
        cypher="WITH datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, timezone: '+05:00'}) AS x, datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, timezone: '+05:00'}) AS d\n      RETURN x > d, x < d, x >= d, x <= d, x = d",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'x > d': '<gt>', 'x < d': 'false', 'x >= d': 'true', 'x <= d': 'true', 'x = d': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal7-6-1',
        feature_path='tck/features/expressions/temporal/Temporal7.feature',
        scenario='[6] Should compare durations for equality (example 1)',
        cypher='WITH duration({years: 12, months: 5, days: 14, hours: 16, minutes: 12, seconds: 70}) AS x, date({year: 1984, month: 10, day: 11}) AS d\n      RETURN x = d',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'x = d': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal7-6-2',
        feature_path='tck/features/expressions/temporal/Temporal7.feature',
        scenario='[6] Should compare durations for equality (example 2)',
        cypher='WITH duration({years: 12, months: 5, days: 14, hours: 16, minutes: 12, seconds: 70}) AS x, localtime({hour: 12, minute: 31, second: 14, nanosecond: 645876123}) AS d\n      RETURN x = d',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'x = d': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal7-6-3',
        feature_path='tck/features/expressions/temporal/Temporal7.feature',
        scenario='[6] Should compare durations for equality (example 3)',
        cypher="WITH duration({years: 12, months: 5, days: 14, hours: 16, minutes: 12, seconds: 70}) AS x, time({hour: 9, minute: 35, second: 14, nanosecond: 645876123, timezone: '+00:00'}) AS d\n      RETURN x = d",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'x = d': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal7-6-4',
        feature_path='tck/features/expressions/temporal/Temporal7.feature',
        scenario='[6] Should compare durations for equality (example 4)',
        cypher='WITH duration({years: 12, months: 5, days: 14, hours: 16, minutes: 12, seconds: 70}) AS x, localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}) AS d\n      RETURN x = d',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'x = d': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal7-6-5',
        feature_path='tck/features/expressions/temporal/Temporal7.feature',
        scenario='[6] Should compare durations for equality (example 5)',
        cypher="WITH duration({years: 12, months: 5, days: 14, hours: 16, minutes: 12, seconds: 70}) AS x, datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, timezone: '+05:00'}) AS d\n      RETURN x = d",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'x = d': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal7-6-6',
        feature_path='tck/features/expressions/temporal/Temporal7.feature',
        scenario='[6] Should compare durations for equality (example 6)',
        cypher='WITH duration({years: 12, months: 5, days: 14, hours: 16, minutes: 12, seconds: 70}) AS x, duration({years: 12, months: 5, days: 14, hours: 16, minutes: 12, seconds: 70}) AS d\n      RETURN x = d',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'x = d': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal7-6-7',
        feature_path='tck/features/expressions/temporal/Temporal7.feature',
        scenario='[6] Should compare durations for equality (example 7)',
        cypher='WITH duration({years: 12, months: 5, days: 14, hours: 16, minutes: 12, seconds: 70}) AS x, duration({years: 12, months: 5, days: 14, hours: 16, minutes: 13, seconds: 10}) AS d\n      RETURN x = d',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'x = d': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal7-6-8',
        feature_path='tck/features/expressions/temporal/Temporal7.feature',
        scenario='[6] Should compare durations for equality (example 8)',
        cypher='WITH duration({years: 12, months: 5, days: 14, hours: 16, minutes: 12, seconds: 70}) AS x, duration({years: 12, months: 5, days: 13, hours: 40, minutes: 13, seconds: 10}) AS d\n      RETURN x = d',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'x = d': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal8-1-1',
        feature_path='tck/features/expressions/temporal/Temporal8.feature',
        scenario='[1] Should add or subtract duration to or from date (example 1)',
        cypher='WITH date({year: 1984, month: 10, day: 11}) AS x\n      MATCH (d:Duration)\n      RETURN x + d.dur AS sum, x - d.dur AS diff',
        graph=graph_fixture_from_create(
            """
            CREATE (:Duration {dur: duration({years: 12, months: 5, days: 14, hours: 16, minutes: 12, seconds: 70, nanoseconds: 2})})
            """
        ),
        expected=Expected(
            rows=[
            {'sum': "'1997-03-25'", 'diff': "'1972-04-27'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal8-1-2',
        feature_path='tck/features/expressions/temporal/Temporal8.feature',
        scenario='[1] Should add or subtract duration to or from date (example 2)',
        cypher='WITH date({year: 1984, month: 10, day: 11}) AS x\n      MATCH (d:Duration)\n      RETURN x + d.dur AS sum, x - d.dur AS diff',
        graph=graph_fixture_from_create(
            """
            CREATE (:Duration {dur: duration({months: 1, days: -14, hours: 16, minutes: -12, seconds: 70})})
            """
        ),
        expected=Expected(
            rows=[
            {'sum': "'1984-10-28'", 'diff': "'1984-09-25'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal8-1-3',
        feature_path='tck/features/expressions/temporal/Temporal8.feature',
        scenario='[1] Should add or subtract duration to or from date (example 3)',
        cypher='WITH date({year: 1984, month: 10, day: 11}) AS x\n      MATCH (d:Duration)\n      RETURN x + d.dur AS sum, x - d.dur AS diff',
        graph=graph_fixture_from_create(
            """
            CREATE (:Duration {dur: duration({years: 12.5, months: 5.5, days: 14.5, hours: 16.5, minutes: 12.5, seconds: 70.5, nanoseconds: 3})})
            """
        ),
        expected=Expected(
            rows=[
            {'sum': "'1997-10-11'", 'diff': "'1971-10-12'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal8-2-1',
        feature_path='tck/features/expressions/temporal/Temporal8.feature',
        scenario='[2] Should add or subtract duration to or from local time (example 1)',
        cypher='WITH localtime({hour: 12, minute: 31, second: 14, nanosecond: 1}) AS x\n      MATCH (d:Duration)\n      RETURN x + d.dur AS sum, x - d.dur AS diff',
        graph=graph_fixture_from_create(
            """
            CREATE (:Duration {dur: duration({years: 12, months: 5, days: 14, hours: 16, minutes: 12, seconds: 70, nanoseconds: 2})})
            """
        ),
        expected=Expected(
            rows=[
            {'sum': "'04:44:24.000000003'", 'diff': "'20:18:03.999999999'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal8-2-2',
        feature_path='tck/features/expressions/temporal/Temporal8.feature',
        scenario='[2] Should add or subtract duration to or from local time (example 2)',
        cypher='WITH localtime({hour: 12, minute: 31, second: 14, nanosecond: 1}) AS x\n      MATCH (d:Duration)\n      RETURN x + d.dur AS sum, x - d.dur AS diff',
        graph=graph_fixture_from_create(
            """
            CREATE (:Duration {dur: duration({months: 1, days: -14, hours: 16, minutes: -12, seconds: 70})})
            """
        ),
        expected=Expected(
            rows=[
            {'sum': "'04:20:24.000000001'", 'diff': "'20:42:04.000000001'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal8-2-3',
        feature_path='tck/features/expressions/temporal/Temporal8.feature',
        scenario='[2] Should add or subtract duration to or from local time (example 3)',
        cypher='WITH localtime({hour: 12, minute: 31, second: 14, nanosecond: 1}) AS x\n      MATCH (d:Duration)\n      RETURN x + d.dur AS sum, x - d.dur AS diff',
        graph=graph_fixture_from_create(
            """
            CREATE (:Duration {dur: duration({years: 12.5, months: 5.5, days: 14.5, hours: 16.5, minutes: 12.5, seconds: 70.5, nanoseconds: 3})})
            """
        ),
        expected=Expected(
            rows=[
            {'sum': "'22:29:27.500000004'", 'diff': "'02:33:00.499999998'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal8-3-1',
        feature_path='tck/features/expressions/temporal/Temporal8.feature',
        scenario='[3] Should add or subtract duration to or from time (example 1)',
        cypher="WITH time({hour: 12, minute: 31, second: 14, nanosecond: 1, timezone: '+01:00'}) AS x\n      MATCH (d:Duration)\n      RETURN x + d.dur AS sum, x - d.dur AS diff",
        graph=graph_fixture_from_create(
            """
            CREATE (:Duration {dur: duration({years: 12, months: 5, days: 14, hours: 16, minutes: 12, seconds: 70, nanoseconds: 2})})
            """
        ),
        expected=Expected(
            rows=[
            {'sum': "'04:44:24.000000003+01:00'", 'diff': "'20:18:03.999999999+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal8-3-2',
        feature_path='tck/features/expressions/temporal/Temporal8.feature',
        scenario='[3] Should add or subtract duration to or from time (example 2)',
        cypher="WITH time({hour: 12, minute: 31, second: 14, nanosecond: 1, timezone: '+01:00'}) AS x\n      MATCH (d:Duration)\n      RETURN x + d.dur AS sum, x - d.dur AS diff",
        graph=graph_fixture_from_create(
            """
            CREATE (:Duration {dur: duration({months: 1, days: -14, hours: 16, minutes: -12, seconds: 70})})
            """
        ),
        expected=Expected(
            rows=[
            {'sum': "'04:20:24.000000001+01:00'", 'diff': "'20:42:04.000000001+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal8-3-3',
        feature_path='tck/features/expressions/temporal/Temporal8.feature',
        scenario='[3] Should add or subtract duration to or from time (example 3)',
        cypher="WITH time({hour: 12, minute: 31, second: 14, nanosecond: 1, timezone: '+01:00'}) AS x\n      MATCH (d:Duration)\n      RETURN x + d.dur AS sum, x - d.dur AS diff",
        graph=graph_fixture_from_create(
            """
            CREATE (:Duration {dur: duration({years: 12.5, months: 5.5, days: 14.5, hours: 16.5, minutes: 12.5, seconds: 70.5, nanoseconds: 3})})
            """
        ),
        expected=Expected(
            rows=[
            {'sum': "'22:29:27.500000004+01:00'", 'diff': "'02:33:00.499999998+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal8-4-1',
        feature_path='tck/features/expressions/temporal/Temporal8.feature',
        scenario='[4] Should add or subtract duration to or from local date time (example 1)',
        cypher='WITH localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 1}) AS x\n      MATCH (d:Duration)\n      RETURN x + d.dur AS sum, x - d.dur AS diff',
        graph=graph_fixture_from_create(
            """
            CREATE (:Duration {dur: duration({years: 12, months: 5, days: 14, hours: 16, minutes: 12, seconds: 70, nanoseconds: 2})})
            """
        ),
        expected=Expected(
            rows=[
            {'sum': "'1997-03-26T04:44:24.000000003'", 'diff': "'1972-04-26T20:18:03.999999999'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal8-4-2',
        feature_path='tck/features/expressions/temporal/Temporal8.feature',
        scenario='[4] Should add or subtract duration to or from local date time (example 2)',
        cypher='WITH localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 1}) AS x\n      MATCH (d:Duration)\n      RETURN x + d.dur AS sum, x - d.dur AS diff',
        graph=graph_fixture_from_create(
            """
            CREATE (:Duration {dur: duration({months: 1, days: -14, hours: 16, minutes: -12, seconds: 70})})
            """
        ),
        expected=Expected(
            rows=[
            {'sum': "'1984-10-29T04:20:24.000000001'", 'diff': "'1984-09-24T20:42:04.000000001'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal8-4-3',
        feature_path='tck/features/expressions/temporal/Temporal8.feature',
        scenario='[4] Should add or subtract duration to or from local date time (example 3)',
        cypher='WITH localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 1}) AS x\n      MATCH (d:Duration)\n      RETURN x + d.dur AS sum, x - d.dur AS diff',
        graph=graph_fixture_from_create(
            """
            CREATE (:Duration {dur: duration({years: 12.5, months: 5.5, days: 14.5, hours: 16.5, minutes: 12.5, seconds: 70.5, nanoseconds: 3})})
            """
        ),
        expected=Expected(
            rows=[
            {'sum': "'1997-10-11T22:29:27.500000004'", 'diff': "'1971-10-12T02:33:00.499999998'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal8-5-1',
        feature_path='tck/features/expressions/temporal/Temporal8.feature',
        scenario='[5] Should add or subtract duration to or from date time (example 1)',
        cypher="WITH datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 1, timezone: '+01:00'}) AS x\n      MATCH (d:Duration)\n      RETURN x + d.dur AS sum, x - d.dur AS diff",
        graph=graph_fixture_from_create(
            """
            CREATE (:Duration {dur: duration({years: 12, months: 5, days: 14, hours: 16, minutes: 12, seconds: 70, nanoseconds: 2})})
            """
        ),
        expected=Expected(
            rows=[
            {'sum': "'1997-03-26T04:44:24.000000003+01:00'", 'diff': "'1972-04-26T20:18:03.999999999+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal8-5-2',
        feature_path='tck/features/expressions/temporal/Temporal8.feature',
        scenario='[5] Should add or subtract duration to or from date time (example 2)',
        cypher="WITH datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 1, timezone: '+01:00'}) AS x\n      MATCH (d:Duration)\n      RETURN x + d.dur AS sum, x - d.dur AS diff",
        graph=graph_fixture_from_create(
            """
            CREATE (:Duration {dur: duration({months: 1, days: -14, hours: 16, minutes: -12, seconds: 70})})
            """
        ),
        expected=Expected(
            rows=[
            {'sum': "'1984-10-29T04:20:24.000000001+01:00'", 'diff': "'1984-09-24T20:42:04.000000001+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal8-5-3',
        feature_path='tck/features/expressions/temporal/Temporal8.feature',
        scenario='[5] Should add or subtract duration to or from date time (example 3)',
        cypher="WITH datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 1, timezone: '+01:00'}) AS x\n      MATCH (d:Duration)\n      RETURN x + d.dur AS sum, x - d.dur AS diff",
        graph=graph_fixture_from_create(
            """
            CREATE (:Duration {dur: duration({years: 12.5, months: 5.5, days: 14.5, hours: 16.5, minutes: 12.5, seconds: 70.5, nanoseconds: 3})})
            """
        ),
        expected=Expected(
            rows=[
            {'sum': "'1997-10-11T22:29:27.500000004+01:00'", 'diff': "'1971-10-12T02:33:00.499999998+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal8-6-1',
        feature_path='tck/features/expressions/temporal/Temporal8.feature',
        scenario='[6] Should add or subtract durations (example 1)',
        cypher='MATCH (dur:Duration1), (dur2: Duration2)\n      RETURN dur.date + dur2.date AS sum, dur.date - dur2.date AS diff',
        graph=graph_fixture_from_create(
            """
            CREATE (:Duration1 {date: duration({years: 12, months: 5, days: 14, hours: 16, minutes: 12, seconds: 70, nanoseconds: 1})})
                  CREATE (:Duration2 {date: duration({years: 12, months: 5, days: 14, hours: 16, minutes: 12, seconds: 70, nanoseconds: 1})})
            """
        ),
        expected=Expected(
            rows=[
            {'sum': "'P24Y10M28DT32H26M20.000000002S'", 'diff': "'PT0S'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal8-6-2',
        feature_path='tck/features/expressions/temporal/Temporal8.feature',
        scenario='[6] Should add or subtract durations (example 2)',
        cypher='MATCH (dur:Duration1), (dur2: Duration2)\n      RETURN dur.date + dur2.date AS sum, dur.date - dur2.date AS diff',
        graph=graph_fixture_from_create(
            """
            CREATE (:Duration1 {date: duration({years: 12, months: 5, days: 14, hours: 16, minutes: 12, seconds: 70, nanoseconds: 1})})
                  CREATE (:Duration2 {date: duration({months: 1, days: -14, hours: 16, minutes: -12, seconds: 70})})
            """
        ),
        expected=Expected(
            rows=[
            {'sum': "'P12Y6MT32H2M20.000000001S'", 'diff': "'P12Y4M28DT24M0.000000001S'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal8-6-3',
        feature_path='tck/features/expressions/temporal/Temporal8.feature',
        scenario='[6] Should add or subtract durations (example 3)',
        cypher='MATCH (dur:Duration1), (dur2: Duration2)\n      RETURN dur.date + dur2.date AS sum, dur.date - dur2.date AS diff',
        graph=graph_fixture_from_create(
            """
            CREATE (:Duration1 {date: duration({years: 12, months: 5, days: 14, hours: 16, minutes: 12, seconds: 70, nanoseconds: 1})})
                  CREATE (:Duration2 {date: duration({years: 12.5, months: 5.5, days: 14.5, hours: 16.5, minutes: 12.5, seconds: 70.5, nanoseconds: 3})})
            """
        ),
        expected=Expected(
            rows=[
            {'sum': "'P25Y4M43DT50H11M23.500000004S'", 'diff': "'P-6M-15DT-17H-45M-3.500000002S'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal8-6-4',
        feature_path='tck/features/expressions/temporal/Temporal8.feature',
        scenario='[6] Should add or subtract durations (example 4)',
        cypher='MATCH (dur:Duration1), (dur2: Duration2)\n      RETURN dur.date + dur2.date AS sum, dur.date - dur2.date AS diff',
        graph=graph_fixture_from_create(
            """
            CREATE (:Duration1 {date: duration({months: 1, days: -14, hours: 16, minutes: -12, seconds: 70})})
                  CREATE (:Duration2 {date: duration({years: 12, months: 5, days: 14, hours: 16, minutes: 12, seconds: 70, nanoseconds: 1})})
            """
        ),
        expected=Expected(
            rows=[
            {'sum': "'P12Y6MT32H2M20.000000001S'", 'diff': "'P-12Y-4M-28DT-24M-0.000000001S'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal8-6-5',
        feature_path='tck/features/expressions/temporal/Temporal8.feature',
        scenario='[6] Should add or subtract durations (example 5)',
        cypher='MATCH (dur:Duration1), (dur2: Duration2)\n      RETURN dur.date + dur2.date AS sum, dur.date - dur2.date AS diff',
        graph=graph_fixture_from_create(
            """
            CREATE (:Duration1 {date: duration({months: 1, days: -14, hours: 16, minutes: -12, seconds: 70})})
                  CREATE (:Duration2 {date: duration({months: 1, days: -14, hours: 16, minutes: -12, seconds: 70})})
            """
        ),
        expected=Expected(
            rows=[
            {'sum': "'P2M-28DT31H38M20S'", 'diff': "'PT0S'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal8-6-6',
        feature_path='tck/features/expressions/temporal/Temporal8.feature',
        scenario='[6] Should add or subtract durations (example 6)',
        cypher='MATCH (dur:Duration1), (dur2: Duration2)\n      RETURN dur.date + dur2.date AS sum, dur.date - dur2.date AS diff',
        graph=graph_fixture_from_create(
            """
            CREATE (:Duration1 {date: duration({months: 1, days: -14, hours: 16, minutes: -12, seconds: 70})})
                  CREATE (:Duration2 {date: duration({years: 12.5, months: 5.5, days: 14.5, hours: 16.5, minutes: 12.5, seconds: 70.5, nanoseconds: 3})})
            """
        ),
        expected=Expected(
            rows=[
            {'sum': "'P13Y15DT49H47M23.500000003S'", 'diff': "'P-12Y-10M-43DT-18H-9M-3.500000003S'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal8-6-7',
        feature_path='tck/features/expressions/temporal/Temporal8.feature',
        scenario='[6] Should add or subtract durations (example 7)',
        cypher='MATCH (dur:Duration1), (dur2: Duration2)\n      RETURN dur.date + dur2.date AS sum, dur.date - dur2.date AS diff',
        graph=graph_fixture_from_create(
            """
            CREATE (:Duration1 {date: duration({years: 12.5, months: 5.5, days: 14.5, hours: 16.5, minutes: 12.5, seconds: 70.5, nanoseconds: 3})})
                  CREATE (:Duration2 {date: duration({years: 12, months: 5, days: 14, hours: 16, minutes: 12, seconds: 70, nanoseconds: 1})})
            """
        ),
        expected=Expected(
            rows=[
            {'sum': "'P25Y4M43DT50H11M23.500000004S'", 'diff': "'P6M15DT17H45M3.500000002S'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal8-6-8',
        feature_path='tck/features/expressions/temporal/Temporal8.feature',
        scenario='[6] Should add or subtract durations (example 8)',
        cypher='MATCH (dur:Duration1), (dur2: Duration2)\n      RETURN dur.date + dur2.date AS sum, dur.date - dur2.date AS diff',
        graph=graph_fixture_from_create(
            """
            CREATE (:Duration1 {date: duration({years: 12.5, months: 5.5, days: 14.5, hours: 16.5, minutes: 12.5, seconds: 70.5, nanoseconds: 3})})
                  CREATE (:Duration2 {date: duration({months: 1, days: -14, hours: 16, minutes: -12, seconds: 70})})
            """
        ),
        expected=Expected(
            rows=[
            {'sum': "'P13Y15DT49H47M23.500000003S'", 'diff': "'P12Y10M43DT18H9M3.500000003S'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal8-6-9',
        feature_path='tck/features/expressions/temporal/Temporal8.feature',
        scenario='[6] Should add or subtract durations (example 9)',
        cypher='MATCH (dur:Duration1), (dur2: Duration2)\n      RETURN dur.date + dur2.date AS sum, dur.date - dur2.date AS diff',
        graph=graph_fixture_from_create(
            """
            CREATE (:Duration1 {date: duration({years: 12.5, months: 5.5, days: 14.5, hours: 16.5, minutes: 12.5, seconds: 70.5, nanoseconds: 3})})
                  CREATE (:Duration2 {date: duration({years: 12.5, months: 5.5, days: 14.5, hours: 16.5, minutes: 12.5, seconds: 70.5, nanoseconds: 3})})
            """
        ),
        expected=Expected(
            rows=[
            {'sum': "'P25Y10M58DT67H56M27.000000006S'", 'diff': "'PT0S'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal8-7-1',
        feature_path='tck/features/expressions/temporal/Temporal8.feature',
        scenario='[7] Should multiply or divide durations by numbers (example 1)',
        cypher='MATCH (d:Duration)\n      RETURN d.date * 1 AS prod, d.date / 1 AS div',
        graph=graph_fixture_from_create(
            """
            CREATE (:Duration {date: duration({years: 12, months: 5, days: 14, hours: 16, minutes: 12, seconds: 70, nanoseconds: 1})})
            """
        ),
        expected=Expected(
            rows=[
            {'prod': "'P12Y5M14DT16H13M10.000000001S'", 'div': "'P12Y5M14DT16H13M10.000000001S'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal8-7-2',
        feature_path='tck/features/expressions/temporal/Temporal8.feature',
        scenario='[7] Should multiply or divide durations by numbers (example 2)',
        cypher='MATCH (d:Duration)\n      RETURN d.date * 2 AS prod, d.date / 2 AS div',
        graph=graph_fixture_from_create(
            """
            CREATE (:Duration {date: duration({years: 12, months: 5, days: 14, hours: 16, minutes: 12, seconds: 70, nanoseconds: 1})})
            """
        ),
        expected=Expected(
            rows=[
            {'prod': "'P24Y10M28DT32H26M20.000000002S'", 'div': "'P6Y2M22DT13H21M8S'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal8-7-3',
        feature_path='tck/features/expressions/temporal/Temporal8.feature',
        scenario='[7] Should multiply or divide durations by numbers (example 3)',
        cypher='MATCH (d:Duration)\n      RETURN d.date * 0.5 AS prod, d.date / 0.5 AS div',
        graph=graph_fixture_from_create(
            """
            CREATE (:Duration {date: duration({years: 12, months: 5, days: 14, hours: 16, minutes: 12, seconds: 70, nanoseconds: 1})})
            """
        ),
        expected=Expected(
            rows=[
            {'prod': "'P6Y2M22DT13H21M8S'", 'div': "'P24Y10M28DT32H26M20.000000002S'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-1-1',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[1] Should truncate date (example 1)',
        cypher="RETURN date.truncate('millennium', date({year: 2017, month: 10, day: 11}), {day: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'2000-01-02'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-1-2',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[1] Should truncate date (example 2)',
        cypher="RETURN date.truncate('millennium', date({year: 2017, month: 10, day: 11}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'2000-01-01'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-1-3',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[1] Should truncate date (example 3)',
        cypher="RETURN date.truncate('millennium', datetime({year: 2017, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {day: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'2000-01-02'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-1-4',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[1] Should truncate date (example 4)',
        cypher="RETURN date.truncate('millennium', datetime({year: 2017, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'2000-01-01'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-1-5',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[1] Should truncate date (example 5)',
        cypher="RETURN date.truncate('millennium', localdatetime({year: 2017, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {day: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'2000-01-02'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-1-6',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[1] Should truncate date (example 6)',
        cypher="RETURN date.truncate('millennium', localdatetime({year: 2017, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'2000-01-01'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-1-7',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[1] Should truncate date (example 7)',
        cypher="RETURN date.truncate('century', date({year: 1984, month: 10, day: 11}), {day: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1900-01-02'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-1-8',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[1] Should truncate date (example 8)',
        cypher="RETURN date.truncate('century', date({year: 1984, month: 10, day: 11}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1900-01-01'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-1-9',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[1] Should truncate date (example 9)',
        cypher="RETURN date.truncate('century', datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {day: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1900-01-02'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-1-10',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[1] Should truncate date (example 10)',
        cypher="RETURN date.truncate('century', datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1900-01-01'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-1-11',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[1] Should truncate date (example 11)',
        cypher="RETURN date.truncate('century', localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {day: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1900-01-02'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-1-12',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[1] Should truncate date (example 12)',
        cypher="RETURN date.truncate('century', localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1900-01-01'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-1-13',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[1] Should truncate date (example 13)',
        cypher="RETURN date.truncate('decade', date({year: 1984, month: 10, day: 11}), {day: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1980-01-02'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-1-14',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[1] Should truncate date (example 14)',
        cypher="RETURN date.truncate('decade', date({year: 1984, month: 10, day: 11}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1980-01-01'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-1-15',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[1] Should truncate date (example 15)',
        cypher="RETURN date.truncate('decade', datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {day: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1980-01-02'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-1-16',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[1] Should truncate date (example 16)',
        cypher="RETURN date.truncate('decade', datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1980-01-01'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-1-17',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[1] Should truncate date (example 17)',
        cypher="RETURN date.truncate('decade', localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {day: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1980-01-02'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-1-18',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[1] Should truncate date (example 18)',
        cypher="RETURN date.truncate('decade', localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1980-01-01'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-1-19',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[1] Should truncate date (example 19)',
        cypher="RETURN date.truncate('year', date({year: 1984, month: 10, day: 11}), {day: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-01-02'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-1-20',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[1] Should truncate date (example 20)',
        cypher="RETURN date.truncate('year', date({year: 1984, month: 10, day: 11}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-01-01'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-1-21',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[1] Should truncate date (example 21)',
        cypher="RETURN date.truncate('year', datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {day: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-01-02'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-1-22',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[1] Should truncate date (example 22)',
        cypher="RETURN date.truncate('year', datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-01-01'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-1-23',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[1] Should truncate date (example 23)',
        cypher="RETURN date.truncate('year', localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {day: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-01-02'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-1-24',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[1] Should truncate date (example 24)',
        cypher="RETURN date.truncate('year', localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-01-01'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-1-25',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[1] Should truncate date (example 25)',
        cypher="RETURN date.truncate('weekYear', date({year: 1984, month: 2, day: 1}), {day: 5}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-01-05'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-1-26',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[1] Should truncate date (example 26)',
        cypher="RETURN date.truncate('weekYear', date({year: 1984, month: 2, day: 1}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-01-02'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-1-27',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[1] Should truncate date (example 27)',
        cypher="RETURN date.truncate('weekYear', datetime({year: 1984, month: 1, day: 1, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {day: 5}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1983-01-05'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-1-28',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[1] Should truncate date (example 28)',
        cypher="RETURN date.truncate('weekYear', datetime({year: 1984, month: 1, day: 1, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1983-01-03'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-1-29',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[1] Should truncate date (example 29)',
        cypher="RETURN date.truncate('weekYear', localdatetime({year: 1984, month: 1, day: 1, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {day: 5}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1983-01-05'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-1-30',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[1] Should truncate date (example 30)',
        cypher="RETURN date.truncate('weekYear', localdatetime({year: 1984, month: 1, day: 1, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1983-01-03'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-1-31',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[1] Should truncate date (example 31)',
        cypher="RETURN date.truncate('quarter', date({year: 1984, month: 11, day: 11}), {day: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-02'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-1-32',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[1] Should truncate date (example 32)',
        cypher="RETURN date.truncate('quarter', date({year: 1984, month: 11, day: 11}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-01'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-1-33',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[1] Should truncate date (example 33)',
        cypher="RETURN date.truncate('quarter', datetime({year: 1984, month: 11, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {day: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-02'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-1-34',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[1] Should truncate date (example 34)',
        cypher="RETURN date.truncate('quarter', datetime({year: 1984, month: 11, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-01'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-1-35',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[1] Should truncate date (example 35)',
        cypher="RETURN date.truncate('quarter', localdatetime({year: 1984, month: 11, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {day: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-02'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-1-36',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[1] Should truncate date (example 36)',
        cypher="RETURN date.truncate('quarter', localdatetime({year: 1984, month: 11, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-01'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-1-37',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[1] Should truncate date (example 37)',
        cypher="RETURN date.truncate('month', date({year: 1984, month: 10, day: 11}), {day: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-02'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-1-38',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[1] Should truncate date (example 38)',
        cypher="RETURN date.truncate('month', date({year: 1984, month: 10, day: 11}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-01'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-1-39',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[1] Should truncate date (example 39)',
        cypher="RETURN date.truncate('month', datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {day: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-02'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-1-40',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[1] Should truncate date (example 40)',
        cypher="RETURN date.truncate('month', datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-01'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-1-41',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[1] Should truncate date (example 41)',
        cypher="RETURN date.truncate('month', localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {day: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-02'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-1-42',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[1] Should truncate date (example 42)',
        cypher="RETURN date.truncate('month', localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-01'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-1-43',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[1] Should truncate date (example 43)',
        cypher="RETURN date.truncate('week', date({year: 1984, month: 10, day: 11}), {dayOfWeek: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-09'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-1-44',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[1] Should truncate date (example 44)',
        cypher="RETURN date.truncate('week', date({year: 1984, month: 10, day: 11}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-08'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-1-45',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[1] Should truncate date (example 45)',
        cypher="RETURN date.truncate('week', datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {dayOfWeek: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-09'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-1-46',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[1] Should truncate date (example 46)',
        cypher="RETURN date.truncate('week', datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-08'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-1-47',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[1] Should truncate date (example 47)',
        cypher="RETURN date.truncate('week', localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {dayOfWeek: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-09'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-1-48',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[1] Should truncate date (example 48)',
        cypher="RETURN date.truncate('week', localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-08'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-1-49',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[1] Should truncate date (example 49)',
        cypher="RETURN date.truncate('day', date({year: 1984, month: 10, day: 11}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-1-50',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[1] Should truncate date (example 50)',
        cypher="RETURN date.truncate('day', datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-1-51',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[1] Should truncate date (example 51)',
        cypher="RETURN date.truncate('day', localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-1',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 1)',
        cypher="RETURN datetime.truncate('millennium', date({year: 2017, month: 10, day: 11}), {day: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'2000-01-02T00:00Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-2',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 2)',
        cypher="RETURN datetime.truncate('millennium', date({year: 2017, month: 10, day: 11}), {timezone: 'Europe/Stockholm'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'2000-01-01T00:00+01:00[Europe/Stockholm]'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-3',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 3)',
        cypher="RETURN datetime.truncate('millennium', date({year: 2017, month: 10, day: 11}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'2000-01-01T00:00Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-4',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 4)',
        cypher="RETURN datetime.truncate('millennium', datetime({year: 2017, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {day: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'2000-01-02T00:00+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-5',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 5)',
        cypher="RETURN datetime.truncate('millennium', datetime({year: 2017, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'2000-01-01T00:00+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-6',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 6)',
        cypher="RETURN datetime.truncate('millennium', datetime({year: 2017, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '-01:00'}), {timezone: 'Europe/Stockholm'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'2000-01-01T00:00+01:00[Europe/Stockholm]'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-7',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 7)',
        cypher="RETURN datetime.truncate('millennium', localdatetime({year: 2017, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {day: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'2000-01-02T00:00Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-8',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 8)',
        cypher="RETURN datetime.truncate('millennium', localdatetime({year: 2017, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {timezone: 'Europe/Stockholm'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'2000-01-01T00:00+01:00[Europe/Stockholm]'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-9',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 9)',
        cypher="RETURN datetime.truncate('millennium', localdatetime({year: 2017, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'2000-01-01T00:00Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-10',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 10)',
        cypher="RETURN datetime.truncate('century', date({year: 1984, month: 10, day: 11}), {day: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1900-01-02T00:00Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-11',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 11)',
        cypher="RETURN datetime.truncate('century', date({year: 1984, month: 10, day: 11}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1900-01-01T00:00Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-12',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 12)',
        cypher="RETURN datetime.truncate('century', date({year: 2017, month: 10, day: 11}), {timezone: 'Europe/Stockholm'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'2000-01-01T00:00+01:00[Europe/Stockholm]'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-13',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 13)',
        cypher="RETURN datetime.truncate('century', datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {day: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1900-01-02T00:00+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-14',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 14)',
        cypher="RETURN datetime.truncate('century', datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1900-01-01T00:00+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-15',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 15)',
        cypher="RETURN datetime.truncate('century', datetime({year: 2017, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '-01:00'}), {timezone: 'Europe/Stockholm'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'2000-01-01T00:00+01:00[Europe/Stockholm]'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-16',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 16)',
        cypher="RETURN datetime.truncate('century', localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {day: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1900-01-02T00:00Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-17',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 17)',
        cypher="RETURN datetime.truncate('century', localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1900-01-01T00:00Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-18',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 18)',
        cypher="RETURN datetime.truncate('century', localdatetime({year: 2017, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {timezone: 'Europe/Stockholm'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'2000-01-01T00:00+01:00[Europe/Stockholm]'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-19',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 19)',
        cypher="RETURN datetime.truncate('decade', date({year: 1984, month: 10, day: 11}), {day: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1980-01-02T00:00Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-20',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 20)',
        cypher="RETURN datetime.truncate('decade', date({year: 1984, month: 10, day: 11}), {timezone: 'Europe/Stockholm'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1980-01-01T00:00+01:00[Europe/Stockholm]'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-21',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 21)',
        cypher="RETURN datetime.truncate('decade', date({year: 1984, month: 10, day: 11}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1980-01-01T00:00Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-22',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 22)',
        cypher="RETURN datetime.truncate('decade', datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {day: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1980-01-02T00:00+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-23',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 23)',
        cypher="RETURN datetime.truncate('decade', datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1980-01-01T00:00+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-24',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 24)',
        cypher="RETURN datetime.truncate('decade', datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '-01:00'}), {timezone: 'Europe/Stockholm'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1980-01-01T00:00+01:00[Europe/Stockholm]'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-25',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 25)',
        cypher="RETURN datetime.truncate('decade', localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {day: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1980-01-02T00:00Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-26',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 26)',
        cypher="RETURN datetime.truncate('decade', localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {timezone: 'Europe/Stockholm'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1980-01-01T00:00+01:00[Europe/Stockholm]'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-27',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 27)',
        cypher="RETURN datetime.truncate('decade', localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1980-01-01T00:00Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-28',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 28)',
        cypher="RETURN datetime.truncate('year', date({year: 1984, month: 10, day: 11}), {day: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-01-02T00:00Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-29',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 29)',
        cypher="RETURN datetime.truncate('year', date({year: 1984, month: 10, day: 11}), {timezone: 'Europe/Stockholm'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-01-01T00:00+01:00[Europe/Stockholm]'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-30',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 30)',
        cypher="RETURN datetime.truncate('year', date({year: 1984, month: 10, day: 11}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-01-01T00:00Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-31',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 31)',
        cypher="RETURN datetime.truncate('year', datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {day: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-01-02T00:00+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-32',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 32)',
        cypher="RETURN datetime.truncate('year', datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-01-01T00:00+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-33',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 33)',
        cypher="RETURN datetime.truncate('year', datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '-01:00'}), {timezone: 'Europe/Stockholm'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-01-01T00:00+01:00[Europe/Stockholm]'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-34',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 34)',
        cypher="RETURN datetime.truncate('year', localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {day: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-01-02T00:00Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-35',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 35)',
        cypher="RETURN datetime.truncate('year', localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {timezone: 'Europe/Stockholm'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-01-01T00:00+01:00[Europe/Stockholm]'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-36',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 36)',
        cypher="RETURN datetime.truncate('year', localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-01-01T00:00Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-37',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 37)',
        cypher="RETURN datetime.truncate('weekYear', date({year: 1984, month: 2, day: 1}), {day: 5}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-01-05T00:00Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-38',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 38)',
        cypher="RETURN datetime.truncate('weekYear', date({year: 1984, month: 2, day: 1}), {timezone: 'Europe/Stockholm'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-01-02T00:00+01:00[Europe/Stockholm]'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-39',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 39)',
        cypher="RETURN datetime.truncate('weekYear', date({year: 1984, month: 2, day: 1}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-01-02T00:00Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-40',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 40)',
        cypher="RETURN datetime.truncate('weekYear', datetime({year: 1984, month: 1, day: 1, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {day: 5}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1983-01-05T00:00+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-41',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 41)',
        cypher="RETURN datetime.truncate('weekYear', datetime({year: 1984, month: 1, day: 1, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1983-01-03T00:00+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-42',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 42)',
        cypher="RETURN datetime.truncate('weekYear', datetime({year: 1984, month: 1, day: 1, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '-01:00'}), {timezone: 'Europe/Stockholm'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1983-01-03T00:00+01:00[Europe/Stockholm]'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-43',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 43)',
        cypher="RETURN datetime.truncate('weekYear', localdatetime({year: 1984, month: 1, day: 1, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {day: 5}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1983-01-05T00:00Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-44',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 44)',
        cypher="RETURN datetime.truncate('weekYear', localdatetime({year: 1984, month: 1, day: 1, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {timezone: 'Europe/Stockholm'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1983-01-03T00:00+01:00[Europe/Stockholm]'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-45',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 45)',
        cypher="RETURN datetime.truncate('weekYear', localdatetime({year: 1984, month: 1, day: 1, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1983-01-03T00:00Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-46',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 46)',
        cypher="RETURN datetime.truncate('quarter', date({year: 1984, month: 11, day: 11}), {day: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-02T00:00Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-47',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 47)',
        cypher="RETURN datetime.truncate('quarter', date({year: 1984, month: 11, day: 11}), {timezone: 'Europe/Stockholm'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-01T00:00+01:00[Europe/Stockholm]'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-48',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 48)',
        cypher="RETURN datetime.truncate('quarter', date({year: 1984, month: 11, day: 11}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-01T00:00Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-49',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 49)',
        cypher="RETURN datetime.truncate('quarter', datetime({year: 1984, month: 11, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {day: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-02T00:00+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-50',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 50)',
        cypher="RETURN datetime.truncate('quarter', datetime({year: 1984, month: 11, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-01T00:00+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-51',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 51)',
        cypher="RETURN datetime.truncate('quarter', datetime({year: 1984, month: 11, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '-01:00'}), {timezone: 'Europe/Stockholm'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-01T00:00+01:00[Europe/Stockholm]'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-52',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 52)',
        cypher="RETURN datetime.truncate('quarter', localdatetime({year: 1984, month: 11, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {day: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-02T00:00Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-53',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 53)',
        cypher="RETURN datetime.truncate('quarter', localdatetime({year: 1984, month: 11, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {timezone: 'Europe/Stockholm'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-01T00:00+01:00[Europe/Stockholm]'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-54',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 54)',
        cypher="RETURN datetime.truncate('quarter', localdatetime({year: 1984, month: 11, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-01T00:00Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-55',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 55)',
        cypher="RETURN datetime.truncate('month', date({year: 1984, month: 10, day: 11}), {day: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-02T00:00Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-56',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 56)',
        cypher="RETURN datetime.truncate('month', date({year: 1984, month: 10, day: 11}), {timezone: 'Europe/Stockholm'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-01T00:00+01:00[Europe/Stockholm]'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-57',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 57)',
        cypher="RETURN datetime.truncate('month', date({year: 1984, month: 10, day: 11}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-01T00:00Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-58',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 58)',
        cypher="RETURN datetime.truncate('month', datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {day: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-02T00:00+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-59',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 59)',
        cypher="RETURN datetime.truncate('month', datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-01T00:00+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-60',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 60)',
        cypher="RETURN datetime.truncate('month', datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '-01:00'}), {timezone: 'Europe/Stockholm'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-01T00:00+01:00[Europe/Stockholm]'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-61',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 61)',
        cypher="RETURN datetime.truncate('month', localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {day: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-02T00:00Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-62',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 62)',
        cypher="RETURN datetime.truncate('month', localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {timezone: 'Europe/Stockholm'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-01T00:00+01:00[Europe/Stockholm]'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-63',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 63)',
        cypher="RETURN datetime.truncate('month', localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-01T00:00Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-64',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 64)',
        cypher="RETURN datetime.truncate('week', date({year: 1984, month: 10, day: 11}), {dayOfWeek: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-09T00:00Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-65',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 65)',
        cypher="RETURN datetime.truncate('week', date({year: 1984, month: 10, day: 11}), {timezone: 'Europe/Stockholm'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-08T00:00+01:00[Europe/Stockholm]'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-66',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 66)',
        cypher="RETURN datetime.truncate('week', date({year: 1984, month: 10, day: 11}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-08T00:00Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-67',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 67)',
        cypher="RETURN datetime.truncate('week', datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {dayOfWeek: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-09T00:00+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-68',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 68)',
        cypher="RETURN datetime.truncate('week', datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-08T00:00+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-69',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 69)',
        cypher="RETURN datetime.truncate('week', datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '-01:00'}), {timezone: 'Europe/Stockholm'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-08T00:00+01:00[Europe/Stockholm]'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-70',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 70)',
        cypher="RETURN datetime.truncate('week', localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {dayOfWeek: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-09T00:00Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-71',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 71)',
        cypher="RETURN datetime.truncate('week', localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {timezone: 'Europe/Stockholm'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-08T00:00+01:00[Europe/Stockholm]'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-72',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 72)',
        cypher="RETURN datetime.truncate('week', localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-08T00:00Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-73',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 73)',
        cypher="RETURN datetime.truncate('day', date({year: 1984, month: 10, day: 11}), {nanosecond: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T00:00:00.000000002Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-74',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 74)',
        cypher="RETURN datetime.truncate('day', date({year: 1984, month: 10, day: 11}), {timezone: 'Europe/Stockholm'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T00:00+01:00[Europe/Stockholm]'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-75',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 75)',
        cypher="RETURN datetime.truncate('day', date({year: 1984, month: 10, day: 11}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T00:00Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-76',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 76)',
        cypher="RETURN datetime.truncate('day', datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {nanosecond: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T00:00:00.000000002+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-77',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 77)',
        cypher="RETURN datetime.truncate('day', datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T00:00+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-78',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 78)',
        cypher="RETURN datetime.truncate('day', datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '-01:00'}), {timezone: 'Europe/Stockholm'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T00:00+01:00[Europe/Stockholm]'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-79',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 79)',
        cypher="RETURN datetime.truncate('day', localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {nanosecond: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T00:00:00.000000002Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-80',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 80)',
        cypher="RETURN datetime.truncate('day', localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {timezone: 'Europe/Stockholm'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T00:00+01:00[Europe/Stockholm]'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-81',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 81)',
        cypher="RETURN datetime.truncate('day', localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T00:00Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-82',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 82)',
        cypher="RETURN datetime.truncate('hour', datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '-01:00'}), {nanosecond: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:00:00.000000002-01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-83',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 83)',
        cypher="RETURN datetime.truncate('hour', datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '-01:00'}), {timezone: 'Europe/Stockholm'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:00+01:00[Europe/Stockholm]'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-84',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 84)',
        cypher="RETURN datetime.truncate('hour', datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '-01:00'}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:00-01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-85',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 85)',
        cypher="RETURN datetime.truncate('hour', localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {nanosecond: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:00:00.000000002Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-86',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 86)',
        cypher="RETURN datetime.truncate('hour', localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {timezone: 'Europe/Stockholm'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:00+01:00[Europe/Stockholm]'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-87',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 87)',
        cypher="RETURN datetime.truncate('hour', localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:00Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-88',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 88)',
        cypher="RETURN datetime.truncate('minute', datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '-01:00'}), {nanosecond: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:31:00.000000002-01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-89',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 89)',
        cypher="RETURN datetime.truncate('minute', datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '-01:00'}), {timezone: 'Europe/Stockholm'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:31+01:00[Europe/Stockholm]'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-90',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 90)',
        cypher="RETURN datetime.truncate('minute', datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '-01:00'}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:31-01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-91',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 91)',
        cypher="RETURN datetime.truncate('minute', localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {nanosecond: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:31:00.000000002Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-92',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 92)',
        cypher="RETURN datetime.truncate('minute', localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {timezone: 'Europe/Stockholm'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:31+01:00[Europe/Stockholm]'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-93',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 93)',
        cypher="RETURN datetime.truncate('minute', localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:31Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-94',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 94)',
        cypher="RETURN datetime.truncate('second', datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {nanosecond: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:31:14.000000002+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-95',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 95)',
        cypher="RETURN datetime.truncate('second', datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:31:14+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-96',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 96)',
        cypher="RETURN datetime.truncate('second', localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {nanosecond: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:31:14.000000002Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-97',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 97)',
        cypher="RETURN datetime.truncate('second', localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:31:14Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-98',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 98)',
        cypher="RETURN datetime.truncate('millisecond', datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {nanosecond: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:31:14.645000002+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-99',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 99)',
        cypher="RETURN datetime.truncate('millisecond', datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:31:14.645+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-100',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 100)',
        cypher="RETURN datetime.truncate('millisecond', localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {nanosecond: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:31:14.645000002Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-101',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 101)',
        cypher="RETURN datetime.truncate('millisecond', localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:31:14.645Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-102',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 102)',
        cypher="RETURN datetime.truncate('microsecond', datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {nanosecond: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:31:14.645876002+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-103',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 103)',
        cypher="RETURN datetime.truncate('microsecond', datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:31:14.645876+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-104',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 104)',
        cypher="RETURN datetime.truncate('microsecond', localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {nanosecond: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:31:14.645876002Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-2-105',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[2] Should truncate datetime (example 105)',
        cypher="RETURN datetime.truncate('microsecond', localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:31:14.645876Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-3-1',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[3] Should truncate localdatetime (example 1)',
        cypher="RETURN localdatetime.truncate('millennium', date({year: 2017, month: 10, day: 11}), {day: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'2000-01-02T00:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-3-2',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[3] Should truncate localdatetime (example 2)',
        cypher="RETURN localdatetime.truncate('millennium', date({year: 2017, month: 10, day: 11}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'2000-01-01T00:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-3-3',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[3] Should truncate localdatetime (example 3)',
        cypher="RETURN localdatetime.truncate('millennium', datetime({year: 2017, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {day: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'2000-01-02T00:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-3-4',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[3] Should truncate localdatetime (example 4)',
        cypher="RETURN localdatetime.truncate('millennium', datetime({year: 2017, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'2000-01-01T00:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-3-5',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[3] Should truncate localdatetime (example 5)',
        cypher="RETURN localdatetime.truncate('millennium', localdatetime({year: 2017, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {day: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'2000-01-02T00:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-3-6',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[3] Should truncate localdatetime (example 6)',
        cypher="RETURN localdatetime.truncate('millennium', localdatetime({year: 2017, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'2000-01-01T00:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-3-7',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[3] Should truncate localdatetime (example 7)',
        cypher="RETURN localdatetime.truncate('century', date({year: 1984, month: 10, day: 11}), {day: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1900-01-02T00:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-3-8',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[3] Should truncate localdatetime (example 8)',
        cypher="RETURN localdatetime.truncate('century', date({year: 1984, month: 10, day: 11}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1900-01-01T00:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-3-9',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[3] Should truncate localdatetime (example 9)',
        cypher="RETURN localdatetime.truncate('century', datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {day: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1900-01-02T00:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-3-10',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[3] Should truncate localdatetime (example 10)',
        cypher="RETURN localdatetime.truncate('century', datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1900-01-01T00:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-3-11',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[3] Should truncate localdatetime (example 11)',
        cypher="RETURN localdatetime.truncate('century', localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {day: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1900-01-02T00:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-3-12',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[3] Should truncate localdatetime (example 12)',
        cypher="RETURN localdatetime.truncate('century', localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1900-01-01T00:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-3-13',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[3] Should truncate localdatetime (example 13)',
        cypher="RETURN localdatetime.truncate('decade', date({year: 1984, month: 10, day: 11}), {day: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1980-01-02T00:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-3-14',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[3] Should truncate localdatetime (example 14)',
        cypher="RETURN localdatetime.truncate('decade', date({year: 1984, month: 10, day: 11}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1980-01-01T00:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-3-15',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[3] Should truncate localdatetime (example 15)',
        cypher="RETURN localdatetime.truncate('decade', datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {day: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1980-01-02T00:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-3-16',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[3] Should truncate localdatetime (example 16)',
        cypher="RETURN localdatetime.truncate('decade', datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1980-01-01T00:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-3-17',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[3] Should truncate localdatetime (example 17)',
        cypher="RETURN localdatetime.truncate('decade', localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {day: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1980-01-02T00:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-3-18',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[3] Should truncate localdatetime (example 18)',
        cypher="RETURN localdatetime.truncate('decade', localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1980-01-01T00:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-3-19',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[3] Should truncate localdatetime (example 19)',
        cypher="RETURN localdatetime.truncate('year', date({year: 1984, month: 10, day: 11}), {day: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-01-02T00:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-3-20',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[3] Should truncate localdatetime (example 20)',
        cypher="RETURN localdatetime.truncate('year', date({year: 1984, month: 10, day: 11}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-01-01T00:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-3-21',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[3] Should truncate localdatetime (example 21)',
        cypher="RETURN localdatetime.truncate('year', datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {day: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-01-02T00:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-3-22',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[3] Should truncate localdatetime (example 22)',
        cypher="RETURN localdatetime.truncate('year', datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-01-01T00:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-3-23',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[3] Should truncate localdatetime (example 23)',
        cypher="RETURN localdatetime.truncate('year', localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {day: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-01-02T00:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-3-24',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[3] Should truncate localdatetime (example 24)',
        cypher="RETURN localdatetime.truncate('year', localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-01-01T00:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-3-25',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[3] Should truncate localdatetime (example 25)',
        cypher="RETURN localdatetime.truncate('weekYear', date({year: 1984, month: 2, day: 1}), {day: 5}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-01-05T00:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-3-26',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[3] Should truncate localdatetime (example 26)',
        cypher="RETURN localdatetime.truncate('weekYear', date({year: 1984, month: 2, day: 1}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-01-02T00:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-3-27',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[3] Should truncate localdatetime (example 27)',
        cypher="RETURN localdatetime.truncate('weekYear', datetime({year: 1984, month: 1, day: 1, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {day: 5}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1983-01-05T00:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-3-28',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[3] Should truncate localdatetime (example 28)',
        cypher="RETURN localdatetime.truncate('weekYear', datetime({year: 1984, month: 1, day: 1, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1983-01-03T00:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-3-29',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[3] Should truncate localdatetime (example 29)',
        cypher="RETURN localdatetime.truncate('weekYear', localdatetime({year: 1984, month: 1, day: 1, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {day: 5}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1983-01-05T00:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-3-30',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[3] Should truncate localdatetime (example 30)',
        cypher="RETURN localdatetime.truncate('weekYear', localdatetime({year: 1984, month: 1, day: 1, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1983-01-03T00:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-3-31',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[3] Should truncate localdatetime (example 31)',
        cypher="RETURN localdatetime.truncate('quarter', date({year: 1984, month: 11, day: 11}), {day: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-02T00:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-3-32',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[3] Should truncate localdatetime (example 32)',
        cypher="RETURN localdatetime.truncate('quarter', date({year: 1984, month: 11, day: 11}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-01T00:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-3-33',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[3] Should truncate localdatetime (example 33)',
        cypher="RETURN localdatetime.truncate('quarter', datetime({year: 1984, month: 11, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {day: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-02T00:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-3-34',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[3] Should truncate localdatetime (example 34)',
        cypher="RETURN localdatetime.truncate('quarter', datetime({year: 1984, month: 11, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-01T00:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-3-35',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[3] Should truncate localdatetime (example 35)',
        cypher="RETURN localdatetime.truncate('quarter', localdatetime({year: 1984, month: 11, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {day: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-02T00:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-3-36',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[3] Should truncate localdatetime (example 36)',
        cypher="RETURN localdatetime.truncate('quarter', localdatetime({year: 1984, month: 11, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-01T00:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-3-37',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[3] Should truncate localdatetime (example 37)',
        cypher="RETURN localdatetime.truncate('month', date({year: 1984, month: 10, day: 11}), {day: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-02T00:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-3-38',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[3] Should truncate localdatetime (example 38)',
        cypher="RETURN localdatetime.truncate('month', date({year: 1984, month: 10, day: 11}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-01T00:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-3-39',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[3] Should truncate localdatetime (example 39)',
        cypher="RETURN localdatetime.truncate('month', datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {day: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-02T00:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-3-40',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[3] Should truncate localdatetime (example 40)',
        cypher="RETURN localdatetime.truncate('month', datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-01T00:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-3-41',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[3] Should truncate localdatetime (example 41)',
        cypher="RETURN localdatetime.truncate('month', localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {day: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-02T00:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-3-42',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[3] Should truncate localdatetime (example 42)',
        cypher="RETURN localdatetime.truncate('month', localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-01T00:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-3-43',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[3] Should truncate localdatetime (example 43)',
        cypher="RETURN localdatetime.truncate('week', date({year: 1984, month: 10, day: 11}), {dayOfWeek: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-09T00:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-3-44',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[3] Should truncate localdatetime (example 44)',
        cypher="RETURN localdatetime.truncate('week', date({year: 1984, month: 10, day: 11}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-08T00:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-3-45',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[3] Should truncate localdatetime (example 45)',
        cypher="RETURN localdatetime.truncate('week', datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {dayOfWeek: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-09T00:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-3-46',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[3] Should truncate localdatetime (example 46)',
        cypher="RETURN localdatetime.truncate('week', datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-08T00:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-3-47',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[3] Should truncate localdatetime (example 47)',
        cypher="RETURN localdatetime.truncate('week', localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {dayOfWeek: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-09T00:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-3-48',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[3] Should truncate localdatetime (example 48)',
        cypher="RETURN localdatetime.truncate('week', localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-08T00:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-3-49',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[3] Should truncate localdatetime (example 49)',
        cypher="RETURN localdatetime.truncate('day', date({year: 1984, month: 10, day: 11}), {nanosecond: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T00:00:00.000000002'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-3-50',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[3] Should truncate localdatetime (example 50)',
        cypher="RETURN localdatetime.truncate('day', date({year: 1984, month: 10, day: 11}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T00:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-3-51',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[3] Should truncate localdatetime (example 51)',
        cypher="RETURN localdatetime.truncate('day', datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {nanosecond: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T00:00:00.000000002'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-3-52',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[3] Should truncate localdatetime (example 52)',
        cypher="RETURN localdatetime.truncate('day', datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T00:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-3-53',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[3] Should truncate localdatetime (example 53)',
        cypher="RETURN localdatetime.truncate('day', localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {nanosecond: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T00:00:00.000000002'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-3-54',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[3] Should truncate localdatetime (example 54)',
        cypher="RETURN localdatetime.truncate('day', localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T00:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-3-55',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[3] Should truncate localdatetime (example 55)',
        cypher="RETURN localdatetime.truncate('hour', datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {nanosecond: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:00:00.000000002'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-3-56',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[3] Should truncate localdatetime (example 56)',
        cypher="RETURN localdatetime.truncate('hour', datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-3-57',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[3] Should truncate localdatetime (example 57)',
        cypher="RETURN localdatetime.truncate('hour', localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {nanosecond: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:00:00.000000002'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-3-58',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[3] Should truncate localdatetime (example 58)',
        cypher="RETURN localdatetime.truncate('hour', localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-3-59',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[3] Should truncate localdatetime (example 59)',
        cypher="RETURN localdatetime.truncate('minute', datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {nanosecond: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:31:00.000000002'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-3-60',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[3] Should truncate localdatetime (example 60)',
        cypher="RETURN localdatetime.truncate('minute', datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:31'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-3-61',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[3] Should truncate localdatetime (example 61)',
        cypher="RETURN localdatetime.truncate('minute', localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {nanosecond: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:31:00.000000002'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-3-62',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[3] Should truncate localdatetime (example 62)',
        cypher="RETURN localdatetime.truncate('minute', localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:31'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-3-63',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[3] Should truncate localdatetime (example 63)',
        cypher="RETURN localdatetime.truncate('second', datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {nanosecond: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:31:14.000000002'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-3-64',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[3] Should truncate localdatetime (example 64)',
        cypher="RETURN localdatetime.truncate('second', datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:31:14'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-3-65',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[3] Should truncate localdatetime (example 65)',
        cypher="RETURN localdatetime.truncate('second', localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {nanosecond: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:31:14.000000002'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-3-66',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[3] Should truncate localdatetime (example 66)',
        cypher="RETURN localdatetime.truncate('second', localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:31:14'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-3-67',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[3] Should truncate localdatetime (example 67)',
        cypher="RETURN localdatetime.truncate('millisecond', datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {nanosecond: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:31:14.645000002'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-3-68',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[3] Should truncate localdatetime (example 68)',
        cypher="RETURN localdatetime.truncate('millisecond', datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:31:14.645'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-3-69',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[3] Should truncate localdatetime (example 69)',
        cypher="RETURN localdatetime.truncate('millisecond', localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {nanosecond: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:31:14.645000002'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-3-70',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[3] Should truncate localdatetime (example 70)',
        cypher="RETURN localdatetime.truncate('millisecond', localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:31:14.645'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-3-71',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[3] Should truncate localdatetime (example 71)',
        cypher="RETURN localdatetime.truncate('microsecond', datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {nanosecond: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:31:14.645876002'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-3-72',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[3] Should truncate localdatetime (example 72)',
        cypher="RETURN localdatetime.truncate('microsecond', datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:31:14.645876'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-3-73',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[3] Should truncate localdatetime (example 73)',
        cypher="RETURN localdatetime.truncate('microsecond', localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {nanosecond: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:31:14.645876002'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-3-74',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[3] Should truncate localdatetime (example 74)',
        cypher="RETURN localdatetime.truncate('microsecond', localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'1984-10-11T12:31:14.645876'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-4-1',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[4] Should truncate localtime (example 1)',
        cypher="RETURN localtime.truncate('day', datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {nanosecond: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'00:00:00.000000002'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-4-2',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[4] Should truncate localtime (example 2)',
        cypher="RETURN localtime.truncate('day', datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'00:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-4-3',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[4] Should truncate localtime (example 3)',
        cypher="RETURN localtime.truncate('day', localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {nanosecond: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'00:00:00.000000002'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-4-4',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[4] Should truncate localtime (example 4)',
        cypher="RETURN localtime.truncate('day', localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'00:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-4-5',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[4] Should truncate localtime (example 5)',
        cypher="RETURN localtime.truncate('hour', datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {nanosecond: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:00:00.000000002'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-4-6',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[4] Should truncate localtime (example 6)',
        cypher="RETURN localtime.truncate('hour', datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-4-7',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[4] Should truncate localtime (example 7)',
        cypher="RETURN localtime.truncate('hour', localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {nanosecond: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:00:00.000000002'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-4-8',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[4] Should truncate localtime (example 8)',
        cypher="RETURN localtime.truncate('hour', localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-4-9',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[4] Should truncate localtime (example 9)',
        cypher="RETURN localtime.truncate('hour', localtime({hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {nanosecond: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:00:00.000000002'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-4-10',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[4] Should truncate localtime (example 10)',
        cypher="RETURN localtime.truncate('hour', localtime({hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-4-11',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[4] Should truncate localtime (example 11)',
        cypher="RETURN localtime.truncate('hour', time({hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {nanosecond: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:00:00.000000002'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-4-12',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[4] Should truncate localtime (example 12)',
        cypher="RETURN localtime.truncate('hour', time({hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-4-13',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[4] Should truncate localtime (example 13)',
        cypher="RETURN localtime.truncate('minute', datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {nanosecond: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31:00.000000002'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-4-14',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[4] Should truncate localtime (example 14)',
        cypher="RETURN localtime.truncate('minute', datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-4-15',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[4] Should truncate localtime (example 15)',
        cypher="RETURN localtime.truncate('minute', localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {nanosecond: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31:00.000000002'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-4-16',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[4] Should truncate localtime (example 16)',
        cypher="RETURN localtime.truncate('minute', localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-4-17',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[4] Should truncate localtime (example 17)',
        cypher="RETURN localtime.truncate('minute', localtime({hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {nanosecond: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31:00.000000002'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-4-18',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[4] Should truncate localtime (example 18)',
        cypher="RETURN localtime.truncate('minute', localtime({hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-4-19',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[4] Should truncate localtime (example 19)',
        cypher="RETURN localtime.truncate('minute', time({hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {nanosecond: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31:00.000000002'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-4-20',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[4] Should truncate localtime (example 20)',
        cypher="RETURN localtime.truncate('minute', time({hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-4-21',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[4] Should truncate localtime (example 21)',
        cypher="RETURN localtime.truncate('second', datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {nanosecond: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31:14.000000002'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-4-22',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[4] Should truncate localtime (example 22)',
        cypher="RETURN localtime.truncate('second', datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31:14'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-4-23',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[4] Should truncate localtime (example 23)',
        cypher="RETURN localtime.truncate('second', localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {nanosecond: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31:14.000000002'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-4-24',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[4] Should truncate localtime (example 24)',
        cypher="RETURN localtime.truncate('second', localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31:14'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-4-25',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[4] Should truncate localtime (example 25)',
        cypher="RETURN localtime.truncate('second', localtime({hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {nanosecond: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31:14.000000002'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-4-26',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[4] Should truncate localtime (example 26)',
        cypher="RETURN localtime.truncate('second', localtime({hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31:14'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-4-27',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[4] Should truncate localtime (example 27)',
        cypher="RETURN localtime.truncate('second', time({hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {nanosecond: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31:14.000000002'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-4-28',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[4] Should truncate localtime (example 28)',
        cypher="RETURN localtime.truncate('second', time({hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31:14'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-4-29',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[4] Should truncate localtime (example 29)',
        cypher="RETURN localtime.truncate('millisecond', datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {nanosecond: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31:14.645000002'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-4-30',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[4] Should truncate localtime (example 30)',
        cypher="RETURN localtime.truncate('millisecond', datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31:14.645'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-4-31',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[4] Should truncate localtime (example 31)',
        cypher="RETURN localtime.truncate('millisecond', localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {nanosecond: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31:14.645000002'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-4-32',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[4] Should truncate localtime (example 32)',
        cypher="RETURN localtime.truncate('millisecond', localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31:14.645'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-4-33',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[4] Should truncate localtime (example 33)',
        cypher="RETURN localtime.truncate('millisecond', localtime({hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {nanosecond: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31:14.645000002'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-4-34',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[4] Should truncate localtime (example 34)',
        cypher="RETURN localtime.truncate('millisecond', localtime({hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31:14.645'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-4-35',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[4] Should truncate localtime (example 35)',
        cypher="RETURN localtime.truncate('millisecond', time({hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {nanosecond: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31:14.645000002'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-4-36',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[4] Should truncate localtime (example 36)',
        cypher="RETURN localtime.truncate('millisecond', time({hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31:14.645'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-4-37',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[4] Should truncate localtime (example 37)',
        cypher="RETURN localtime.truncate('microsecond', datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {nanosecond: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31:14.645876002'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-4-38',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[4] Should truncate localtime (example 38)',
        cypher="RETURN localtime.truncate('microsecond', datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31:14.645876'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-4-39',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[4] Should truncate localtime (example 39)',
        cypher="RETURN localtime.truncate('microsecond', localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {nanosecond: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31:14.645876002'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-4-40',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[4] Should truncate localtime (example 40)',
        cypher="RETURN localtime.truncate('microsecond', localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31:14.645876'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-4-41',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[4] Should truncate localtime (example 41)',
        cypher="RETURN localtime.truncate('microsecond', localtime({hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {nanosecond: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31:14.645876002'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-4-42',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[4] Should truncate localtime (example 42)',
        cypher="RETURN localtime.truncate('microsecond', localtime({hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31:14.645876'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-4-43',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[4] Should truncate localtime (example 43)',
        cypher="RETURN localtime.truncate('microsecond', time({hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {nanosecond: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31:14.645876002'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-4-44',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[4] Should truncate localtime (example 44)',
        cypher="RETURN localtime.truncate('microsecond', time({hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31:14.645876'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-5-1',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[5] Should truncate time (example 1)',
        cypher="RETURN time.truncate('day', datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {nanosecond: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'00:00:00.000000002+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-5-2',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[5] Should truncate time (example 2)',
        cypher="RETURN time.truncate('day', datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'00:00+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-5-3',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[5] Should truncate time (example 3)',
        cypher="RETURN time.truncate('day', localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {nanosecond: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'00:00:00.000000002Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-5-4',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[5] Should truncate time (example 4)',
        cypher="RETURN time.truncate('day', localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'00:00Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-5-5',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[5] Should truncate time (example 5)',
        cypher="RETURN time.truncate('hour', datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '-01:00'}), {nanosecond: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:00:00.000000002-01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-5-6',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[5] Should truncate time (example 6)',
        cypher="RETURN time.truncate('hour', datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '-01:00'}), {timezone: '+01:00'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:00+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-5-7',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[5] Should truncate time (example 7)',
        cypher="RETURN time.truncate('hour', datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '-01:00'}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:00-01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-5-8',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[5] Should truncate time (example 8)',
        cypher="RETURN time.truncate('hour', localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {nanosecond: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:00:00.000000002Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-5-9',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[5] Should truncate time (example 9)',
        cypher="RETURN time.truncate('hour', localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {timezone: '+01:00'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:00+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-5-10',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[5] Should truncate time (example 10)',
        cypher="RETURN time.truncate('hour', localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:00Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-5-11',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[5] Should truncate time (example 11)',
        cypher="RETURN time.truncate('hour', localtime({hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {nanosecond: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:00:00.000000002Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-5-12',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[5] Should truncate time (example 12)',
        cypher="RETURN time.truncate('hour', localtime({hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {timezone: '+01:00'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:00+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-5-13',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[5] Should truncate time (example 13)',
        cypher="RETURN time.truncate('hour', localtime({hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:00Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-5-14',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[5] Should truncate time (example 14)',
        cypher="RETURN time.truncate('hour', time({hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '-01:00'}), {nanosecond: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:00:00.000000002-01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-5-15',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[5] Should truncate time (example 15)',
        cypher="RETURN time.truncate('hour', time({hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '-01:00'}), {timezone: '+01:00'}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:00+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-5-16',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[5] Should truncate time (example 16)',
        cypher="RETURN time.truncate('hour', time({hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '-01:00'}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:00-01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-5-17',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[5] Should truncate time (example 17)',
        cypher="RETURN time.truncate('minute', datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '-01:00'}), {nanosecond: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31:00.000000002-01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-5-18',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[5] Should truncate time (example 18)',
        cypher="RETURN time.truncate('minute', datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '-01:00'}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31-01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-5-19',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[5] Should truncate time (example 19)',
        cypher="RETURN time.truncate('minute', localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {nanosecond: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31:00.000000002Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-5-20',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[5] Should truncate time (example 20)',
        cypher="RETURN time.truncate('minute', localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-5-21',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[5] Should truncate time (example 21)',
        cypher="RETURN time.truncate('minute', localtime({hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {nanosecond: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31:00.000000002Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-5-22',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[5] Should truncate time (example 22)',
        cypher="RETURN time.truncate('minute', localtime({hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-5-23',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[5] Should truncate time (example 23)',
        cypher="RETURN time.truncate('minute', time({hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '-01:00'}), {nanosecond: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31:00.000000002-01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-5-24',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[5] Should truncate time (example 24)',
        cypher="RETURN time.truncate('minute', time({hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '-01:00'}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31-01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-5-25',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[5] Should truncate time (example 25)',
        cypher="RETURN time.truncate('second', datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {nanosecond: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31:14.000000002+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-5-26',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[5] Should truncate time (example 26)',
        cypher="RETURN time.truncate('second', datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31:14+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-5-27',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[5] Should truncate time (example 27)',
        cypher="RETURN time.truncate('second', localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {nanosecond: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31:14.000000002Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-5-28',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[5] Should truncate time (example 28)',
        cypher="RETURN time.truncate('second', localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31:14Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-5-29',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[5] Should truncate time (example 29)',
        cypher="RETURN time.truncate('second', localtime({hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {nanosecond: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31:14.000000002Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-5-30',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[5] Should truncate time (example 30)',
        cypher="RETURN time.truncate('second', localtime({hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31:14Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-5-31',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[5] Should truncate time (example 31)',
        cypher="RETURN time.truncate('second', time({hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {nanosecond: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31:14.000000002+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-5-32',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[5] Should truncate time (example 32)',
        cypher="RETURN time.truncate('second', time({hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31:14+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-5-33',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[5] Should truncate time (example 33)',
        cypher="RETURN time.truncate('millisecond', datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {nanosecond: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31:14.645000002+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-5-34',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[5] Should truncate time (example 34)',
        cypher="RETURN time.truncate('millisecond', datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31:14.645+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-5-35',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[5] Should truncate time (example 35)',
        cypher="RETURN time.truncate('millisecond', localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {nanosecond: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31:14.645000002Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-5-36',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[5] Should truncate time (example 36)',
        cypher="RETURN time.truncate('millisecond', localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31:14.645Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-5-37',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[5] Should truncate time (example 37)',
        cypher="RETURN time.truncate('millisecond', localtime({hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {nanosecond: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31:14.645000002Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-5-38',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[5] Should truncate time (example 38)',
        cypher="RETURN time.truncate('millisecond', localtime({hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31:14.645Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-5-39',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[5] Should truncate time (example 39)',
        cypher="RETURN time.truncate('millisecond', time({hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {nanosecond: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31:14.645000002+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-5-40',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[5] Should truncate time (example 40)',
        cypher="RETURN time.truncate('millisecond', time({hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31:14.645+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-5-41',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[5] Should truncate time (example 41)',
        cypher="RETURN time.truncate('microsecond', datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {nanosecond: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31:14.645876002+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-5-42',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[5] Should truncate time (example 42)',
        cypher="RETURN time.truncate('microsecond', datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31:14.645876+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-5-43',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[5] Should truncate time (example 43)',
        cypher="RETURN time.truncate('microsecond', localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {nanosecond: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31:14.645876002Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-5-44',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[5] Should truncate time (example 44)',
        cypher="RETURN time.truncate('microsecond', localdatetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31:14.645876Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-5-45',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[5] Should truncate time (example 45)',
        cypher="RETURN time.truncate('microsecond', localtime({hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {nanosecond: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31:14.645876002Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-5-46',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[5] Should truncate time (example 46)',
        cypher="RETURN time.truncate('microsecond', localtime({hour: 12, minute: 31, second: 14, nanosecond: 645876123}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31:14.645876Z'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-5-47',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[5] Should truncate time (example 47)',
        cypher="RETURN time.truncate('microsecond', time({hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {nanosecond: 2}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31:14.645876002+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-temporal9-5-48',
        feature_path='tck/features/expressions/temporal/Temporal9.feature',
        scenario='[5] Should truncate time (example 48)',
        cypher="RETURN time.truncate('microsecond', time({hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '+01:00'}), {}) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'12:31:14.645876+01:00'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'temporal', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-typeconversion1-1',
        feature_path='tck/features/expressions/typeConversion/TypeConversion1.feature',
        scenario='[1] `toBoolean()` on booleans',
        cypher='UNWIND [true, false] AS b\n      RETURN toBoolean(b) AS b',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'b': 'true'},
            {'b': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'typeConversion', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-typeconversion1-2',
        feature_path='tck/features/expressions/typeConversion/TypeConversion1.feature',
        scenario='[2] `toBoolean()` on valid literal string',
        cypher="RETURN toBoolean('true') AS b",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'b': 'true'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'typeConversion', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-typeconversion1-3',
        feature_path='tck/features/expressions/typeConversion/TypeConversion1.feature',
        scenario='[3] `toBoolean()` on variables with valid string values',
        cypher="UNWIND ['true', 'false'] AS s\n      RETURN toBoolean(s) AS b",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'b': 'true'},
            {'b': 'false'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'typeConversion', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-typeconversion1-4',
        feature_path='tck/features/expressions/typeConversion/TypeConversion1.feature',
        scenario='[4] `toBoolean()` on invalid strings',
        cypher="UNWIND [null, '', ' tru ', 'f alse'] AS things\n      RETURN toBoolean(things) AS b",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'b': 'null'},
            {'b': 'null'},
            {'b': 'null'},
            {'b': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'typeConversion', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-typeconversion1-5-1',
        feature_path='tck/features/expressions/typeConversion/TypeConversion1.feature',
        scenario='[5] Fail `toBoolean()` on invalid types #Example: <exampleName> (example 1)',
        cypher='MATCH p = (n)-[r:T]->()\n      RETURN [x IN [true, []] | toBoolean(x) ] AS list',
        graph=graph_fixture_from_create(
            """
            CREATE ()-[:T]->()
            """
        ),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Runtime error semantics are not supported',
        tags=('expr', 'typeConversion', 'meta-xfail', 'runtime-error', 'xfail'),
    ),
    Scenario(
        key='expr-typeconversion1-5-2',
        feature_path='tck/features/expressions/typeConversion/TypeConversion1.feature',
        scenario='[5] Fail `toBoolean()` on invalid types #Example: <exampleName> (example 2)',
        cypher='MATCH p = (n)-[r:T]->()\n      RETURN [x IN [true, {}] | toBoolean(x) ] AS list',
        graph=graph_fixture_from_create(
            """
            CREATE ()-[:T]->()
            """
        ),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Runtime error semantics are not supported',
        tags=('expr', 'typeConversion', 'meta-xfail', 'runtime-error', 'xfail'),
    ),
    Scenario(
        key='expr-typeconversion1-5-3',
        feature_path='tck/features/expressions/typeConversion/TypeConversion1.feature',
        scenario='[5] Fail `toBoolean()` on invalid types #Example: <exampleName> (example 3)',
        cypher='MATCH p = (n)-[r:T]->()\n      RETURN [x IN [true, 1.0] | toBoolean(x) ] AS list',
        graph=graph_fixture_from_create(
            """
            CREATE ()-[:T]->()
            """
        ),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Runtime error semantics are not supported',
        tags=('expr', 'typeConversion', 'meta-xfail', 'runtime-error', 'xfail'),
    ),
    Scenario(
        key='expr-typeconversion1-5-4',
        feature_path='tck/features/expressions/typeConversion/TypeConversion1.feature',
        scenario='[5] Fail `toBoolean()` on invalid types #Example: <exampleName> (example 4)',
        cypher='MATCH p = (n)-[r:T]->()\n      RETURN [x IN [true, n] | toBoolean(x) ] AS list',
        graph=graph_fixture_from_create(
            """
            CREATE ()-[:T]->()
            """
        ),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Runtime error semantics are not supported',
        tags=('expr', 'typeConversion', 'meta-xfail', 'runtime-error', 'xfail'),
    ),
    Scenario(
        key='expr-typeconversion1-5-5',
        feature_path='tck/features/expressions/typeConversion/TypeConversion1.feature',
        scenario='[5] Fail `toBoolean()` on invalid types #Example: <exampleName> (example 5)',
        cypher='MATCH p = (n)-[r:T]->()\n      RETURN [x IN [true, r] | toBoolean(x) ] AS list',
        graph=graph_fixture_from_create(
            """
            CREATE ()-[:T]->()
            """
        ),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Runtime error semantics are not supported',
        tags=('expr', 'typeConversion', 'meta-xfail', 'runtime-error', 'xfail'),
    ),
    Scenario(
        key='expr-typeconversion1-5-6',
        feature_path='tck/features/expressions/typeConversion/TypeConversion1.feature',
        scenario='[5] Fail `toBoolean()` on invalid types #Example: <exampleName> (example 6)',
        cypher='MATCH p = (n)-[r:T]->()\n      RETURN [x IN [true, p] | toBoolean(x) ] AS list',
        graph=graph_fixture_from_create(
            """
            CREATE ()-[:T]->()
            """
        ),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Runtime error semantics are not supported',
        tags=('expr', 'typeConversion', 'meta-xfail', 'runtime-error', 'xfail'),
    ),
    Scenario(
        key='expr-typeconversion2-1',
        feature_path='tck/features/expressions/typeConversion/TypeConversion2.feature',
        scenario='[1] `toInteger()` on float',
        cypher='WITH 82.9 AS weight\n      RETURN toInteger(weight)',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'toInteger(weight)': 82}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'typeConversion', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-typeconversion2-2',
        feature_path='tck/features/expressions/typeConversion/TypeConversion2.feature',
        scenario='[2] `toInteger()` returning null on non-numerical string',
        cypher="WITH 'foo' AS foo_string, '' AS empty_string\n      RETURN toInteger(foo_string) AS foo, toInteger(empty_string) AS empty",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'foo': 'null', 'empty': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'typeConversion', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-typeconversion2-3',
        feature_path='tck/features/expressions/typeConversion/TypeConversion2.feature',
        scenario='[3] `toInteger()` handling mixed number types',
        cypher='WITH [2, 2.9] AS numbers\n      RETURN [n IN numbers | toInteger(n)] AS int_numbers',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'int_numbers': '[2, 2]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'typeConversion', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-typeconversion2-4',
        feature_path='tck/features/expressions/typeConversion/TypeConversion2.feature',
        scenario='[4] `toInteger()` handling Any type',
        cypher="WITH [2, 2.9, '1.7'] AS things\n      RETURN [n IN things | toInteger(n)] AS int_numbers",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'int_numbers': '[2, 2, 1]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'typeConversion', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-typeconversion2-5',
        feature_path='tck/features/expressions/typeConversion/TypeConversion2.feature',
        scenario='[5] `toInteger()` on a list of strings',
        cypher="WITH ['2', '2.9', 'foo'] AS numbers\n      RETURN [n IN numbers | toInteger(n)] AS int_numbers",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'int_numbers': '[2, 2, null]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'typeConversion', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-typeconversion2-6',
        feature_path='tck/features/expressions/typeConversion/TypeConversion2.feature',
        scenario='[6] `toInteger()` on a complex-typed expression',
        cypher='RETURN toInteger(1 - $param) AS result',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': 0}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Parameter binding is not supported',
        tags=('expr', 'typeConversion', 'meta-xfail', 'params', 'xfail'),
    ),
    Scenario(
        key='expr-typeconversion2-7',
        feature_path='tck/features/expressions/typeConversion/TypeConversion2.feature',
        scenario='[7] `toInteger()` on node property',
        cypher="MATCH (p:Person { name: '42' })\n      WITH *\n      MATCH (n)\n      RETURN toInteger(n.name) AS name",
        graph=graph_fixture_from_create(
            """
            CREATE (:Person {name: '42'})
            """
        ),
        expected=Expected(
            rows=[
            {'name': 42}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'typeConversion', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-typeconversion2-8-1',
        feature_path='tck/features/expressions/typeConversion/TypeConversion2.feature',
        scenario='[8] Fail `toInteger()` on invalid types #Example: <exampleName> (example 1)',
        cypher='MATCH p = (n)-[r:T]->()\n      RETURN [x IN [1, []] | toInteger(x) ] AS list',
        graph=graph_fixture_from_create(
            """
            CREATE ()-[:T]->()
            """
        ),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Runtime error semantics are not supported',
        tags=('expr', 'typeConversion', 'meta-xfail', 'runtime-error', 'xfail'),
    ),
    Scenario(
        key='expr-typeconversion2-8-2',
        feature_path='tck/features/expressions/typeConversion/TypeConversion2.feature',
        scenario='[8] Fail `toInteger()` on invalid types #Example: <exampleName> (example 2)',
        cypher='MATCH p = (n)-[r:T]->()\n      RETURN [x IN [1, {}] | toInteger(x) ] AS list',
        graph=graph_fixture_from_create(
            """
            CREATE ()-[:T]->()
            """
        ),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Runtime error semantics are not supported',
        tags=('expr', 'typeConversion', 'meta-xfail', 'runtime-error', 'xfail'),
    ),
    Scenario(
        key='expr-typeconversion2-8-3',
        feature_path='tck/features/expressions/typeConversion/TypeConversion2.feature',
        scenario='[8] Fail `toInteger()` on invalid types #Example: <exampleName> (example 3)',
        cypher='MATCH p = (n)-[r:T]->()\n      RETURN [x IN [1, n] | toInteger(x) ] AS list',
        graph=graph_fixture_from_create(
            """
            CREATE ()-[:T]->()
            """
        ),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Runtime error semantics are not supported',
        tags=('expr', 'typeConversion', 'meta-xfail', 'runtime-error', 'xfail'),
    ),
    Scenario(
        key='expr-typeconversion2-8-4',
        feature_path='tck/features/expressions/typeConversion/TypeConversion2.feature',
        scenario='[8] Fail `toInteger()` on invalid types #Example: <exampleName> (example 4)',
        cypher='MATCH p = (n)-[r:T]->()\n      RETURN [x IN [1, r] | toInteger(x) ] AS list',
        graph=graph_fixture_from_create(
            """
            CREATE ()-[:T]->()
            """
        ),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Runtime error semantics are not supported',
        tags=('expr', 'typeConversion', 'meta-xfail', 'runtime-error', 'xfail'),
    ),
    Scenario(
        key='expr-typeconversion2-8-5',
        feature_path='tck/features/expressions/typeConversion/TypeConversion2.feature',
        scenario='[8] Fail `toInteger()` on invalid types #Example: <exampleName> (example 5)',
        cypher='MATCH p = (n)-[r:T]->()\n      RETURN [x IN [1, p] | toInteger(x) ] AS list',
        graph=graph_fixture_from_create(
            """
            CREATE ()-[:T]->()
            """
        ),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Runtime error semantics are not supported',
        tags=('expr', 'typeConversion', 'meta-xfail', 'runtime-error', 'xfail'),
    ),
    Scenario(
        key='expr-typeconversion3-1',
        feature_path='tck/features/expressions/typeConversion/TypeConversion3.feature',
        scenario='[1] `toFloat()` on mixed number types',
        cypher='WITH [3.4, 3] AS numbers\n      RETURN [n IN numbers | toFloat(n)] AS float_numbers',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'float_numbers': '[3.4, 3.0]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'typeConversion', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-typeconversion3-2',
        feature_path='tck/features/expressions/typeConversion/TypeConversion3.feature',
        scenario='[2] `toFloat()` returning null on non-numerical string',
        cypher="WITH 'foo' AS foo_string, '' AS empty_string\n      RETURN toFloat(foo_string) AS foo, toFloat(empty_string) AS empty",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'foo': 'null', 'empty': 'null'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'typeConversion', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-typeconversion3-3',
        feature_path='tck/features/expressions/typeConversion/TypeConversion3.feature',
        scenario='[3] `toFloat()` handling Any type',
        cypher="WITH [3.4, 3, '5'] AS numbers\n      RETURN [n IN numbers | toFloat(n)] AS float_numbers",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'float_numbers': '[3.4, 3.0, 5.0]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'typeConversion', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-typeconversion3-4',
        feature_path='tck/features/expressions/typeConversion/TypeConversion3.feature',
        scenario='[4] `toFloat()` on a list of strings',
        cypher="WITH ['1', '2', 'foo'] AS numbers\n      RETURN [n IN numbers | toFloat(n)] AS float_numbers",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'float_numbers': '[1.0, 2.0, null]'}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'typeConversion', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-typeconversion3-5',
        feature_path='tck/features/expressions/typeConversion/TypeConversion3.feature',
        scenario='[5] `toFloat()` on node property',
        cypher='MATCH (m:Movie { rating: 4 })\n      WITH *\n      MATCH (n)\n      RETURN toFloat(n.rating) AS float',
        graph=graph_fixture_from_create(
            """
            CREATE (:Movie {rating: 4})
            """
        ),
        expected=Expected(
            rows=[
            {'float': 4.0}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'typeConversion', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-typeconversion3-6-1',
        feature_path='tck/features/expressions/typeConversion/TypeConversion3.feature',
        scenario='[6] Fail `toFloat()` on invalid types #Example: <exampleName> (example 1)',
        cypher='MATCH p = (n)-[r:T]->()\n      RETURN [x IN [1.0, true] | toFloat(x) ] AS list',
        graph=graph_fixture_from_create(
            """
            CREATE ()-[:T]->()
            """
        ),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Runtime error semantics are not supported',
        tags=('expr', 'typeConversion', 'meta-xfail', 'runtime-error', 'xfail'),
    ),
    Scenario(
        key='expr-typeconversion3-6-2',
        feature_path='tck/features/expressions/typeConversion/TypeConversion3.feature',
        scenario='[6] Fail `toFloat()` on invalid types #Example: <exampleName> (example 2)',
        cypher='MATCH p = (n)-[r:T]->()\n      RETURN [x IN [1.0, []] | toFloat(x) ] AS list',
        graph=graph_fixture_from_create(
            """
            CREATE ()-[:T]->()
            """
        ),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Runtime error semantics are not supported',
        tags=('expr', 'typeConversion', 'meta-xfail', 'runtime-error', 'xfail'),
    ),
    Scenario(
        key='expr-typeconversion3-6-3',
        feature_path='tck/features/expressions/typeConversion/TypeConversion3.feature',
        scenario='[6] Fail `toFloat()` on invalid types #Example: <exampleName> (example 3)',
        cypher='MATCH p = (n)-[r:T]->()\n      RETURN [x IN [1.0, {}] | toFloat(x) ] AS list',
        graph=graph_fixture_from_create(
            """
            CREATE ()-[:T]->()
            """
        ),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Runtime error semantics are not supported',
        tags=('expr', 'typeConversion', 'meta-xfail', 'runtime-error', 'xfail'),
    ),
    Scenario(
        key='expr-typeconversion3-6-4',
        feature_path='tck/features/expressions/typeConversion/TypeConversion3.feature',
        scenario='[6] Fail `toFloat()` on invalid types #Example: <exampleName> (example 4)',
        cypher='MATCH p = (n)-[r:T]->()\n      RETURN [x IN [1.0, n] | toFloat(x) ] AS list',
        graph=graph_fixture_from_create(
            """
            CREATE ()-[:T]->()
            """
        ),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Runtime error semantics are not supported',
        tags=('expr', 'typeConversion', 'meta-xfail', 'runtime-error', 'xfail'),
    ),
    Scenario(
        key='expr-typeconversion3-6-5',
        feature_path='tck/features/expressions/typeConversion/TypeConversion3.feature',
        scenario='[6] Fail `toFloat()` on invalid types #Example: <exampleName> (example 5)',
        cypher='MATCH p = (n)-[r:T]->()\n      RETURN [x IN [1.0, r] | toFloat(x) ] AS list',
        graph=graph_fixture_from_create(
            """
            CREATE ()-[:T]->()
            """
        ),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Runtime error semantics are not supported',
        tags=('expr', 'typeConversion', 'meta-xfail', 'runtime-error', 'xfail'),
    ),
    Scenario(
        key='expr-typeconversion3-6-6',
        feature_path='tck/features/expressions/typeConversion/TypeConversion3.feature',
        scenario='[6] Fail `toFloat()` on invalid types #Example: <exampleName> (example 6)',
        cypher='MATCH p = (n)-[r:T]->()\n      RETURN [x IN [1.0, p] | toFloat(x) ] AS list',
        graph=graph_fixture_from_create(
            """
            CREATE ()-[:T]->()
            """
        ),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Runtime error semantics are not supported',
        tags=('expr', 'typeConversion', 'meta-xfail', 'runtime-error', 'xfail'),
    ),
    Scenario(
        key='expr-typeconversion4-1',
        feature_path='tck/features/expressions/typeConversion/TypeConversion4.feature',
        scenario='[1] `toString()` handling integer literal',
        cypher='RETURN toString(42) AS bool',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'bool': "'42'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'typeConversion', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-typeconversion4-2',
        feature_path='tck/features/expressions/typeConversion/TypeConversion4.feature',
        scenario='[2] `toString()` handling boolean literal',
        cypher='RETURN toString(true) AS bool',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'bool': "'true'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'typeConversion', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-typeconversion4-3',
        feature_path='tck/features/expressions/typeConversion/TypeConversion4.feature',
        scenario='[3] `toString()` handling inlined boolean',
        cypher='RETURN toString(1 < 0) AS bool',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'bool': "'false'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'typeConversion', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-typeconversion4-4',
        feature_path='tck/features/expressions/typeConversion/TypeConversion4.feature',
        scenario='[4] `toString()` handling boolean properties',
        cypher='MATCH (m:Movie)\n      RETURN toString(m.watched)',
        graph=graph_fixture_from_create(
            """
            CREATE (:Movie {watched: true})
            """
        ),
        expected=Expected(
            rows=[
            {'toString(m.watched)': "'true'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'typeConversion', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-typeconversion4-5',
        feature_path='tck/features/expressions/typeConversion/TypeConversion4.feature',
        scenario='[5] `toString()` should work on Any type',
        cypher="RETURN [x IN [1, 2.3, true, 'apa'] | toString(x) ] AS list",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'list': "['1', '2.3', 'true', 'apa']"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'typeConversion', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-typeconversion4-6',
        feature_path='tck/features/expressions/typeConversion/TypeConversion4.feature',
        scenario='[6] `toString()` on a list of integers',
        cypher='WITH [1, 2, 3] AS numbers\n      RETURN [n IN numbers | toString(n)] AS string_numbers',
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'string_numbers': "['1', '2', '3']"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'typeConversion', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-typeconversion4-7',
        feature_path='tck/features/expressions/typeConversion/TypeConversion4.feature',
        scenario='[7] `toString()` on node property',
        cypher='MATCH (m:Movie { rating: 4 })\n      WITH *\n      MATCH (n)\n      RETURN toString(n.rating)',
        graph=graph_fixture_from_create(
            """
            CREATE (:Movie {rating: 4})
            """
        ),
        expected=Expected(
            rows=[
            {'toString(n.rating)': "'4'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'typeConversion', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-typeconversion4-8',
        feature_path='tck/features/expressions/typeConversion/TypeConversion4.feature',
        scenario='[8] `toString()` should accept potentially correct types 1',
        cypher="UNWIND ['male', 'female', null] AS gen\n      RETURN coalesce(toString(gen), 'x') AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'male'"},
            {'result': "'female'"},
            {'result': "'x'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'typeConversion', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-typeconversion4-9',
        feature_path='tck/features/expressions/typeConversion/TypeConversion4.feature',
        scenario='[9] `toString()` should accept potentially correct types 2',
        cypher="UNWIND ['male', 'female', null] AS gen\n      RETURN toString(coalesce(gen, 'x')) AS result",
        graph=GraphFixture(nodes=[], edges=[]),
        expected=Expected(
            rows=[
            {'result': "'male'"},
            {'result': "'female'"},
            {'result': "'x'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='Expression evaluation is not supported',
        tags=('expr', 'typeConversion', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='expr-typeconversion4-10-1',
        feature_path='tck/features/expressions/typeConversion/TypeConversion4.feature',
        scenario='[10] Fail `toString()` on invalid types #Example: <exampleName> (example 1)',
        cypher="MATCH p = (n)-[r:T]->()\n      RETURN [x IN [1, '', []] | toString(x) ] AS list",
        graph=graph_fixture_from_create(
            """
            CREATE ()-[:T]->()
            """
        ),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Runtime error semantics are not supported',
        tags=('expr', 'typeConversion', 'meta-xfail', 'runtime-error', 'xfail'),
    ),
    Scenario(
        key='expr-typeconversion4-10-2',
        feature_path='tck/features/expressions/typeConversion/TypeConversion4.feature',
        scenario='[10] Fail `toString()` on invalid types #Example: <exampleName> (example 2)',
        cypher="MATCH p = (n)-[r:T]->()\n      RETURN [x IN [1, '', {}] | toString(x) ] AS list",
        graph=graph_fixture_from_create(
            """
            CREATE ()-[:T]->()
            """
        ),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Runtime error semantics are not supported',
        tags=('expr', 'typeConversion', 'meta-xfail', 'runtime-error', 'xfail'),
    ),
    Scenario(
        key='expr-typeconversion4-10-3',
        feature_path='tck/features/expressions/typeConversion/TypeConversion4.feature',
        scenario='[10] Fail `toString()` on invalid types #Example: <exampleName> (example 3)',
        cypher="MATCH p = (n)-[r:T]->()\n      RETURN [x IN [1, '', n] | toString(x) ] AS list",
        graph=graph_fixture_from_create(
            """
            CREATE ()-[:T]->()
            """
        ),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Runtime error semantics are not supported',
        tags=('expr', 'typeConversion', 'meta-xfail', 'runtime-error', 'xfail'),
    ),
    Scenario(
        key='expr-typeconversion4-10-4',
        feature_path='tck/features/expressions/typeConversion/TypeConversion4.feature',
        scenario='[10] Fail `toString()` on invalid types #Example: <exampleName> (example 4)',
        cypher="MATCH p = (n)-[r:T]->()\n      RETURN [x IN [1, '', r] | toString(x) ] AS list",
        graph=graph_fixture_from_create(
            """
            CREATE ()-[:T]->()
            """
        ),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Runtime error semantics are not supported',
        tags=('expr', 'typeConversion', 'meta-xfail', 'runtime-error', 'xfail'),
    ),
    Scenario(
        key='expr-typeconversion4-10-5',
        feature_path='tck/features/expressions/typeConversion/TypeConversion4.feature',
        scenario='[10] Fail `toString()` on invalid types #Example: <exampleName> (example 5)',
        cypher="MATCH p = (n)-[r:T]->()\n      RETURN [x IN [1, '', p] | toString(x) ] AS list",
        graph=graph_fixture_from_create(
            """
            CREATE ()-[:T]->()
            """
        ),
        expected=Expected(),
        gfql=None,
        status="xfail",
        reason='Runtime error semantics are not supported',
        tags=('expr', 'typeConversion', 'meta-xfail', 'runtime-error', 'xfail'),
    ),

    Scenario(
        key='usecase-countingsubgraphmatches1-1',
        feature_path='tck/features/useCases/countingSubgraphMatches/CountingSubgraphMatches1.feature',
        scenario='[1] Undirected match in self-relationship graph, count',
        cypher='MATCH ()--()\n      RETURN count(*)',
        graph=graph_fixture_from_create(
            """
            CREATE (a:A)-[:LOOP]->(a)
            """
        ),
        expected=Expected(
            rows=[
            {'count(*)': 1}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='UseCases suite is not supported',
        tags=('usecase', 'countingSubgraphMatches', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='usecase-countingsubgraphmatches1-2',
        feature_path='tck/features/useCases/countingSubgraphMatches/CountingSubgraphMatches1.feature',
        scenario='[2] Undirected match of self-relationship in self-relationship graph, count',
        cypher='MATCH (n)--(n)\n      RETURN count(*)',
        graph=graph_fixture_from_create(
            """
            CREATE (a:A)-[:LOOP]->(a)
            """
        ),
        expected=Expected(
            rows=[
            {'count(*)': 1}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='UseCases suite is not supported',
        tags=('usecase', 'countingSubgraphMatches', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='usecase-countingsubgraphmatches1-3',
        feature_path='tck/features/useCases/countingSubgraphMatches/CountingSubgraphMatches1.feature',
        scenario='[3] Undirected match on simple relationship graph, count',
        cypher='MATCH ()--()\n      RETURN count(*)',
        graph=graph_fixture_from_create(
            """
            CREATE (:A)-[:LOOP]->(:B)
            """
        ),
        expected=Expected(
            rows=[
            {'count(*)': 2}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='UseCases suite is not supported',
        tags=('usecase', 'countingSubgraphMatches', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='usecase-countingsubgraphmatches1-4',
        feature_path='tck/features/useCases/countingSubgraphMatches/CountingSubgraphMatches1.feature',
        scenario='[4] Directed match on self-relationship graph, count',
        cypher='MATCH ()-->()\n      RETURN count(*)',
        graph=graph_fixture_from_create(
            """
            CREATE (a:A)-[:LOOP]->(a)
            """
        ),
        expected=Expected(
            rows=[
            {'count(*)': 1}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='UseCases suite is not supported',
        tags=('usecase', 'countingSubgraphMatches', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='usecase-countingsubgraphmatches1-5',
        feature_path='tck/features/useCases/countingSubgraphMatches/CountingSubgraphMatches1.feature',
        scenario='[5] Directed match of self-relationship on self-relationship graph, count',
        cypher='MATCH (n)-->(n)\n      RETURN count(*)',
        graph=graph_fixture_from_create(
            """
            CREATE (a:A)-[:LOOP]->(a)
            """
        ),
        expected=Expected(
            rows=[
            {'count(*)': 1}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='UseCases suite is not supported',
        tags=('usecase', 'countingSubgraphMatches', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='usecase-countingsubgraphmatches1-6',
        feature_path='tck/features/useCases/countingSubgraphMatches/CountingSubgraphMatches1.feature',
        scenario='[6] Counting undirected self-relationships in self-relationship graph',
        cypher='MATCH (n)-[r]-(n)\n      RETURN count(r)',
        graph=graph_fixture_from_create(
            """
            CREATE (a:A)-[:LOOP]->(a)
            """
        ),
        expected=Expected(
            rows=[
            {'count(r)': 1}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='UseCases suite is not supported',
        tags=('usecase', 'countingSubgraphMatches', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='usecase-countingsubgraphmatches1-7',
        feature_path='tck/features/useCases/countingSubgraphMatches/CountingSubgraphMatches1.feature',
        scenario='[7] Counting distinct undirected self-relationships in self-relationship graph',
        cypher='MATCH (n)-[r]-(n)\n      RETURN count(DISTINCT r)',
        graph=graph_fixture_from_create(
            """
            CREATE (a:A)-[:LOOP]->(a)
            """
        ),
        expected=Expected(
            rows=[
            {'count(DISTINCT r)': 1}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='UseCases suite is not supported',
        tags=('usecase', 'countingSubgraphMatches', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='usecase-countingsubgraphmatches1-8',
        feature_path='tck/features/useCases/countingSubgraphMatches/CountingSubgraphMatches1.feature',
        scenario='[8] Directed match of a simple relationship, count',
        cypher='MATCH ()-->()\n      RETURN count(*)',
        graph=graph_fixture_from_create(
            """
            CREATE (:A)-[:LOOP]->(:B)
            """
        ),
        expected=Expected(
            rows=[
            {'count(*)': 1}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='UseCases suite is not supported',
        tags=('usecase', 'countingSubgraphMatches', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='usecase-countingsubgraphmatches1-9',
        feature_path='tck/features/useCases/countingSubgraphMatches/CountingSubgraphMatches1.feature',
        scenario='[9] Counting directed self-relationships',
        cypher='MATCH (n)-[r]->(n)\n      RETURN count(r)',
        graph=graph_fixture_from_create(
            """
            CREATE (a:A)-[:LOOP]->(a),
                         ()-[:T]->()
            """
        ),
        expected=Expected(
            rows=[
            {'count(r)': 1}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='UseCases suite is not supported',
        tags=('usecase', 'countingSubgraphMatches', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='usecase-countingsubgraphmatches1-10',
        feature_path='tck/features/useCases/countingSubgraphMatches/CountingSubgraphMatches1.feature',
        scenario='[10] Mixing directed and undirected pattern parts with self-relationship, count',
        cypher='MATCH (:A)-->()--()\n      RETURN count(*)',
        graph=graph_fixture_from_create(
            """
            CREATE (:A)-[:T1]->(l:Looper),
                         (l)-[:LOOP]->(l),
                         (l)-[:T2]->(:B)
            """
        ),
        expected=Expected(
            rows=[
            {'count(*)': 2}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='UseCases suite is not supported',
        tags=('usecase', 'countingSubgraphMatches', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='usecase-countingsubgraphmatches1-11',
        feature_path='tck/features/useCases/countingSubgraphMatches/CountingSubgraphMatches1.feature',
        scenario='[11] Mixing directed and undirected pattern parts with self-relationship, undirected count',
        cypher='MATCH ()-[]-()-[]-()\n      RETURN count(*)',
        graph=graph_fixture_from_create(
            """
            CREATE (:A)-[:T1]->(l:Looper),
                         (l)-[:LOOP]->(l),
                         (l)-[:T2]->(:B)
            """
        ),
        expected=Expected(
            rows=[
            {'count(*)': 6}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='UseCases suite is not supported',
        tags=('usecase', 'countingSubgraphMatches', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='usecase-triadicselection1-1',
        feature_path='tck/features/useCases/triadicSelection/TriadicSelection1.feature',
        scenario='[1] Handling triadic friend of a friend',
        cypher='MATCH (a:A)-[:KNOWS]->(b)-->(c)\n      RETURN c.name',
        graph=BINARY_TREE_1_GRAPH,
        expected=Expected(
            rows=[
            {'c.name': "'b2'"},
            {'c.name': "'b3'"},
            {'c.name': "'c11'"},
            {'c.name': "'c12'"},
            {'c.name': "'c21'"},
            {'c.name': "'c22'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='UseCases suite is not supported',
        tags=('usecase', 'triadicSelection', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='usecase-triadicselection1-2',
        feature_path='tck/features/useCases/triadicSelection/TriadicSelection1.feature',
        scenario='[2] Handling triadic friend of a friend that is not a friend',
        cypher='MATCH (a:A)-[:KNOWS]->(b)-->(c)\n      OPTIONAL MATCH (a)-[r:KNOWS]->(c)\n      WITH c WHERE r IS NULL\n      RETURN c.name',
        graph=BINARY_TREE_1_GRAPH,
        expected=Expected(
            rows=[
            {'c.name': "'b3'"},
            {'c.name': "'c11'"},
            {'c.name': "'c12'"},
            {'c.name': "'c21'"},
            {'c.name': "'c22'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='UseCases suite is not supported',
        tags=('usecase', 'triadicSelection', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='usecase-triadicselection1-3',
        feature_path='tck/features/useCases/triadicSelection/TriadicSelection1.feature',
        scenario='[3] Handling triadic friend of a friend that is not a friend with different relationship type',
        cypher='MATCH (a:A)-[:KNOWS]->(b)-->(c)\n      OPTIONAL MATCH (a)-[r:FOLLOWS]->(c)\n      WITH c WHERE r IS NULL\n      RETURN c.name',
        graph=BINARY_TREE_1_GRAPH,
        expected=Expected(
            rows=[
            {'c.name': "'b2'"},
            {'c.name': "'c11'"},
            {'c.name': "'c12'"},
            {'c.name': "'c21'"},
            {'c.name': "'c22'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='UseCases suite is not supported',
        tags=('usecase', 'triadicSelection', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='usecase-triadicselection1-4',
        feature_path='tck/features/useCases/triadicSelection/TriadicSelection1.feature',
        scenario='[4] Handling triadic friend of a friend that is not a friend with superset of relationship type',
        cypher='MATCH (a:A)-[:KNOWS]->(b)-->(c)\n      OPTIONAL MATCH (a)-[r]->(c)\n      WITH c WHERE r IS NULL\n      RETURN c.name',
        graph=BINARY_TREE_1_GRAPH,
        expected=Expected(
            rows=[
            {'c.name': "'c11'"},
            {'c.name': "'c12'"},
            {'c.name': "'c21'"},
            {'c.name': "'c22'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='UseCases suite is not supported',
        tags=('usecase', 'triadicSelection', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='usecase-triadicselection1-5',
        feature_path='tck/features/useCases/triadicSelection/TriadicSelection1.feature',
        scenario='[5] Handling triadic friend of a friend that is not a friend with implicit subset of relationship type',
        cypher='MATCH (a:A)-->(b)-->(c)\n      OPTIONAL MATCH (a)-[r:KNOWS]->(c)\n      WITH c WHERE r IS NULL\n      RETURN c.name',
        graph=BINARY_TREE_1_GRAPH,
        expected=Expected(
            rows=[
            {'c.name': "'b3'"},
            {'c.name': "'b4'"},
            {'c.name': "'c11'"},
            {'c.name': "'c12'"},
            {'c.name': "'c21'"},
            {'c.name': "'c22'"},
            {'c.name': "'c31'"},
            {'c.name': "'c32'"},
            {'c.name': "'c41'"},
            {'c.name': "'c42'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='UseCases suite is not supported',
        tags=('usecase', 'triadicSelection', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='usecase-triadicselection1-6',
        feature_path='tck/features/useCases/triadicSelection/TriadicSelection1.feature',
        scenario='[6] Handling triadic friend of a friend that is not a friend with explicit subset of relationship type',
        cypher='MATCH (a:A)-[:KNOWS|FOLLOWS]->(b)-->(c)\n      OPTIONAL MATCH (a)-[r:KNOWS]->(c)\n      WITH c WHERE r IS NULL\n      RETURN c.name',
        graph=BINARY_TREE_1_GRAPH,
        expected=Expected(
            rows=[
            {'c.name': "'b3'"},
            {'c.name': "'b4'"},
            {'c.name': "'c11'"},
            {'c.name': "'c12'"},
            {'c.name': "'c21'"},
            {'c.name': "'c22'"},
            {'c.name': "'c31'"},
            {'c.name': "'c32'"},
            {'c.name': "'c41'"},
            {'c.name': "'c42'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='UseCases suite is not supported',
        tags=('usecase', 'triadicSelection', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='usecase-triadicselection1-7',
        feature_path='tck/features/useCases/triadicSelection/TriadicSelection1.feature',
        scenario='[7] Handling triadic friend of a friend that is not a friend with same labels',
        cypher='MATCH (a:A)-[:KNOWS]->(b:X)-->(c:X)\n      OPTIONAL MATCH (a)-[r:KNOWS]->(c)\n      WITH c WHERE r IS NULL\n      RETURN c.name',
        graph=BINARY_TREE_2_GRAPH,
        expected=Expected(
            rows=[
            {'c.name': "'b3'"},
            {'c.name': "'c11'"},
            {'c.name': "'c21'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='UseCases suite is not supported',
        tags=('usecase', 'triadicSelection', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='usecase-triadicselection1-8',
        feature_path='tck/features/useCases/triadicSelection/TriadicSelection1.feature',
        scenario='[8] Handling triadic friend of a friend that is not a friend with different labels',
        cypher='MATCH (a:A)-[:KNOWS]->(b:X)-->(c:Y)\n      OPTIONAL MATCH (a)-[r:KNOWS]->(c)\n      WITH c WHERE r IS NULL\n      RETURN c.name',
        graph=BINARY_TREE_2_GRAPH,
        expected=Expected(
            rows=[
            {'c.name': "'c12'"},
            {'c.name': "'c22'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='UseCases suite is not supported',
        tags=('usecase', 'triadicSelection', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='usecase-triadicselection1-9',
        feature_path='tck/features/useCases/triadicSelection/TriadicSelection1.feature',
        scenario='[9] Handling triadic friend of a friend that is not a friend with implicit subset of labels',
        cypher='MATCH (a:A)-[:KNOWS]->(b)-->(c:X)\n      OPTIONAL MATCH (a)-[r:KNOWS]->(c)\n      WITH c WHERE r IS NULL\n      RETURN c.name',
        graph=BINARY_TREE_2_GRAPH,
        expected=Expected(
            rows=[
            {'c.name': "'b3'"},
            {'c.name': "'c11'"},
            {'c.name': "'c21'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='UseCases suite is not supported',
        tags=('usecase', 'triadicSelection', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='usecase-triadicselection1-10',
        feature_path='tck/features/useCases/triadicSelection/TriadicSelection1.feature',
        scenario='[10] Handling triadic friend of a friend that is not a friend with implicit superset of labels',
        cypher='MATCH (a:A)-[:KNOWS]->(b:X)-->(c)\n      OPTIONAL MATCH (a)-[r:KNOWS]->(c)\n      WITH c WHERE r IS NULL\n      RETURN c.name',
        graph=BINARY_TREE_2_GRAPH,
        expected=Expected(
            rows=[
            {'c.name': "'b3'"},
            {'c.name': "'c11'"},
            {'c.name': "'c12'"},
            {'c.name': "'c21'"},
            {'c.name': "'c22'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='UseCases suite is not supported',
        tags=('usecase', 'triadicSelection', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='usecase-triadicselection1-11',
        feature_path='tck/features/useCases/triadicSelection/TriadicSelection1.feature',
        scenario='[11] Handling triadic friend of a friend that is a friend',
        cypher='MATCH (a:A)-[:KNOWS]->(b)-->(c)\n      OPTIONAL MATCH (a)-[r:KNOWS]->(c)\n      WITH c WHERE r IS NOT NULL\n      RETURN c.name',
        graph=BINARY_TREE_2_GRAPH,
        expected=Expected(
            rows=[
            {'c.name': "'b2'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='UseCases suite is not supported',
        tags=('usecase', 'triadicSelection', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='usecase-triadicselection1-12',
        feature_path='tck/features/useCases/triadicSelection/TriadicSelection1.feature',
        scenario='[12] Handling triadic friend of a friend that is a friend with different relationship type',
        cypher='MATCH (a:A)-[:KNOWS]->(b)-->(c)\n      OPTIONAL MATCH (a)-[r:FOLLOWS]->(c)\n      WITH c WHERE r IS NOT NULL\n      RETURN c.name',
        graph=BINARY_TREE_1_GRAPH,
        expected=Expected(
            rows=[
            {'c.name': "'b3'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='UseCases suite is not supported',
        tags=('usecase', 'triadicSelection', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='usecase-triadicselection1-13',
        feature_path='tck/features/useCases/triadicSelection/TriadicSelection1.feature',
        scenario='[13] Handling triadic friend of a friend that is a friend with superset of relationship type',
        cypher='MATCH (a:A)-[:KNOWS]->(b)-->(c)\n      OPTIONAL MATCH (a)-[r]->(c)\n      WITH c WHERE r IS NOT NULL\n      RETURN c.name',
        graph=BINARY_TREE_1_GRAPH,
        expected=Expected(
            rows=[
            {'c.name': "'b2'"},
            {'c.name': "'b3'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='UseCases suite is not supported',
        tags=('usecase', 'triadicSelection', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='usecase-triadicselection1-14',
        feature_path='tck/features/useCases/triadicSelection/TriadicSelection1.feature',
        scenario='[14] Handling triadic friend of a friend that is a friend with implicit subset of relationship type',
        cypher='MATCH (a:A)-->(b)-->(c)\n      OPTIONAL MATCH (a)-[r:KNOWS]->(c)\n      WITH c WHERE r IS NOT NULL\n      RETURN c.name',
        graph=BINARY_TREE_1_GRAPH,
        expected=Expected(
            rows=[
            {'c.name': "'b1'"},
            {'c.name': "'b2'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='UseCases suite is not supported',
        tags=('usecase', 'triadicSelection', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='usecase-triadicselection1-15',
        feature_path='tck/features/useCases/triadicSelection/TriadicSelection1.feature',
        scenario='[15] Handling triadic friend of a friend that is a friend with explicit subset of relationship type',
        cypher='MATCH (a:A)-[:KNOWS|FOLLOWS]->(b)-->(c)\n      OPTIONAL MATCH (a)-[r:KNOWS]->(c)\n      WITH c WHERE r IS NOT NULL\n      RETURN c.name',
        graph=BINARY_TREE_1_GRAPH,
        expected=Expected(
            rows=[
            {'c.name': "'b1'"},
            {'c.name': "'b2'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='UseCases suite is not supported',
        tags=('usecase', 'triadicSelection', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='usecase-triadicselection1-16',
        feature_path='tck/features/useCases/triadicSelection/TriadicSelection1.feature',
        scenario='[16] Handling triadic friend of a friend that is a friend with same labels',
        cypher='MATCH (a:A)-[:KNOWS]->(b:X)-->(c:X)\n      OPTIONAL MATCH (a)-[r:KNOWS]->(c)\n      WITH c WHERE r IS NOT NULL\n      RETURN c.name',
        graph=BINARY_TREE_2_GRAPH,
        expected=Expected(
            rows=[
            {'c.name': "'b2'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='UseCases suite is not supported',
        tags=('usecase', 'triadicSelection', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='usecase-triadicselection1-17',
        feature_path='tck/features/useCases/triadicSelection/TriadicSelection1.feature',
        scenario='[17] Handling triadic friend of a friend that is a friend with different labels',
        cypher='MATCH (a:A)-[:KNOWS]->(b:X)-->(c:Y)\n      OPTIONAL MATCH (a)-[r:KNOWS]->(c)\n      WITH c WHERE r IS NOT NULL\n      RETURN c.name',
        graph=BINARY_TREE_2_GRAPH,
        expected=Expected(
            rows=[

            ],
        ),
        gfql=None,
        status="xfail",
        reason='UseCases suite is not supported',
        tags=('usecase', 'triadicSelection', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='usecase-triadicselection1-18',
        feature_path='tck/features/useCases/triadicSelection/TriadicSelection1.feature',
        scenario='[18] Handling triadic friend of a friend that is a friend with implicit subset of labels',
        cypher='MATCH (a:A)-[:KNOWS]->(b)-->(c:X)\n      OPTIONAL MATCH (a)-[r:KNOWS]->(c)\n      WITH c WHERE r IS NOT NULL\n      RETURN c.name',
        graph=BINARY_TREE_2_GRAPH,
        expected=Expected(
            rows=[
            {'c.name': "'b2'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='UseCases suite is not supported',
        tags=('usecase', 'triadicSelection', 'meta-xfail', 'xfail'),
    ),
    Scenario(
        key='usecase-triadicselection1-19',
        feature_path='tck/features/useCases/triadicSelection/TriadicSelection1.feature',
        scenario='[19] Handling triadic friend of a friend that is a friend with implicit superset of labels',
        cypher='MATCH (a:A)-[:KNOWS]->(b:X)-->(c)\n      OPTIONAL MATCH (a)-[r:KNOWS]->(c)\n      WITH c WHERE r IS NOT NULL\n      RETURN c.name',
        graph=BINARY_TREE_2_GRAPH,
        expected=Expected(
            rows=[
            {'c.name': "'b2'"}
            ],
        ),
        gfql=None,
        status="xfail",
        reason='UseCases suite is not supported',
        tags=('usecase', 'triadicSelection', 'meta-xfail', 'xfail'),
    ),

]

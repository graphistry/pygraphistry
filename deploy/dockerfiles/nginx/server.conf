sendfile                        on;
tcp_nopush                      on;
tcp_nodelay                     on;

types_hash_max_size             2048;
server_tokens                   off;

keepalive_timeout               120;
ssl_session_cache               shared:SSL:50m;

client_max_body_size            128M;
gzip                            on;


# Support WebSocket proxying by intelligently setting the `Connection` header passed to tbe upstream
map $http_upgrade $connection_upgrade {
    default                     upgrade;
    ''                          close;
}


include                     /etc/nginx/graphistry/upstreams-central.conf;
include                     /etc/nginx/graphistry/upstreams-workers.conf;


server {
    listen                      80 default_server;
    server_name                 _;

    include                     /etc/nginx/graphistry/ssl.conf;

    proxy_http_version          1.1;

    proxy_set_header            Host              $http_host;
    proxy_set_header            X-Real-IP         $remote_addr;
    proxy_set_header            X-Forwarded-For   $proxy_add_x_forwarded_for;
    proxy_set_header            X-Forwarded-Proto $scheme;

    # Support proxying WebSocket connections
    proxy_set_header            Upgrade           $http_upgrade;
    proxy_set_header            Connection        $connection_upgrade;

    # TODO: figure out caching for upstreams (central, workers)
    proxy_cache                 off;
    proxy_buffering             on;

    # Allow upstreams to access the original request URI, before rewrites, etc.
    proxy_set_header            X-Original-Uri    $request_uri;
    proxy_set_header            X-Resolved-Uri    $uri$is_args$args;


    include                     /etc/nginx/graphistry/routes-workers.conf;

    # Redirect '/' (root index), and only that exact path, to /graphistry/
    location = / {
        return                  301 /graphistry/;
    }

    # # Central receives /etl and /graph requests so it can find an available worker and redirect the
    # # request there. We strip request POST bodies from the requests central receives, because it
    # # only needs to examine the request headers to find+redirect to a worker. This saves us some
    # # bandwidth that would otherwise be wasted (which, in the case of ETL, could be substantial).
    # location /etl {
    #     proxy_method            GET;
    #     proxy_pass_request_body off;
    #     proxy_set_header        Content-Length    "";
    #
    #     proxy_set_header        X-Original-Uri    $request_uri;
    #     proxy_set_header        X-Resolved-Uri    $uri$is_args$args;
    #
    #     proxy_pass              http://proxy-central;
    # }
    #
    # location /graph {
    #     proxy_method            GET;
    #     proxy_pass_request_body off;
    #     proxy_set_header        Content-Length    "";
    #
    #     proxy_set_header        X-Original-Uri    $request_uri;
    #     proxy_set_header        X-Resolved-Uri    $uri$is_args$args;
    #
    #     proxy_pass              http://proxy-central;
    # }

    location / {
        proxy_pass              http://proxy-central;
    }
}

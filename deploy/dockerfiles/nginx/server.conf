sendfile                        on;
tcp_nopush                      on;
tcp_nodelay                     on;

types_hash_max_size             2048;
server_tokens                   off;

keepalive_timeout               120;
ssl_session_cache               shared:SSL:50m;

client_max_body_size            128M;
gzip                            on;


# Support WebSocket proxying by intelligently setting the `Connection` header passed to tbe upstream
map $http_upgrade $connection_upgrade {
    default                     upgrade;
    ''                          close;
}


include                     /etc/nginx/graphistry/upstreams-central.conf;
include                     /etc/nginx/graphistry/upstreams-workers.conf;


server {
    listen                      80 default_server;
    server_name                 _;

    include                     /etc/nginx/graphistry/ssl.conf;

    proxy_http_version          1.1;

    proxy_set_header            Host              $http_host;
    proxy_set_header            X-Real-IP         $remote_addr;
    proxy_set_header            X-Forwarded-For   $proxy_add_x_forwarded_for;
    proxy_set_header            X-Forwarded-Proto $scheme;

    # Support proxying WebSocket connections
    proxy_set_header            Upgrade           $http_upgrade;
    proxy_set_header            Connection        $connection_upgrade;

    # TODO: figure out caching for upstreams (central, workers)
    proxy_cache                 off;
    proxy_buffering             on;


    ################################################################################################
    # Workers config
    ################################################################################################

    # Since a `proxy_set_header` directive inside a `location` block clears all inherited headers,
    # we define a var and set *that* inside a location, then set below, outside a `location`.
    set                         $worker_id             '';

    # We strip off the `/worker/xxxx/` prefix of the request path before sending it to the worker
    # (to canonicalize it), but a worker needs to be aware of its prefix if it wants to construct
    # publically accessible URIs that route to it. This header tells the worker its prefix.
    proxy_set_header            X-Graphistry-Prefix    /worker/$worker_id;

    include                     /etc/nginx/graphistry/routes-workers.conf;

    # Map requests for a worker from URI prefix (`/worker/1234/...`) to its private location block
    location /worker/ {
        # Get $worker_path from the URI, then rewrite the request to remove `/worker/xxxx`. This
        # rewritten, canonicalized request URI is what is sent to the upstream worker.
        rewrite                 ^/worker/(?<worker_path>[0-9]+)/(.*)$ /$2 break;

        # Do an internal redirect to the `@` name location of the worker. `@` locations aren't
        # processed in normal request handling, so we use `try_files` with a filename known to
        # not exist, and specifiy the named location as the final, fallback URI.
        try_files                /workers_offline.html  $worker_location;
    }

    # This location is used as a default, fallback location if we can't map to a defined worker
    location @worker_notfound {
        return 404;
    }


    ################################################################################################
    # Central config
    ################################################################################################

    # Redirect '/' (root index), and only that exact path, to /graphistry/
    location = / {
        return                  301 /graphistry/;
    }

    # # Central receives /etl and /graph requests so it can find an available worker and redirect the
    # # request there. We strip request POST bodies from the requests central receives, because it
    # # only needs to examine the request headers to find+redirect to a worker. This saves us some
    # # bandwidth that would otherwise be wasted (which, in the case of ETL, could be substantial).
    # location /etl {
    #     proxy_method            GET;
    #     proxy_pass_request_body off;
    #     proxy_set_header        Content-Length    "";
    #
    #     proxy_set_header        X-Original-Uri    $request_uri;
    #     proxy_set_header        X-Resolved-Uri    $uri$is_args$args;
    #
    #     proxy_pass              http://proxy-central;
    # }
    #
    # location /graph {
    #     proxy_method            GET;
    #     proxy_pass_request_body off;
    #     proxy_set_header        Content-Length    "";
    #
    #     proxy_set_header        X-Original-Uri    $request_uri;
    #     proxy_set_header        X-Resolved-Uri    $uri$is_args$args;
    #
    #     proxy_pass              http://proxy-central;
    # }

    location / {
        proxy_pass              http://proxy-central;
    }
}
